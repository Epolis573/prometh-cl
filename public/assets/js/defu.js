if (typeof console == "undefined") {
    window.console = {};
    console.log = console.error = console.info = console.debug = console.warn = console.trace = function () {};
  }
  window.performance = window.performance && window.performance.now ? window.performance : Date;
  Date.now = Date.now || function () {
    return +new Date();
  };
  window.requestAnimationFrame ||= window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function () {
    const start = Date.now();
    return function (callback) {
      window.setTimeout(() => callback(Date.now() - start), 1000 / 60);
    };
  }();
  window.defer = window.requestAnimationFrame;
  window.clearTimeout = function () {
    const _clearTimeout = window.clearTimeout;
    return function (ref) {
      return window.Timer && Timer.__clearTimeout(ref) || _clearTimeout(ref);
    };
  }();
  window.requestIdleCallback = function () {
    const _requestIdleCallback = window.requestIdleCallback;
    return function (callback, max) {
      if (_requestIdleCallback) {
        return _requestIdleCallback(callback, max ? {
          timeout: max
        } : null);
      } else {
        return defer(() => {
          callback({
            didTimeout: false
          });
        }, 0);
      }
    };
  }();
  window.onIdle = window.requestIdleCallback;
  if (typeof Float32Array == "undefined") {
    Float32Array = Array;
  }
  Math.sign = function (x) {
    if ((x = +x) === 0 || isNaN(x)) {
      return Number(x);
    } else if (x > 0) {
      return 1;
    } else {
      return -1;
    }
  };
  Math._round = Math.round;
  Math.round = function (value, precision = 0) {
    let p = Math.pow(10, precision);
    return Math._round(value * p) / p;
  };
  Math._random = Math.random;
  Math.rand = Math.random = function (min, max, precision = 0) {
    if (min === undefined) {
      return Math._random();
    } else if (min === max) {
      return min;
    } else {
      min = min || 0;
      max = max || 1;
      if (precision == 0) {
        return Math.floor(Math._random() * (max + 1 - min) + min);
      } else {
        return Math.round(min + Math._random() * (max - min), precision);
      }
    }
  };
  Math.degrees = function (radians) {
    return radians * (180 / Math.PI);
  };
  Math.radians = function (degrees) {
    return degrees * (Math.PI / 180);
  };
  Math.clamp = function (value, min = 0, max = 1) {
    return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));
  };
  Math.map = Math.range = function (value, oldMin = -1, oldMax = 1, newMin = 0, newMax = 1, isClamp) {
    const newValue = (value - oldMin) * (newMax - newMin) / (oldMax - oldMin) + newMin;
    if (isClamp) {
      return Math.clamp(newValue, Math.min(newMin, newMax), Math.max(newMin, newMax));
    } else {
      return newValue;
    }
  };
  Math.mix = function (a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  };
  Math.step = function (edge, value) {
    if (value < edge) {
      return 0;
    } else {
      return 1;
    }
  };
  Math.smoothStep = function (min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - x * 2);
  };
  Math.fract = function (value) {
    return value - Math.floor(value);
  };
  {
    const mainThread = !!window.document;
    Math.lerp = function (target, value, alpha, calcHz = true) {
      let hz = mainThread && calcHz ? Render.HZ_MULTIPLIER : 1;
      return value + (target - value) * Math.clamp(alpha * hz, 0, 1);
    };
  }
  Math.mod = function (value, n) {
    return (value % n + n) % n;
  };
  Array.prototype.shuffle = function () {
    let temp;
    let r;
    let i = this.length - 1;
    while (i > 0) {
      r = Math.random(0, i, 0);
      i -= 1;
      temp = this[i];
      this[i] = this[r];
      this[r] = temp;
    }
    return this;
  };
  Array.storeRandom = function (arr) {
    arr.randomStore = [];
  };
  Array.prototype.random = function (range) {
    let value = Math.random(0, this.length - 1);
    if (arguments.length && !this.randomStore) {
      Array.storeRandom(this);
    }
    if (!this.randomStore) {
      return this[value];
    }
    if (range > this.length - 1) {
      range = this.length;
    }
    if (range > 1) {
      while (~this.randomStore.indexOf(value)) {
        if ((value += 1) > this.length - 1) {
          value = 0;
        }
      }
      this.randomStore.push(value);
      if (this.randomStore.length >= range) {
        this.randomStore.shift();
      }
    }
    return this[value];
  };
  Array.prototype.remove = function (element) {
    if (!this.indexOf) {
      return;
    }
    const index = this.indexOf(element);
    if (~index) {
      return this.splice(index, 1);
    } else {
      return undefined;
    }
  };
  Array.prototype.last = function () {
    return this[this.length - 1];
  };
  window.Promise = window.Promise || {};
  if (!Array.prototype.flat) {
    Object.defineProperty(Array.prototype, "flat", {
      configurable: true,
      value: function flat() {
        var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
        if (depth) {
          return Array.prototype.reduce.call(this, function (acc, cur) {
            if (Array.isArray(cur)) {
              acc.push.apply(acc, flat.call(cur, depth - 1));
            } else {
              acc.push(cur);
            }
            return acc;
          }, []);
        } else {
          return Array.prototype.slice.call(this);
        }
      },
      writable: true
    });
  }
  Promise.create = function () {
    const promise = new Promise((resolve, reject) => {
      this.temp_resolve = resolve;
      this.temp_reject = reject;
    });
    promise.resolve = this.temp_resolve;
    promise.reject = this.temp_reject;
    delete this.temp_resolve;
    delete this.temp_reject;
    return promise;
  };
  Promise.catchAll = function (array) {
    return Promise.all(array.map(promise => promise.catch(error => {
      Promise.reject(error);
    })));
  };
  Promise.timeout = function (promise, timeout) {
    if (Array.isArray(promise)) {
      promise = Promise.all(promise);
    }
    return Promise.race([promise, Timer.delayedCall(timeout)]);
  };
  String.prototype.includes = function (str) {
    if (!Array.isArray(str)) {
      return !!~this.indexOf(str);
    }
    for (let i = str.length - 1; i >= 0; i--) {
      if (~this.indexOf(str[i])) {
        return true;
      }
    }
    return false;
  };
  String.prototype.equals = function (str) {
    let compare = String(this);
    if (!Array.isArray(str)) {
      return str === compare;
    }
    for (let i = str.length - 1; i >= 0; i--) {
      if (str[i] === compare) {
        return true;
      }
    }
    return false;
  };
  String.prototype.strpos = function (str) {
    console.warn("strpos deprecated: use .includes()");
    return this.includes(str);
  };
  String.prototype.clip = function (num, end = "") {
    if (this.length > num) {
      return this.slice(0, Math.max(0, num - end.length)).trim() + end;
    } else {
      return this.slice();
    }
  };
  String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };
  String.prototype.replaceAll = function (find, replace) {
    return this.split(find).join(replace);
  };
  String.prototype.replaceAt = function (index, replacement) {
    return this.substr(0, index) + replacement + this.substr(index + replacement.length);
  };
  if (!window.fetch || !window.AURA && location.protocol.includes("file")) {
    window.fetch = function (url, options) {
      options = options || {};
      const promise = Promise.create();
      const request = new XMLHttpRequest();
      request.open(options.method || "get", url);
      if (url.includes(".ktx")) {
        request.responseType = "arraybuffer";
      }
      for (let i in options.headers) {
        request.setRequestHeader(i, options.headers[i]);
      }
      function response() {
        let header;
        let keys = [];
        let all = [];
        let headers = {};
        request.getAllResponseHeaders().replace(/^(.*?):\s*([\s\S]*?)$/gm, (m, key, value) => {
          keys.push(key = key.toLowerCase());
          all.push([key, value]);
          header = headers[key];
          headers[key] = header ? `${header},${value}` : value;
        });
        return {
          ok: (request.status / 200 | 0) == 1,
          status: request.status,
          statusText: request.statusText,
          url: request.responseURL,
          clone: response,
          text: () => Promise.resolve(request.responseText),
          json: () => Promise.resolve(request.responseText).then(JSON.parse),
          xml: () => Promise.resolve(request.responseXML),
          blob: () => Promise.resolve(new Blob([request.response])),
          arrayBuffer: () => Promise.resolve(request.response),
          headers: {
            keys: () => keys,
            entries: () => all,
            get: n => headers[n.toLowerCase()],
            has: n => n.toLowerCase() in headers
          }
        };
      }
      request.onload = () => {
        promise.resolve(response());
      };
      request.onerror = promise.reject;
      request.send(options.body);
      return promise;
    };
  }
  window.get = function (url, options = {
    credentials: "same-origin"
  }) {
    let promise = Promise.create();
    options.method = "GET";
    fetch(url, options).then(function handleResponse(e) {
      if (!e.ok) {
        return promise.reject(e);
      }
      e.text().then(text => {
        if (text.charAt(0).includes(["[", "{"])) {
          try {
            promise.resolve(JSON.parse(text));
          } catch (err) {
            promise.resolve(text);
          }
        } else {
          promise.resolve(text);
        }
      });
    }).catch(promise.reject);
    return promise;
  };
  window.post = function (url, body = {}, options = {}) {
    let promise = Promise.create();
    options.method = "POST";
    if (body) {
      options.body = typeof body == "object" || Array.isArray(body) ? JSON.stringify(body) : body;
    }
    options.headers ||= {
      "content-type": "application/json"
    };
    fetch(url, options).then(function handleResponse(e) {
      if (!e.ok) {
        return promise.reject(e);
      }
      e.text().then(text => {
        if (text.charAt(0).includes("[") || text.charAt(0).includes("{")) {
          try {
            promise.resolve(JSON.parse(text));
          } catch (err) {
            promise.resolve(text);
          }
        } else {
          promise.resolve(text);
        }
      });
    }).catch(promise.reject);
    return promise;
  };
  window.put = function (url, body, options = {}) {
    let promise = Promise.create();
    options.method = "PUT";
    if (body) {
      options.body = typeof body == "object" || Array.isArray(body) ? JSON.stringify(body) : body;
    }
    fetch(url, options).then(function handleResponse(e) {
      if (!e.ok) {
        return promise.reject(e);
      }
      e.text().then(text => {
        if (text.charAt(0).includes(["[", "{"])) {
          try {
            promise.resolve(JSON.parse(text));
          } catch (err) {
            promise.resolve(text);
          }
        } else {
          promise.resolve(text);
        }
      });
    }).catch(promise.reject);
    return promise;
  };
  window.Class = function (_class, _type, _static) {
    const _this = this || window;
    const _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];
    if (typeof _type == "function") {
      _static = _type;
      _type = null;
    }
    if (_type = (_type || "").toLowerCase()) {
      if (_type == "static") {
        _this[_name] = new _class();
      } else if (_type == "singleton") {
        _this[_name] = _class;
        (function () {
          let _instance;
          _this[_name].instance = function (a, b, c) {
            _instance ||= new _class(a, b, c);
            return _instance;
          };
        })();
        if (_static) {
          _static();
        }
      }
    } else {
      _this[_name] = _class;
      if (_static) {
        _static();
      }
    }
    if (this && this !== window) {
      this[_name]._namespace = this.__namespace;
    }
  };
  window.Inherit = function (child, parent) {
    const args = [].slice.call(arguments, 2);
    parent.apply(child, args);
    const save = {};
    for (let method in child) {
      save[method] = child[method];
    }
    defer(() => {
      for (let method in child) {
        if (save[method] && child[method] !== save[method]) {
          if (method == "destroy" && child.destroy && !child.__element) {
            throw "Do not override destroy directly, use onDestroy :: " + child.constructor.toString();
          }
          child["_" + method] = save[method];
        }
      }
    });
  };
  window.Namespace = function (obj) {
    if (typeof obj == "string") {
      window[obj] ||= {
        Class: Class,
        __namespace: obj
      };
    } else {
      obj.Class = Class;
      obj.__namespace = obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
    }
  };
  window.Global = {};
  window.THREAD = false;
  Class(function Hydra() {
    const _this = this;
    const _readyPromise = Promise.create();
    var _base;
    var _callbacks = [];
    function initLoad() {
      if (document && window) {
        if (window._NODE_) {
          return setTimeout(loaded, 1);
        } else if (window._AURA_) {
          if (window.Main) {
            return setTimeout(loaded, 1);
          } else {
            return setTimeout(initLoad, 1);
          }
        } else {
          window.addEventListener("load", loaded, false);
          return;
        }
      } else {
        return setTimeout(initLoad, 1);
      }
    }
    function loaded() {
      window.removeEventListener("load", loaded, false);
      _this.LOCAL = (!window._BUILT_ || location.pathname.toLowerCase().includes("platform")) && (location.hostname.indexOf("local") > -1 || location.hostname.split(".")[0] == "10" || location.hostname.split(".")[0] == "192" || /atdev.online$/.test(location.hostname)) && location.port == "";
      _callbacks.forEach(cb => cb());
      _callbacks = null;
      _readyPromise.resolve();
      if (window.Main) {
        _readyPromise.then(() => Hydra.Main = new window.Main());
      }
    }
    this.HASH = window.location.hash.slice(1);
    this.LOCAL = !window._BUILT_ && (location.hostname.indexOf("local") > -1 || location.hostname.split(".")[0] == "10" || location.hostname.split(".")[0] == "192" || /atdev.online$/.test(location.hostname)) && location.port == "";
    initLoad();
    this.__triggerReady = function () {
      loaded();
    };
    this.ready = function (callback) {
      if (!callback) {
        return _readyPromise;
      }
      if (_callbacks) {
        _callbacks.push(callback);
      } else {
        callback();
      }
    };
    this.absolutePath = function (path) {
      if (window.AURA) {
        return path;
      }
      let base = _base;
      if (base === undefined) {
        try {
          if (document.getElementsByTagName("base").length > 0) {
            var a = document.createElement("a");
            a.href = document.getElementsByTagName("base")[0].href;
            base = a.pathname;
            _base = base;
          }
        } catch (e) {
          _base = null;
        }
      }
      let pathname = base || location.pathname;
      if (pathname.includes("/index.html")) {
        pathname = pathname.replace("/index.html", "");
      }
      let port = Number(location.port) > 1000 ? `:${location.port}` : "";
      if (path.includes("http")) {
        return path;
      } else {
        return (location.protocol.length ? location.protocol + "//" : "") + (location.hostname + port + pathname + "/" + path).replace("//", "/");
      }
    };
  }, "Static");
  Class(function Utils() {
    var _queries = {};
    var _searchParams = window.URLSearchParams ? new URLSearchParams(window.location.search) : null;
    this.query = this.queryParams = function (key, value) {
      if (value !== undefined) {
        _queries[key] = value;
      }
      if (_queries[key] !== undefined) {
        return _queries[key];
      }
      if (_searchParams) {
        if ((value = _searchParams.get(key)) === "0") {
          value = 0;
        } else if (value === "false" || value === null) {
          value = false;
        } else if (value === "") {
          value = true;
        }
      } else {
        let escapedKey = encodeURIComponent(key).replace(/[\.\+\*]/g, "\\$&");
        if ((value = decodeURIComponent(window.location.search.replace(new RegExp(`^(?:.*?[&?]${escapedKey}(?:=([^&]*)|[&$]))?.*$`, "i"), "$1"))) == "0") {
          value = 0;
        } else if (value == "false") {
          value = false;
        } else if (!value.length) {
          value = new RegExp(`[&?]${escapedKey}(?:[&=]|$)`, "i").test(window.location.search);
        }
      }
      _queries[key] = value;
      return value;
    };
    this.addQuery = function (query, value) {
      if (_queries[query] === value) {
        return _queries[query];
      } else {
        this.removeQuery(query);
        window.history.replaceState({}, document.title, `${location.pathname}${this.addParam(location.search, query, value)}`);
        _searchParams = window.URLSearchParams ? new URLSearchParams(window.location.search) : null;
        return _queries[query] = value;
      }
    };
    this.removeQuery = function (query) {
      window.history.replaceState({}, document.title, `${location.pathname}${this.removeParam(location.search, query)}`);
      _searchParams = window.URLSearchParams ? new URLSearchParams(window.location.search) : null;
      return delete _queries[query];
    };
    this.addParam = function (url, param, value) {
      let u = url.split("?");
      let addedParam = encodeURIComponent(param) + "=" + value;
      let pars = u[1] ? u[1].split(/[&;]/g) : [];
      pars.push(addedParam);
      return url = u[0] + (pars.length > 0 ? "?" + pars.join("&") : "");
    };
    this.removeParam = function (url, param) {
      let u = url.split("?");
      if (u.length >= 2) {
        let prefix = encodeURIComponent(param) + "=";
        let pars = u[1].split(/[&;]/g);
        for (let i = pars.length; i-- > 0;) {
          if (pars[i].lastIndexOf(prefix, 0) !== -1) {
            pars.splice(i, 1);
          }
        }
        return url = u[0] + (pars.length > 0 ? "?" + pars.join("&") : "");
      }
      return url;
    };
    this.getConstructorName = function (obj) {
      if (obj) {
        if (typeof obj == "function") {
          return obj.toString().match(/function ([^\(]+)/)[1];
        } else {
          return obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
        }
      } else {
        return obj;
      }
    };
    this.nullObject = function (object) {
      if (object && (object.destroy || object.div)) {
        for (var key in object) {
          if (object[key] !== undefined) {
            object[key] = null;
          }
        }
      }
      return null;
    };
    this.cloneObject = function (obj) {
      return JSON.parse(JSON.stringify(obj));
    };
    this.headsTails = function (n0, n1) {
      if (Math.random(0, 1)) {
        return n1;
      } else {
        return n0;
      }
    };
    this.mergeObject = function () {
      var obj = {};
      for (var i = 0; i < arguments.length; i++) {
        var o = arguments[i];
        for (var key in o) {
          obj[key] = o[key];
        }
      }
      return obj;
    };
    this.timestamp = this.uuid = function () {
      return Date.now() + "xx-4xx-yxx-xxx".replace(/[xy]/g, function (c) {
        let r = Math.random() * 16 | 0;
        return (c == "x" ? r : r & 3 | 8).toString(16);
      });
    };
    this.randomColor = function () {
      var color = "#" + Math.floor(Math.random() * 16777215).toString(16);
      if (color.length < 7) {
        color = this.randomColor();
      }
      return color;
    };
    this.numberWithCommas = function (num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };
    this.padInt = function (num, digits, isLimit) {
      if (isLimit) {
        num = Math.min(num, Math.pow(10, digits) - 1);
      }
      let str = Math.floor(num).toString();
      return Math.pow(10, Math.max(0, digits - str.length)).toString().slice(1) + str;
    };
    this.copyToClipboard = function (string) {
      try {
        var el = document.createElement("textarea");
        var range = document.createRange();
        el.contentEditable = true;
        el.readOnly = true;
        el.value = string;
        document.body.appendChild(el);
        el.select();
        range.selectNodeContents(el);
        var s = window.getSelection();
        s.removeAllRanges();
        s.addRange(range);
        el.setSelectionRange(0, string.length);
        document.execCommand("copy");
        document.body.removeChild(el);
        return true;
      } catch (e) {
        return false;
      }
    };
    this.stringList = function (items = [], limit = 0, options = {}) {
      if (items.length === 0) {
        return "";
      }
      let output = "";
      let printed = 0;
      if (typeof limit == "object") {
        options = limit;
        limit = 0;
      }
      options.oxford = options.oxford === true;
      options.more = options.more !== false && (options.more ? options.more : "more");
      options.and = options.and ? options.and : "&";
      options.comma = options.comma ? options.comma : ",";
      if (!isNaN(options.limit)) {
        limit = options.limit;
      }
      if (limit === 0) {
        limit = items.length;
      }
      do {
        output = `${output}${items.shift()}${options.comma} `;
        printed++;
      } while (items.length > 1 && printed + 1 < limit);
      output = output.trim();
      output = output.slice(0, output.length - 1);
      if (items.length === 1) {
        output = `${output}${options.oxford && printed > 1 ? options.comma : ""} ${options.and} ${items.shift()}`;
      } else if (items.length > 1 && options.more) {
        let more = `${items.length} ${options.more}`;
        output = `${output}${options.oxford && printed > 1 ? options.comma : ""} ${options.and} ${more}`;
      }
      return output;
    };
    this.debounce = function (callback, time = 100) {
      clearTimeout(callback.__interval);
      callback.__interval = Timer.create(callback, time);
    };
  }, "Static");
  Class(function Render() {
    const _this = this;
    const _render = [];
    const _native = [];
    const _drawFrame = [];
    const _multipliers = [];
    var _last = performance.now();
    var _localTSL = 0;
    var _elapsed = 0;
    var _capLast = 0;
    var _sampleRefreshRate = [];
    var _firstSample = false;
    var _saveRefreshRate = 60;
    var rAF = requestAnimationFrame;
    var _refreshScale = 1;
    var _canCap = 0;
    function render(tsl) {
      if (_native.length) {
        let multiplier = 60 / _saveRefreshRate;
        for (let i = _native.length - 1; i > -1; i--) {
          _native[i](multiplier);
        }
      }
      if (_this.capFPS > 0 && ++_canCap > 31) {
        let delta = tsl - _capLast;
        _capLast = tsl;
        if ((_elapsed += delta) < 1000 / _this.capFPS) {
          return rAF(render);
        }
        _this.REFRESH_RATE = _this.capFPS;
        _this.HZ_MULTIPLIER = 60 / _this.REFRESH_RATE * _refreshScale;
        _elapsed = 0;
      }
      _this.timeScaleUniform.value = 1;
      if (_multipliers.length) {
        for (let i = 0; i < _multipliers.length; i++) {
          let obj = _multipliers[i];
          _this.timeScaleUniform.value *= obj.value;
        }
      }
      _this.DT = tsl - _last;
      _last = tsl;
      let delta = _this.DT * _this.timeScaleUniform.value;
      delta = Math.min(200, delta);
      if (_this.startFrame) {
        _this.startFrame(tsl, delta);
      }
      if (_sampleRefreshRate && !_this.capFPS) {
        let fps = 1000 / _this.DT;
        _sampleRefreshRate.push(fps);
        if (_sampleRefreshRate.length > 30) {
          _sampleRefreshRate.sort((a, b) => a - b);
          let rate = _sampleRefreshRate[Math.round(_sampleRefreshRate.length / 2)];
          rate = _this.REFRESH_TABLE.reduce((prev, curr) => Math.abs(curr - rate) < Math.abs(prev - rate) ? curr : prev);
          _this.REFRESH_RATE = _saveRefreshRate = _firstSample ? Math.max(_this.REFRESH_RATE, rate) : rate;
          _this.HZ_MULTIPLIER = 60 / _this.REFRESH_RATE * _refreshScale;
          _sampleRefreshRate = null;
          _firstSample = true;
        }
      }
      _this.TIME = tsl;
      _this.DELTA = delta;
      _localTSL += delta;
      for (let i = _render.length - 1; i >= 0; i--) {
        var callback = _render[i];
        if (callback) {
          if (callback.fps) {
            if (tsl - callback.last < 1000 / callback.fps) {
              continue;
            }
            callback(++callback.frame);
            callback.last = tsl;
          } else {
            callback(tsl, delta);
          }
        } else {
          _render.remove(callback);
        }
      }
      for (let i = _drawFrame.length - 1; i > -1; i--) {
        _drawFrame[i](tsl, delta);
      }
      if (_this.drawFrame) {
        _this.drawFrame(tsl, delta);
      }
      if (_this.endFrame) {
        _this.endFrame(tsl, delta);
      }
      if (!THREAD && !_this.isPaused) {
        rAF(render);
      }
    }
    this.timeScaleUniform = {
      value: 1,
      type: "f",
      ignoreUIL: true
    };
    this.REFRESH_TABLE = [30, 60, 72, 90, 100, 120, 144, 240];
    this.REFRESH_RATE = 60;
    this.HZ_MULTIPLIER = 1;
    this.capFPS = null;
    if (!THREAD) {
      rAF(render);
      setInterval(_ => _sampleRefreshRate = [], 3000);
    }
    this.now = function () {
      return _localTSL;
    };
    this.setRefreshScale = function (scale) {
      _refreshScale = scale;
      _sampleRefreshRate = [];
    };
    this.start = function (callback, fps, native) {
      if (fps) {
        callback.fps = fps;
        callback.last = -Infinity;
        callback.frame = -1;
      }
      if (native) {
        if (!~_native.indexOf(callback)) {
          _native.unshift(callback);
        }
      } else if (!~_render.indexOf(callback)) {
        _render.unshift(callback);
      }
    };
    this.stop = function (callback) {
      _render.remove(callback);
      _native.remove(callback);
    };
    this.tick = function () {
      if (THREAD) {
        this.TIME = performance.now();
        render(this.TIME);
      }
    };
    this.forceRender = function (time) {
      this.TIME = time;
      render(this.TIME);
    };
    this.Worker = function (_callback, _budget = 4) {
      Inherit(this, Component);
      let _scope = this;
      let _elapsed = 0;
      function loop() {
        if (!_scope.dead) {
          while (_elapsed < _budget) {
            if (_scope.dead || _scope.paused) {
              return;
            }
            const start = performance.now();
            if (_callback) {
              _callback();
            }
            _elapsed += performance.now() - start;
          }
          _elapsed = 0;
        }
      }
      this.startRender(loop);
      this.stop = function () {
        this.dead = true;
        this.stopRender(loop);
      };
      this.pause = function () {
        this.paused = true;
        this.stopRender(loop);
      };
      this.resume = function () {
        this.paused = false;
        this.startRender(loop);
      };
      this.setCallback = function (cb) {
        _callback = cb;
      };
    };
    this.pause = function () {
      _this.isPaused = true;
    };
    this.resume = function () {
      if (_this.isPaused) {
        _this.isPaused = false;
        rAF(render);
      }
    };
    this.useRAF = function (raf) {
      _firstSample = null;
      _last = performance.now();
      (rAF = raf)(render);
    };
    this.onDrawFrame = function (cb) {
      _drawFrame.push(cb);
    };
    this.setTimeScale = function (v) {
      _this.timeScaleUniform.value = v;
    };
    this.getTimeScale = function () {
      return _this.timeScaleUniform.value;
    };
    this.createTimeMultiplier = function () {
      let obj = {
        value: 1
      };
      _multipliers.push(obj);
      return obj;
    };
    this.destroyTimeMultiplier = function (obj) {
      _multipliers.remove(obj);
    };
    this.tweenTimeScale = function (value, time, ease, delay) {
      return tween(_this.timeScaleUniform, {
        value: value
      }, time, ease, delay, null, null, true);
    };
  }, "Static");
  Class(function Timer() {
    const _this = this;
    const _callbacks = [];
    const _discard = [];
    const _deferA = [];
    const _deferB = [];
    var _defer = _deferA;
    function loop(t, delta) {
      for (let i = _discard.length - 1; i >= 0; i--) {
        let obj = _discard[i];
        obj.callback = null;
        _callbacks.remove(obj);
      }
      _discard.length &&= 0;
      for (let i = _callbacks.length - 1; i >= 0; i--) {
        let obj = _callbacks[i];
        if (obj) {
          if (obj.scaledTime) {
            obj.current += delta;
          } else {
            obj.current += Render.DT;
          }
          if (obj.current >= obj.time) {
            if (obj.callback) {
              obj.callback();
            }
            _discard.push(obj);
          }
        } else {
          _callbacks.remove(obj);
        }
      }
      for (let i = _defer.length - 1; i > -1; i--) {
        _defer[i]();
      }
      _defer.length = 0;
      _defer = _defer == _deferA ? _deferB : _deferA;
    }
    Render.start(loop);
    this.__clearTimeout = function (ref) {
      const obj = function find(ref) {
        for (let i = _callbacks.length - 1; i > -1; i--) {
          if (_callbacks[i].ref == ref) {
            return _callbacks[i];
          }
        }
      }(ref);
      return !!obj && (obj.callback = null, _callbacks.remove(obj), true);
    };
    this.create = function (callback, time, scaledTime) {
      if (window._NODE_) {
        return setTimeout(callback, time);
      }
      const obj = {
        time: Math.max(1, time || 1),
        current: 0,
        ref: Utils.timestamp(),
        callback: callback,
        scaledTime: scaledTime
      };
      _callbacks.unshift(obj);
      return obj.ref;
    };
    this.delayedCall = function (time) {
      let promise = Promise.create();
      _this.create(promise.resolve, time);
      return promise;
    };
    window.defer = this.defer = function (callback) {
      let promise;
      if (!callback) {
        promise = Promise.create();
        callback = promise.resolve;
      }
      (_defer == _deferA ? _deferB : _deferA).unshift(callback);
      return promise;
    };
  }, "static");
  Class(function Events() {
    const _this = this;
    this.events = {};
    const _e = {};
    const _linked = [];
    let _emitter;
    this.events.sub = function (obj, evt, callback) {
      if (typeof obj != "object") {
        callback = evt;
        evt = obj;
        obj = null;
      }
      if (!obj) {
        Events.emitter._addEvent(evt, callback.resolve ? callback.resolve : callback, this);
        return callback;
      }
      let emitter = obj.events.emitter();
      emitter._addEvent(evt, callback.resolve ? callback.resolve : callback, this);
      emitter._saveLink(this);
      _linked.push(emitter);
      return callback;
    };
    this.events.wait = async function (obj, evt) {
      const promise = Promise.create();
      const args = [obj, evt, e => {
        _this.events.unsub(...args);
        promise.resolve(e);
      }];
      if (typeof obj != "object") {
        args.splice(1, 1);
      }
      _this.events.sub(...args);
      return promise;
    };
    this.events.unsub = function (obj, evt, callback) {
      if (typeof obj != "object") {
        callback = evt;
        evt = obj;
        obj = null;
      }
      if (!obj) {
        return Events.emitter._removeEvent(evt, callback.resolve ? callback.resolve : callback);
      }
      obj.events.emitter()._removeEvent(evt, callback.resolve ? callback.resolve : callback);
    };
    this.events.fire = function (evt, obj, isLocalOnly) {
      (obj = obj || _e).target = this;
      Events.emitter._check(evt);
      if ((!_emitter || !_emitter._fireEvent(evt, obj)) && !isLocalOnly) {
        Events.emitter._fireEvent(evt, obj);
      }
    };
    this.events.bubble = function (obj, evt) {
      _this.events.sub(obj, evt, e => _this.events.fire(evt, e));
    };
    this.events.destroy = function () {
      Events.emitter._destroyEvents(this);
      if (_linked) {
        _linked.forEach(emitter => emitter._destroyEvents(this));
      }
      if (_emitter && _emitter.links) {
        _emitter.links.forEach(obj => obj.events && obj.events._unlink(_emitter));
      }
      return null;
    };
    this.events.emitter = function () {
      _emitter ||= Events.emitter.createLocalEmitter();
      return _emitter;
    };
    this.events._unlink = function (emitter) {
      _linked.remove(emitter);
    };
  }, () => {
    Events.emitter = new function Emitter() {
      const prototype = Emitter.prototype;
      this.events = [];
      if (prototype._check !== undefined) {
        return;
      }
      prototype._check = function (evt) {
        if (evt === undefined) {
          throw "Undefined event";
        }
      };
      prototype._addEvent = function (evt, callback, object) {
        this._check(evt);
        this.events.push({
          evt: evt,
          object: object,
          callback: callback
        });
      };
      prototype._removeEvent = function (eventString, callback) {
        this._check(eventString);
        for (let i = this.events.length - 1; i >= 0; i--) {
          if (this.events[i].evt === eventString && this.events[i].callback === callback) {
            this._markForDeletion(i);
          }
        }
      };
      prototype._sweepEvents = function () {
        for (let i = 0; i < this.events.length; i++) {
          if (this.events[i].markedForDeletion) {
            delete this.events[i].markedForDeletion;
            this.events.splice(i, 1);
            --i;
          }
        }
      };
      prototype._markForDeletion = function (i) {
        this.events[i].markedForDeletion = true;
        if (!this._sweepScheduled) {
          this._sweepScheduled = true;
          defer(() => {
            this._sweepScheduled = false;
            this._sweepEvents();
          });
        }
      };
      prototype._fireEvent = function (eventString, obj) {
        if (this._check) {
          this._check(eventString);
        }
        obj = obj || _e;
        let called = false;
        for (let i = 0; i < this.events.length; i++) {
          let evt = this.events[i];
          if (evt.evt == eventString && !evt.markedForDeletion) {
            evt.callback(obj);
            called = true;
          }
        }
        return called;
      };
      prototype._destroyEvents = function (object) {
        for (var i = this.events.length - 1; i >= 0; i--) {
          if (this.events[i].object === object) {
            this._markForDeletion(i);
          }
        }
      };
      prototype._saveLink = function (obj) {
        this.links ||= [];
        if (!~this.links.indexOf(obj)) {
          this.links.push(obj);
        }
      };
      prototype.createLocalEmitter = function () {
        return new Emitter();
      };
    }();
    Events.broadcast = Events.emitter._fireEvent;
    Events.VISIBILITY = "hydra_visibility";
    Events.HASH_UPDATE = "hydra_hash_update";
    Events.COMPLETE = "hydra_complete";
    Events.PROGRESS = "hydra_progress";
    Events.CONNECTIVITY = "hydra_connectivity";
    Events.UPDATE = "hydra_update";
    Events.LOADED = "hydra_loaded";
    Events.END = "hydra_end";
    Events.FAIL = "hydra_fail";
    Events.SELECT = "hydra_select";
    Events.ERROR = "hydra_error";
    Events.READY = "hydra_ready";
    Events.RESIZE = "hydra_resize";
    Events.CLICK = "hydra_click";
    Events.HOVER = "hydra_hover";
    Events.MESSAGE = "hydra_message";
    Events.ORIENTATION = "orientation";
    Events.BACKGROUND = "background";
    Events.BACK = "hydra_back";
    Events.PREVIOUS = "hydra_previous";
    Events.NEXT = "hydra_next";
    Events.RELOAD = "hydra_reload";
    Events.UNLOAD = "hydra_unload";
    Events.FULLSCREEN = "hydra_fullscreen";
    const _e = {};
    Hydra.ready(() => {
      let box;
      (function () {
        let _last;
        let _lastTime = performance.now();
        function onfocus() {
          Render.blurTime = -1;
          if (_last != "focus") {
            Events.emitter._fireEvent(Events.VISIBILITY, {
              type: "focus"
            });
          }
          _last = "focus";
        }
        function onblur() {
          Render.blurTime = Date.now();
          if (_last != "blur") {
            Events.emitter._fireEvent(Events.VISIBILITY, {
              type: "blur"
            });
          }
          _last = "blur";
        }
        Timer.create(function addVisibilityHandler() {
          let hidden;
          let eventName;
          [["msHidden", "msvisibilitychange"], ["webkitHidden", "webkitvisibilitychange"], ["hidden", "visibilitychange"]].forEach(d => {
            if (document[d[0]] !== undefined) {
              hidden = d[0];
              eventName = d[1];
            }
          });
          if (!eventName) {
            const root = Device.browser == "ie" ? document : window;
            root.onfocus = onfocus;
            root.onblur = onblur;
            return;
          }
          document.addEventListener(eventName, () => {
            const time = performance.now();
            if (time - _lastTime > 10) {
              if (document[hidden] === false) {
                onfocus();
              } else {
                onblur();
              }
            }
            _lastTime = time;
          });
        }, 250);
        window.addEventListener("online", _ => Events.emitter._fireEvent(Events.CONNECTIVITY, {
          online: true
        }));
        window.addEventListener("offline", _ => Events.emitter._fireEvent(Events.CONNECTIVITY, {
          online: false
        }));
        window.onbeforeunload = _ => {
          Events.emitter._fireEvent(Events.UNLOAD);
          return null;
        };
      })();
      window.Stage = window.Stage || {};
      if (Device.system.browser == "social" && Device.system.os == "ios") {
        box = document.createElement("div");
        box.style.position = "fixed";
        box.style.top = box.style.left = box.style.right = box.style.bottom = "0px";
        box.style.zIndex = "-1";
        box.style.opacity = "0";
        box.style.pointerEvents = "none";
        document.body.appendChild(box);
      }
      updateStage();
      let timer;
      let iosResize = Device.system.os === "ios";
      let html = !!iosResize && document.querySelector("html");
      let delay = iosResize ? 500 : 16;
      function updateStage() {
        if (box) {
          let bbox = box.getBoundingClientRect();
          Stage.width = bbox.width || window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
          Stage.height = bbox.height || window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
          document.body.parentElement.scrollTop = document.body.scrollTop = 0;
          document.documentElement.style.width = document.body.style.width = `${Stage.width}px`;
          document.documentElement.style.height = document.body.style.height = `${Stage.height}px`;
          Events.emitter._fireEvent(Events.RESIZE);
        } else {
          Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
          Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
        }
      }
      window.addEventListener("resize", function handleResize() {
        clearTimeout(timer);
        timer = setTimeout(_ => {
          updateStage();
          if (html && Math.min(window.screen.width, window.screen.height) !== Stage.height && !Mobile.isAllowNativeScroll) {
            html.scrollTop = -1;
          }
          Events.emitter._fireEvent(Events.RESIZE);
        }, delay);
      });
      window.onorientationchange = window.onresize;
      if (Device.system.browser == "social" && (Stage.height >= screen.height || Stage.width >= screen.width)) {
        setTimeout(updateStage, 1000);
      }
      defer(window.onresize);
    });
  });
  Class(function Device() {
    var vid;
    var _this = this;
    this.agent = navigator.userAgent.toLowerCase();
    this.detect = function (match) {
      return this.agent.includes(match);
    };
    this.touchCapable = !!navigator.maxTouchPoints;
    this.pixelRatio = window.devicePixelRatio;
    this.system = {};
    this.system.retina = window.devicePixelRatio > 1;
    this.system.webworker = window.Worker !== undefined;
    if (!window._NODE_) {
      this.system.geolocation = navigator.geolocation !== undefined;
    }
    if (!window._NODE_) {
      this.system.pushstate = window.history.pushState !== undefined;
    }
    this.system.webcam = !!navigator.getUserMedia || !!navigator.webkitGetUserMedia || !!navigator.mozGetUserMedia || !!navigator.mediaDevices;
    this.system.language = window.navigator.userLanguage || window.navigator.language;
    this.system.webaudio = window.AudioContext !== undefined;
    this.system.xr = {};
    this.system.detectXR = async function () {
      if (window.AURA) {
        _this.system.xr.vr = true;
        _this.system.xr.ar = true;
        return;
      }
      if (!navigator.xr) {
        _this.system.xr.vr = false;
        _this.system.xr.ar = false;
        return;
      }
      try {
        [_this.system.xr.vr, _this.system.xr.ar] = await Promise.all([navigator.xr.isSessionSupported("immersive-vr"), navigator.xr.isSessionSupported("immersive-ar")]);
      } catch (e) {}
      if (_this.system.os == "android") {
        if (!_this.detect("oculus")) {
          _this.system.xr.vr = false;
        }
      }
    };
    try {
      this.system.localStorage = window.localStorage !== undefined;
    } catch (e) {
      this.system.localStorage = false;
    }
    this.system.fullscreen = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    this.system.os = _this.detect(["ipad", "iphone", "ios"]) || _this.detect("mac") && _this.touchCapable && Math.max(screen.width, screen.height) < 1370 ? "ios" : _this.detect(["android", "kindle"]) ? "android" : _this.detect(["blackberry"]) ? "blackberry" : _this.detect(["mac os"]) ? "mac" : _this.detect(["windows", "iemobile"]) ? "windows" : _this.detect(["linux"]) ? "linux" : "unknown";
    this.system.version = function () {
      try {
        if (_this.system.os == "ios") {
          if (_this.agent.includes("intel mac")) {
            let split = _this.agent.split("version/")[1].split(" ")[0].split(".");
            return Number(split[0] + "." + split[1]);
          }
          var num = _this.agent.split("os ")[1].split("_");
          var main = num[0];
          var sub = num[1].split(" ")[0];
          return Number(main + "." + sub);
        }
        if (_this.system.os == "android") {
          var version = _this.agent.split("android ")[1].split(";")[0];
          if (version.length > 3) {
            version = version.slice(0, -2);
          }
          if (version.charAt(version.length - 1) == ".") {
            version = version.slice(0, -1);
          }
          return Number(version);
        }
        if (_this.system.os == "windows") {
          if (_this.agent.includes("rv:11")) {
            return 11;
          } else {
            return Number(_this.agent.split("windows phone ")[1].split(";")[0]);
          }
        }
      } catch (e) {}
      return -1;
    }();
    this.system.browser = _this.system.os == "ios" ? _this.detect(["twitter", "fbios", "instagram"]) ? "social" : _this.detect(["crios"]) ? "chrome" : _this.detect(["safari"]) ? "safari" : "unknown" : _this.system.os == "android" ? _this.detect(["twitter", "fb", "facebook", "instagram"]) ? "social" : _this.detect(["chrome"]) ? "chrome" : _this.detect(["firefox"]) ? "firefox" : "browser" : _this.detect(["msie"]) || _this.detect(["trident"]) && _this.detect(["rv:"]) || _this.detect(["windows"]) && _this.detect(["edge"]) ? "ie" : _this.detect(["chrome"]) ? "chrome" : _this.detect(["safari"]) ? "safari" : _this.detect(["firefox"]) ? "firefox" : "unknown";
    this.system.browserVersion = function () {
      try {
        if (_this.system.browser == "chrome") {
          return Number(_this.agent.split("chrome/")[1].split(".")[0]);
        }
        if (_this.system.browser == "firefox") {
          return Number(_this.agent.split("firefox/")[1].split(".")[0]);
        }
        if (_this.system.browser == "safari") {
          return Number(_this.agent.split("version/")[1].split(".")[0].split(".")[0]);
        }
        if (_this.system.browser == "ie") {
          if (_this.detect(["msie"])) {
            return Number(_this.agent.split("msie ")[1].split(".")[0]);
          } else if (_this.detect(["rv:"])) {
            return Number(_this.agent.split("rv:")[1].split(".")[0]);
          } else {
            return Number(_this.agent.split("edge/")[1].split(".")[0]);
          }
        }
      } catch (e) {
        return -1;
      }
    }();
    this.mobile = !window._NODE_ && (!!("ontouchstart" in window) || !!("onpointerdown" in window)) && !!_this.system.os.includes(["ios", "android", "magicleap"]) && {};
    if (_this.detect("quest")) {
      this.mobile = true;
    }
    if (this.mobile && this.detect(["windows"]) && !this.detect(["touch"])) {
      this.mobile = false;
    }
    if (this.mobile) {
      this.mobile.tablet = Math.max(window.screen ? screen.width : window.innerWidth, window.screen ? screen.height : window.innerHeight) > 1000;
      this.mobile.phone = !this.mobile.tablet;
      this.mobile.pwa = !!window.matchMedia && !!window.matchMedia("(display-mode: standalone)").matches || !!window.navigator.standalone;
      Hydra.ready(() => {
        _this.mobile.native = !!Mobile.NativeCore && !!Mobile.NativeCore.active || !!window._AURA_;
      });
    }
    this.media = {};
    this.media.audio = !!document.createElement("audio").canPlayType && (_this.detect(["firefox", "opera"]) ? "ogg" : "mp3");
    this.media.video = !!(vid = document.createElement("video")).canPlayType && (vid.canPlayType("video/webm;") ? "webm" : "mp4");
    this.media.webrtc = !!window.webkitRTCPeerConnection || !!window.mozRTCPeerConnection || !!window.msRTCPeerConnection || !!window.oRTCPeerConnection || !!window.RTCPeerConnection;
    this.graphics = {};
    this.graphics.webgl = function () {
      let DISABLED = false;
      Object.defineProperty(_this.graphics, "webgl", {
        get: () => {
          if (DISABLED) {
            return false;
          }
          if (_this.graphics._webglContext) {
            return _this.graphics._webglContext;
          }
          try {
            const names = ["webgl2", "webgl", "experimental-webgl"];
            const canvas = document.createElement("canvas");
            let gl;
            for (let i = 0; i < names.length && (gl = canvas.getContext(names[i]), !gl); i++);
            let info = gl.getExtension("WEBGL_debug_renderer_info");
            let output = {};
            if (info) {
              let gpu = info.UNMASKED_RENDERER_WEBGL;
              output.gpu = gl.getParameter(gpu).toLowerCase();
            } else {
              output.gpu = "unknown";
            }
            output.renderer = gl.getParameter(gl.RENDERER).toLowerCase();
            output.version = gl.getParameter(gl.VERSION).toLowerCase();
            output.glsl = gl.getParameter(gl.SHADING_LANGUAGE_VERSION).toLowerCase();
            output.extensions = gl.getSupportedExtensions();
            output.webgl2 = output.version.includes(["webgl 2", "webgl2"]);
            output.canvas = canvas;
            output.context = gl;
            output.detect = function (matches) {
              if (output.gpu && output.gpu.toLowerCase().includes(matches)) {
                return true;
              }
              if (output.version && output.version.toLowerCase().includes(matches)) {
                return true;
              }
              for (let i = 0; i < output.extensions.length; i++) {
                if (output.extensions[i].toLowerCase().includes(matches)) {
                  return true;
                }
              }
              return false;
            };
            if (!output.webgl2 && !output.detect("instance") && !window.AURA) {
              DISABLED = true;
            }
            _this.graphics._webglContext = output;
            return output;
          } catch (e) {
            return false;
          }
        },
        set: v => {
          if (v === false) {
            DISABLED = true;
          }
        }
      });
    }();
    this.graphics.metal = function () {
      if (!window.Metal) {
        return false;
      }
      let output = {};
      output.gpu = Metal.device.getName().toLowerCase();
      output.detect = function (matches) {
        return output.gpu.includes(matches);
      };
      return output;
    }();
    this.graphics.gpu = function () {
      if (!_this.graphics.webgl && !_this.graphics.metal) {
        return false;
      }
      let output = {};
      ["metal", "webgl"].forEach(name => {
        if (_this.graphics[name] && !output.identifier) {
          output.detect = _this.graphics[name].detect;
          output.identifier = _this.graphics[name].gpu;
        }
      });
      return output;
    }();
    this.graphics.canvas = !!document.createElement("canvas").getContext;
    const checkForStyle = function () {
      let _tagDiv;
      return function (prop) {
        _tagDiv = _tagDiv || document.createElement("div");
        const vendors = ["Khtml", "ms", "O", "Moz", "Webkit"];
        if (prop in _tagDiv.style) {
          return true;
        }
        prop = prop.replace(/^[a-z]/, val => val.toUpperCase());
        for (let i = vendors.length - 1; i >= 0; i--) {
          if (vendors[i] + prop in _tagDiv.style) {
            return true;
          }
        }
        return false;
      };
    }();
    this.styles = {};
    this.styles.filter = checkForStyle("filter");
    this.styles.blendMode = checkForStyle("mix-blend-mode");
    this.tween = {};
    this.tween.transition = checkForStyle("transition");
    this.tween.css2d = checkForStyle("transform");
    this.tween.css3d = checkForStyle("perspective");
    this.social = _this.agent.includes("instagram") ? "instagram" : _this.agent.includes("fban") || _this.agent.includes("fbav") || _this.agent.includes("fbios") ? "facebook" : (_this.agent.includes("twitter") || !!document.referrer && !!document.referrer.includes("//t.co/")) && "twitter";
  }, "Static");
  Class(function Component() {
    Inherit(this, Events);
    const _this = this;
    const _setters = {};
    const _flags = {};
    const _timers = [];
    const _loops = [];
    var _onDestroy;
    var _appStateBindings;
    function defineSetter(_this, prop) {
      _setters[prop] = {};
      Object.defineProperty(_this, prop, {
        set: function (v) {
          if (_setters[prop] && _setters[prop].s) {
            _setters[prop].s.call(_this, v);
          }
          v = null;
        },
        get: function () {
          if (_setters[prop] && _setters[prop].g) {
            return _setters[prop].g.apply(_this);
          }
        }
      });
    }
    this.classes = {};
    this.findParent = function (type) {
      let p = _this.parent;
      while (p) {
        p._cachedName ||= Utils.getConstructorName(p);
        if (p._cachedName == type) {
          return p;
        }
        p = p.parent;
      }
    };
    this.set = function (prop, callback) {
      if (!_setters[prop]) {
        defineSetter(this, prop);
      }
      _setters[prop].s = callback;
    };
    this.get = function (prop, callback) {
      if (!_setters[prop]) {
        defineSetter(this, prop);
      }
      _setters[prop].g = callback;
    };
    this.isPlayground = function (name) {
      return Global.PLAYGROUND && Global.PLAYGROUND == (name || Utils.getConstructorName(_this));
    };
    this.initClass = function (clss) {
      if (!clss) {
        console.trace();
        throw "unable to locate class";
      }
      const args = [].slice.call(arguments, 1);
      const child = Object.create(clss.prototype);
      child.parent = this;
      clss.apply(child, args);
      if (child.destroy) {
        const id = Utils.timestamp();
        this.classes[id] = child;
        this.classes[id].__id = id;
      }
      if (child.element) {
        const last = arguments[arguments.length - 1];
        if (Array.isArray(last) && last.length == 1 && last[0] instanceof HydraObject) {
          last[0].add(child.element);
        } else if (this.element && this.element.add && last !== null) {
          this.element.add(child.element);
        }
      }
      if (child.group) {
        const last = arguments[arguments.length - 1];
        if (this.group && last !== null) {
          this.group.add(child.group);
        }
      }
      return child;
    };
    this.delayedCall = function (callback, time, scaledTime) {
      const timer = Timer.create(() => {
        if (_this && _this.destroy && callback) {
          callback();
        }
      }, time, scaledTime);
      _timers.push(timer);
      if (_timers.length > 50) {
        _timers.shift();
      }
      return timer;
    };
    this.clearTimers = function () {
      for (let i = _timers.length - 1; i >= 0; i--) {
        clearTimeout(_timers[i]);
      }
      _timers.length = 0;
    };
    this.startRender = function (callback, fps, obj) {
      if (typeof fps != "number") {
        obj = fps;
        fps = undefined;
      }
      for (let i = 0; i < _loops.length; i++) {
        if (_loops[i].callback == callback) {
          return;
        }
      }
      let flagInvisible = _ => {
        if (!_this._invisible) {
          _this._invisible = true;
          if (_this.onInvisible) {
            _this.onInvisible();
          }
        }
      };
      let loop = (a, b, c, d) => {
        if (!_this.startRender) {
          return false;
        }
        let p = _this;
        while (p) {
          if (p.visible === false) {
            return flagInvisible();
          }
          if (p.group && p.group.visible === false) {
            return flagInvisible();
          }
          p = p.parent;
        }
        if (_this._invisible !== false) {
          _this._invisible = false;
          if (_this.onVisible) {
            _this.onVisible();
          }
        }
        callback(a, b, c, d);
        return true;
      };
      _loops.push({
        callback: callback,
        loop: loop
      });
      if (obj) {
        if (obj == RenderManager.NATIVE_FRAMERATE) {
          Render.start(loop, null, true);
        } else {
          RenderManager.schedule(loop, obj);
        }
      } else {
        Render.start(loop, fps);
      }
    };
    this.onResize = function (callback) {
      callback();
      this.events.sub(Events.RESIZE, callback);
    };
    this.stopRender = function (callback, obj) {
      for (let i = 0; i < _loops.length; i++) {
        if (_loops[i].callback == callback) {
          let loop = _loops[i].loop;
          if (obj) {
            RenderManager.unschedule(loop, obj);
          }
          Render.stop(loop);
          _loops.splice(i, 1);
        }
      }
    };
    this.clearRenders = function () {
      for (let i = 0; i < _loops.length; i++) {
        Render.stop(_loops[i].loop);
      }
      _loops.length = 0;
    };
    this.wait = function (object, key, callback) {
      const promise = Promise.create();
      let condition;
      if (typeof object == "string") {
        callback = key;
        key = object;
        object = _this;
      }
      if (typeof object == "number" && arguments.length === 1) {
        _this.delayedCall(promise.resolve, object);
        return promise;
      }
      if (typeof object == "function" && arguments.length === 1) {
        condition = object;
        object = _this;
      }
      if (typeof object == "function" && typeof callback == "string") {
        let _object = object;
        object = key;
        key = callback;
        callback = _object;
      }
      callback = callback || promise.resolve;
      if (!condition) {
        if (key?.charAt?.(0) === "!") {
          key = key.slice(1);
          condition = () => !object[key] && !_this.flag(key);
        } else {
          condition = () => !!object[key] || !!_this.flag(key);
        }
      }
      if (condition()) {
        callback();
      } else {
        function test() {
          if (!object || !_this.flag || object.destroy === null) {
            return Render.stop(test);
          }
          if (condition()) {
            callback();
            Render.stop(test);
          }
        }
        Render.start(test);
      }
      return promise;
    };
    this.bindState = function (appState, key, ...rest) {
      _appStateBindings ||= [];
      _appStateBindings.push(appState.bind(key, ...rest));
    };
    this.flag = function (name, value, time) {
      if (value === undefined) {
        return _flags[name];
      }
      _flags[name] = value;
      if (time) {
        clearTimeout(_flags[name + "_timer"]);
        _flags[name + "_timer"] = this.delayedCall(() => {
          _flags[name] = !_flags[name];
        }, time);
      }
    };
    this.destroy = function () {
      if (this.removeDispatch) {
        this.removeDispatch();
      }
      if (this.onDestroy) {
        this.onDestroy();
      }
      if (this.fxDestroy) {
        this.fxDestroy();
      }
      if (_onDestroy) {
        _onDestroy.forEach(cb => cb());
      }
      for (let id in this.classes) {
        var clss = this.classes[id];
        if (clss && clss.destroy) {
          clss.destroy();
        }
      }
      this.classes = null;
      if (this.clearRenders) {
        this.clearRenders();
      }
      if (this.clearTimers) {
        this.clearTimers();
      }
      if (this.element && window.GLUI && this.element instanceof GLUIObject) {
        this.element.remove();
      }
      this.events &&= this.events.destroy();
      if (this.parent && this.parent.__destroyChild) {
        this.parent.__destroyChild(this.__id);
      }
      if (_appStateBindings) {
        _appStateBindings.forEach(b => b.destroy?.());
      }
      return Utils.nullObject(this);
    };
    this._bindOnDestroy = function (cb) {
      _onDestroy ||= [];
      _onDestroy.push(cb);
    };
    this.__destroyChild = function (name) {
      delete this.classes[name];
    };
  });
  Class(function Model() {
    Inherit(this, Component);
    Namespace(this);
    const _this = this;
    const _storage = {};
    const _requests = {};
    let _data = 0;
    let _triggered = 0;
    this.push = function (name, val) {
      _storage[name] = val;
    };
    this.pull = function (name) {
      return _storage[name];
    };
    this.waitForData = this.promiseData = function (num = 1) {
      _data += num;
    };
    this.fulfillData = this.resolveData = function () {
      _triggered++;
      if (_triggered == _data) {
        _this.dataReady = true;
      }
    };
    this.ready = function (callback) {
      let promise = Promise.create();
      if (callback) {
        promise.then(callback);
      }
      _this.wait(_this, "dataReady").then(promise.resolve);
      return promise;
    };
    this.initWithData = function (data) {
      _this.STATIC_DATA = data;
      for (var key in _this) {
        var model = _this[key];
        var init = false;
        for (var i in data) {
          if (i.toLowerCase().replace(/-/g, "") == key.toLowerCase()) {
            init = true;
            if (model.init) {
              model.init(data[i]);
            }
          }
        }
        if (!init && model.init) {
          model.init();
        }
      }
      if (_this.init) {
        _this.init(data);
      }
    };
    this.loadData = function (url, callback) {
      let promise = Promise.create();
      callback ||= promise.resolve;
      var _this = this;
      get(url + "?" + Utils.timestamp()).then(d => {
        defer(() => {
          _this.initWithData(d);
          callback(d);
        });
      });
      return promise;
    };
    this.handleRequest = function (type, callback) {
      _requests[type] = callback;
    };
    this.makeRequest = async function (type, data, mockData = {}) {
      if (!_requests[type]) {
        console.warn(`Missing data handler for ${type} with mockData`, mockData);
        if (Array.isArray(mockData)) {
          return new StateArray(mockData);
        } else {
          return AppState.createLocal(mockData);
        }
      }
      let result = await _requests[type](data, mockData);
      if (!(result instanceof StateArray) && !result.createLocal) {
        throw `makeRequest ${type} must return either an AppState or StateArray`;
      }
      return result;
    };
  });
  Class(function Modules() {
    const _modules = {};
    const _constructors = {};
    function exec() {
      for (let m in _modules) {
        for (let key in _modules[m]) {
          let module = _modules[m][key];
          if (!module._ready) {
            module._ready = true;
            if (module.exec) {
              module.exec();
            }
          }
        }
      }
    }
    defer(exec);
    this.Module = function (module) {
      let m = new module();
      let name = module.toString().slice(0, 100).match(/function ([^\(]+)/);
      if (name) {
        m._ready = true;
        name = name[1];
        _modules[name] = {
          index: m
        };
        _constructors[name] = module;
      } else {
        _modules[m.module] ||= {};
        _modules[m.module][m.path] = m;
      }
    };
    this.require = function (path) {
      let root;
      if (path.includes("/")) {
        root = path.split("/")[0];
        path = path.replace(root + "/", "");
      } else {
        root = path;
        path = "index";
      }
      return function requireModule(root, path) {
        let module = _modules[root];
        if (!module) {
          throw `Module ${root} not found`;
        }
        module = module[path];
        if (!module._ready) {
          module._ready = true;
          if (module.exec) {
            module.exec();
          }
        }
        return module;
      }(root, path).exports;
    };
    this.getConstructor = function (name) {
      return _constructors[name];
    };
    window.Module = this.Module;
    if (!window._NODE_) {
      window.requireNative = window.require;
      window.require = this.require;
    }
  }, "Static");
  Class(function LinkedList() {
    var prototype = LinkedList.prototype;
    this.length = 0;
    this.first = null;
    this.last = null;
    this.current = null;
    this.prev = null;
    if (prototype.push === undefined) {
      prototype.push = function (obj) {
        if (this.first) {
          obj.__next = this.first;
          obj.__prev = this.last;
          this.last.__next = obj;
          this.last = obj;
        } else {
          this.first = obj;
          this.last = obj;
          obj.__prev = obj;
          obj.__next = obj;
        }
        this.length++;
      };
      prototype.remove = function (obj) {
        if (obj && obj.__next) {
          if (this.length <= 1) {
            this.empty();
          } else {
            if (obj == this.first) {
              this.first = obj.__next;
              this.last.__next = this.first;
              this.first.__prev = this.last;
            } else if (obj == this.last) {
              this.last = obj.__prev;
              this.last.__next = this.first;
              this.first.__prev = this.last;
            } else {
              obj.__prev.__next = obj.__next;
              obj.__next.__prev = obj.__prev;
            }
            this.length--;
          }
          obj.__prev = null;
          obj.__next = null;
        }
      };
      prototype.empty = function () {
        this.first = null;
        this.last = null;
        this.current = null;
        this.prev = null;
        this.length = 0;
      };
      prototype.start = function () {
        this.current = this.first;
        this.prev = this.current;
        return this.current;
      };
      prototype.next = function () {
        if (this.current && (this.current = this.current.__next, this.length != 1 && this.prev.__next != this.first)) {
          this.prev = this.current;
          return this.current;
        }
      };
      prototype.destroy = function () {
        Utils.nullObject(this);
        return null;
      };
    }
  });
  Class(function ObjectPool(_type, _number = 10) {
    var _pool = [];
    this.array = _pool;
    (function () {
      if (_type) {
        for (var i = 0; i < _number; i++) {
          _pool.push(new _type());
        }
      }
    })();
    this.get = function () {
      return _pool.shift() || (_type ? new _type() : null);
    };
    this.empty = function () {
      _pool.length = 0;
    };
    this.put = function (obj) {
      if (obj) {
        _pool.push(obj);
      }
    };
    this.insert = function (array) {
      if (array.push === undefined) {
        array = [array];
      }
      for (var i = 0; i < array.length; i++) {
        _pool.push(array[i]);
      }
    };
    this.length = function () {
      return _pool.length;
    };
    this.randomize = function () {
      let array = _pool;
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    };
    this.destroy = function () {
      for (let i = _pool.length - 1; i >= 0; i--) {
        if (_pool[i].destroy) {
          _pool[i].destroy();
        }
      }
      return _pool = null;
    };
  });
  Class(function Gate() {
    var _list = [];
    var _map = {};
    this.create = function (name) {
      let promise = Promise.create();
      if (name) {
        _map[name] = promise;
      } else {
        _list.push(promise);
      }
    };
    this.open = function (name) {
      if (name) {
        _map[name] ||= Promise.create();
        _map[name].resolve();
      }
      let promise = _list.shift();
      if (promise) {
        promise.resolve();
      }
    };
    this.wait = function (name) {
      if (_list.length || name) {
        if (name) {
          _map[name] ||= Promise.create();
          return _map[name];
        } else {
          return _list[_list.length - 1] || Promise.resolve();
        }
      } else {
        return Promise.resolve();
      }
    };
  }, "static");
  Class(function Assets() {
    const _this = this;
    function AssetList(arr) {
      arr.__proto__ = AssetList.prototype;
      return arr;
    }
    this.__loaded = [];
    this.FLIPY = true;
    this.CDN = "";
    this.CORS = "anonymous";
    this.IMAGES = {};
    this.VIDEOS = {};
    this.AUDIOS = {};
    this.SDF = {};
    this.JSON = {
      push: function (prop, value) {
        this[prop] = value;
        Object.defineProperty(this, prop, {
          get: () => JSON.parse(JSON.stringify(value))
        });
      }
    };
    Object.defineProperty(this.JSON, "push", {
      enumerable: false,
      writable: true
    });
    this.SVG = {};
    AssetList.prototype = new Array();
    AssetList.prototype.filter = function (items) {
      for (let i = this.length - 1; i >= 0; i--) {
        if (!this[i].includes(items)) {
          this.splice(i, 1);
        }
      }
      return this;
    };
    AssetList.prototype.exclude = function (items) {
      for (let i = this.length - 1; i >= 0; i--) {
        if (this[i].includes(items)) {
          this.splice(i, 1);
        }
      }
      return this;
    };
    AssetList.prototype.prepend = function (prefix) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = prefix + this[i];
      }
      return this;
    };
    AssetList.prototype.append = function (suffix) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = this[i] + suffix;
      }
      return this;
    };
    this.list = function () {
      if (!window.ASSETS) {
        console.warn("ASSETS list not available");
      }
      return new AssetList(window.ASSETS.slice(0) || []);
    };
    this.BASE_PATH = "";
    this.getPath = function (path) {
      if (path.includes("~")) {
        return _this.BASE_PATH + path.replace("~", "");
      }
      if (path.includes("//")) {
        return path;
      }
      path = function parseResolution(path) {
        if (!window.ASSETS || !ASSETS.RES) {
          return path;
        }
        var res = ASSETS.RES[path];
        var ratio = Math.min(Device.pixelRatio, 3);
        if (!res) {
          return path;
        }
        if (!res["x" + ratio]) {
          return path;
        }
        var split = path.split("/");
        var file = split[split.length - 1];
        split = file.split(".");
        return path.replace(file, split[0] + "-" + ratio + "x." + split[1]);
      }(path);
      if (_this.dictionary) {
        for (let pathKey in _this.dictionary) {
          if (_this.dictionary[pathKey].includes(path.split("?")[0])) {
            return pathKey + path;
          }
        }
      }
      if (this.CDN && !~path.indexOf(this.CDN)) {
        path = this.CDN + path;
      }
      return path;
    };
    this.registerPath = function (path, assets) {
      _this.dictionary ||= {};
      _this.dictionary[path] = assets;
    };
    this.loadImage = function (path, isStore) {
      var img = new Image();
      img.crossOrigin = this.CORS;
      img.src = _this.getPath(path);
      img.loadPromise = function () {
        let promise = Promise.create();
        img.onload = promise.resolve;
        return promise;
      };
      if (isStore) {
        this.IMAGES[path] = img;
      }
      return img;
    };
    this.decodeImage = function (path, params, promise) {
      promise ||= Promise.create();
      let img = _this.loadImage(path);
      img.onload = () => promise.resolve(img);
      img.onerror = () => _this.decodeImage("assets/images/_scenelayout/uv.jpg", params, promise);
      return promise;
    };
  }, "static");
  Class(function AssetLoader(_assets, _callback, ASSETS = Assets) {
    Inherit(this, Events);
    const _this = this;
    let _total = _assets.length;
    let _loaded = 0;
    let _lastFiredPercent = 0;
    function loadAsset() {
      let path = _assets.splice(_assets.length - 1, 1)[0];
      const name = path.split("assets/").last().split(".")[0];
      const ext = path.split(".").last().split("?")[0].toLowerCase();
      let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);
      if (!Assets.preventCache && ~Assets.__loaded.indexOf(path)) {
        return loaded();
      }
      if (ext.includes(["jpg", "jpeg", "png", "gif"])) {
        let image = ASSETS.loadImage(path);
        if (image.complete) {
          return loaded();
        } else {
          image.onload = loaded;
          image.onerror = loaded;
          return;
        }
      }
      function loaded() {
        if (timeout) {
          clearTimeout(timeout);
        }
        increment();
        if (_assets.length) {
          loadAsset();
        }
      }
      if (ext.includes(["mp4", "webm"])) {
        fetch(path).then(async response => {
          let blob = await response.blob();
          Assets.VIDEOS[name] = URL.createObjectURL(blob);
          loaded();
        }).catch(e => {
          console.warn(e);
          loaded();
        });
      } else if (ext.includes(["mp3"])) {
        fetch(path).then(async response => {
          let blob = await response.blob();
          Assets.AUDIOS[name] = URL.createObjectURL(blob);
          loaded();
        }).catch(e => {
          console.warn(e);
          loaded();
        });
      } else {
        get(Assets.getPath(path), Assets.HEADERS).then(data => {
          Assets.__loaded.push(path);
          if (ext == "json") {
            ASSETS.JSON.push(name, data);
          }
          if (ext == "svg") {
            ASSETS.SVG[name] = data;
          }
          if (ext == "fnt") {
            ASSETS.SDF[name.split("/")[1]] = data;
          }
          if (ext == "js") {
            window.eval(data);
          }
          if (ext.includes(["fs", "vs", "glsl"]) && window.Shaders) {
            Shaders.parse(data, path);
          }
          loaded();
        }).catch(e => {
          console.warn(e);
          loaded();
        });
      }
    }
    function increment() {
      let percent = Math.max(_lastFiredPercent, Math.min(1, ++_loaded / _total));
      _this.events.fire(Events.PROGRESS, {
        percent: percent
      });
      _lastFiredPercent = percent;
      if (_loaded >= _total) {
        defer(complete);
      }
    }
    function complete() {
      if (!_this.completed) {
        _this.completed = true;
        defer(() => {
          if (_callback) {
            _callback();
          }
          _this.events.fire(Events.COMPLETE);
        });
      }
    }
    function timedOut(path) {
      console.warn("Asset timed out", path);
    }
    (function () {
      if (!Array.isArray(_assets)) {
        throw "AssetLoader requires array of assets to load";
      }
      _assets = _assets.slice(0).reverse();
      (function init() {
        if (!_assets.length) {
          return complete();
        }
        for (let i = 0; i < AssetLoader.SPLIT; i++) {
          if (_assets.length) {
            loadAsset();
          }
        }
      })();
    })();
    this.loadModules = function () {
      if (!window._BUILT_) {
        return;
      }
      this.add(1);
      let module = window._ES5_ ? "es5-modules" : "modules";
      let s = document.createElement("script");
      s.src = "assets/js/" + module + ".js?" + window._CACHE_;
      s.async = true;
      document.head.appendChild(s);
      return AssetLoader.waitForLib("_MODULES_").then(_ => _this.trigger(1));
    };
    this.add = function (num) {
      _total += num || 1;
    };
    this.trigger = function (num) {
      for (let i = 0; i < (num || 1); i++) {
        increment();
      }
    };
  }, () => {
    AssetLoader.SPLIT = 2;
    AssetLoader.TIMEOUT = 5000;
    AssetLoader.loadAllAssets = function (callback) {
      let promise = Promise.create();
      callback ||= promise.resolve;
      promise.loader = new AssetLoader(Assets.list(), () => {
        if (callback) {
          callback();
        }
        if (promise.loader && promise.loader.destroy) {
          promise.loader = promise.loader.destroy();
        }
      });
      return promise;
    };
    AssetLoader.loadAssets = function (list, callback) {
      let promise = Promise.create();
      callback ||= promise.resolve;
      promise.loader = new AssetLoader(list, () => {
        if (callback) {
          callback();
        }
        if (promise.loader && promise.loader.destroy) {
          promise.loader = promise.loader.destroy();
        }
      });
      return promise;
    };
    AssetLoader.waitForLib = function (name, callback) {
      let promise = Promise.create();
      callback ||= promise.resolve;
      Render.start(function check() {
        if (window[name]) {
          Render.stop(check);
          if (callback) {
            callback();
          }
        }
      });
      return promise;
    };
    AssetLoader.waitForModules = function () {
      return AssetLoader.waitForLib(window._BUILT_ ? "_MODULES_" : "zUtils3D");
    };
  });
  (function (e, t) {
    if (typeof exports == "object" && typeof module != "undefined") {
      t(exports);
    } else if (typeof define == "function" && define.amd) {
      define(["exports"], t);
    } else {
      t((e = e || self).goober = {});
    }
  })(this, function (e) {
    let t = {
      data: ""
    };
    let n = e => typeof window != "undefined" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), {
      innerHTML: " ",
      id: "_goober"
    })).firstChild : e || t;
    let o = /(?:([A-Z0-9-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(})/gi;
    let r = /\/\*[^]*?\*\/|\s\s+|\n/g;
    let l = (e, t) => {
      let n;
      let o = "";
      let r = "";
      let a = "";
      for (let s in e) {
        let c = e[s];
        if (typeof c == "object") {
          n = t ? t.replace(/([^,])+/g, e => s.replace(/([^,])+/g, t => /&/.test(t) ? t.replace(/&/g, e) : e ? e + " " + t : t)) : s;
          r += s[0] == "@" ? s[1] == "f" ? l(c, s) : s + "{" + l(c, s[1] == "k" ? "" : t) + "}" : l(c, n);
        } else if (s[0] == "@" && s[1] == "i") {
          o = s + " " + c + ";";
        } else {
          s = s.replace(/[A-Z]/g, "-$&").toLowerCase();
          a += l.p ? l.p(s, c) : s + ":" + c + ";";
        }
      }
      if (a[0]) {
        n = t ? t + "{" + a + "}" : a;
        return o + n + r;
      } else {
        return o + r;
      }
    };
    let a = {};
    let s = e => {
      let t = "";
      for (let n in e) {
        t += n + (typeof e[n] == "object" ? s(e[n]) : e[n]);
      }
      return t;
    };
    let c = (e, t, n, c, i) => {
      let f = typeof e == "object" ? s(e) : e;
      let p = a[f] ||= (e => {
        let t = 0;
        let n = 11;
        while (t < e.length) {
          n = n * 101 + e.charCodeAt(t++) >>> 0;
        }
        return "go" + n;
      })(f);
      if (!a[p]) {
        let t = typeof e == "object" ? e : (e => {
          let t;
          let n = [{}];
          while (t = o.exec(e.replace(r, ""))) {
            if (t[4]) {
              n.shift();
            }
            if (t[3]) {
              n.unshift(n[0][t[3]] = n[0][t[3]] || {});
            } else if (!t[4]) {
              n[0][t[1]] = t[2];
            }
          }
          return n[0];
        })(e);
        a[p] = l(i ? {
          ["@keyframes " + p]: t
        } : t, n ? "" : "." + p);
      }
      ((e, t, n) => {
        if (t.data.indexOf(e) == -1) {
          t.data = n ? e + t.data : t.data + e;
        }
      })(a[p], t, c);
      return p;
    };
    let i = (e, t, n) => e.reduce((e, o, r) => {
      let a = t[r];
      if (a && a.call) {
        let e = a(n);
        let t = e && e.props && e.props.className || /^go/.test(e) && e;
        a = t ? "." + t : e && typeof e == "object" ? e.props ? "" : l(e, "") : e;
      }
      return e + o + (a == null ? "" : a);
    }, "");
    function f(e) {
      let t = this || {};
      let o = e.call ? e(t.p) : e;
      return c(o.unshift ? o.raw ? i(o, [].slice.call(arguments, 1), t.p) : o.reduce((e, n) => n ? Object.assign(e, n.call ? n(t.p) : n) : e, {}) : o, n(t.target), t.g, t.o, t.k);
    }
    let p;
    let d;
    let u;
    let g = f.bind({
      g: 1
    });
    let b = f.bind({
      k: 1
    });
    e.css = f;
    e.extractCss = e => {
      let t = n(e);
      let o = t.data;
      t.data = "";
      return o;
    };
    e.glob = g;
    e.keyframes = b;
    e.setup = function (e, t, n, o) {
      l.p = t;
      p = e;
      d = n;
      u = o;
    };
    e.styled = function (e, t) {
      let n = this || {};
      return function () {
        let o = arguments;
        function r(l, a) {
          let s = Object.assign({}, l);
          let c = s.className || r.className;
          n.p = Object.assign({
            theme: d && d()
          }, s);
          n.o = / *go\d+/.test(c);
          s.className = f.apply(n, o) + (c ? " " + c : "");
          if (t) {
            s.ref = a;
          }
          let i = s.as || e;
          if (u && i[0]) {
            u(s);
          }
          return p(i, s);
        }
        if (t) {
          return t(r);
        } else {
          return r;
        }
      };
    };
  });
  (function (i, n) {
    if (typeof exports == "object" && typeof module != "undefined") {
      n(exports);
    } else if (typeof define == "function" && define.amd) {
      define(["exports"], n);
    } else {
      n((i = i || self).gooberPrefixer = {});
    }
  })(this, function (i) {
    var n = new Map([["align-self", "-ms-grid-row-align"], ["color-adjust", "-webkit-print-color-adjust"], ["column-gap", "grid-column-gap"], ["gap", "grid-gap"], ["grid-template-columns", "-ms-grid-columns"], ["grid-template-rows", "-ms-grid-rows"], ["justify-self", "-ms-grid-column-align"], ["margin-inline-end", "-webkit-margin-end"], ["margin-inline-start", "-webkit-margin-start"], ["overflow-wrap", "word-wrap"], ["padding-inline-end", "-webkit-padding-end"], ["padding-inline-start", "-webkit-padding-start"], ["row-gap", "grid-row-gap"], ["scroll-margin-bottom", "scroll-snap-margin-bottom"], ["scroll-margin-left", "scroll-snap-margin-left"], ["scroll-margin-right", "scroll-snap-margin-right"], ["scroll-margin-top", "scroll-snap-margin-top"], ["scroll-margin", "scroll-snap-margin"], ["text-combine-upright", "-ms-text-combine-horizontal"]]);
    i.prefix = function (i, r) {
      let t = "";
      const e = n.get(i);
      if (e) {
        t += `${e}:${r};`;
      }
      const o = function (i) {
        var n = /^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|(?:mask(?:$|-[ispro]|-cl)))|(tab-|column(?!-s)|text-align-l)|(ap)|(u|hy))/i.exec(i);
        if (n) {
          if (n[1]) {
            return 1;
          } else if (n[2]) {
            return 2;
          } else if (n[3]) {
            return 3;
          } else {
            return 5;
          }
        } else {
          return 0;
        }
      }(i);
      if (o & 1) {
        t += `-webkit-${i}:${r};`;
      }
      if (o & 2) {
        t += `-moz-${i}:${r};`;
      }
      if (o & 4) {
        t += `-ms-${i}:${r};`;
      }
      const a = function (i, n) {
        var r = /^(?:(pos)|(background-i)|((?:max-|min-)?(?:block-s|inl|he|widt))|(dis))/i.exec(i);
        if (r) {
          if (r[1]) {
            if (/^sti/i.test(n)) {
              return 1;
            } else {
              return 0;
            }
          } else if (r[2]) {
            if (/^image-/i.test(n)) {
              return 1;
            } else {
              return 0;
            }
          } else if (r[3]) {
            if (n[3] === "-") {
              return 2;
            } else {
              return 0;
            }
          } else if (/^(inline-)?grid$/i.test(n)) {
            return 4;
          } else {
            return 0;
          }
        } else {
          return 0;
        }
      }(i, r);
      if (a & 1) {
        t += `${i}:-webkit-${r};`;
      } else if (a & 2) {
        t += `${i}:-moz-${r};`;
      } else if (a & 4) {
        t += `${i}:-ms-${r};`;
      }
      t += `${i}:${r};`;
      return t;
    };
  });
  (function (e, o) {
    if (typeof exports == "object" && typeof module != "undefined") {
      o(exports, require("goober"));
    } else if (typeof define == "function" && define.amd) {
      define(["exports", "goober"], o);
    } else {
      o((e = e || self).gooberGlobal = {}, e.goober);
    }
  })(this, function (e, o) {
    let n = o.css.bind({
      g: 1
    });
    e.createGlobalStyles = function () {
      const e = o.styled.call({
        g: 1
      }, "div").apply(null, arguments);
      return function (o) {
        e(o);
        return null;
      };
    };
    e.glob = n;
  });
  Hydra.ready(function () {
    window.__window = $(window);
    window.__document = $(document);
    window.__body = $(document.getElementsByTagName("body")[0]);
    window.Stage = window.Stage && window.Stage.style ? $(window.Stage) : __body.create("#Stage");
    Stage.size("100%");
    Stage.__useFragment = true;
    Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
    Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
  });
  Class(function HydraCSS() {
    var _tag;
    var _obj;
    var _style;
    var _needsUpdate;
    var _this = this;
    function objToCSS(key) {
      var match = key.match(/[A-Z]/);
      var camelIndex = match ? match.index : null;
      if (camelIndex) {
        var start = key.slice(0, camelIndex);
        var end = key.slice(camelIndex);
        key = start + "-" + end.toLowerCase();
      }
      return key;
    }
    function setHTML() {
      _tag.innerHTML = _style;
      _needsUpdate = false;
    }
    Hydra.ready(function () {
      _obj = {};
      _style = "";
      (_tag = document.createElement("style")).type = "text/css";
      document.getElementsByTagName("head")[0].appendChild(_tag);
    });
    this._read = function () {
      return _style;
    };
    this._write = function (css) {
      _style = css;
      if (!_needsUpdate) {
        _needsUpdate = true;
        defer(setHTML);
      }
    };
    this.style = function (selector, obj = {}) {
      _obj[selector] ||= {};
      Object.assign(_obj[selector], obj);
      (function render() {
        var s = "";
        for (let selector in _obj) {
          let obj = _obj[selector];
          s += `${selector} {`;
          for (var key in obj) {
            var prop = objToCSS(key);
            var val = obj[key];
            if (typeof val != "string" && key != "opacity") {
              val += "px";
            }
            s += prop + ":" + val + "!important;";
          }
          s += "}";
        }
        _this._write(s);
      })();
    };
    this.get = function (selector, prop) {
      if (!_obj[selector]) {
        if (prop) {
          return null;
        } else {
          return {};
        }
      }
      let obj = Object.assign({}, _obj[selector]);
      if (prop) {
        return obj[prop];
      } else {
        return obj;
      }
    };
    this.textSize = function ($obj) {
      var $clone = $obj.clone();
      $clone.css({
        position: "relative",
        cssFloat: "left",
        styleFloat: "left",
        marginTop: -99999,
        width: "",
        height: ""
      });
      __body.addChild($clone);
      var width = $clone.div.offsetWidth;
      var height = $clone.div.offsetHeight;
      $clone.remove();
      return {
        width: width,
        height: height
      };
    };
    this.prefix = function (style) {
      if (_this.styles.vendor == "") {
        return style.charAt(0).toLowerCase() + style.slice(1);
      } else {
        return _this.styles.vendor + style;
      }
    };
    this._toCSS = objToCSS;
  }, "Static");
  Class(function HydraObject(_selector, _type, _exists, _useFragment) {
    this._children = new LinkedList();
    this._onDestroy;
    this.__useFragment = _useFragment;
    this._initSelector(_selector, _type, _exists);
  }, () => {
    var prototype = HydraObject.prototype;
    prototype._initSelector = function (_selector, _type, _exists) {
      if (_selector && typeof _selector != "string") {
        this.div = _selector;
      } else {
        var first = _selector ? _selector.charAt(0) : null;
        var name = _selector ? _selector.slice(1) : null;
        if (first != "." && first != "#") {
          name = _selector;
          first = ".";
        }
        if (_exists) {
          if (first != "#") {
            throw "Hydra Selectors Require #ID";
          }
          this.div = document.getElementById(name);
        } else {
          this._type = _type || "div";
          if (this._type == "svg") {
            this.div = document.createElementNS("http://www.w3.org/2000/svg", this._type);
            this.div.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
          } else {
            this.div = document.createElement(this._type);
            if (first) {
              if (first == "#") {
                this.div.id = name;
              } else {
                this.div.className = name;
              }
            }
          }
        }
      }
      this.div.hydraObject = this;
    };
    prototype.add = function (child) {
      var div = this.div;
      var _this = this;
      function createFrag() {
        if (_this.__useFragment) {
          if (!_this._fragment) {
            _this._fragment = document.createDocumentFragment();
            defer(function () {
              if (!_this._fragment || !_this.div) {
                return _this._fragment = null;
              }
              _this.div.appendChild(_this._fragment);
              _this._fragment = null;
            });
          }
          div = _this._fragment;
        }
      }
      if (child.element && child.element instanceof HydraObject) {
        createFrag();
        div.appendChild(child.element.div);
        this._children.push(child.element);
        child.element._parent = this;
        child.element.div.parentNode = this.div;
      } else if (child.div) {
        createFrag();
        div.appendChild(child.div);
        this._children.push(child);
        child._parent = this;
        child.div.parentNode = this.div;
      } else if (child.nodeName) {
        createFrag();
        div.appendChild(child);
        child.parentNode = this.div;
      }
      return this;
    };
    prototype.clone = function () {
      return $(this.div.cloneNode(true));
    };
    prototype.create = function (name, type) {
      var $obj = $(name, type);
      this.add($obj);
      return $obj;
    };
    prototype.empty = function () {
      for (var child = this._children.start(); child;) {
        var next = this._children.next();
        if (child && child.remove) {
          child.remove();
        }
        child = next;
      }
      this.div.innerHTML = "";
      return this;
    };
    prototype.parent = function () {
      return this._parent;
    };
    prototype.children = function (isHydraChildren = false) {
      let children = this.div.children ? this.div.children : this.div.childNodes;
      if (isHydraChildren) {
        children = [];
        for (var child = this._children.start(); child;) {
          if (child) {
            children.push(child);
            child = this._children.next();
          }
        }
      }
      return children;
    };
    prototype.removeChild = function (object, keep) {
      try {
        object.div.parentNode.removeChild(object.div);
      } catch (e) {}
      if (!keep) {
        this._children.remove(object);
      }
    };
    prototype.remove = function (param) {
      if (param) {
        console.warn("HydraObject.remove removes ITSELF from its parent. use removeChild instead");
      }
      if (this._onDestroy) {
        this._onDestroy.forEach(cb => cb());
      }
      this.removed = true;
      var parent = this._parent;
      if (parent && !parent.removed && parent.removeChild) {
        parent.removeChild(this, true);
      }
      for (var child = this._children.start(); child;) {
        var next = this._children.next();
        if (child && child.remove) {
          child.remove();
        }
        child = next;
      }
      this._children.destroy();
      this.div.hydraObject = null;
      Utils.nullObject(this);
    };
    prototype.destroy = function () {
      this.remove();
    };
    prototype._bindOnDestroy = function (cb) {
      this._onDestroy ||= [];
      this._onDestroy.push(cb);
    };
    window.$ = function (selector, type, exists) {
      return new HydraObject(selector, type, exists);
    };
    $.fn = HydraObject.prototype;
  });
  $.fn.text = function (text) {
    if (text !== undefined) {
      if (this.__cacheText != text) {
        this.div.textContent = text;
      }
      this.__cacheText = text;
      return this;
    } else {
      return this.div.textContent;
    }
  };
  $.fn.html = function (text, force) {
    if (!text || text.includes("<") || force) {
      if (text !== undefined) {
        this.div.innerHTML = text;
        return this;
      } else {
        return this.div.innerHTML;
      }
    } else {
      return this.text(text);
    }
  };
  $.fn.hide = function () {
    this.div.style.display = "none";
    return this;
  };
  $.fn.show = function () {
    this.div.style.display = "";
    return this;
  };
  $.fn.visible = function () {
    this.div.style.visibility = "visible";
    return this;
  };
  $.fn.invisible = function () {
    this.div.style.visibility = "hidden";
    return this;
  };
  $.fn.setZ = function (z) {
    this.div.style.zIndex = z;
    return this;
  };
  $.fn.clearAlpha = function () {
    this.div.style.opacity = "";
    return this;
  };
  $.fn.size = function (w, h, noScale) {
    if (typeof w == "string") {
      if (h === undefined) {
        h = "100%";
      } else if (typeof h != "string") {
        h += "px";
      }
      this.div.style.width = w;
      this.div.style.height = h;
    } else {
      this.div.style.width = w + "px";
      this.div.style.height = h + "px";
      if (!noScale) {
        this.div.style.backgroundSize = w + "px " + h + "px";
      }
    }
    this.width = w;
    this.height = h;
    return this;
  };
  $.fn.mouseEnabled = function (bool) {
    this.div.style.pointerEvents = bool ? "auto" : "none";
    return this;
  };
  $.fn.fontStyle = function (family, size, color, style) {
    var font = {};
    if (family) {
      font.fontFamily = family;
    }
    if (size) {
      font.fontSize = size;
    }
    if (color) {
      font.color = color;
    }
    if (style) {
      font.fontStyle = style;
    }
    this.css(font);
    return this;
  };
  $.fn.font = function (font) {
    this.css("font", font);
    return this;
  };
  $.fn.bg = function (src, x, y, repeat) {
    if (src) {
      if (src.includes(".")) {
        src = Assets.getPath(src);
      }
      if (src.includes(".")) {
        this.div.style.backgroundImage = "url(" + src + ")";
      } else {
        this.div.style.backgroundColor = src;
      }
      if (x !== undefined) {
        x = typeof x == "number" ? x + "px" : x;
        y = typeof y == "number" ? y + "px" : y;
        this.div.style.backgroundPosition = x + " " + y;
      }
      if (repeat) {
        this.div.style.backgroundSize = "";
        this.div.style.backgroundRepeat = repeat;
      }
      if (x == "cover" || x == "contain") {
        this.div.style.backgroundSize = x;
        this.div.style.backgroundPosition = y !== undefined ? y + " " + repeat : "center";
      }
      return this;
    } else {
      return this;
    }
  };
  $.fn.center = function (x, y, noPos) {
    var css = {};
    if (x === undefined) {
      css.left = "50%";
      css.top = "50%";
      css.marginLeft = -this.width / 2;
      css.marginTop = -this.height / 2;
    } else {
      if (x) {
        css.left = "50%";
        css.marginLeft = -this.width / 2;
      }
      if (y) {
        css.top = "50%";
        css.marginTop = -this.height / 2;
      }
    }
    if (noPos) {
      delete css.left;
      delete css.top;
    }
    this.css(css);
    return this;
  };
  $.fn.max = function (width, height) {
    let w;
    let h;
    if (width !== undefined) {
      w = typeof width == "number" ? width + "px" : width;
      this.div.style.maxWidth = w;
    }
    if (height !== undefined) {
      h = typeof height == "number" ? height + "px" : height;
      this.div.style.maxHeight = h;
    } else {
      h = w;
      this.div.style.maxHeight = h;
    }
    return this;
  };
  $.fn.min = function (width, height) {
    let w;
    let h;
    if (width !== undefined) {
      w = typeof width == "number" ? width + "px" : width;
      this.div.style.minWidth = w;
    }
    if (height !== undefined) {
      h = typeof height == "number" ? height + "px" : height;
      this.div.style.minHeight = h;
    } else {
      h = w;
      this.div.style.minHeight = h;
    }
    return this;
  };
  $.fn.flex = function (inline) {
    this.div.style.display = inline ? "inline-flex" : "flex";
    this.div.style.justifyContent = "center";
    this.div.style.alignItems = "center";
    this.div.classList.add("relative-children");
    return this;
  };
  $.fn.order = function (opts = {}) {
    let s = this.div.style;
    if (opts.flexWrap === "none") {
      opts.flexWrap = "nowrap";
    }
    if (opts.direction) {
      s.flexDirection = opts.direction;
    }
    if (opts.wrap) {
      s.flexWrap = opts.wrap;
    }
    if (opts.order) {
      s.order = opts.order;
    }
    return this;
  };
  $.fn.align = function (opts = {}) {
    let s = this.div.style;
    function flex(str, contentMode = false) {
      if (str === "start") {
        return "flex-start";
      } else if (str === "end") {
        return "flex-end";
      } else if (str === "between") {
        if (contentMode) {
          return "space-between";
        } else {
          return "flex-between";
        }
      } else if (str === "around") {
        if (contentMode) {
          return "space-around";
        } else {
          return "flex-around";
        }
      } else if (str === "none") {
        return "nowrap";
      } else {
        return str;
      }
    }
    if (opts.justify) {
      s.justifyContent = flex(opts.justify);
    }
    if (opts.items) {
      s.alignItems = flex(opts.items);
    }
    if (opts.self) {
      s.alignSelf = flex(opts.self);
    }
    if (opts.content) {
      s.alignContent = flex(opts.content, true);
    }
    return this;
  };
  $.fn.flexibility = function (opts = {}) {
    let s = this.div.style;
    if (opts.grow !== "undefined") {
      s.flexGrow = opts.grow;
    }
    if (opts.shrink !== "undefined") {
      s.flexGrow = opts.shrink;
    }
    if (opts.basis !== undefined) {
      s.flexBasis = typeof opts.basis == "number" ? opts.basis + "px" : opts.basis;
    }
    return this;
  };
  $.fn.mask = function (arg) {
    let maskPrefix = HydraCSS.styles.vendor === "Moz" ? "mask" : HydraCSS.prefix("Mask");
    this.div.style[maskPrefix] = (arg.includes(".") ? "url(" + arg + ")" : arg) + " no-repeat";
    this.div.style[maskPrefix + "Size"] = "contain";
    return this;
  };
  $.fn.blendMode = function (mode, bg) {
    if (bg) {
      this.div.style["background-blend-mode"] = mode;
    } else {
      this.div.style["mix-blend-mode"] = mode;
    }
    return this;
  };
  $.fn.css = function (obj, value) {
    if (typeof value == "boolean") {
      value = null;
    }
    if (typeof obj != "object") {
      if (value) {
        this.div.style[obj] = value;
        return this;
      }
      var style = this.div.style[obj];
      if (typeof style != "number") {
        if (!style) {
          return false;
        }
        if (style.includes("px")) {
          style = Number(style.slice(0, -2));
        }
        if (obj == "opacity") {
          style = isNaN(Number(this.div.style.opacity)) ? 1 : Number(this.div.style.opacity);
        }
      }
      style ||= 0;
      return style;
    }
    TweenManager._clearCSSTween(this);
    for (var type in obj) {
      var val = obj[type];
      if (typeof val == "string" || typeof val == "number") {
        if (typeof val != "string" && type != "opacity" && type != "zIndex") {
          val += "px";
        }
        if (type == "position" && val == "sticky" && Device.system.browser == "safari") {
          val = "-webkit-sticky";
        }
        this.div.style[type] = val;
      }
    }
    return this;
  };
  $.fn.transform = function (props) {
    TweenManager._clearCSSTween(this);
    if (Device.tween.css2d) {
      if (props) {
        for (var key in props) {
          if (typeof props[key] == "number" || typeof props[key] == "string") {
            this[key] = props[key];
          }
        }
      } else {
        props = this;
      }
      var transformString = TweenManager._parseTransform(props);
      if (this.__transformCache != transformString) {
        this.div.style[HydraCSS.styles.vendorTransform] = transformString;
        this.__transformCache = transformString;
      }
    }
    return this;
  };
  $.fn.willChange = function (props) {
    if (typeof props == "boolean") {
      this._willChangeLock = props === true;
    } else if (this._willChangeLock) {
      return;
    }
    var string = typeof props == "string";
    if (this._willChange && !string || typeof props == "null") {
      this._willChange = false;
      this.div.style["will-change"] = "";
    } else {
      this._willChange = true;
      this.div.style["will-change"] = string ? props : HydraCSS.transformProperty + ", opacity";
    }
  };
  $.fn.backfaceVisibility = function (visible) {
    this.div.style[HydraCSS.prefix("BackfaceVisibility")] = visible ? "visible" : "hidden";
  };
  $.fn.enable3D = function (perspective, x, y) {
    if (Device.tween.css3d) {
      this.div.style[HydraCSS.prefix("TransformStyle")] = "preserve-3d";
      if (perspective) {
        this.div.style[HydraCSS.prefix("Perspective")] = perspective + "px";
      }
      if (x !== undefined) {
        x = typeof x == "number" ? x + "px" : x;
        y = typeof y == "number" ? y + "px" : y;
        this.div.style[HydraCSS.prefix("PerspectiveOrigin")] = x + " " + y;
      }
      return this;
    } else {
      return this;
    }
  };
  $.fn.disable3D = function () {
    this.div.style[HydraCSS.prefix("TransformStyle")] = "";
    this.div.style[HydraCSS.prefix("Perspective")] = "";
    return this;
  };
  $.fn.transformPoint = function (x, y, z) {
    var origin = "";
    if (x !== undefined) {
      origin += typeof x == "number" ? x + "px " : x + " ";
    }
    if (y !== undefined) {
      origin += typeof y == "number" ? y + "px " : y + " ";
    }
    if (z !== undefined) {
      origin += typeof z == "number" ? z + "px" : z;
    }
    this.div.style[HydraCSS.prefix("TransformOrigin")] = origin;
    return this;
  };
  $.fn.tween = function (props, time, ease, delay, callback, manual) {
    if (typeof delay == "boolean") {
      manual = delay;
      delay = 0;
      callback = null;
    } else if (typeof delay == "function") {
      callback = delay;
      delay = 0;
    }
    if (typeof callback == "boolean") {
      manual = callback;
      callback = null;
    }
    delay ||= 0;
    var usePromise = null;
    if (callback && callback instanceof Promise) {
      usePromise = callback;
      callback = callback.resolve;
    }
    var tween = TweenManager._detectTween(this, props, time, ease, delay, callback, manual);
    return usePromise || tween;
  };
  $.fn.clearTransform = function () {
    if (typeof this.x == "number") {
      this.x = 0;
    }
    if (typeof this.y == "number") {
      this.y = 0;
    }
    if (typeof this.z == "number") {
      this.z = 0;
    }
    if (typeof this.scale == "number") {
      this.scale = 1;
    }
    if (typeof this.scaleX == "number") {
      this.scaleX = 1;
    }
    if (typeof this.scaleY == "number") {
      this.scaleY = 1;
    }
    if (typeof this.rotation == "number") {
      this.rotation = 0;
    }
    if (typeof this.rotationX == "number") {
      this.rotationX = 0;
    }
    if (typeof this.rotationY == "number") {
      this.rotationY = 0;
    }
    if (typeof this.rotationZ == "number") {
      this.rotationZ = 0;
    }
    if (typeof this.skewX == "number") {
      this.skewX = 0;
    }
    if (typeof this.skewY == "number") {
      this.skewY = 0;
    }
    this.div.style[HydraCSS.styles.vendorTransform] = "";
    this.__transformCache = "";
    return this;
  };
  $.fn.clearTween = function () {
    if (this._cssTween) {
      this._cssTween.stop();
    }
    if (this._mathTween) {
      this._mathTween.stop();
    }
    return this;
  };
  $.fn.stopTween = function () {
    console.warn(".stopTween deprecated. use .clearTween instead");
    return this.clearTween();
  };
  $.fn.keypress = function (callback) {
    this.div.onkeypress = function (e) {
      (e = e || window.event).code = e.keyCode ? e.keyCode : e.charCode;
      if (callback) {
        callback(e);
      }
    };
  };
  $.fn.keydown = function (callback) {
    this.div.onkeydown = function (e) {
      (e = e || window.event).code = e.keyCode;
      if (callback) {
        callback(e);
      }
    };
  };
  $.fn.keyup = function (callback) {
    this.div.onkeyup = function (e) {
      (e = e || window.event).code = e.keyCode;
      if (callback) {
        callback(e);
      }
    };
  };
  $.fn.attr = function (attr, value) {
    if (typeof attr != "string") {
      return this;
    } else if (value === undefined) {
      return this.div.getAttribute(attr);
    } else {
      if (value === false || value === null) {
        this.div.removeAttribute(attr);
      } else {
        this.div.setAttribute(attr, value);
      }
      return this;
    }
  };
  $.fn.val = function (value) {
    if (value === undefined) {
      return this.div.value;
    } else {
      this.div.value = value;
      return this;
    }
  };
  $.fn.change = function (callback) {
    var _this = this;
    this.div.onchange = function () {
      callback({
        object: _this,
        value: _this.div.value || ""
      });
    };
  };
  $.fn.svgSymbol = function (id, width, height) {
    var config = SVG.getSymbolConfig(id);
    var svgHTML = "<svg viewBox=\"0 0 " + config.width + " " + config.height + "\" width=\"" + width + "\" height=\"" + height + "\"><use xlink:href=\"#" + config.id + "\" x=\"0\" y=\"0\" /></svg>";
    this.html(svgHTML, true);
  };
  $.fn.svg = async function (url) {
    let promise = Promise.create();
    fetch(url).then(async res => {
      let svgHTML = await res.text();
      this.html(svgHTML, true);
      promise.resolve();
    });
    return promise;
  };
  $.fn.overflowScroll = function (dir) {
    var x = !!dir.x;
    var y = !!dir.y;
    var overflow = {};
    if (!x && !y || x && y) {
      overflow.overflow = "auto";
    }
    if (!x && y) {
      overflow.overflowY = "auto";
      overflow.overflowX = "hidden";
    }
    if (x && !y) {
      overflow.overflowX = "auto";
      overflow.overflowY = "hidden";
    }
    if (Device.mobile) {
      overflow["-webkit-overflow-scrolling"] = "touch";
      Mobile._addOverflowScroll(this);
    }
    this.css(overflow);
  };
  $.fn.removeOverflowScroll = function () {
    this.css({
      overflow: "hidden",
      overflowX: "",
      overflowY: "",
      "-webkit-overflow-scrolling": ""
    });
    if (Device.mobile) {
      Mobile._removeOverflowScroll(this);
    }
  };
  $.fn.accessible = function (type = "label", tabIndex = -1) {
    if (tabIndex > -1) {
      this.attr("tabindex", tabIndex);
    }
    switch (type) {
      case "label":
        this.attr("aria-label", this.div.textContent);
        break;
      case "hidden":
        this.attr("aria-hidden", true);
    }
  };
  $.fn.tabIndex = function (tabIndex) {
    this.attr("tabindex", tabIndex);
    return this;
  };
  $.fn.createObserver = function (callback, {
    isViewport = false,
    ...options
  } = {}) {
    if (isViewport) {
      options.root = this.div;
    }
    const observer = this._observer = new IntersectionObserver(array => {
      array.forEach(entry => {
        entry.object = entry.target.hydraObject;
      });
      callback(array);
    }, options);
    this._bindOnDestroy(() => {
      observer.disconnect();
    });
    return this;
  };
  $.fn.observe = function (obj = this) {
    this._observer?.observe(obj.div);
    return this;
  };
  $.fn.unobserve = function (obj = this) {
    this._observer?.unobserve(obj.div);
    return this;
  };
  $.fn.cursor = function (cursor, lock) {
    if (lock) {
      this.cursorLock ||= new Map();
      if (cursor == "auto") {
        this.cursorLock.delete(lock);
      } else {
        this.cursorLock.set(lock, cursor);
      }
    }
    if (this.cursorLock && cursor == "auto") {
      this.cursorLock.forEach(v => {
        cursor = v;
      });
    }
    this.css("cursor", cursor);
    return this;
  };
  $.fn.classList = function () {
    return this.div.classList;
  };
  $.fn.goob = function (styles) {
    let _styles;
    _styles = typeof styles == "string" ? goober.css`${styles}` : goober.css(styles);
    this.goobClass = _styles;
    this.div.classList.add(_styles);
    return this;
  };
  (function () {
    var windowsPointer = !!window.MSGesture;
    function translateEvent(evt) {
      if (windowsPointer) {
        switch (evt) {
          case "touchstart":
            return "pointerdown";
          case "touchmove":
            return "MSGestureChange";
          case "touchend":
            return "pointerup";
        }
      }
      return evt;
    }
    function convertTouchEvent(e) {
      var touchEvent = {
        x: 0,
        y: 0
      };
      if (e.windowsPointer) {
        return e;
      }
      if (!e) {
        return touchEvent;
      }
      if (e.touches || e.changedTouches) {
        if (e.touches.length) {
          touchEvent.x = e.touches[0].clientX;
          touchEvent.y = e.touches[0].clientY;
        } else {
          touchEvent.x = e.changedTouches[0].clientX;
          touchEvent.y = e.changedTouches[0].clientY;
        }
      } else {
        touchEvent.x = e.clientX;
        touchEvent.y = e.clientY;
      }
      if (Mobile.ScreenLock && Mobile.ScreenLock.isActive && Mobile.orientationSet && Mobile.orientation !== Mobile.orientationSet) {
        if (window.orientation == 90 || window.orientation === 0) {
          var x = touchEvent.y;
          touchEvent.y = touchEvent.x;
          touchEvent.x = Stage.width - x;
        }
        if (window.orientation == -90 || window.orientation === 180) {
          var y = touchEvent.x;
          touchEvent.x = touchEvent.y;
          touchEvent.y = Stage.height - y;
        }
      }
      return touchEvent;
    }
    $.fn.click = function (callback) {
      var _this = this;
      this.div.addEventListener(translateEvent("click"), function click(e) {
        return !!_this.div && !Mouse._preventClicks && (e.object = _this.div.className == "hit" ? _this.parent() : _this, e.action = "click", callback && callback(e), void (Mouse.autoPreventClicks && Mouse.preventClicks()));
      }, true);
      this.div.style.cursor = "pointer";
      return this;
    };
    $.fn.hover = function (callback) {
      var _time;
      var _this = this;
      var _over = false;
      function hover(e) {
        if (!_this.div) {
          return false;
        }
        var time = performance.now();
        var original = e.toElement || e.relatedTarget;
        if (_time && time - _time < 5) {
          _time = time;
          return false;
        }
        _time = time;
        e.object = _this.div.className == "hit" ? _this.parent() : _this;
        switch (e.type) {
          case "mouseout":
          case "mouseleave":
            e.action = "out";
            break;
          default:
            e.action = "over";
        }
        if (_over) {
          if (Mouse._preventClicks) {
            return false;
          }
          if (e.action == "over") {
            return false;
          }
          if (e.action == "out" && isAChild(_this.div, original)) {
            return false;
          }
          _over = false;
        } else {
          if (e.action == "out") {
            return false;
          }
          _over = true;
        }
        if (callback) {
          callback(e);
        }
      }
      function isAChild(div, object) {
        var len = div.children.length - 1;
        for (var i = len; i > -1; i--) {
          if (object == div.children[i]) {
            return true;
          }
        }
        for (i = len; i > -1; i--) {
          if (isAChild(div.children[i], object)) {
            return true;
          }
        }
      }
      this.div.addEventListener(translateEvent("mouseover"), hover, true);
      this.div.addEventListener(translateEvent("mouseout"), hover, true);
      return this;
    };
    $.fn.press = function (callback) {
      var _this = this;
      function press(e) {
        if (!_this.div) {
          return false;
        }
        e.object = _this.div.className == "hit" ? _this.parent() : _this;
        switch (e.type) {
          case "mousedown":
            e.action = "down";
            break;
          default:
            e.action = "up";
        }
        if (callback) {
          callback(e);
        }
      }
      this.div.addEventListener(translateEvent("mousedown"), press, true);
      this.div.addEventListener(translateEvent("mouseup"), press, true);
      return this;
    };
    $.fn.bind = function (evt, callback) {
      this._events = this._events || {};
      if (windowsPointer && this == __window) {
        return Stage.bind(evt, callback);
      }
      if (evt == "touchstart") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.bind("mousedown", callback);
          } else {
            evt = "mousedown";
          }
        }
      } else if (evt == "touchmove") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.bind("mousemove", callback);
          } else {
            evt = "mousemove";
          }
        }
        if (windowsPointer && !this.div.msGesture) {
          this.div.msGesture = new MSGesture();
          this.div.msGesture.target = this.div;
        }
      } else if (evt == "touchend") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.bind("mouseup", callback);
          } else {
            evt = "mouseup";
          }
        }
      }
      this._events["bind_" + evt] = this._events["bind_" + evt] || [];
      var _events = this._events["bind_" + evt];
      var e = {};
      var target = this.div;
      function touchEvent(e) {
        if (windowsPointer && target.msGesture && evt == "touchstart") {
          target.msGesture.addPointer(e.pointerId);
        }
        if (!Device.mobile && evt == "touchstart") {
          e.preventDefault();
        }
        var touch = convertTouchEvent(e);
        if (windowsPointer) {
          var windowsEvt = e;
          (e = {}).preventDefault = () => windowsEvt.preventDefault();
          e.stopPropagation = () => windowsEvt.stopPropagation();
          e.x = Number(windowsEvt.clientX);
          e.y = Number(windowsEvt.clientY);
          e.target = windowsEvt.target;
          e.currentTarget = windowsEvt.currentTarget;
          e.path = [];
          for (var node = e.target; node;) {
            e.path.push(node);
            node = node.parentElement || null;
          }
          e.windowsPointer = true;
        } else {
          e.x = touch.x;
          e.y = touch.y;
        }
        for (var i = 0; i < _events.length; i++) {
          var ev = _events[i];
          if (ev.target == e.currentTarget) {
            ev.callback(e);
          }
        }
      }
      e.callback = callback;
      e.target = this.div;
      _events.push(e);
      const safariEvents = ["wheel"];
      if (!this._events["fn_" + evt]) {
        this._events["fn_" + evt] = touchEvent;
        this.div.addEventListener(translateEvent(evt), touchEvent, {
          capture: true,
          passive: Device.system.browser == "safari" && !!safariEvents.includes(evt)
        });
      }
      return this;
    };
    $.fn.unbind = function (evt, callback) {
      this._events = this._events || {};
      if (windowsPointer && this == __window) {
        return Stage.unbind(evt, callback);
      }
      if (evt == "touchstart") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.unbind("mousedown", callback);
          } else {
            evt = "mousedown";
          }
        }
      } else if (evt == "touchmove") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.unbind("mousemove", callback);
          } else {
            evt = "mousemove";
          }
        }
      } else if (evt == "touchend") {
        if (!Device.mobile) {
          if (Device.touchCapable) {
            this.unbind("mouseup", callback);
          } else {
            evt = "mouseup";
          }
        }
      }
      var _events = this._events["bind_" + evt];
      if (!_events) {
        return this;
      }
      for (var i = 0; i < _events.length; i++) {
        if (_events[i].callback == callback) {
          _events.splice(i, 1);
        }
      }
      if (this._events["fn_" + evt] && !_events.length) {
        this.div.removeEventListener(translateEvent(evt), this._events["fn_" + evt], !Device.mobile || {
          passive: true
        });
        this._events["fn_" + evt] = null;
      }
      return this;
    };
    $.fn.interact = function (overCallback, clickCallback, seoLink, seoText, zIndex, options) {
      if (!this.hit) {
        if (typeof arguments[arguments.length - 1] == "object") {
          options = arguments[arguments.length - 1];
          [overCallback, clickCallback, seoLink, seoText, zIndex] = Array.prototype.slice.call(arguments, 0, -1);
          if (options.overCallback) {
            overCallback = options.overCallback;
          }
          if (options.clickCallback) {
            clickCallback = options.clickCallback;
          }
          if (options.seoLink) {
            seoLink = options.seoLink;
          }
          if (options.seoText) {
            seoText = options.seoText;
          }
          if (options.zIndex) {
            zIndex = options.zIndex;
          }
        }
        options ||= {};
        this.hit = $(".hit", seoLink ? "a" : undefined);
        this.hit.css({
          width: "100%",
          height: "100%",
          zIndex: zIndex || 99999,
          top: 0,
          left: 0,
          position: "absolute"
        });
        this.add(this.hit);
        var _this = this;
        if (seoLink) {
          this.hit.attr("href", seoLink === "#" ? seoLink : Hydra.absolutePath(seoLink));
          this.hit.text(seoText || this.div.textContent);
          this.hit.css({
            fontSize: 0
          });
          this.hit.accessible();
          if (typeof overCallback == "function") {
            this.hit.div.onfocus = _ => overCallback({
              action: "over",
              object: this
            });
            this.hit.div.onblur = _ => overCallback({
              action: "out",
              object: this
            });
          }
          this.hit.div.onclick = e => {
            e.preventDefault();
            e.object = _this;
            e.action = "click";
            clicked(e);
          };
        }
        if (options.role) {
          this.hit.attr("role", options.role);
          if (options.role === "button") {
            this.hit.div.onkeydown = e => {
              switch (e.key) {
                case " ":
                case "Spacebar":
                  e.preventDefault();
                  e.stopPropagation();
                  e.object = _this;
                  e.action = "click";
                  clicked(e);
              }
            };
          }
        }
      }
      let time = Render.TIME;
      function clicked(e) {
        if (clickCallback && Render.TIME - time > 250) {
          clickCallback(e);
        }
        time = Render.TIME;
      }
      if (Device.mobile) {
        this.hit.touchClick(overCallback, clicked).click(clicked);
      } else {
        this.hit.hover(overCallback).click(clicked);
      }
    };
    $.fn.clearInteract = function () {
      this.hit &&= this.hit.destroy();
    };
    $.fn.disableInteract = function () {
      if (this.hit) {
        this.hit.css({
          pointerEvents: "none"
        });
      }
    };
    $.fn.enableInteract = function () {
      if (this.hit) {
        this.hit.css({
          pointerEvents: "auto"
        });
      }
    };
    $.fn.touchSwipe = function (callback, distance) {
      if (!window.addEventListener) {
        return this;
      }
      var _startX;
      var _startY;
      var _this = this;
      var _distance = distance || 75;
      var _moving = false;
      var _move = {};
      function touchMove(e) {
        if (!_this.div) {
          return false;
        }
        if (_moving) {
          var touch = convertTouchEvent(e);
          var dx = _startX - touch.x;
          var dy = _startY - touch.y;
          _move.direction = null;
          _move.moving = null;
          _move.x = null;
          _move.y = null;
          _move.evt = e;
          if (Math.abs(dx) >= _distance) {
            touchEnd();
            _move.direction = dx > 0 ? "left" : "right";
          } else if (Math.abs(dy) >= _distance) {
            touchEnd();
            _move.direction = dy > 0 ? "up" : "down";
          } else {
            _move.moving = true;
            _move.x = dx;
            _move.y = dy;
          }
          if (callback) {
            callback(_move, e);
          }
        }
      }
      function touchEnd(e) {
        if (!_this.div) {
          return false;
        }
        _startX = _startY = _moving = false;
        _this.div.removeEventListener(translateEvent("touchmove"), touchMove);
      }
      if (Device.mobile) {
        this.div.addEventListener(translateEvent("touchstart"), function touchStart(e) {
          var touch = convertTouchEvent(e);
          if (!_this.div) {
            return false;
          }
          if (e.touches.length == 1) {
            _startX = touch.x;
            _startY = touch.y;
            _moving = true;
            _this.div.addEventListener(translateEvent("touchmove"), touchMove, {
              passive: true
            });
          }
        }, {
          passive: true
        });
        this.div.addEventListener(translateEvent("touchend"), touchEnd, {
          passive: true
        });
        this.div.addEventListener(translateEvent("touchcancel"), touchEnd, {
          passive: true
        });
      }
      return this;
    };
    $.fn.touchClick = function (hover, click) {
      if (!window.addEventListener) {
        return this;
      }
      var _time;
      var _move;
      var _this = this;
      var _start = {};
      var _touch = {};
      function setTouch(e) {
        var touch = convertTouchEvent(e);
        e.touchX = touch.x;
        e.touchY = touch.y;
        _start.x = e.touchX;
        _start.y = e.touchY;
      }
      if (Device.mobile) {
        this.div.addEventListener(translateEvent("touchstart"), function touchStart(e) {
          if (!_this.div) {
            return false;
          }
          _time = performance.now();
          e.action = "over";
          e.object = _this.div.className == "hit" ? _this.parent() : _this;
          setTouch(e);
          if (hover && !_move) {
            hover(e);
          }
        }, {
          passive: true
        });
        this.div.addEventListener(translateEvent("touchend"), function touchEnd(e) {
          if (!_this.div) {
            return false;
          }
          var time = performance.now();
          _touch = convertTouchEvent(e);
          _move = function findDistance(p1, p2) {
            var dx = p2.x - p1.x;
            var dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
          }(_start, _touch) > 25;
          e.object = _this.div.className == "hit" ? _this.parent() : _this;
          setTouch(e);
          if (_time && time - _time < 750) {
            if (Mouse._preventClicks) {
              return false;
            }
            if (click && !_move) {
              true;
              e.action = "click";
              if (click && !_move) {
                click(e);
              }
              if (Mouse.autoPreventClicks) {
                Mouse.preventClicks();
              }
            }
          }
          if (hover) {
            e.action = "out";
            if (!Mouse._preventFire) {
              hover(e);
            }
          }
          _move = false;
        }, {
          passive: true
        });
      }
      return this;
    };
  })();
  Class(function Element(type = "div") {
    Inherit(this, Component);
    var name = Utils.getConstructorName(this);
    this.__element = true;
    this.element = $("." + name, type);
    this.element.__useFragment = true;
    this.destroy = function () {
      if (this.element && this.element.remove) {
        this.element = this.element.remove();
      }
      if (this._destroy) {
        this._destroy();
      }
    };
    this.querySelector = async function (selector) {
      await defer();
      if (Array.isArray(selector)) {
        let values = [];
        selector.forEach(s => {
          values.push($(this.element.div.querySelector(s)));
        });
        return values;
      }
      return $(this.element.div.querySelector(selector));
    };
    this.querySelectorAll = async function (selector) {
      await defer();
      let list = this.element.div.querySelectorAll(selector);
      let values = [];
      for (let i = 0; i < list.length; i++) {
        values.push($(list[i]));
      }
      return values;
    };
  });
  (() => {
    var zn = Object.create;
    var ke = Object.defineProperty;
    var Wn = Object.defineProperties;
    var Ln = Object.getOwnPropertyDescriptor;
    var Un = Object.getOwnPropertyDescriptors;
    var Kn = Object.getOwnPropertyNames;
    var Be = Object.getOwnPropertySymbols;
    var Hn = Object.getPrototypeOf;
    var It = Object.prototype.hasOwnProperty;
    var vr = Object.prototype.propertyIsEnumerable;
    var Tt = (t, e, r) => e in t ? ke(t, e, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: r
    }) : t[e] = r;
    var g = (t, e) => {
      for (var r in e ||= {}) {
        if (It.call(e, r)) {
          Tt(t, r, e[r]);
        }
      }
      if (Be) {
        for (var r of Be(e)) {
          if (vr.call(e, r)) {
            Tt(t, r, e[r]);
          }
        }
      }
      return t;
    };
    var x = (t, e) => Wn(t, Un(e));
    var br = t => ke(t, "__esModule", {
      value: true
    });
    var Fe = (t, e) => () => {
      if (!e) {
        t((e = {
          exports: {}
        }).exports, e);
      }
      return e.exports;
    };
    var wt = (t, e) => {
      br(t);
      for (var r in e) {
        ke(t, r, {
          get: e[r],
          enumerable: true
        });
      }
    };
    var Re = t => ((t, e, r) => {
      if (e && typeof e == "object" || typeof e == "function") {
        for (let o of Kn(e)) {
          if (!It.call(t, o) && o !== "default") {
            ke(t, o, {
              get: () => e[o],
              enumerable: !(r = Ln(e, o)) || r.enumerable
            });
          }
        }
      }
      return t;
    })(br(ke(t != null ? zn(Hn(t)) : {}, "default", t && t.__esModule && "default" in t ? {
      get: () => t.default,
      enumerable: true
    } : {
      value: t,
      enumerable: true
    })), t);
    var l = (t, e, r) => {
      Tt(t, typeof e != "symbol" ? e + "" : e, r);
      return r;
    };
    var No = Fe((Mc, Vo) => {
      Vo.exports = function () {
        function t(e, r, o, n) {
          this.set(e, r, o, n);
        }
        t.prototype.set = function (e, r, o, n) {
          this._cx = e * 3;
          this._bx = (o - e) * 3 - this._cx;
          this._ax = 1 - this._cx - this._bx;
          this._cy = r * 3;
          this._by = (n - r) * 3 - this._cy;
          this._ay = 1 - this._cy - this._by;
        };
        t.epsilon = 0.000001;
        t.prototype._sampleCurveX = function (e) {
          return ((this._ax * e + this._bx) * e + this._cx) * e;
        };
        t.prototype._sampleCurveY = function (e) {
          return ((this._ay * e + this._by) * e + this._cy) * e;
        };
        t.prototype._sampleCurveDerivativeX = function (e) {
          return (this._ax * 3 * e + this._bx * 2) * e + this._cx;
        };
        t.prototype._solveCurveX = function (e, r) {
          var o;
          var n;
          var a;
          var i;
          var s;
          var u;
          a = undefined;
          i = undefined;
          s = undefined;
          u = undefined;
          o = undefined;
          n = undefined;
          s = e;
          n = 0;
          while (n < 8) {
            u = this._sampleCurveX(s) - e;
            if (Math.abs(u) < r) {
              return s;
            }
            o = this._sampleCurveDerivativeX(s);
            if (Math.abs(o) < r) {
              break;
            }
            s -= u / o;
            n++;
          }
          if ((s = e) < (a = 0)) {
            return a;
          }
          if (s > (i = 1)) {
            return i;
          }
          while (a < i) {
            u = this._sampleCurveX(s);
            if (Math.abs(u - e) < r) {
              return s;
            }
            if (e > u) {
              a = s;
            } else {
              i = s;
            }
            s = (i - a) * 0.5 + a;
          }
          return s;
        };
        t.prototype.solve = function (e, r) {
          return this._sampleCurveY(this._solveCurveX(e, r));
        };
        t.prototype.solveSimple = function (e) {
          return this._sampleCurveY(this._solveCurveX(e, 0.000001));
        };
        return t;
      }();
    });
    var qo = Fe((dd, Ro) => {
      var nt;
      var Lt;
      nt = [];
      Lt = [];
      Ro.exports = function ts(t, e, r) {
        var o;
        var n;
        var a;
        var i;
        var s;
        var u;
        var p;
        var f;
        if (t === e) {
          return 0;
        }
        o = t.length;
        n = e.length;
        if (o === 0) {
          return n;
        }
        if (n === 0) {
          return o;
        }
        if (r) {
          t = t.toLowerCase();
          e = e.toLowerCase();
        }
        p = 0;
        while (p < o) {
          Lt[p] = t.charCodeAt(p);
          nt[p] = ++p;
        }
        for (f = 0; f < n;) {
          a = e.charCodeAt(f);
          i = s = f++;
          p = -1;
          while (++p < o) {
            u = a === Lt[p] ? s : s + 1;
            s = nt[p];
            nt[p] = i = s > i ? u > i ? i + 1 : u : u > s ? s + 1 : u;
          }
        }
        return i;
      };
    });
    var Lo = Fe((hd, Wo) => {
      var zo = qo();
      Wo.exports = function rs() {
        var t;
        var e;
        var r;
        var o;
        var n;
        var a = 0;
        var i = arguments[0];
        var s = arguments[1];
        var u = s.length;
        var p = arguments[2];
        if (p) {
          o = p.threshold;
          n = p.ignoreCase;
        }
        if (o === undefined) {
          o = 0;
        }
        for (var f = 0; f < u; ++f) {
          if ((t = (e = n ? zo(i, s[f], true) : zo(i, s[f])) > i.length ? 1 - e / s[f].length : 1 - e / i.length) > a) {
            a = t;
            r = s[f];
          }
        }
        if (a >= o) {
          return r;
        } else {
          return null;
        }
      };
    });
    var Qt = Fe((Qh, In) => {
      "use strict";
  
      In.exports = function t(e, r) {
        if (e === r) {
          return true;
        }
        if (e && r && typeof e == "object" && typeof r == "object") {
          if (e.constructor !== r.constructor) {
            return false;
          }
          var o;
          var n;
          var a;
          if (Array.isArray(e)) {
            if ((o = e.length) != r.length) {
              return false;
            }
            for (n = o; n-- != 0;) {
              if (!t(e[n], r[n])) {
                return false;
              }
            }
            return true;
          }
          if (e.constructor === RegExp) {
            return e.source === r.source && e.flags === r.flags;
          }
          if (e.valueOf !== Object.prototype.valueOf) {
            return e.valueOf() === r.valueOf();
          }
          if (e.toString !== Object.prototype.toString) {
            return e.toString() === r.toString();
          }
          if ((o = (a = Object.keys(e)).length) !== Object.keys(r).length) {
            return false;
          }
          for (n = o; n-- != 0;) {
            if (!Object.prototype.hasOwnProperty.call(r, a[n])) {
              return false;
            }
          }
          for (n = o; n-- != 0;) {
            var i = a[n];
            if (!t(e[i], r[i])) {
              return false;
            }
          }
          return true;
        }
        return e != e && r != r;
      };
    });
    var gr = {};
    wt(gr, {
      getProject: () => Bn,
      onChange: () => Fn,
      types: () => ft
    });
    var yr = {};
    wt(yr, {
      getProject: () => Bn,
      onChange: () => Fn,
      types: () => ft
    });
    var ue = Array.isArray;
    var xr = typeof window == "object" && window && window.Object === Object && window;
    var Xn = typeof self == "object" && self && self.Object === Object && self;
    var le = xr || Xn || Function("return this")();
    var N = le.Symbol;
    var Pr = Object.prototype;
    var ea = Pr.hasOwnProperty;
    var ta = Pr.toString;
    var Ce = N ? N.toStringTag : undefined;
    var _r = function ra(t) {
      var e = ea.call(t, Ce);
      var r = t[Ce];
      try {
        t[Ce] = undefined;
        var o = true;
      } catch (a) {}
      var n = ta.call(t);
      if (o) {
        if (e) {
          t[Ce] = r;
        } else {
          delete t[Ce];
        }
      }
      return n;
    };
    var na = Object.prototype.toString;
    var Sr = function aa(t) {
      return na.call(t);
    };
    var Ir = N ? N.toStringTag : undefined;
    var fe = function pa(t) {
      if (t == null) {
        if (t === undefined) {
          return "[object Undefined]";
        } else {
          return "[object Null]";
        }
      } else if (Ir && Ir in Object(t)) {
        return _r(t);
      } else {
        return Sr(t);
      }
    };
    var qe = function ua(t) {
      return t != null && typeof t == "object";
    };
    var z = function fa(t) {
      return typeof t == "symbol" || qe(t) && fe(t) == "[object Symbol]";
    };
    var ca = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var da = /^\w*$/;
    var Tr = function ha(t, e) {
      if (ue(t)) {
        return false;
      }
      var r = typeof t;
      return r == "number" || r == "symbol" || r == "boolean" || t == null || !!z(t) || da.test(t) || !ca.test(t) || e != null && t in Object(e);
    };
    var Y = function ma(t) {
      var e = typeof t;
      return t != null && (e == "object" || e == "function");
    };
    var wr = function ja(t) {
      if (!Y(t)) {
        return false;
      }
      var e = fe(t);
      return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]";
    };
    var ze = le["__core-js_shared__"];
    var Dr = function () {
      var t = /[^.]+$/.exec(ze && ze.keys && ze.keys.IE_PROTO || "");
      if (t) {
        return "Symbol(src)_1." + t;
      } else {
        return "";
      }
    }();
    var Ar = function Pa(t) {
      return !!Dr && Dr in t;
    };
    var Sa = Function.prototype.toString;
    var Or = function Ia(t) {
      if (t != null) {
        try {
          return Sa.call(t);
        } catch (e) {}
        try {
          return t + "";
        } catch (e) {}
      }
      return "";
    };
    var wa = /^\[object .+?Constructor\]$/;
    var Da = Function.prototype;
    var Aa = Object.prototype;
    var Oa = Da.toString;
    var ka = Aa.hasOwnProperty;
    var Ca = RegExp("^" + Oa.call(ka).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var kr = function Va(t) {
      return !!Y(t) && !Ar(t) && (wr(t) ? Ca : wa).test(Or(t));
    };
    var Cr = function Na(t, e) {
      if (t == null) {
        return undefined;
      } else {
        return t[e];
      }
    };
    var We = function Ma(t, e) {
      var r = Cr(t, e);
      if (kr(r)) {
        return r;
      } else {
        return undefined;
      }
    };
    var M = We(Object, "create");
    var Vr = function $a() {
      this.__data__ = M ? M(null) : {};
      this.size = 0;
    };
    var Nr = function Ba(t) {
      var e = this.has(t) && delete this.__data__[t];
      this.size -= e ? 1 : 0;
      return e;
    };
    var qa = Object.prototype.hasOwnProperty;
    var Mr = function za(t) {
      var e = this.__data__;
      if (M) {
        var r = e[t];
        if (r === "__lodash_hash_undefined__") {
          return undefined;
        } else {
          return r;
        }
      }
      if (qa.call(e, t)) {
        return e[t];
      } else {
        return undefined;
      }
    };
    var La = Object.prototype.hasOwnProperty;
    var Er = function Ua(t) {
      var e = this.__data__;
      if (M) {
        return e[t] !== undefined;
      } else {
        return La.call(e, t);
      }
    };
    var $r = function Ha(t, e) {
      var r = this.__data__;
      this.size += this.has(t) ? 0 : 1;
      r[t] = M && e === undefined ? "__lodash_hash_undefined__" : e;
      return this;
    };
    function ce(t) {
      var e = -1;
      var r = t == null ? 0 : t.length;
      for (this.clear(); ++e < r;) {
        var o = t[e];
        this.set(o[0], o[1]);
      }
    }
    ce.prototype.clear = Vr;
    ce.prototype.delete = Nr;
    ce.prototype.get = Mr;
    ce.prototype.has = Er;
    ce.prototype.set = $r;
    var Dt = ce;
    var Br = function Ga() {
      this.__data__ = [];
      this.size = 0;
    };
    var Fr = function Ja(t, e) {
      return t === e || t != t && e != e;
    };
    var W = function Ya(t, e) {
      for (var r = t.length; r--;) {
        if (Fr(t[r][0], e)) {
          return r;
        }
      }
      return -1;
    };
    var Za = Array.prototype.splice;
    var Rr = function Qa(t) {
      var e = this.__data__;
      var r = W(e, t);
      return !(r < 0) && (r == e.length - 1 ? e.pop() : Za.call(e, r, 1), --this.size, true);
    };
    var qr = function ei(t) {
      var e = this.__data__;
      var r = W(e, t);
      if (r < 0) {
        return undefined;
      } else {
        return e[r][1];
      }
    };
    var zr = function ti(t) {
      return W(this.__data__, t) > -1;
    };
    var Wr = function ri(t, e) {
      var r = this.__data__;
      var o = W(r, t);
      if (o < 0) {
        ++this.size;
        r.push([t, e]);
      } else {
        r[o][1] = e;
      }
      return this;
    };
    function de(t) {
      var e = -1;
      var r = t == null ? 0 : t.length;
      for (this.clear(); ++e < r;) {
        var o = t[e];
        this.set(o[0], o[1]);
      }
    }
    de.prototype.clear = Br;
    de.prototype.delete = Rr;
    de.prototype.get = qr;
    de.prototype.has = zr;
    de.prototype.set = Wr;
    var Lr = de;
    var Ur = We(le, "Map");
    var Kr = function ni() {
      this.size = 0;
      this.__data__ = {
        hash: new Dt(),
        map: new (Ur || Lr)(),
        string: new Dt()
      };
    };
    var Hr = function ai(t) {
      var e = typeof t;
      if (e == "string" || e == "number" || e == "symbol" || e == "boolean") {
        return t !== "__proto__";
      } else {
        return t === null;
      }
    };
    var L = function ii(t, e) {
      var r = t.__data__;
      if (Hr(e)) {
        return r[typeof e == "string" ? "string" : "hash"];
      } else {
        return r.map;
      }
    };
    var Gr = function si(t) {
      var e = L(this, t).delete(t);
      this.size -= e ? 1 : 0;
      return e;
    };
    var Jr = function pi(t) {
      return L(this, t).get(t);
    };
    var Yr = function ui(t) {
      return L(this, t).has(t);
    };
    var Xr = function li(t, e) {
      var r = L(this, t);
      var o = r.size;
      r.set(t, e);
      this.size += r.size == o ? 0 : 1;
      return this;
    };
    function he(t) {
      var e = -1;
      var r = t == null ? 0 : t.length;
      for (this.clear(); ++e < r;) {
        var o = t[e];
        this.set(o[0], o[1]);
      }
    }
    he.prototype.clear = Kr;
    he.prototype.delete = Gr;
    he.prototype.get = Jr;
    he.prototype.has = Yr;
    he.prototype.set = Xr;
    var At = he;
    function Ot(t, e) {
      if (typeof t != "function" || e != null && typeof e != "function") {
        throw new TypeError("Expected a function");
      }
      function r() {
        var o = arguments;
        var n = e ? e.apply(this, o) : o[0];
        var a = r.cache;
        if (a.has(n)) {
          return a.get(n);
        }
        var i = t.apply(this, o);
        r.cache = a.set(n, i) || a;
        return i;
      }
      r.cache = new (Ot.Cache || At)();
      return r;
    }
    Ot.Cache = At;
    var Zr = Ot;
    var hi = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var mi = /\\(\\)?/g;
    var eo = function di(t) {
      var e = Zr(t, function (o) {
        if (r.size === 500) {
          r.clear();
        }
        return o;
      });
      var r = e.cache;
      return e;
    }(function (t) {
      var e = [];
      if (t.charCodeAt(0) === 46) {
        e.push("");
      }
      t.replace(hi, function (r, o, n, a) {
        e.push(n ? a.replace(mi, "$1") : o || r);
      });
      return e;
    });
    var to = function gi(t, e) {
      for (var r = -1, o = t == null ? 0 : t.length, n = Array(o); ++r < o;) {
        n[r] = e(t[r], r, t);
      }
      return n;
    };
    var ro = N ? N.prototype : undefined;
    var oo = ro ? ro.toString : undefined;
    var Le = function no(t) {
      if (typeof t == "string") {
        return t;
      }
      if (ue(t)) {
        return to(t, no) + "";
      }
      if (z(t)) {
        if (oo) {
          return oo.call(t);
        } else {
          return "";
        }
      }
      var e = t + "";
      if (e == "0" && 1 / t == -Infinity) {
        return "-0";
      } else {
        return e;
      }
    };
    var Ue = function bi(t) {
      if (t == null) {
        return "";
      } else {
        return Le(t);
      }
    };
    var ao = function ji(t, e) {
      if (ue(t)) {
        return t;
      } else if (Tr(t, e)) {
        return [t];
      } else {
        return eo(Ue(t));
      }
    };
    var io = function Pi(t) {
      if (typeof t == "string" || z(t)) {
        return t;
      }
      var e = t + "";
      if (e == "0" && 1 / t == -Infinity) {
        return "-0";
      } else {
        return e;
      }
    };
    var so = function _i(t, e) {
      for (var r = 0, o = (e = ao(e, t)).length; t != null && r < o;) {
        t = t[io(e[r++])];
      }
      if (r && r == o) {
        return t;
      } else {
        return undefined;
      }
    };
    var me = function Si(t, e, r) {
      var o = t == null ? undefined : so(t, e);
      if (o === undefined) {
        return r;
      } else {
        return o;
      }
    };
    var uo = function Ii(t, e) {
      return function (r) {
        return t(e(r));
      };
    }(Object.getPrototypeOf, Object);
    var Di = Function.prototype;
    var Ai = Object.prototype;
    var lo = Di.toString;
    var Oi = Ai.hasOwnProperty;
    var ki = lo.call(Object);
    var Ve = function Ci(t) {
      if (!qe(t) || fe(t) != "[object Object]") {
        return false;
      }
      var e = uo(t);
      if (e === null) {
        return true;
      }
      var r = Oi.call(e, "constructor") && e.constructor;
      return typeof r == "function" && r instanceof r && lo.call(r) == ki;
    };
    var j;
    var o;
    var fo = function Vi(t) {
      var e = t == null ? 0 : t.length;
      if (e) {
        return t[e - 1];
      } else {
        return undefined;
      }
    };
    var U = class {
      constructor() {
        this._lastTapperId = 0;
        this._tappers = new Map();
        this.tappable = new class {
          constructor(e) {
            this._untapFromSourceTimeout = null;
            this._cb = e => {
              this._tappers.forEach(r => {
                r(e);
              });
            };
            this._lastTapperId = 0;
            this._untapFromSource = null;
            this._props = e;
            this._tappers = new Map();
          }
          _check() {
            if (this._untapFromSource) {
              if (this._tappers.size === 0) {
                this._scheduleToUntapFromSource();
              }
            } else if (this._tappers.size !== 0) {
              this._untapFromSource = this._props.tapToSource(this._cb);
            }
          }
          _scheduleToUntapFromSource() {
            if (this._untapFromSourceTimeout === null) {
              this._untapFromSourceTimeout = setTimeout(() => {
                this._untapFromSourceTimeout = null;
                if (this._tappers.size === 0) {
                  this._untapFromSource();
                  this._untapFromSource = null;
                }
              }, 0);
            }
          }
          tap(e) {
            let r = this._lastTapperId++;
            this._tappers.set(r, e);
            this._check();
            return () => {
              this._removeTapperById(r);
            };
          }
          _removeTapperById(e) {
            this._tappers.delete(e);
            this._check();
          }
        }({
          tapToSource: e => this._tap(e)
        });
      }
      _tap(e) {
        let r = this._lastTapperId++;
        this._tappers.set(r, e);
        if (this._onNumberOfTappersChangeListener) {
          this._onNumberOfTappersChangeListener(this._tappers.size);
        }
        return () => {
          this._removeTapperById(r);
        };
      }
      _removeTapperById(e) {
        let r = this._tappers.size;
        this._tappers.delete(e);
        if (r !== this._tappers.size && this._onNumberOfTappersChangeListener) {
          this._onNumberOfTappersChangeListener(this._tappers.size);
        }
      }
      emit(e) {
        this._tappers.forEach(r => {
          r(e);
        });
      }
      hasTappers() {
        return this._tappers.size !== 0;
      }
      onNumberOfTappersChange(e) {
        this._onNumberOfTappersChangeListener = e;
      }
    };
    function C(t) {
      return t && t.isDerivation && t.isDerivation === true;
    }
    (o = j ||= {})[o.none = 0] = "none";
    o[o.dep = 1] = "dep";
    o[o.inner = 2] = "inner";
    var kt;
    var Ni = () => {
      class t extends _ {
        constructor(r, o) {
          super();
          this._depDerivation = r;
          this._fn = o;
          this._innerDerivation = undefined;
          this._staleDependency = 1;
          this._addDependency(r);
          return this;
        }
        _recalculateHot() {
          let r = this._staleDependency;
          this._staleDependency = 0;
          if (r === 2) {
            return this._innerDerivation.getValue();
          }
          let o = this._fn(this._depDerivation.getValue());
          if (C(o)) {
            this._innerDerivation = o;
            this._addDependency(o);
            return o.getValue();
          } else {
            return o;
          }
        }
        _recalculateCold() {
          let r = this._fn(this._depDerivation.getValue());
          if (C(r)) {
            return r.getValue();
          } else {
            return r;
          }
        }
        _recalculate() {
          if (this.isHot) {
            return this._recalculateHot();
          } else {
            return this._recalculateCold();
          }
        }
        _reactToDependencyBecomingStale(r) {
          let o = r === this._depDerivation ? 1 : 2;
          if (o === 2 && r !== this._innerDerivation) {
            throw Error("got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation");
          }
          if (this._staleDependency === 0) {
            this._staleDependency = o;
            if (o === 1) {
              this._removeInnerDerivation();
            }
          } else if (this._staleDependency !== 1) {
            if (o === 1) {
              this._staleDependency = 1;
              this._removeInnerDerivation();
            }
          }
        }
        _removeInnerDerivation() {
          if (this._innerDerivation) {
            this._removeDependency(this._innerDerivation);
            this._innerDerivation = undefined;
          }
        }
        _keepHot() {
          this._staleDependency = 1;
          this.getValue();
        }
        _becomeCold() {
          this._staleDependency = 1;
          this._removeInnerDerivation();
        }
      }
      t.displayName = "flatMap";
      return t;
    };
    var Vt;
    var Mi = () => class extends _ {
      constructor(e, r) {
        super();
        this._dep = e;
        this._fn = r;
        this._addDependency(e);
      }
      _recalculate() {
        return this._fn(this._dep.getValue());
      }
      _reactToDependencyBecomingStale() {}
    };
    var ye = class {
      constructor() {
        this._head = undefined;
      }
      peek() {
        return this._head && this._head.data;
      }
      pop() {
        let e = this._head;
        if (e) {
          this._head = e.next;
          return e.data;
        }
      }
      push(e) {
        let r = {
          next: this._head,
          data: e
        };
        this._head = r;
      }
    };
    function co() {
      let e = new ye();
      let r = () => {};
      return {
        type: "Dataverse_discoveryMechanism",
        startIgnoringDependencies: () => {
          e.push(r);
        },
        stopIgnoringDependencies: () => {
          if (e.peek() === r) {
            e.pop();
          }
        },
        reportResolutionStart: p => {
          let f = e.peek();
          if (f) {
            f(p);
          }
          e.push(r);
        },
        reportResolutionEnd: p => {
          e.pop();
        },
        pushCollector: p => {
          e.push(p);
        },
        popCollector: p => {
          if (e.peek() !== p) {
            throw new Error("Popped collector is not on top of the stack");
          }
          e.pop();
        }
      };
    }
    var {
      startIgnoringDependencies: ge,
      stopIgnoringDependencies: ve,
      reportResolutionEnd: ho,
      reportResolutionStart: mo,
      pushCollector: yo,
      popCollector: go
    } = function Ei() {
      let t = "__dataverse_discoveryMechanism_sharedStack";
      if (window) {
        let e = window[t];
        if (e && typeof e == "object" && e.type === "Dataverse_discoveryMechanism") {
          return e;
        }
        {
          let r = co();
          window[t] = r;
          return r;
        }
      }
      return co();
    }();
    var _ = class {
      constructor() {
        this.isDerivation = true;
        this._didMarkDependentsAsStale = false;
        this._isHot = false;
        this._isFresh = false;
        this._lastValue = undefined;
        this._dependents = new Set();
        this._dependencies = new Set();
        this._internal_markAsStale = e => {
          this._reactToDependencyBecomingStale(e);
          if (!this._didMarkDependentsAsStale) {
            this._didMarkDependentsAsStale = true;
            this._isFresh = false;
            this._dependents.forEach(r => {
              r(this);
            });
          }
        };
      }
      get isHot() {
        return this._isHot;
      }
      _addDependency(e) {
        if (!this._dependencies.has(e)) {
          this._dependencies.add(e);
          if (this._isHot) {
            e.addDependent(this._internal_markAsStale);
          }
        }
      }
      _removeDependency(e) {
        if (this._dependencies.has(e)) {
          this._dependencies.delete(e);
          if (this._isHot) {
            e.removeDependent(this._internal_markAsStale);
          }
        }
      }
      changes(e) {
        return new class {
          constructor(e, r) {
            this._possiblyMarkAsStale = () => {
              this._ticker.onThisOrNextTick(this._refresh);
            };
            this._refresh = () => {
              let e = this._derivation.getValue();
              if (e !== this._lastValue || this._lastValueRecorded !== true) {
                this._lastValue = e;
                this._lastValueRecorded = true;
                this._emitter.emit(e);
              }
            };
            this._derivation = e;
            this._ticker = r;
            this._emitter = new U();
            this._emitter.onNumberOfTappersChange(() => {
              this._reactToNumberOfTappersChange();
            });
            this._hadTappers = false;
            this._lastValueRecorded = false;
            this._lastValue = undefined;
            return this;
          }
          _reactToNumberOfTappersChange() {
            let e = this._emitter.hasTappers();
            if (e !== this._hadTappers) {
              this._hadTappers = e;
              if (e) {
                this._derivation.addDependent(this._possiblyMarkAsStale);
              } else {
                this._derivation.removeDependent(this._possiblyMarkAsStale);
              }
            }
          }
          tappable() {
            return this._emitter.tappable;
          }
        }(this, e).tappable();
      }
      changesWithoutValues() {
        return new class {
          constructor(e, r = false) {
            this.dontEmitValues = r;
            this._possiblyMarkAsStale = () => {
              this._emitter.emit(undefined);
            };
            this._derivation = e;
            this._emitter = new U();
            this._emitter.onNumberOfTappersChange(() => {
              this._reactToNumberOfTappersChange();
            });
            this._hadTappers = false;
            return this;
          }
          _reactToNumberOfTappersChange() {
            let e = this._emitter.hasTappers();
            if (e !== this._hadTappers) {
              this._hadTappers = e;
              if (e) {
                this._derivation.addDependent(this._possiblyMarkAsStale);
              } else {
                this._derivation.removeDependent(this._possiblyMarkAsStale);
              }
            }
          }
          tappable() {
            return this._emitter.tappable;
          }
        }(this).tappable();
      }
      keepHot() {
        return this.changesWithoutValues().tap(() => {});
      }
      tapImmediate(e, r) {
        let o = this.changes(e).tap(r);
        r(this.getValue());
        return o;
      }
      addDependent(e) {
        let r = this._dependents.size > 0;
        this._dependents.add(e);
        if (r !== this._dependents.size > 0) {
          this._reactToNumberOfDependentsChange();
        }
      }
      removeDependent(e) {
        let r = this._dependents.size > 0;
        this._dependents.delete(e);
        if (r !== this._dependents.size > 0) {
          this._reactToNumberOfDependentsChange();
        }
      }
      _markAsStale(e) {
        this._internal_markAsStale(e);
      }
      getValue() {
        mo(this);
        if (!this._isFresh) {
          let e = this._recalculate();
          this._lastValue = e;
          if (this._isHot) {
            this._isFresh = true;
            this._didMarkDependentsAsStale = false;
          }
        }
        ho(this);
        return this._lastValue;
      }
      _reactToNumberOfDependentsChange() {
        let e = this._dependents.size > 0;
        if (e !== this._isHot) {
          this._isHot = e;
          this._didMarkDependentsAsStale = false;
          this._isFresh = false;
          if (e) {
            this._dependencies.forEach(r => {
              r.addDependent(this._internal_markAsStale);
            });
            this._keepHot();
          } else {
            this._dependencies.forEach(r => {
              r.removeDependent(this._internal_markAsStale);
            });
            this._becomeCold();
          }
        }
      }
      _keepHot() {}
      _becomeCold() {}
      map(e) {
        return function Nt(t, e) {
          Vt ||= Mi();
          return new Vt(t, e);
        }(this, e);
      }
      flatMap(e) {
        return function Ct(t, e) {
          kt ||= Ni();
          return new kt(t, e);
        }(this, e);
      }
    };
    var vo = () => {};
    var X = class extends _ {
      constructor(e, r) {
        super();
        this._tapToSource = e;
        this._getValueFromSource = r;
        this._untapFromChanges = vo;
        this._cachedValue = undefined;
        this._hasCachedValue = false;
      }
      _recalculate() {
        if (this.isHot) {
          if (!this._hasCachedValue) {
            this._cachedValue = this._getValueFromSource();
            this._hasCachedValue = true;
          }
          return this._cachedValue;
        } else {
          return this._getValueFromSource();
        }
      }
      _keepHot() {
        this._hasCachedValue = false;
        this._cachedValue = undefined;
        this._untapFromChanges = this._tapToSource(e => {
          this._hasCachedValue = true;
          this._cachedValue = e;
          this._markAsStale(this);
        });
      }
      _becomeCold() {
        this._untapFromChanges();
        this._untapFromChanges = vo;
        this._hasCachedValue = false;
        this._cachedValue = undefined;
      }
      _reactToDependencyBecomingStale() {}
    };
    var Mt = new WeakMap();
    var bo = Symbol("pointerMeta");
    var jo = new WeakMap();
    var $i = {
      get(t, e) {
        if (e === bo) {
          return Mt.get(t);
        }
        let r = jo.get(t);
        if (!r) {
          r = {};
          jo.set(t, r);
        }
        if (r[e]) {
          return r[e];
        }
        let o = Mt.get(t);
        let n = xo({
          root: o.root,
          path: [...o.path, e]
        });
        r[e] = n;
        return n;
      }
    };
    var Je = t => t[bo];
    var Ne = t => {
      let {
        root: e,
        path: r
      } = Je(t);
      return {
        root: e,
        path: r
      };
    };
    function xo(t) {
      let e = {
        root: t.root,
        path: t.path ?? []
      };
      let r = {};
      Mt.set(r, e);
      return new Proxy(r, $i);
    }
    var Z = xo;
    var Q = t => t && !!Je(t);
    var K;
    var Ye = (t, e, r) => {
      if (e.length === 0) {
        return r(t);
      }
      if (Array.isArray(t)) {
        let [o, ...n] = e;
        o = parseInt(String(o), 10);
        if (isNaN(o)) {
          o = 0;
        }
        let a = t[o];
        let i = Ye(a, n, r);
        if (a === i) {
          return t;
        }
        let s = [...t];
        s.splice(o, 1, i);
        return s;
      }
      if (typeof t == "object" && t !== null) {
        let [o, ...n] = e;
        let a = t[o];
        let i = Ye(a, n, r);
        if (a === i) {
          return t;
        } else {
          return x(g({}, t), {
            [o]: i
          });
        }
      }
      {
        let [o, ...n] = e;
        return {
          [o]: Ye(undefined, n, r)
        };
      }
    };
    (function (o) {
      o[o.Dict = 0] = "Dict";
      o[o.Array = 1] = "Array";
      o[o.Other = 2] = "Other";
    })(K ||= {});
    var $t = t => Array.isArray(t) ? 1 : Ve(t) ? 0 : 2;
    var Po = (t, e, r = $t(t)) => r === 0 && typeof e == "string" || r === 1 && Bi(e) ? t[e] : undefined;
    var Bi = t => {
      let e = typeof t == "number" ? t : parseInt(t, 10);
      return !isNaN(e) && e >= 0 && e < Infinity && (e | 0) === e;
    };
    var Xe = class {
      constructor(e, r) {
        this._parent = e;
        this._path = r;
        this.children = new Map();
        this.identityChangeListeners = new Set();
      }
      addIdentityChangeListener(e) {
        this.identityChangeListeners.add(e);
      }
      removeIdentityChangeListener(e) {
        this.identityChangeListeners.delete(e);
        this._checkForGC();
      }
      removeChild(e) {
        this.children.delete(e);
        this._checkForGC();
      }
      getChild(e) {
        return this.children.get(e);
      }
      getOrCreateChild(e) {
        let r = this.children.get(e);
        if (!r) {
          r = r = new Xe(this, this._path.concat([e]));
          this.children.set(e, r);
        }
        return r;
      }
      _checkForGC() {
        if (!(this.identityChangeListeners.size > 0) && !(this.children.size > 0)) {
          if (this._parent) {
            this._parent.removeChild(fo(this._path));
          }
        }
      }
    };
    var y = class {
      constructor(e) {
        this.$$isIdentityDerivationProvider = true;
        this.reduceState = (e, r) => {
          let o = function Et(t, e, r) {
            if (e.length === 0) {
              return r(t);
            } else {
              return Ye(t, e, r);
            }
          }(this.getState(), e, r);
          this.setState(o);
          return o;
        };
        this._onPathValueChange = (e, r) => {
          let o = this._getOrCreateScopeForPath(e);
          o.identityChangeListeners.add(r);
          return () => {
            o.identityChangeListeners.delete(r);
          };
        };
        this._currentState = e;
        this._rootScope = new Xe(undefined, []);
        this.pointer = Z({
          root: this,
          path: []
        });
      }
      setState(e) {
        let r = this._currentState;
        this._currentState = e;
        this._checkUpdates(this._rootScope, r, e);
      }
      getState() {
        return this._currentState;
      }
      getIn(e) {
        if (e.length === 0) {
          return this.getState();
        } else {
          return me(this.getState(), e);
        }
      }
      setIn(e, r) {
        return this.reduceState(e, () => r);
      }
      _checkUpdates(e, r, o) {
        if (r === o || (e.identityChangeListeners.forEach(i => i(o)), e.children.size === 0)) {
          return;
        }
        let n = $t(r);
        let a = $t(o);
        if (n !== 2 || n !== a) {
          e.children.forEach((i, s) => {
            let u = Po(r, s, n);
            let p = Po(o, s, a);
            this._checkUpdates(i, u, p);
          });
        }
      }
      _getOrCreateScopeForPath(e) {
        let r = this._rootScope;
        for (let o of e) {
          r = r.getOrCreateChild(o);
        }
        return r;
      }
      getIdentityDerivation(e) {
        return new X(r => this._onPathValueChange(e, r), () => this.getIn(e));
      }
    };
    var _o = new WeakMap();
    var S = t => {
      let e = Je(t);
      let r = _o.get(e);
      if (!r) {
        let o = e.root;
        if (!function Fi(t) {
          return typeof t == "object" && t !== null && t.$$isIdentityDerivationProvider === true;
        }(o)) {
          throw new Error("Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider");
        }
        let {
          path: n
        } = e;
        r = o.getIdentityDerivation(n);
        _o.set(e, r);
      }
      return r;
    };
    var v = t => Q(t) ? S(t).getValue() : C(t) ? t.getValue() : t;
    var E = class {
      constructor(e) {
        this._value = e;
        this._emitter = new U();
        this._publicDerivation = new X(r => this._emitter.tappable.tap(r), this.get.bind(this));
      }
      set(e) {
        if (e !== this._value) {
          this._value = e;
          this._emitter.emit(e);
        }
      }
      get() {
        return this._value;
      }
      get derivation() {
        return this._publicDerivation;
      }
    };
    var T = class extends _ {
      constructor(e) {
        super();
        this._v = e;
        return this;
      }
      _recalculate() {
        return this._v;
      }
      _reactToDependencyBecomingStale() {}
    };
    var So = () => {};
    var Io = class extends _ {
      constructor(e) {
        super();
        this._fn = e;
        this._cacheOfDendencyValues = new Map();
        this._possiblyStaleDeps = new Set();
        this._prismScope = new je();
      }
      _recalculate() {
        let e;
        if (this._possiblyStaleDeps.size > 0) {
          let n = false;
          ge();
          for (let a of this._possiblyStaleDeps) {
            if (this._cacheOfDendencyValues.get(a) !== a.getValue()) {
              n = true;
              break;
            }
          }
          ve();
          this._possiblyStaleDeps.clear();
          if (!n) {
            return this._lastValue;
          }
        }
        let r = new Set();
        this._cacheOfDendencyValues.clear();
        let o = n => {
          r.add(n);
          this._addDependency(n);
        };
        yo(o);
        V.push(this._prismScope);
        try {
          e = this._fn();
        } catch (n) {
          console.error(n);
        } finally {
          if (V.pop() !== this._prismScope) {
            console.warn("The Prism hook stack has slipped. This is a bug.");
          }
        }
        go(o);
        this._dependencies.forEach(n => {
          if (!r.has(n)) {
            this._removeDependency(n);
          }
        });
        this._dependencies = r;
        ge();
        r.forEach(n => {
          this._cacheOfDendencyValues.set(n, n.getValue());
        });
        ve();
        return e;
      }
      _reactToDependencyBecomingStale(e) {
        this._possiblyStaleDeps.add(e);
      }
      _keepHot() {
        this._prismScope = new je();
        ge();
        this.getValue();
        ve();
      }
      _becomeCold() {
        To(this._prismScope);
        this._prismScope = new je();
      }
    };
    var je = class {
      constructor() {
        this.isPrismScope = true;
        this._subs = {};
      }
      sub(e) {
        this._subs[e] ||= new je();
        return this._subs[e];
      }
      get subs() {
        return this._subs;
      }
    };
    function To(t) {
      for (let [e, r] of Object.entries(t.subs)) {
        To(r);
      }
      (function Ri(t) {
        let e = Qe.get(t);
        if (e) {
          for (let r of Object.keys(e)) {
            Ze(e[r].cleanup, undefined);
          }
        }
        Qe.delete(t);
      })(t);
    }
    function Ze(t, e) {
      let r = e;
      let o = false;
      try {
        r = t();
        o = true;
      } catch (n) {
        setTimeout(() => {
          throw n;
        });
      }
      return {
        success: o,
        returnValue: r
      };
    }
    var V = new ye();
    var wo = new WeakMap();
    var Qe = new WeakMap();
    var Do = new WeakMap();
    function Ao(t, e) {
      return t === undefined || e === undefined || t.length !== e.length || t.some((r, o) => r !== e[o]);
    }
    function Oo(t, e, r) {
      let o = V.peek();
      if (!o) {
        throw new Error("prism.memo() is called outside of a prism() call.");
      }
      let n = Do.get(o);
      if (!n) {
        n = {};
        Do.set(o, n);
      }
      n[t] ||= {
        cachedValue: null,
        deps: [{}]
      };
      let a = n[t];
      if (Ao(a.deps, r)) {
        ge();
        a.cachedValue = Ze(e, undefined).returnValue;
        ve();
        a.deps = r;
      }
      return a.cachedValue;
    }
    var O = t => new Io(t);
    O.ref = function qi(t, e) {
      let r = V.peek();
      if (!r) {
        throw new Error("prism.ref() is called outside of a prism() call.");
      }
      let o = wo.get(r);
      if (!o) {
        o = {};
        wo.set(r, o);
      }
      if (o[t]) {
        return o[t];
      }
      {
        let n = {
          current: e
        };
        o[t] = n;
        return n;
      }
    };
    O.effect = function zi(t, e, r) {
      let o = V.peek();
      if (!o) {
        throw new Error("prism.effect() is called outside of a prism() call.");
      }
      let n = Qe.get(o);
      if (!n) {
        n = {};
        Qe.set(o, n);
      }
      n[t] ||= {
        cleanup: So,
        deps: [{}]
      };
      let a = n[t];
      if (Ao(a.deps, r)) {
        a.cleanup();
        ge();
        a.cleanup = Ze(e, So).returnValue;
        ve();
        a.deps = r;
      }
    };
    O.memo = Oo;
    O.ensurePrism = function Li() {
      if (!V.peek()) {
        throw new Error("The parent function is called outside of a prism() call.");
      }
    };
    O.state = function Wi(t, e) {
      let {
        b: r,
        setValue: o
      } = O.memo("state/" + t, () => {
        let n = new E(e);
        return {
          b: n,
          setValue: i => n.set(i)
        };
      }, []);
      return [r.derivation.getValue(), o];
    };
    O.scope = function Ui(t, e) {
      let r = V.peek();
      if (!r) {
        throw new Error("prism.scope() is called outside of a prism() call.");
      }
      let o = r.sub(t);
      V.push(o);
      let n = Ze(e, undefined).returnValue;
      V.pop();
      return n;
    };
    O.sub = function Ki(t, e, r) {
      return Oo(t, () => O(e), r).getValue();
    };
    O.inPrism = function Hi() {
      return !!V.peek();
    };
    var d = O;
    var ee = class {
      constructor(e) {
        this.$$isIdentityDerivationProvider = true;
        this._currentPointerBox = new E(e);
        this.pointer = Z({
          root: this,
          path: []
        });
      }
      setPointer(e) {
        this._currentPointerBox.set(e);
      }
      getIdentityDerivation(e) {
        return this._currentPointerBox.derivation.flatMap(r => {
          let o = e.reduce((n, a) => n[a], r);
          return S(o);
        });
      }
    };
    var xe = new class {
      constructor() {
        l(this, "atom", new y({
          projects: {}
        }));
      }
      add(e, r) {
        this.atom.reduceState(["projects", e], () => r);
      }
      get(e) {
        return this.atom.getState().projects[e];
      }
      has(e) {
        return !!this.get(e);
      }
    }();
    var Co = new WeakMap();
    function m(t) {
      return Co.get(t);
    }
    function H(t, e) {
      Co.set(t, e);
    }
    var Bt = [];
    var G = class {
      constructor() {
        l(this, "_values", {});
      }
      get(e, r) {
        if (this.has(e)) {
          return this._values[e];
        }
        {
          let o = r();
          this._values[e] = o;
          return o;
        }
      }
      has(e) {
        return this._values.hasOwnProperty(e);
      }
    };
    var Rt = new WeakMap();
    function zt(t) {
      if (Rt.has(t)) {
        return Rt.get(t);
      }
      let e = t.type === "compound" ? function Yi(t) {
        let e = {};
        for (let [r, o] of Object.entries(t.props)) {
          e[r] = zt(o);
        }
        return e;
      }(t) : t.type === "enum" ? function Ji(t) {
        let e = {
          $case: t.defaultCase
        };
        for (let [r, o] of Object.entries(t.cases)) {
          e[r] = zt(o);
        }
        return e;
      }(t) : t.default;
      Rt.set(t, e);
      return e;
    }
    var Pe = {
      log: console.log,
      warn: console.warn,
      error: console.error,
      trace: console.trace
    };
    var Mo = Re(No());
    function Wt(t, e) {
      return d(() => {
        let r = v(t);
        return d.memo("driver", () => r ? r.type === "BasicKeyframedTrack" ? function Qi(t, e) {
          return d(() => {
            let r = d.ref("state", {
              started: false
            });
            let o = r.current;
            let n = e.getValue();
            if (!o.started || n < o.validFrom || o.validTo <= n) {
              r.current = o = es(e, t);
            }
            return o.der.getValue();
          });
        }(r, e) : (Pe.error("Track type not yet supported."), new T(undefined)) : new T(undefined), [r]).getValue();
      });
    }
    var Eo = new T(undefined);
    var es = (t, e) => {
      let r = t.getValue();
      if (e.keyframes.length === 0) {
        return {
          started: true,
          validFrom: -Infinity,
          validTo: Infinity,
          der: Eo
        };
      }
      let o = 0;
      while (true) {
        let n = e.keyframes[o];
        if (!n) {
          return te.error;
        }
        let a = o === e.keyframes.length - 1;
        if (r < n.position) {
          if (o === 0) {
            return te.beforeFirstKeyframe(n);
          } else {
            return te.error;
          }
        }
        if (n.position === r) {
          if (a) {
            return te.lastKeyframe(n);
          } else {
            return te.between(n, e.keyframes[o + 1], t);
          }
        }
        if (o === e.keyframes.length - 1) {
          return te.lastKeyframe(n);
        }
        {
          let i = o + 1;
          if (e.keyframes[i].position <= r) {
            o = i;
            continue;
          }
          return te.between(n, e.keyframes[o + 1], t);
        }
      }
    };
    var te = {
      beforeFirstKeyframe: t => ({
        started: true,
        validFrom: -Infinity,
        validTo: t.position,
        der: new T(t.value)
      }),
      lastKeyframe: t => ({
        started: true,
        validFrom: t.position,
        validTo: Infinity,
        der: new T(t.value)
      }),
      between(t, e, r) {
        if (!t.connectedRight) {
          return {
            started: true,
            validFrom: t.position,
            validTo: e.position,
            der: new T(t.value)
          };
        }
        let o = new Mo.default(t.handles[2], t.handles[3], e.handles[0], e.handles[1]);
        let a = d(() => {
          let i = (i => (i - t.position) / (e.position - t.position))(r.getValue());
          let s = o.solveSimple(i);
          return t.value + s * (e.value - t.value);
        });
        return {
          started: true,
          validFrom: t.position,
          validTo: e.position,
          der: a
        };
      },
      error: {
        started: true,
        validFrom: -Infinity,
        validTo: Infinity,
        der: Eo
      }
    };
    function _e(t, e, r) {
      let n = r.get(t);
      if (n && n.override === e) {
        return n.merged;
      }
      let a = g({}, t);
      for (let i of Object.keys(e)) {
        let s = e[i];
        let u = t[i];
        a[i] = typeof s == "object" && typeof u == "object" ? _e(u, s, r) : s === undefined ? u : s;
      }
      r.set(t, {
        override: e,
        merged: a
      });
      return a;
    }
    function et(t, e) {
      let r = t;
      for (let o of e) {
        r = r[o];
      }
      return r;
    }
    var Bo = new class {
      constructor() {
        this._ticking = false;
        this._scheduledForThisOrNextTick = new Set();
        this._scheduledForNextTick = new Set();
        this._timeAtCurrentTick = 0;
      }
      onThisOrNextTick(e) {
        this._scheduledForThisOrNextTick.add(e);
      }
      onNextTick(e) {
        this._scheduledForNextTick.add(e);
      }
      offThisOrNextTick(e) {
        this._scheduledForThisOrNextTick.delete(e);
      }
      offNextTick(e) {
        this._scheduledForNextTick.delete(e);
      }
      get time() {
        if (this._ticking) {
          return this._timeAtCurrentTick;
        } else {
          return performance.now();
        }
      }
      tick(e = performance.now()) {
        this._ticking = true;
        this._timeAtCurrentTick = e;
        this._scheduledForNextTick.forEach(r => this._scheduledForThisOrNextTick.add(r));
        this._scheduledForNextTick.clear();
        this._tick(0);
        this._ticking = false;
      }
      _tick(e) {
        let r = this.time;
        if (e > 10) {
          console.warn("_tick() recursing for 10 times");
        }
        if (e > 100) {
          throw new Error("Maximum recursion limit for _tick()");
        }
        let o = this._scheduledForThisOrNextTick;
        this._scheduledForThisOrNextTick = new Set();
        o.forEach(n => {
          n(r);
        });
        if (this._scheduledForThisOrNextTick.size > 0) {
          return this._tick(e + 1);
        }
      }
    }();
    var $ = Bo;
    var Fo = t => {
      Bo.tick(t);
      window.requestAnimationFrame(Fo);
    };
    window.requestAnimationFrame(Fo);
    Re(Lo());
    var Uo = class extends Error {};
    var w = class extends Uo {};
    var ns = /\s/;
    var Ko = function as(t) {
      for (var e = t.length; e-- && ns.test(t.charAt(e)););
      return e;
    };
    var is = /^\s+/;
    var Ho = function ss(t) {
      return t && t.slice(0, Ko(t) + 1).replace(is, "");
    };
    var ps = /^[-+]0x[0-9a-f]+$/i;
    var us = /^0b[01]+$/i;
    var ls = /^0o[0-7]+$/i;
    var fs = parseInt;
    var Jo = function cs(t) {
      if (typeof t == "number") {
        return t;
      }
      if (z(t)) {
        return NaN;
      }
      if (Y(t)) {
        var e = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = Y(e) ? e + "" : e;
      }
      if (typeof t != "string") {
        if (t === 0) {
          return t;
        } else {
          return +t;
        }
      }
      t = Ho(t);
      var r = us.test(t);
      if (r || ls.test(t)) {
        return fs(t.slice(2), r ? 2 : 8);
      } else if (ps.test(t)) {
        return NaN;
      } else {
        return +t;
      }
    };
    var Xo = function hs(t) {
      if (t) {
        if ((t = Jo(t)) === Infinity || t === -Infinity) {
          return (t < 0 ? -1 : 1) * 1.7976931348623157e+308;
        } else if (t == t) {
          return t;
        } else {
          return 0;
        }
      } else if (t === 0) {
        return t;
      } else {
        return 0;
      }
    };
    var Zo = function ms(t) {
      var e = Xo(t);
      var r = e % 1;
      if (e == e) {
        if (r) {
          return e - r;
        } else {
          return e;
        }
      } else {
        return 0;
      }
    };
    var Qo = function ys(t, e, r) {
      var o = -1;
      var n = t.length;
      if (e < 0) {
        e = -e > n ? 0 : n + e;
      }
      if ((r = r > n ? n : r) < 0) {
        r += n;
      }
      n = e > r ? 0 : r - e >>> 0;
      e >>>= 0;
      var a = Array(n);
      for (; ++o < n;) {
        a[o] = t[o + e];
      }
      return a;
    };
    var en = function gs(t, e, r) {
      var o = t.length;
      r = r === undefined ? o : r;
      if (!e && r >= o) {
        return t;
      } else {
        return Qo(t, e, r);
      }
    };
    var Is = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    var Se = function Ts(t) {
      return Is.test(t);
    };
    var tn = function ws(t) {
      return t.split("");
    };
    var rn = "\\ud800-\\udfff";
    var Vs = "[" + rn + "]";
    var Ut = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]";
    var Kt = "\\ud83c[\\udffb-\\udfff]";
    var on = "[^" + rn + "]";
    var nn = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var an = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var sn = "(?:" + Ut + "|" + Kt + ")?";
    var pn = "[\\ufe0e\\ufe0f]?";
    var $s = pn + sn + ("(?:\\u200d(?:" + [on, nn, an].join("|") + ")" + pn + sn + ")*");
    var Bs = "(?:" + [on + Ut + "?", Ut, nn, an, Vs].join("|") + ")";
    var Fs = RegExp(Kt + "(?=" + Kt + ")|" + Bs + $s, "g");
    var un = function Rs(t) {
      return t.match(Fs) || [];
    };
    var ln = function qs(t) {
      if (Se(t)) {
        return un(t);
      } else {
        return tn(t);
      }
    };
    var fn = function zs(t) {
      return function (e) {
        if (e == null) {
          return undefined;
        } else {
          return e[t];
        }
      };
    };
    var Ls = Math.floor;
    var Ht = function Us(t, e) {
      var r = "";
      if (!t || e < 1 || e > 9007199254740991) {
        return r;
      }
      do {
        if (e % 2) {
          r += t;
        }
        if (e = Ls(e / 2)) {
          t += t;
        }
      } while (e);
      return r;
    };
    var cn = fn("length");
    var dn = "\\ud800-\\udfff";
    var Zs = "[" + dn + "]";
    var Gt = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]";
    var Jt = "\\ud83c[\\udffb-\\udfff]";
    var hn = "[^" + dn + "]";
    var mn = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var yn = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var gn = "(?:" + Gt + "|" + Jt + ")?";
    var vn = "[\\ufe0e\\ufe0f]?";
    var rp = vn + gn + ("(?:\\u200d(?:" + [hn, mn, yn].join("|") + ")" + vn + gn + ")*");
    var op = "(?:" + [hn + Gt + "?", Gt, mn, yn, Zs].join("|") + ")";
    var bn = RegExp(Jt + "(?=" + Jt + ")|" + op + rp, "g");
    var jn = function np(t) {
      var e = bn.lastIndex = 0;
      for (; bn.test(t);) {
        ++e;
      }
      return e;
    };
    var at = function ap(t) {
      if (Se(t)) {
        return jn(t);
      } else {
        return cn(t);
      }
    };
    var ip = Math.ceil;
    var xn = function sp(t, e) {
      var r = (e = e === undefined ? " " : Le(e)).length;
      if (r < 2) {
        if (r) {
          return Ht(e, t);
        } else {
          return e;
        }
      }
      var o = Ht(e, ip(t / at(e)));
      if (Se(e)) {
        return en(ln(o), 0, t).join("");
      } else {
        return o.slice(0, t);
      }
    };
    var re = function pp(t, e, r) {
      t = Ue(t);
      var o = (e = Zo(e)) ? at(t) : 0;
      if (e && o < e) {
        return xn(e - o, r) + t;
      } else {
        return t;
      }
    };
    function B() {
      let t;
      let e;
      let r = new Promise((n, a) => {
        t = i => {
          n(i);
          o.status = "resolved";
        };
        e = i => {
          a(i);
          o.status = "rejected";
        };
      });
      let o = {
        resolve: t,
        reject: e,
        promise: r,
        status: "pending"
      };
      return o;
    }
    var Ie = () => {};
    var Pn = class {
      constructor(e) {
        this._fps = e;
      }
      formatSubUnitForGrid(e) {
        let r = e % 1;
        let o = 1 / this._fps;
        return Math.round(r / o) + "f";
      }
      formatFullUnitForGrid(e) {
        let r = e;
        let o = "";
        if (r >= Te) {
          o += Math.floor(r / Te) + "h";
          r %= Te;
        }
        if (r >= ne) {
          o += Math.floor(r / ne) + "m";
          r %= ne;
        }
        if (r >= oe) {
          o += Math.floor(r / oe) + "s";
          r %= oe;
        }
        let n = 1 / this._fps;
        if (r >= n) {
          o += Math.floor(r / n) + "f";
          r %= n;
        }
        if (o.length === 0) {
          return "0s";
        } else {
          return o;
        }
      }
      formatForPlayhead(e) {
        let r = e;
        let o = "";
        if (r >= Te) {
          let a = Math.floor(r / Te);
          o += re(a.toString(), 2, "0") + "h";
          r %= Te;
        }
        if (r >= ne) {
          let a = Math.floor(r / ne);
          o += re(a.toString(), 2, "0") + "m";
          r %= ne;
        } else if (o.length > 0) {
          o += "00m";
        }
        if (r >= oe) {
          let a = Math.floor(r / oe);
          o += re(a.toString(), 2, "0") + "s";
          r %= oe;
        } else {
          o += "00s";
        }
        let n = 1 / this._fps;
        if (r >= n) {
          let a = Math.round(r / n);
          o += re(a.toString(), 2, "0") + "f";
          r %= n;
        } else if (r / n > 0.98) {
          o += re(1 .toString(), 2, "0") + "f";
          r %= n;
        } else {
          o += "00f";
        }
        if (o.length === 0) {
          return "00s00f";
        } else {
          return o;
        }
      }
      formatBasic(e) {
        return e.toFixed(2) + "s";
      }
    };
    var oe = 1;
    var ne = oe * 60;
    var Te = ne * 60;
    var ft = {};
    function lt(t, e) {
      if (t.length <= e) {
        return t;
      } else {
        return t.substr(0, e - 3) + "...";
      }
    }
    wt(ft, {
      boolean: () => Xt,
      compound: () => Me,
      number: () => Yt,
      string: () => Zt,
      stringLiteral: () => hp
    });
    var we = t => typeof t == "string" ? `string("${lt(t, 10)}")` : typeof t == "number" ? `number(${lt(String(t), 10)})` : t === null ? "null" : t === undefined ? "undefined" : typeof t == "boolean" ? String(t) : Array.isArray(t) ? "array" : typeof t == "object" ? "object" : "unknown";
    var ae = Symbol("TheatrePropType_Basic");
    function _n(t) {
      return typeof t == "object" && !!t && t[ae] === "TheatrePropType";
    }
    function cp(t) {
      if (typeof t == "number") {
        return Yt(t);
      }
      if (typeof t == "boolean") {
        return Xt(t);
      }
      if (typeof t == "string") {
        return Zt(t);
      }
      if (typeof t == "object" && t) {
        if (_n(t)) {
          return t;
        }
        if (Ve(t)) {
          return Me(t);
        }
        throw new w(`This value is not a valid prop type: ${we(t)}`);
      }
      throw new w(`This value is not a valid prop type: ${we(t)}`);
    }
    function Sn(t) {
      let e = {};
      for (let r of Object.keys(t)) {
        let o = t[r];
        if (_n(o)) {
          e[r] = o;
        } else {
          e[r] = cp(o);
        }
      }
      return e;
    }
    var Me = (t, e) => ({
      type: "compound",
      props: Sn(t),
      valueType: null,
      [ae]: "TheatrePropType",
      label: e == null ? undefined : e.label
    });
    var Yt = (t, e) => {
      return x(g({
        type: "number",
        valueType: 0,
        default: t,
        [ae]: "TheatrePropType"
      }, e || {}), {
        label: e == null ? undefined : e.label,
        nudgeFn: (e == null ? undefined : e.nudgeFn) ?? mp,
        nudgeMultiplier: typeof (e == null ? undefined : e.nudgeMultiplier) == "number" ? e.nudgeMultiplier : 1
      });
    };
    var Xt = (t, e) => ({
      type: "boolean",
      default: t,
      valueType: null,
      [ae]: "TheatrePropType",
      label: e == null ? undefined : e.label
    });
    var Zt = (t, e) => ({
      type: "string",
      default: t,
      valueType: null,
      [ae]: "TheatrePropType",
      label: e == null ? undefined : e.label
    });
    function hp(t, e, r) {
      return {
        type: "stringLiteral",
        default: t,
        options: g({}, e),
        [ae]: "TheatrePropType",
        valueType: null,
        as: (r == null ? undefined : r.as) ?? "menu",
        label: r == null ? undefined : r.label
      };
    }
    var mp = ({
      config: t,
      deltaX: e,
      deltaFraction: r,
      magnitude: o
    }) => {
      let {
        range: n
      } = t;
      if (n) {
        return r * (n[1] - n[0]) * o * t.nudgeMultiplier;
      } else {
        return e * o * t.nudgeMultiplier;
      }
    };
    function ct(t, e) {
      return (t => t.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/, " / "))(t);
    }
    Re(Qt());
    new WeakMap();
    var Tn = t => new Promise(e => setTimeout(e, t));
    function D(t) {
      for (var e = arguments.length, r = Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++) {
        r[o - 1] = arguments[o];
      }
      throw Error("[Immer] minified error nr: " + t + (r.length ? " " + r.map(function (i) {
        return "'" + i + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function ie(t) {
      return !!t && !!t[P];
    }
    function se(t) {
      return !!t && (function (e) {
        if (!e || typeof e != "object") {
          return false;
        }
        var r = Object.getPrototypeOf(e);
        if (r === null) {
          return true;
        }
        var o = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
        return o === Object || typeof o == "function" && Function.toString.call(o) === Tp;
      }(t) || Array.isArray(t) || !!t[$n] || !!t.constructor[$n] || tr(t) || rr(t));
    }
    function Ee(t, e, r = false) {
      if (De(t) === 0) {
        (r ? Object.keys : hr)(t).forEach(function (o) {
          if (!r || typeof o != "symbol") {
            e(o, t[o], t);
          }
        });
      } else {
        t.forEach(function (o, n) {
          return e(n, o, t);
        });
      }
    }
    function De(t) {
      var e = t[P];
      if (e) {
        if (e.i > 3) {
          return e.i - 4;
        } else {
          return e.i;
        }
      } else if (Array.isArray(t)) {
        return 1;
      } else if (tr(t)) {
        return 2;
      } else if (rr(t)) {
        return 3;
      } else {
        return 0;
      }
    }
    function er(t, e) {
      if (De(t) === 2) {
        return t.has(e);
      } else {
        return Object.prototype.hasOwnProperty.call(t, e);
      }
    }
    function Dn(t, e, r) {
      var o = De(t);
      if (o === 2) {
        t.set(e, r);
      } else if (o === 3) {
        t.delete(e);
        t.add(r);
      } else {
        t[e] = r;
      }
    }
    function tr(t) {
      return Sp && t instanceof Map;
    }
    function rr(t) {
      return Ip && t instanceof Set;
    }
    function pe(t) {
      return t.o || t.t;
    }
    function or(t) {
      if (Array.isArray(t)) {
        return Array.prototype.slice.call(t);
      }
      var e = wp(t);
      delete e[P];
      for (var r = hr(e), o = 0; o < r.length; o++) {
        var n = r[o];
        var a = e[n];
        if (a.writable === false) {
          a.writable = true;
          a.configurable = true;
        }
        if (a.get || a.set) {
          e[n] = {
            configurable: true,
            writable: true,
            enumerable: a.enumerable,
            value: t[n]
          };
        }
      }
      return Object.create(Object.getPrototypeOf(t), e);
    }
    function nr(t, e = false) {
      if (!ar(t) && !ie(t) && !!se(t)) {
        if (De(t) > 1) {
          t.set = t.add = t.clear = t.delete = xp;
        }
        Object.freeze(t);
        if (e) {
          Ee(t, function (r, o) {
            return nr(o, true);
          }, true);
        }
      }
      return t;
    }
    function xp() {
      D(2);
    }
    function ar(t) {
      return t == null || typeof t != "object" || Object.isFrozen(t);
    }
    function F(t) {
      var e = Dp[t];
      if (!e) {
        D(18, t);
      }
      return e;
    }
    function An() {
      return $e;
    }
    function ir(t, e) {
      if (e) {
        F("Patches");
        t.u = [];
        t.s = [];
        t.v = e;
      }
    }
    function yt(t) {
      sr(t);
      t.p.forEach(Pp);
      t.p = null;
    }
    function sr(t) {
      if (t === $e) {
        $e = t.l;
      }
    }
    function On(t) {
      return $e = {
        p: [],
        l: $e,
        h: t,
        m: true,
        _: 0
      };
    }
    function Pp(t) {
      var e = t[P];
      if (e.i === 0 || e.i === 1) {
        e.j();
      } else {
        e.O = true;
      }
    }
    function pr(t, e) {
      e._ = e.p.length;
      var r = e.p[0];
      var o = t !== undefined && t !== r;
      if (!e.h.g) {
        F("ES5").S(e, t, o);
      }
      if (o) {
        if (r[P].P) {
          yt(e);
          D(4);
        }
        if (se(t)) {
          t = gt(e, t);
          if (!e.l) {
            vt(e, t);
          }
        }
        if (e.u) {
          F("Patches").M(r[P], t, e.u, e.s);
        }
      } else {
        t = gt(e, r, []);
      }
      yt(e);
      if (e.u) {
        e.v(e.u, e.s);
      }
      if (t !== En) {
        return t;
      } else {
        return undefined;
      }
    }
    function gt(t, e, r) {
      if (ar(e)) {
        return e;
      }
      var o = e[P];
      if (!o) {
        Ee(e, function (a, i) {
          return kn(t, o, e, a, i, r);
        }, true);
        return e;
      }
      if (o.A !== t) {
        return e;
      }
      if (!o.P) {
        vt(t, o.t, true);
        return o.t;
      }
      if (!o.I) {
        o.I = true;
        o.A._--;
        var n = o.i === 4 || o.i === 5 ? o.o = or(o.k) : o.o;
        Ee(o.i === 3 ? new Set(n) : n, function (a, i) {
          return kn(t, o, n, a, i, r);
        });
        vt(t, n, false);
        if (r && t.u) {
          F("Patches").R(o, r, t.u, t.s);
        }
      }
      return o.o;
    }
    function kn(t, e, r, o, n, a) {
      if (ie(n)) {
        var i = gt(t, n, a && e && e.i !== 3 && !er(e.D, o) ? a.concat(o) : undefined);
        Dn(r, o, i);
        if (!ie(i)) {
          return;
        }
        t.m = false;
      }
      if (se(n) && !ar(n)) {
        if (!t.h.F && t._ < 1) {
          return;
        }
        gt(t, n);
        if (!e || !e.A.l) {
          vt(t, n);
        }
      }
    }
    function vt(t, e, r = false) {
      if (t.h.F && t.m) {
        nr(e, r);
      }
    }
    function ur(t, e) {
      var r = t[P];
      return (r ? pe(r) : t)[e];
    }
    function Cn(t, e) {
      if (e in t) {
        for (var r = Object.getPrototypeOf(t); r;) {
          var o = Object.getOwnPropertyDescriptor(r, e);
          if (o) {
            return o;
          }
          r = Object.getPrototypeOf(r);
        }
      }
    }
    function lr(t) {
      if (!t.P) {
        t.P = true;
        if (t.l) {
          lr(t.l);
        }
      }
    }
    function fr(t) {
      t.o ||= or(t.t);
    }
    function cr(t, e, r) {
      var o = tr(e) ? F("MapSet").N(e, r) : rr(e) ? F("MapSet").T(e, r) : t.g ? function (n, a) {
        var i = Array.isArray(n);
        var s = {
          i: i ? 1 : 0,
          A: a ? a.A : An(),
          P: false,
          I: false,
          D: {},
          l: a,
          t: n,
          k: null,
          o: null,
          j: null,
          C: false
        };
        var u = s;
        var p = bt;
        if (i) {
          u = [s];
          p = jt;
        }
        var f = Proxy.revocable(u, p);
        var h = f.revoke;
        var b = f.proxy;
        s.k = b;
        s.j = h;
        return b;
      }(e, r) : F("ES5").J(e, r);
      (r ? r.A : An()).p.push(o);
      return o;
    }
    function _p(t) {
      if (!ie(t)) {
        D(22, t);
      }
      return function e(r) {
        if (!se(r)) {
          return r;
        }
        var o;
        var n = r[P];
        var a = De(r);
        if (n) {
          if (!n.P && (n.i < 4 || !F("ES5").K(n))) {
            return n.t;
          }
          n.I = true;
          o = Vn(r, a);
          n.I = false;
        } else {
          o = Vn(r, a);
        }
        Ee(o, function (i, s) {
          if (!n || function bp(t, e) {
            if (De(t) === 2) {
              return t.get(e);
            } else {
              return t[e];
            }
          }(n.t, i) !== s) {
            Dn(o, i, e(s));
          }
        });
        if (a === 3) {
          return new Set(o);
        } else {
          return o;
        }
      }(t);
    }
    function Vn(t, e) {
      switch (e) {
        case 2:
          return new Map(t);
        case 3:
          return Array.from(t);
      }
      return or(t);
    }
    var Nn;
    var $e;
    var dr = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
    var Sp = typeof Map != "undefined";
    var Ip = typeof Set != "undefined";
    var Mn = typeof Proxy != "undefined" && Proxy.revocable !== undefined && typeof Reflect != "undefined";
    var En = dr ? Symbol.for("immer-nothing") : ((Nn = {})["immer-nothing"] = true, Nn);
    var $n = dr ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var P = dr ? Symbol.for("immer-state") : "__$immer_state";
    if (typeof Symbol != "undefined") {
      Symbol.iterator;
    }
    var Tp = "" + Object.prototype.constructor;
    var hr = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== undefined ? function (t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : Object.getOwnPropertyNames;
    var wp = Object.getOwnPropertyDescriptors || function (t) {
      var e = {};
      hr(t).forEach(function (r) {
        e[r] = Object.getOwnPropertyDescriptor(t, r);
      });
      return e;
    };
    var Dp = {};
    var bt = {
      get: function (t, e) {
        if (e === P) {
          return t;
        }
        var r = pe(t);
        if (!er(r, e)) {
          return function (n, a, i) {
            var s;
            var u = Cn(a, i);
            if (u) {
              if ("value" in u) {
                return u.value;
              } else if ((s = u.get) === null || s === undefined) {
                return undefined;
              } else {
                return s.call(n.k);
              }
            } else {
              return undefined;
            }
          }(t, r, e);
        }
        var o = r[e];
        if (t.I || !se(o)) {
          return o;
        } else if (o === ur(t.t, e)) {
          fr(t);
          return t.o[e] = cr(t.A.h, o, t);
        } else {
          return o;
        }
      },
      has: function (t, e) {
        return e in pe(t);
      },
      ownKeys: function (t) {
        return Reflect.ownKeys(pe(t));
      },
      set: function (t, e, r) {
        var o = Cn(pe(t), e);
        if (o == null ? undefined : o.set) {
          o.set.call(t.k, r);
          return true;
        }
        if (!t.P) {
          var n = ur(pe(t), e);
          var a = n == null ? undefined : n[P];
          if (a && a.t === r) {
            t.o[e] = r;
            t.D[e] = false;
            return true;
          }
          if (function jp(t, e) {
            if (t === e) {
              return t !== 0 || 1 / t == 1 / e;
            } else {
              return t != t && e != e;
            }
          }(r, n) && (r !== undefined || er(t.t, e))) {
            return true;
          }
          fr(t);
          lr(t);
        }
        return t.o[e] === r && typeof r != "number" && (r !== undefined || e in t.o) || (t.o[e] = r, t.D[e] = true, true);
      },
      deleteProperty: function (t, e) {
        if (ur(t.t, e) !== undefined || e in t.t) {
          t.D[e] = false;
          fr(t);
          lr(t);
        } else {
          delete t.D[e];
        }
        if (t.o) {
          delete t.o[e];
        }
        return true;
      },
      getOwnPropertyDescriptor: function (t, e) {
        var r = pe(t);
        var o = Reflect.getOwnPropertyDescriptor(r, e);
        return o && {
          writable: true,
          configurable: t.i !== 1 || e !== "length",
          enumerable: o.enumerable,
          value: r[e]
        };
      },
      defineProperty: function () {
        D(11);
      },
      getPrototypeOf: function (t) {
        return Object.getPrototypeOf(t.t);
      },
      setPrototypeOf: function () {
        D(12);
      }
    };
    var jt = {};
    Ee(bt, function (t, e) {
      jt[t] = function () {
        arguments[0] = arguments[0][0];
        return e.apply(this, arguments);
      };
    });
    jt.deleteProperty = function (t, e) {
      return bt.deleteProperty.call(this, t[0], e);
    };
    jt.set = function (t, e, r) {
      return bt.set.call(this, t[0], e, r, t[0]);
    };
    var I = new (function () {
      function t(r) {
        var o = this;
        this.g = Mn;
        this.F = true;
        this.produce = function (n, a, i) {
          if (typeof n == "function" && typeof a != "function") {
            var s = a;
            a = n;
            var u = o;
            return function (c) {
              var Oe = this;
              if (c === undefined) {
                c = s;
              }
              for (var J = arguments.length, R = Array(J > 1 ? J - 1 : 0), k = 1; k < J; k++) {
                R[k - 1] = arguments[k];
              }
              return u.produce(c, function (A) {
                var q;
                return (q = a).call.apply(q, [Oe, A].concat(R));
              });
            };
          }
          var p;
          if (typeof a != "function") {
            D(6);
          }
          if (i !== undefined && typeof i != "function") {
            D(7);
          }
          if (se(n)) {
            var f = On(o);
            var h = cr(o, n, undefined);
            var b = true;
            try {
              p = a(h);
              b = false;
            } finally {
              if (b) {
                yt(f);
              } else {
                sr(f);
              }
            }
            if (typeof Promise != "undefined" && p instanceof Promise) {
              return p.then(function (c) {
                ir(f, i);
                return pr(c, f);
              }, function (c) {
                yt(f);
                throw c;
              });
            } else {
              ir(f, i);
              return pr(p, f);
            }
          }
          if (!n || typeof n != "object") {
            if ((p = a(n)) === En) {
              return undefined;
            } else {
              if (p === undefined) {
                p = n;
              }
              if (o.F) {
                nr(p, true);
              }
              return p;
            }
          }
          D(21, n);
        };
        this.produceWithPatches = function (n, a) {
          if (typeof n == "function") {
            return function (u) {
              for (var p = arguments.length, f = Array(p > 1 ? p - 1 : 0), h = 1; h < p; h++) {
                f[h - 1] = arguments[h];
              }
              return o.produceWithPatches(u, function (b) {
                return n.apply(undefined, [b].concat(f));
              });
            };
          } else {
            return [o.produce(n, a, function (u, p) {
              i = u;
              s = p;
            }), i, s];
          }
          var i;
          var s;
        };
        if (typeof (r == null ? undefined : r.useProxies) == "boolean") {
          this.setUseProxies(r.useProxies);
        }
        if (typeof (r == null ? undefined : r.autoFreeze) == "boolean") {
          this.setAutoFreeze(r.autoFreeze);
        }
      }
      var e = t.prototype;
      e.createDraft = function (r) {
        if (!se(r)) {
          D(8);
        }
        if (ie(r)) {
          r = _p(r);
        }
        var o = On(this);
        var n = cr(this, r, undefined);
        n[P].C = true;
        sr(o);
        return n;
      };
      e.finishDraft = function (r, o) {
        var a = (r && r[P]).A;
        ir(a, o);
        return pr(undefined, a);
      };
      e.setAutoFreeze = function (r) {
        this.F = r;
      };
      e.setUseProxies = function (r) {
        if (r && !Mn) {
          D(20);
        }
        this.g = r;
      };
      e.applyPatches = function (r, o) {
        var n;
        for (n = o.length - 1; n >= 0; n--) {
          var a = o[n];
          if (a.path.length === 0 && a.op === "replace") {
            r = a.value;
            break;
          }
        }
        var i = F("Patches").$;
        if (ie(r)) {
          return i(r, o);
        } else {
          return this.produce(r, function (s) {
            return i(s, o.slice(n + 1));
          });
        }
      };
      return t;
    }())();
    I.produce;
    I.produceWithPatches.bind(I);
    I.setAutoFreeze.bind(I);
    I.setUseProxies.bind(I);
    I.applyPatches.bind(I);
    I.createDraft.bind(I);
    I.finishDraft.bind(I);
    var Ae = {
      currentProjectStateDefinitionVersion: "0.4.0"
    };
    async function mr(t, e, r) {
      await Tn(0);
      t.transaction(({
        drafts: o
      }) => {
        var f;
        let n = e.address.projectId;
        o.ephemeral.coreByProject[n] = {
          lastExportedObject: null,
          loadingState: {
            type: "loading"
          }
        };
        o.ahistoric.coreByProject[n] = {
          ahistoricStuff: ""
        };
        let p = (f = function wn(t) {
          if (!ie(t)) {
            D(23, t);
          }
          return t[P].t;
        }(o.historic)) == null ? undefined : f.coreByProject[e.address.projectId];
        if (p) {
          if (r && p.revisionHistory.indexOf(r.revisionHistory[0]) == -1) {
            (function u(h) {
              o.ephemeral.coreByProject[n].loadingState = {
                type: "browserStateIsNotBasedOnDiskState",
                onDiskState: h
              };
            })(r);
          } else {
            (function s() {
              o.ephemeral.coreByProject[n].loadingState = {
                type: "loaded"
              };
            })();
          }
        } else if (r) {
          (function i(h) {
            o.ephemeral.coreByProject[n].loadingState = {
              type: "loaded"
            };
            o.historic.coreByProject[n] = h;
          })(r);
        } else {
          (function a() {
            o.ephemeral.coreByProject[n].loadingState = {
              type: "loaded"
            };
            o.historic.coreByProject[n] = {
              sheetsById: {},
              definitionVersion: Ae.currentProjectStateDefinitionVersion,
              revisionHistory: []
            };
          })();
        }
      });
    }
    Re(Qt());
    function Bn(t, e = {}) {
      let r = ((t, e) => {
        var r = {};
        for (var o in t) {
          if (It.call(t, o) && e.indexOf(o) < 0) {
            r[o] = t[o];
          }
        }
        if (t != null && Be) {
          for (var o of Be(t)) {
            if (e.indexOf(o) < 0 && vr.call(t, o)) {
              r[o] = t[o];
            }
          }
        }
        return r;
      })(e, []);
      let o = xe.get(t);
      if (o) {
        return o.publicApi;
      } else {
        if (e.state) {
          Cp(t, e.state);
        }
        return new class {
          get type() {
            return "Theatre_Project_PublicAPI";
          }
          constructor(e, r = {}) {
            H(this, new class {
              constructor(e, r = {}, o) {
                this.config = r;
                this.publicApi = o;
                l(this, "pointers");
                l(this, "_pointerProxies");
                l(this, "address");
                l(this, "_readyDeferred");
                l(this, "_sheetTemplates", new y({}));
                l(this, "sheetTemplatesP", this._sheetTemplates.pointer);
                l(this, "_studio");
                l(this, "type", "Theatre_Project");
                this.address = {
                  projectId: e
                };
                let n = new y({
                  ahistoric: {
                    ahistoricStuff: ""
                  },
                  historic: r.state ?? {
                    sheetsById: {},
                    definitionVersion: Ae.currentProjectStateDefinitionVersion,
                    revisionHistory: []
                  },
                  ephemeral: {
                    loadingState: {
                      type: "loaded"
                    },
                    lastExportedObject: null
                  }
                });
                this._pointerProxies = {
                  historic: new ee(n.pointer.historic),
                  ahistoric: new ee(n.pointer.ahistoric),
                  ephemeral: new ee(n.pointer.ephemeral)
                };
                this.pointers = {
                  historic: this._pointerProxies.historic.pointer,
                  ahistoric: this._pointerProxies.ahistoric.pointer,
                  ephemeral: this._pointerProxies.ephemeral.pointer
                };
                xe.add(e, this);
                this._readyDeferred = B();
                if (r.state) {
                  setTimeout(() => {
                    if (!this._studio) {
                      this._readyDeferred.resolve(undefined);
                    }
                  }, 0);
                } else {
                  setTimeout(() => {
                    if (!this._studio) {
                      throw new Error(`Argument config.state in Theatre.getProject("${e}", config) is empty. This is fine while you are using @theatre/core along with @theatre/sutdio. But since @theatre/studio is not loaded, the state of project "${e}" will be empty.\n\nTo fix this, you need to add @theatre/studio into the bundle and export the projet's state. Learn how to do that at https://docs.theatrejs.com/in-depth/#exporting`);
                    }
                  }, 1000);
                }
              }
              attachToStudio(e) {
                if (this._studio) {
                  if (this._studio !== e) {
                    throw new Error(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
                  }
                  console.warn(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
                } else {
                  this._studio = e;
                  e.initialized.then(async () => {
                    await mr(e, this, this.config.state);
                    this._pointerProxies.historic.setPointer(e.atomP.historic.coreByProject[this.address.projectId]);
                    this._pointerProxies.ahistoric.setPointer(e.atomP.ahistoric.coreByProject[this.address.projectId]);
                    this._pointerProxies.ephemeral.setPointer(e.atomP.ephemeral.coreByProject[this.address.projectId]);
                    this._readyDeferred.resolve(undefined);
                  });
                }
              }
              get isAttachedToStudio() {
                return !!this._studio;
              }
              get ready() {
                return this._readyDeferred.promise;
              }
              isReady() {
                return this._readyDeferred.status === "resolved";
              }
              getOrCreateSheet(e, r = "default") {
                let o = this._sheetTemplates.getState()[e];
                if (!o) {
                  o = new class {
                    constructor(e, r) {
                      this.project = e;
                      l(this, "type", "Theatre_SheetTemplate");
                      l(this, "address");
                      l(this, "_instances", new y({}));
                      l(this, "instancesP", this._instances.pointer);
                      l(this, "_objectTemplates", new y({}));
                      l(this, "objectTemplatesP", this._objectTemplates.pointer);
                      this.address = x(g({}, e.address), {
                        sheetId: r
                      });
                    }
                    getInstance(e) {
                      let r = this._instances.getState()[e];
                      if (!r) {
                        r = new class {
                          constructor(e, r) {
                            this.template = e;
                            this.instanceId = r;
                            l(this, "_objects", new y({}));
                            l(this, "_sequence");
                            l(this, "address");
                            l(this, "publicApi");
                            l(this, "project");
                            l(this, "objectsP", this._objects.pointer);
                            l(this, "type", "Theatre_Sheet");
                            this.project = e.project;
                            this.address = x(g({}, e.address), {
                              sheetInstanceId: this.instanceId
                            });
                            this.publicApi = new class {
                              get type() {
                                return "Theatre_Sheet_PublicAPI";
                              }
                              constructor(e) {
                                H(this, e);
                              }
                              object(e, r) {
                                let o = m(this);
                                let n = ct(e);
                                let a = o.getObject(n);
                                if (a) {
                                  return a.publicApi;
                                }
                                {
                                  let s = Me(r);
                                  return o.createObject(n, null, s).publicApi;
                                }
                              }
                              get sequence() {
                                return m(this).getSequence().publicApi;
                              }
                              get project() {
                                return m(this).project.publicApi;
                              }
                              get address() {
                                return g({}, m(this).address);
                              }
                            }(this);
                          }
                          createObject(e, r, o) {
                            let a = this.template.getObjectTemplate(e, r, o).createInstance(this, r, o);
                            this._objects.setIn([e], a);
                            return a;
                          }
                          getObject(e) {
                            return this._objects.getState()[e];
                          }
                          getSequence() {
                            if (!this._sequence) {
                              let e = S(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length).map(o => typeof o == "number" ? o : 10);
                              let r = S(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit).map(o => typeof o == "number" ? o : 30);
                              this._sequence = new class {
                                constructor(e, r, o, n, a) {
                                  this._project = e;
                                  this._sheet = r;
                                  this._lengthD = o;
                                  this._subUnitsPerUnitD = n;
                                  l(this, "address");
                                  l(this, "publicApi");
                                  l(this, "_playbackControllerBox");
                                  l(this, "_statePointerDerivation");
                                  l(this, "_positionD");
                                  l(this, "_positionFormatterD");
                                  l(this, "_playableRangeD");
                                  l(this, "closestGridPosition", e => {
                                    let o = 1 / this.subUnitsPerUnit;
                                    return parseFloat((Math.round(e / o) * o).toFixed(3));
                                  });
                                  this.address = x(g({}, this._sheet.address), {
                                    sequenceName: "default"
                                  });
                                  this.publicApi = new class {
                                    get type() {
                                      return "Theatre_Sequence_PublicAPI";
                                    }
                                    constructor(e) {
                                      H(this, e);
                                    }
                                    play(e) {
                                      if (m(this)._project.isReady()) {
                                        return m(this).play(e);
                                      }
                                      {
                                        let r = B();
                                        r.resolve(true);
                                        return r.promise;
                                      }
                                    }
                                    pause() {
                                      m(this).pause();
                                    }
                                    get position() {
                                      return m(this).position;
                                    }
                                    set position(e) {
                                      m(this).position = e;
                                    }
                                    async attachAudio(e) {
                                      let {
                                        audioContext: r,
                                        destinationNode: o,
                                        decodedBuffer: n
                                      } = await async function lp(t) {
                                        function e() {
                                          if (t.audioContext) {
                                            return Promise.resolve(t.audioContext);
                                          }
                                          let u = new AudioContext();
                                          if (u.state === "running") {
                                            return Promise.resolve(u);
                                          } else {
                                            return new Promise(p => {
                                              let f = () => {
                                                u.resume();
                                              };
                                              let h = ["mousedown", "keydown", "touchstart"];
                                              let b = {
                                                capture: true,
                                                passive: false
                                              };
                                              h.forEach(c => {
                                                window.addEventListener(c, f, b);
                                              });
                                              u.addEventListener("statechange", () => {
                                                if (u.state === "running") {
                                                  h.forEach(c => {
                                                    window.removeEventListener(c, f, b);
                                                  });
                                                  p(u);
                                                }
                                              });
                                            });
                                          }
                                        }
                                        async function r() {
                                          if (t.source instanceof AudioBuffer) {
                                            return t.source;
                                          }
                                          let p;
                                          let f;
                                          let b;
                                          let u = B();
                                          if (typeof t.source != "string") {
                                            throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");
                                          }
                                          try {
                                            p = await fetch(t.source);
                                          } catch (c) {
                                            console.error(c);
                                            throw new Error(`Could not fetch '${t.source}'. Network error logged above.`);
                                          }
                                          try {
                                            f = await p.arrayBuffer();
                                          } catch (c) {
                                            console.error(c);
                                            throw new Error(`Could not read '${t.source}' as an arrayBuffer.`);
                                          }
                                          (await o).decodeAudioData(f, u.resolve, u.reject);
                                          try {
                                            b = await u.promise;
                                          } catch (c) {
                                            console.error(c);
                                            throw new Error(`Could not decode ${t.source} as an audio file.`);
                                          }
                                          return b;
                                        }
                                        let o = e();
                                        let n = r();
                                        let [a, i] = await Promise.all([o, n]);
                                        return {
                                          destinationNode: t.destinationNode || a.destination,
                                          audioContext: a,
                                          decodedBuffer: i
                                        };
                                      }(e);
                                      let a = new class {
                                        constructor(e, r, o, n) {
                                          this._ticker = e;
                                          this._decodedBuffer = r;
                                          this._audioContext = o;
                                          this._nodeDestination = n;
                                          l(this, "_mainGain");
                                          l(this, "_state", new y({
                                            position: 0
                                          }));
                                          l(this, "statePointer");
                                          l(this, "_stopPlayCallback", Ie);
                                          l(this, "playing", false);
                                          this.statePointer = this._state.pointer;
                                          this._mainGain = this._audioContext.createGain();
                                          this._mainGain.connect(this._nodeDestination);
                                        }
                                        destroy() {}
                                        pause() {
                                          this._stopPlayCallback();
                                          this.playing = false;
                                          this._stopPlayCallback = Ie;
                                        }
                                        gotoPosition(e) {
                                          this._updatePositionInState(e);
                                        }
                                        _updatePositionInState(e) {
                                          this._state.reduceState(["position"], () => e);
                                        }
                                        getCurrentPosition() {
                                          return this._state.getState().position;
                                        }
                                        play(e, r, o, n) {
                                          if (this.playing) {
                                            this.pause();
                                          }
                                          this.playing = true;
                                          let a = this._ticker;
                                          let i = this.getCurrentPosition();
                                          let s = r[1] - r[0];
                                          if (n !== "normal") {
                                            throw new w(`Audio-controlled sequences can only be played in the "normal" direction. '${n}' given.`);
                                          }
                                          if (i < r[0] || i > r[1] || i === r[1]) {
                                            this._updatePositionInState(r[0]);
                                          }
                                          i = this.getCurrentPosition();
                                          let u = B();
                                          let p = this._audioContext.createBufferSource();
                                          p.buffer = this._decodedBuffer;
                                          p.connect(this._mainGain);
                                          p.playbackRate.value = o;
                                          if (e > 1000) {
                                            console.warn("Audio-controlled sequences cannot have an iterationCount larger than 1000. It has been clamped to 1000.");
                                            e = 1000;
                                          }
                                          if (e > 1) {
                                            p.loop = true;
                                            p.loopStart = r[0];
                                            p.loopEnd = r[1];
                                          }
                                          let f = a.time;
                                          let h = i - r[0];
                                          let b = s * e;
                                          p.start(0, i, b - h);
                                          let c = R => {
                                            let A = Math.max(R - f, 0) / 1000;
                                            let q = Math.min(A * o + h, b);
                                            if (q !== b) {
                                              let qn = q / s % 1 * s;
                                              this._updatePositionInState(qn + r[0]);
                                              J();
                                            } else {
                                              this._updatePositionInState(r[1]);
                                              this.playing = false;
                                              Oe();
                                              u.resolve(true);
                                            }
                                          };
                                          let Oe = () => {
                                            p.stop();
                                            p.disconnect();
                                          };
                                          this._stopPlayCallback = () => {
                                            Oe();
                                            a.offThisOrNextTick(c);
                                            a.offNextTick(c);
                                            if (this.playing) {
                                              u.resolve(false);
                                            }
                                          };
                                          let J = () => a.onNextTick(c);
                                          a.onThisOrNextTick(c);
                                          return u.promise;
                                        }
                                      }($, n, r, o);
                                      m(this).replacePlaybackController(a);
                                      return {
                                        audioContext: r,
                                        destinationNode: o,
                                        decodedBuffer: n
                                      };
                                    }
                                  }(this);
                                  this._playbackControllerBox = new E(a ?? new class {
                                    constructor(e) {
                                      this._ticker = e;
                                      l(this, "playing", false);
                                      l(this, "_stopPlayCallback", Ie);
                                      l(this, "_state", new y({
                                        position: 0
                                      }));
                                      l(this, "statePointer");
                                      this.statePointer = this._state.pointer;
                                    }
                                    destroy() {}
                                    pause() {
                                      this._stopPlayCallback();
                                      this.playing = false;
                                      this._stopPlayCallback = Ie;
                                    }
                                    gotoPosition(e) {
                                      this._updatePositionInState(e);
                                    }
                                    _updatePositionInState(e) {
                                      this._state.reduceState(["position"], () => e);
                                    }
                                    getCurrentPosition() {
                                      return this._state.getState().position;
                                    }
                                    play(e, r, o, n) {
                                      if (this.playing) {
                                        this.pause();
                                      }
                                      this.playing = true;
                                      let a = this._ticker;
                                      let i = r[1] - r[0];
                                      {
                                        let c = this.getCurrentPosition();
                                        if (c < r[0] || c > r[1]) {
                                          if (n === "normal" || n === "alternate") {
                                            this._updatePositionInState(r[0]);
                                          } else if (n === "reverse" || n === "alternateReverse") {
                                            this._updatePositionInState(r[1]);
                                          }
                                        } else if (n === "normal" || n === "alternate") {
                                          if (c === r[1]) {
                                            this._updatePositionInState(r[0]);
                                          }
                                        } else if (c === r[0]) {
                                          this._updatePositionInState(r[1]);
                                        }
                                      }
                                      let s = B();
                                      let u = a.time;
                                      let p = i * e;
                                      let f = this.getCurrentPosition() - r[0];
                                      if (n === "reverse" || n === "alternateReverse") {
                                        f = r[1] - this.getCurrentPosition();
                                      }
                                      let h = c => {
                                        let J = Math.max(c - u, 0) / 1000;
                                        let R = Math.min(J * o + f, p);
                                        if (R !== p) {
                                          let k = Math.floor(R / i);
                                          let A = R / i % 1 * i;
                                          if (n !== "normal") {
                                            if (n === "reverse") {
                                              A = i - A;
                                            } else {
                                              let q = k % 2 == 0;
                                              if (n === "alternate") {
                                                if (!q) {
                                                  A = i - A;
                                                }
                                              } else if (q) {
                                                A = i - A;
                                              }
                                            }
                                          }
                                          this._updatePositionInState(A + r[0]);
                                          b();
                                        } else {
                                          if (n === "normal") {
                                            this._updatePositionInState(r[1]);
                                          } else if (n === "reverse") {
                                            this._updatePositionInState(r[0]);
                                          } else {
                                            let k = (e - 1) % 2 == 0;
                                            if (n === "alternate") {
                                              if (k) {
                                                this._updatePositionInState(r[1]);
                                              } else {
                                                this._updatePositionInState(r[0]);
                                              }
                                            } else if (k) {
                                              this._updatePositionInState(r[0]);
                                            } else {
                                              this._updatePositionInState(r[1]);
                                            }
                                          }
                                          this.playing = false;
                                          s.resolve(true);
                                        }
                                      };
                                      this._stopPlayCallback = () => {
                                        a.offThisOrNextTick(h);
                                        a.offNextTick(h);
                                        if (this.playing) {
                                          s.resolve(false);
                                        }
                                      };
                                      let b = () => a.onNextTick(h);
                                      a.onThisOrNextTick(h);
                                      return s.promise;
                                    }
                                  }($));
                                  this._statePointerDerivation = this._playbackControllerBox.derivation.map(i => i.statePointer);
                                  this._positionD = this._statePointerDerivation.flatMap(i => S(i.position));
                                  this._positionFormatterD = this._subUnitsPerUnitD.map(i => new Pn(i));
                                }
                                get positionFormatter() {
                                  return this._positionFormatterD.getValue();
                                }
                                get derivationToStatePointer() {
                                  return this._statePointerDerivation;
                                }
                                get length() {
                                  return this._lengthD.getValue();
                                }
                                get positionDerivation() {
                                  return this._positionD;
                                }
                                get position() {
                                  return this._playbackControllerBox.get().getCurrentPosition();
                                }
                                get subUnitsPerUnit() {
                                  return this._subUnitsPerUnitD.getValue();
                                }
                                get positionSnappedToGrid() {
                                  return this.closestGridPosition(this.position);
                                }
                                set position(e) {
                                  let r = e;
                                  this.pause();
                                  if (r > this.length) {
                                    r = this.length;
                                  }
                                  let o = this.length;
                                  this._playbackControllerBox.get().gotoPosition(r > o ? o : r);
                                }
                                getDurationCold() {
                                  return this._lengthD.getValue();
                                }
                                get playing() {
                                  return this._playbackControllerBox.get().playing;
                                }
                                _makeRangeFromSequenceTemplate() {
                                  return d(() => [0, v(this._lengthD)]);
                                }
                                async play(e) {
                                  let r = this.length;
                                  let o = e && e.range ? e.range : [0, r];
                                  let n = e && typeof e.iterationCount == "number" ? e.iterationCount : 1;
                                  let a = e && e.rate !== undefined ? e.rate : 1;
                                  let i = e && e.direction ? e.direction : "normal";
                                  return await this._play(n, [o[0], o[1]], a, i);
                                }
                                _play(e, r, o, n) {
                                  return this._playbackControllerBox.get().play(e, r, o, n);
                                }
                                pause() {
                                  this._playbackControllerBox.get().pause();
                                }
                                replacePlaybackController(e) {
                                  this.pause();
                                  let r = this._playbackControllerBox.get();
                                  this._playbackControllerBox.set(e);
                                  let o = r.getCurrentPosition();
                                  r.destroy();
                                  e.gotoPosition(o);
                                }
                              }(this.template.project, this, e, r);
                            }
                            return this._sequence;
                          }
                        }(this, e);
                        this._instances.setIn([e], r);
                      }
                      return r;
                    }
                    getObjectTemplate(e, r, o) {
                      let n = this._objectTemplates.getState()[e];
                      if (!n) {
                        n = new class {
                          constructor(e, r, o, n) {
                            this.sheetTemplate = e;
                            l(this, "address");
                            l(this, "type", "Theatre_SheetObjectTemplate");
                            l(this, "_config");
                            l(this, "_cache", new G());
                            l(this, "project");
                            this.address = x(g({}, e.address), {
                              objectKey: r
                            });
                            this._config = new y(n);
                            this.project = e.project;
                          }
                          get config() {
                            return this._config.getState();
                          }
                          createInstance(e, r, o) {
                            this._config.setState(o);
                            return new class {
                              constructor(e, r, o) {
                                this.sheet = e;
                                this.template = r;
                                this.nativeObject = o;
                                l(this, "$$isIdentityDerivationProvider", true);
                                l(this, "address");
                                l(this, "publicApi");
                                l(this, "_initialValue", new y({}));
                                l(this, "_cache", new G());
                                this.address = x(g({}, r.address), {
                                  sheetInstanceId: e.address.sheetInstanceId
                                });
                                this.publicApi = new class {
                                  constructor(e) {
                                    l(this, "_cache", new G());
                                    H(this, e);
                                  }
                                  get type() {
                                    return "Theatre_SheetObject_PublicAPI";
                                  }
                                  get props() {
                                    return m(this).propsP;
                                  }
                                  get sheet() {
                                    return m(this).sheet.publicApi;
                                  }
                                  get project() {
                                    return m(this).sheet.project.publicApi;
                                  }
                                  get address() {
                                    return g({}, m(this).address);
                                  }
                                  _valuesDerivation() {
                                    return this._cache.get("onValuesChangeDerivation", () => {
                                      let e = m(this);
                                      return d(() => v(e.getValues().getValue()));
                                    });
                                  }
                                  onValuesChange(e) {
                                    return this._valuesDerivation().tapImmediate($, e);
                                  }
                                  get value() {
                                    return this._valuesDerivation().getValue();
                                  }
                                  set initialValue(e) {
                                    m(this).setInitialValue(e);
                                  }
                                }(this);
                              }
                              get type() {
                                return "Theatre_SheetObject";
                              }
                              getValues() {
                                return this._cache.get("getValues()", () => d(() => {
                                  let p;
                                  let n = _e(v(this.template.getDefaultValues()), v(this._initialValue.pointer), d.memo("withInitialCache", () => new WeakMap(), []));
                                  let u = _e(n, v(this.template.getStaticValues()), d.memo("withStatics", () => new WeakMap(), []));
                                  {
                                    let h = d.memo("seq", () => this.getSequencedValues(), []);
                                    let b = d.memo("withSeqsCache", () => new WeakMap(), []);
                                    p = v(v(h));
                                    u = _e(u, p, b);
                                  }
                                  return ((t, e) => {
                                    let r = d.memo(t, () => new y(e), []);
                                    r.setState(e);
                                    return r;
                                  })("finalAtom", u).pointer;
                                }));
                              }
                              getValueByPointer(e) {
                                let r = v(this.getValues());
                                let {
                                  path: o
                                } = Ne(e);
                                return v(et(r, o));
                              }
                              getIdentityDerivation(e) {
                                return d(() => {
                                  let r = v(this.getValues());
                                  return v(et(r, e));
                                });
                              }
                              getSequencedValues() {
                                return d(() => {
                                  let e = d.memo("tracksToProcess", () => this.template.getArrayOfValidSequenceTracks(), []);
                                  let r = v(e);
                                  let o = new y({});
                                  d.effect("processTracks", () => {
                                    let n = [];
                                    for (let {
                                      trackId: a,
                                      pathToProp: i
                                    } of r) {
                                      let s = this._trackIdToDerivation(a);
                                      let u = () => {
                                        o.setIn(i, s.getValue());
                                      };
                                      let p = s.changesWithoutValues().tap(u);
                                      u();
                                      n.push(p);
                                    }
                                    return () => {
                                      for (let a of n) {
                                        a();
                                      }
                                    };
                                  }, r);
                                  return o.pointer;
                                });
                              }
                              _trackIdToDerivation(e) {
                                return Wt(this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[e], this.sheet.getSequence().positionDerivation);
                              }
                              get propsP() {
                                return this._cache.get("propsP", () => Z({
                                  root: this,
                                  path: []
                                }));
                              }
                              validateValue(e, r) {}
                              setInitialValue(e) {
                                this.validateValue(this.propsP, e);
                                this._initialValue.setState(e);
                              }
                            }(e, this, r);
                          }
                          overrideConfig(e) {
                            this._config.setState(e);
                          }
                          getDefaultValues() {
                            return this._cache.get("getDefaultValues()", () => d(() => function qt(t) {
                              return zt(t);
                            }(v(this._config.pointer))));
                          }
                          getStaticValues() {
                            return this._cache.get("getDerivationOfStatics", () => d(() => {
                              let e = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId];
                              return v(e.staticOverrides.byObject[this.address.objectKey]) || {};
                            }));
                          }
                          getArrayOfValidSequenceTracks() {
                            return this._cache.get("getArrayOfValidSequenceTracks", () => d(() => {
                              let e = v(this.getDefaultValues());
                              let r = this.project.pointers.historic.sheetsById[this.address.sheetId];
                              let o = v(r.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);
                              let n = [];
                              if (!o) {
                                return Bt;
                              }
                              for (let [a, i] of Object.entries(o)) {
                                let s;
                                try {
                                  s = JSON.parse(a);
                                } catch (p) {
                                  Pe.warn(`property ${JSON.stringify(a)} cannot be parsed. Skipping.`);
                                  continue;
                                }
                                if (typeof me(e, s) == "number") {
                                  n.push({
                                    pathToProp: s,
                                    trackId: i
                                  });
                                }
                              }
                              if (n.length === 0) {
                                return Bt;
                              } else {
                                return n;
                              }
                            }));
                          }
                          getMapOfValidSequenceTracks_forStudio() {
                            return new T({});
                          }
                          getDefaultsAtPointer(e) {
                            let {
                              path: r
                            } = Ne(e);
                            return function Ft(t, e) {
                              if (e.length === 0) {
                                return t;
                              } else {
                                return me(t, e);
                              }
                            }(this.getDefaultValues().getValue(), r);
                          }
                        }(this, e, r, o);
                        this._objectTemplates.setIn([e], n);
                      }
                      return n;
                    }
                  }(this, e);
                  this._sheetTemplates.setIn([e], o);
                }
                return o.getInstance(r);
              }
            }(e, r, this));
          }
          get ready() {
            return m(this).ready;
          }
          get isReady() {
            return m(this).isReady();
          }
          get address() {
            return g({}, m(this).address);
          }
          sheet(e, r = "default") {
            let o = ct(e);
            return m(this).getOrCreateSheet(o, r).publicApi;
          }
        }(t, r);
      }
    }
    var Cp = (t, e) => {
      ((t, e) => {
        if (Array.isArray(e) || e == null || e.definitionVersion !== Ae.currentProjectStateDefinitionVersion) {
          throw new w(`Error validating conf.state in Theatre.getProject(${JSON.stringify(t)}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://docs.theatrejs.com`);
        }
      })(t, e);
    };
    function Fn(t, e) {
      if (Q(t)) {
        return S(t).tapImmediate($, e);
      }
      if (C(t)) {
        return t.tapImmediate($, e);
      }
      throw new Error("Called onChange(p) where p is neither a pointer nor a derivation.");
    }
    var _t = "__TheatreJS_CoreBundle";
    (function Vp() {
      if (typeof window == "undefined") {
        return;
      }
      let t = window[_t];
      if (t !== undefined) {
        throw typeof t == "object" && t && typeof t.version == "string" ? new Error("It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of theatre in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.") : new Error(`The variable window.${_t} seems to be already set by a module other than @theatre/core.`);
      }
      let e = new class {
        constructor() {
          l(this, "_studio");
        }
        get type() {
          return "Theatre_CoreBundle";
        }
        get version() {
          return process.env.version;
        }
        getBitsForStudio(e, r) {
          if (this._studio) {
            throw new Error("@theatre/core is already attached to @theatre/studio");
          }
          this._studio = e;
          r({
            projectsP: xe.atom.pointer.projects,
            privateAPI: m,
            coreExports: yr
          });
        }
      }();
      window[_t] = e;
      let r = window.__TheatreJS_StudioBundle;
      if (r && r !== null && r.type === "Theatre_StudioBundle") {
        r.registerCoreBundle(e);
      }
    })();
    window.Theatre = {
      core: gr,
      get studio() {
        alert("Theatre.studio is only available in the core-and-studio.js bundle. You're using the core-only.min.js bundle.");
      }
    };
  })();
  Hydra.ready(() => {
    TweenManager.Transforms = ["scale", "scaleX", "scaleY", "x", "y", "z", "rotation", "rotationX", "rotationY", "rotationZ", "skewX", "skewY", "perspective"];
    TweenManager.CubicEases = [{
      name: "easeOutCubic",
      curve: "cubic-bezier(0.215, 0.610, 0.355, 1.000)"
    }, {
      name: "easeOutQuad",
      curve: "cubic-bezier(0.250, 0.460, 0.450, 0.940)"
    }, {
      name: "easeOutQuart",
      curve: "cubic-bezier(0.165, 0.840, 0.440, 1.000)"
    }, {
      name: "easeOutQuint",
      curve: "cubic-bezier(0.230, 1.000, 0.320, 1.000)"
    }, {
      name: "easeOutSine",
      curve: "cubic-bezier(0.390, 0.575, 0.565, 1.000)"
    }, {
      name: "easeOutExpo",
      curve: "cubic-bezier(0.190, 1.000, 0.220, 1.000)"
    }, {
      name: "easeOutCirc",
      curve: "cubic-bezier(0.075, 0.820, 0.165, 1.000)"
    }, {
      name: "easeOutBack",
      curve: "cubic-bezier(0.175, 0.885, 0.320, 1.275)"
    }, {
      name: "easeInCubic",
      curve: "cubic-bezier(0.550, 0.055, 0.675, 0.190)"
    }, {
      name: "easeInQuad",
      curve: "cubic-bezier(0.550, 0.085, 0.680, 0.530)"
    }, {
      name: "easeInQuart",
      curve: "cubic-bezier(0.895, 0.030, 0.685, 0.220)"
    }, {
      name: "easeInQuint",
      curve: "cubic-bezier(0.755, 0.050, 0.855, 0.060)"
    }, {
      name: "easeInSine",
      curve: "cubic-bezier(0.470, 0.000, 0.745, 0.715)"
    }, {
      name: "easeInCirc",
      curve: "cubic-bezier(0.600, 0.040, 0.980, 0.335)"
    }, {
      name: "easeInBack",
      curve: "cubic-bezier(0.600, -0.280, 0.735, 0.045)"
    }, {
      name: "easeInOutCubic",
      curve: "cubic-bezier(0.645, 0.045, 0.355, 1.000)"
    }, {
      name: "easeInOutQuad",
      curve: "cubic-bezier(0.455, 0.030, 0.515, 0.955)"
    }, {
      name: "easeInOutQuart",
      curve: "cubic-bezier(0.770, 0.000, 0.175, 1.000)"
    }, {
      name: "easeInOutQuint",
      curve: "cubic-bezier(0.860, 0.000, 0.070, 1.000)"
    }, {
      name: "easeInOutSine",
      curve: "cubic-bezier(0.445, 0.050, 0.550, 0.950)"
    }, {
      name: "easeInOutExpo",
      curve: "cubic-bezier(1.000, 0.000, 0.000, 1.000)"
    }, {
      name: "easeInOutCirc",
      curve: "cubic-bezier(0.785, 0.135, 0.150, 0.860)"
    }, {
      name: "easeInOutBack",
      curve: "cubic-bezier(0.680, -0.550, 0.265, 1.550)"
    }, {
      name: "easeInOut",
      curve: "cubic-bezier(.42,0,.58,1)"
    }, {
      name: "linear",
      curve: "linear"
    }];
    TweenManager.useCSSTrans = function (props, ease, object) {
      return !props.math && (typeof ease != "string" || !ease.includes(["Elastic", "Bounce"])) && !object.multiTween && !TweenManager._inspectEase(ease).path && !!Device.tween.transition;
    };
    TweenManager._detectTween = function (object, props, time, ease, delay, callback) {
      if (TweenManager.useCSSTrans(props, ease, object)) {
        return new CSSTransition(object, props, time, ease, delay, callback);
      } else {
        return new FrameTween(object, props, time, ease, delay, callback);
      }
    };
    TweenManager._parseTransform = function (props) {
      var unitRequiresCSSTween = ["%", "vw", "vh", "em"];
      var transforms = "";
      var translate = "";
      if (props.perspective > 0) {
        transforms += "perspective(" + props.perspective + "px)";
      }
      if (props.x !== undefined || props.y !== undefined || props.z !== undefined) {
        var x = props.x || 0;
        var y = props.y || 0;
        var z = props.z || 0;
        translate += x + (typeof props.x == "string" && props.x.includes(unitRequiresCSSTween) ? "" : "px") + ", ";
        translate += y + (typeof props.y == "string" && props.y.includes(unitRequiresCSSTween) ? "" : "px");
        if (Device.tween.css3d) {
          transforms += "translate3d(" + (translate += ", " + z + "px") + ")";
        } else {
          transforms += "translate(" + translate + ")";
        }
      }
      if (props.scale !== undefined) {
        transforms += "scale(" + props.scale + ")";
      } else {
        if (props.scaleX !== undefined) {
          transforms += "scaleX(" + props.scaleX + ")";
        }
        if (props.scaleY !== undefined) {
          transforms += "scaleY(" + props.scaleY + ")";
        }
      }
      if (props.rotation !== undefined) {
        transforms += "rotate(" + props.rotation + "deg)";
      }
      if (props.rotationX !== undefined) {
        transforms += "rotateX(" + props.rotationX + "deg)";
      }
      if (props.rotationY !== undefined) {
        transforms += "rotateY(" + props.rotationY + "deg)";
      }
      if (props.rotationZ !== undefined) {
        transforms += "rotateZ(" + props.rotationZ + "deg)";
      }
      if (props.skewX !== undefined) {
        transforms += "skewX(" + props.skewX + "deg)";
      }
      if (props.skewY !== undefined) {
        transforms += "skewY(" + props.skewY + "deg)";
      }
      return transforms;
    };
    TweenManager._clearCSSTween = function (obj) {
      if (obj && !obj._cssTween && obj.div._transition && !obj.persistTween) {
        obj.div.style[HydraCSS.styles.vendorTransition] = "";
        obj.div._transition = false;
        obj._cssTween = null;
      }
    };
    TweenManager._isTransform = function (key) {
      return TweenManager.Transforms.indexOf(key) > -1;
    };
    TweenManager._getAllTransforms = function (object) {
      var obj = {};
      for (var i = TweenManager.Transforms.length - 1; i > -1; i--) {
        var tf = TweenManager.Transforms[i];
        var val = object[tf];
        if (val !== 0 && (typeof val == "number" || typeof val == "string")) {
          obj[tf] = val;
        }
      }
      return obj;
    };
    const prefix = function () {
      let pre = "";
      let dom = "";
      try {
        var styles = window.getComputedStyle(document.documentElement, "");
        pre = (Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/) || styles.OLink === "" && ["", "o"])[1];
        dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1];
        return {
          unprefixed: Device.system.browser == "ie" && !Device.detect("msie 9"),
          dom: dom,
          lowercase: pre,
          css: "-" + pre + "-",
          js: (Device.system.browser == "ie" ? pre[0] : pre[0].toUpperCase()) + pre.substr(1)
        };
      } catch (e) {
        return {
          unprefixed: true,
          dom: "",
          lowercase: "",
          css: "",
          js: ""
        };
      }
    }();
    HydraCSS.styles = {};
    HydraCSS.styles.vendor = prefix.unprefixed ? "" : prefix.js;
    HydraCSS.styles.vendorTransition = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + "Transition" : "transition";
    HydraCSS.styles.vendorTransform = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + "Transform" : "transform";
    HydraCSS.vendor = prefix.css;
    HydraCSS.transformProperty = function () {
      switch (prefix.lowercase) {
        case "moz":
          return "-moz-transform";
        case "webkit":
          return "-webkit-transform";
        case "o":
          return "-o-transform";
        case "ms":
          return "-ms-transform";
        default:
          return "transform";
      }
    }();
    HydraCSS.tween = {};
    HydraCSS.tween.complete = prefix.unprefixed ? "transitionend" : prefix.lowercase + "TransitionEnd";
  });
  Class(function CSSTransition(_object, _props, _time, _ease, _delay, _callback) {
    const _this = this;
    let _transformProps;
    let _transitionProps;
    function killed() {
      return !_this || _this.kill || !_object || !_object.div;
    }
    function clearCSSTween() {
      if (!killed()) {
        _this.playing = false;
        _object._cssTween = null;
        _object.willChange(null);
        _object = _props = null;
        Utils.nullObject(this);
      }
    }
    this.playing = true;
    (function () {
      if (typeof _time != "number") {
        throw "CSSTween Requires object, props, time, ease";
      }
      (function initProperties() {
        var transform = TweenManager._getAllTransforms(_object);
        var properties = [];
        for (var key in _props) {
          if (TweenManager._isTransform(key)) {
            transform.use = true;
            transform[key] = _props[key];
            delete _props[key];
          } else if (typeof _props[key] == "number" || key.includes(["-", "color"])) {
            properties.push(key);
          }
        }
        if (transform.use) {
          properties.push(HydraCSS.transformProperty);
          delete transform.use;
        }
        _transformProps = transform;
        _transitionProps = properties;
      })();
      (async function initCSSTween(values) {
        if (killed()) {
          return;
        }
        if (_object._cssTween) {
          _object._cssTween.kill = true;
        }
        _object._cssTween = _this;
        _object.div._transition = true;
        var strings = function buildStrings(time, ease, delay) {
          var props = "";
          var str = "";
          for (var len = _transitionProps.length, i = 0; i < len; i++) {
            var transitionProp = _transitionProps[i];
            props += (props.length ? ", " : "") + transitionProp;
            str += (str.length ? ", " : "") + transitionProp + " " + time + "ms " + TweenManager._getEase(ease) + " " + delay + "ms";
          }
          return {
            props: props,
            transition: str
          };
        }(_time, _ease, _delay);
        _object.willChange(strings.props);
        var time = values ? values.time : _time;
        var delay = values ? values.delay : _delay;
        var props = values ? values.props : _props;
        var transformProps = values ? values.transform : _transformProps;
        var singleFrame = 1000 / Render.REFRESH_RATE;
        _this.time = _time;
        _this.delay = _delay;
        await Timer.delayedCall(singleFrame * 3);
        if (killed()) {
          return;
        }
        _object.div.style[HydraCSS.styles.vendorTransition] = strings.transition;
        _this.playing = true;
        if (Device.system.browser == "safari") {
          if (Device.system.browserVersion < 11) {
            await Timer.delayedCall(singleFrame);
          }
          if (killed()) {
            return;
          }
          _object.css(props);
          _object.transform(transformProps);
        } else {
          _object.css(props);
          _object.transform(transformProps);
        }
        Timer.create(function () {
          if (!killed()) {
            clearCSSTween();
            if (_callback) {
              _callback();
            }
            if (_this.completePromise) {
              _this.completePromise.resolve();
            }
          }
        }, time + delay);
      })();
    })();
    this.stop = function () {
      if (this.playing) {
        this.kill = true;
        this.playing = false;
        _object.div.style[HydraCSS.styles.vendorTransition] = "";
        _object.div._transition = false;
        _object.willChange(null);
        _object._cssTween = null;
        Utils.nullObject(this);
      }
    };
    this.onComplete = function (callback) {
      _callback = callback;
      return this;
    };
    this.promise = function () {
      _this.completePromise = Promise.create();
      return _this.completePromise;
    };
  });
  Class(function FrameTween(_object, _props, _time, _ease, _delay, _callback, _manual) {
    var _endValues;
    var _transformEnd;
    var _transformStart;
    var _startValues;
    var _isTransform;
    var _isCSS;
    var _transformProps;
    var _cssTween;
    var _transformTween;
    var _this = this;
    function copy(obj) {
      let newObj = {};
      for (let key in obj) {
        if (typeof obj[key] == "number") {
          newObj[key] = obj[key];
        }
      }
      return newObj;
    }
    function clear() {
      if (_object._cssTweens) {
        _object._cssTweens.remove(_this);
      }
      _this.playing = false;
      _object._cssTween = null;
      _object = _props = null;
    }
    function update() {
      if (!function killed() {
        return _this.kill || !_object || !_object.div || !_object.css;
      }()) {
        if (_isCSS) {
          _object.css(_props);
        }
        if (_isTransform) {
          if (_object.multiTween) {
            for (var key in _transformProps) {
              if (typeof _transformProps[key] == "number") {
                _object[key] = _transformProps[key];
              }
            }
            _object.transform();
          } else {
            _object.transform(_transformProps);
          }
        }
        undefined;
      }
    }
    function tweenComplete() {
      if (_this.playing) {
        clear();
        if (_callback) {
          _callback();
        }
        if (_this.completePromise) {
          _this.completePromise.resolve();
        }
      }
    }
    this.playing = true;
    _this.object = _object;
    _this.props = _props;
    _this.time = _time;
    _this.ease = _ease;
    _this.delay = _delay;
    defer(function () {
      if (_this.overrideValues) {
        let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
        if (values) {
          _this.props = _props = values.props || _props;
          _this.time = _time = values.time || _time;
          _this.ease = _ease = values.ease || _ease;
          _this.delay = _delay = values.delay || _delay;
        }
      }
      if (typeof _ease == "object") {
        _ease = "easeOutCubic";
      }
      if (_object && _props) {
        _this.object = _object;
        if (typeof _time != "number") {
          throw "FrameTween Requires object, props, time, ease";
        }
        (function initValues() {
          if (_props.math) {
            delete _props.math;
          }
          if (Device.tween.transition && _object.div && _object.div._transition) {
            _object.div.style[HydraCSS.styles.vendorTransition] = "";
            _object.div._transition = false;
          }
          _this.time = _time;
          _this.delay = _delay;
          _endValues = {};
          _transformEnd = {};
          _transformStart = {};
          _startValues = {};
          if (!_object.multiTween) {
            if (_props.x === undefined) {
              _props.x = _object.x;
            }
            if (_props.y === undefined) {
              _props.y = _object.y;
            }
            if (_props.z === undefined) {
              _props.z = _object.z;
            }
          }
          for (var key in _props) {
            if (key.includes(["damping", "spring"])) {
              _endValues[key] = _props[key];
              _transformEnd[key] = _props[key];
            } else if (TweenManager._isTransform(key)) {
              _isTransform = true;
              _transformStart[key] = _object[key] || (key == "scale" ? 1 : 0);
              _transformEnd[key] = _props[key];
            } else {
              _isCSS = true;
              var v = _props[key];
              if (typeof v == "string") {
                _object.div.style[key] = v;
              } else if (typeof v == "number") {
                _startValues[key] = _object.css ? Number(_object.css(key)) : 0;
                _endValues[key] = v;
              }
            }
          }
        })();
        (function startTween() {
          if (!!_object._cssTween && !_manual && !_object.multiTween) {
            _object._cssTween.kill = true;
          }
          _this.time = _time;
          _this.delay = _delay;
          if (_object.multiTween) {
            _object._cssTweens ||= [];
            _object._cssTweens.push(_this);
          }
          _object._cssTween = _this;
          _this.playing = true;
          _props = copy(_startValues);
          _transformProps = copy(_transformStart);
          if (_isCSS) {
            _cssTween = tween(_props, _endValues, _time, _ease, _delay, null, _manual).onUpdate(update).onComplete(tweenComplete);
          }
          if (_isTransform) {
            _transformTween = tween(_transformProps, _transformEnd, _time, _ease, _delay, null, _manual).onComplete(_isCSS ? null : tweenComplete).onUpdate(_isCSS ? null : update);
          }
        })();
      }
    });
    this.stop = function () {
      if (this.playing) {
        if (_cssTween && _cssTween.stop) {
          _cssTween.stop();
        }
        if (_transformTween && _transformTween.stop) {
          _transformTween.stop();
        }
        clear();
      }
    };
    this.interpolate = function (elapsed) {
      if (_cssTween) {
        _cssTween.interpolate(elapsed);
      }
      if (_transformTween) {
        _transformTween.interpolate(elapsed);
      }
      update();
    };
    this.getValues = function () {
      return {
        start: _startValues,
        transformStart: _transformStart,
        end: _endValues,
        transformEnd: _transformEnd
      };
    };
    this.setEase = function (ease) {
      if (_cssTween) {
        _cssTween.setEase(ease);
      }
      if (_transformTween) {
        _transformTween.setEase(ease);
      }
    };
    this.onUpdate = function () {
      return this;
    };
    this.onComplete = function (callback) {
      _callback = callback;
      return this;
    };
    this.promise = function () {
      _this.completePromise ||= Promise.create();
      return _this.completePromise;
    };
  });
  class DOMAttribute {
    constructor({
      name: name,
      value: value,
      belongsTo: belongsTo,
      bindingLookup: bindingLookup
    }) {
      this.name = name;
      this.value = value;
      this.belongsTo = belongsTo;
      this.bindingLookup = bindingLookup;
    }
  }
  class TemplateRoot {
    constructor(string, values) {
      this.string = string;
      this.values = values;
    }
    consolidate() {
      let template = this.string;
      const consolidatedValues = {};
      for (const [marker, value] of Object.entries(this.values)) {
        if (value instanceof TemplateHTML) {
          const [innerTemplate, innerValues] = value.consolidate();
          template = template.replace(marker, innerTemplate);
          Object.assign(consolidatedValues, innerValues);
        } else if (Array.isArray(value)) {
          let childTemplate = "";
          for (let k = 0; k < value.length; k++) {
            const [innerString, innerValue] = value[k].consolidate();
            childTemplate += innerString;
            Object.assign(consolidatedValues, innerValue);
          }
          template = template.replace(marker, childTemplate);
        } else {
          consolidatedValues[marker] = value;
        }
      }
      return [template, consolidatedValues];
    }
    modifyMarkers(template, config, dataMarkers, bindings) {
      let count = 0;
      return template.replace(/@([a-z]+)="\{\{(hydra-[0-9]+)\}\}"/g, function (_, event, marker) {
        const dataMarker = "data-attach-event-" + count++;
        dataMarkers.push(dataMarker);
        return `${dataMarker}="${event}|${marker}"`;
      }).replace(/\{\{hydra-[0-9]+\}\}/g, function (marker) {
        if (config[marker] && config[marker].state) {
          bindings.push({
            lookup: marker.trim()
          });
          return marker;
        }
        if (config[marker]["@style"]) {
          const styles = config[marker]["@style"];
          if (!styles || typeof styles != "object") {
            console.error("@style must contain an object");
            return;
          }
          let styleString = "";
          Object.keys(styles).forEach(prop => {
            const kebabProp = prop.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
            styleString += `${kebabProp}: ${styles[prop]};\n`;
          });
          return styleString;
        }
        return config[marker];
      });
    }
  }
  class TemplateHTML extends TemplateRoot {
    constructor(string, values) {
      super(string, values);
    }
    inflate(root, cssElement) {
      let [template, config] = this.consolidate();
      let dataMarkers = [];
      let nestedComponents = [];
      let bindings = new LinkedList();
      let scrollTop = root.firstChild?.scrollTop;
      const t = this.modifyMarkers(template, config, dataMarkers, bindings);
      while (root.firstChild) {
        root.removeChild(root.firstChild);
      }
      if (root.flatBindings) {
        root.flatBindings.forEach(b => b.destroy());
      }
      root.flatBindings = [];
      let fragment = document.createDocumentFragment();
      let newNode = DOMTemplate.parser.parseFromString(t, "text/html");
      let els = newNode.body.firstChild.querySelectorAll("*");
      let length = els.length;
      fragment.appendChild(newNode.body.firstChild);
      if (cssElement) {
        fragment.appendChild(cssElement);
      }
      for (let index = length - 1; index > -1; index--) {
        let el = els[index];
        if (~el.tagName.indexOf("-")) {
          nestedComponents.push(el);
        }
        let innerText = el.innerText;
        let innerHTML = el.innerHTML;
        let attributes = [...el.attributes].map(a => ({
          name: a.name,
          value: a.value
        }));
        if (~innerHTML.indexOf("<")) {
          continue;
        }
        let binding = bindings.start();
        while (binding) {
          let bindingLookup = binding.lookup;
          attributes.forEach(attr => {
            if (~attr?.value?.indexOf(bindingLookup)) {
              let obj = config[bindingLookup];
              const attrObject = new DOMAttribute({
                name: attr.name,
                value: el.getAttribute(attr.name),
                belongsTo: el,
                bindingLookup: bindingLookup
              });
              root.flatBindings.push(obj.state.bind(obj.key, attrObject));
            }
          });
          if (~innerText.indexOf(bindingLookup)) {
            let obj = config[bindingLookup];
            if (~innerText.indexOf("@[")) {
              el.innerText = innerText.replace(bindingLookup, obj.key);
            }
            root.flatBindings.push(obj.state.bind(obj.key, el));
          }
          binding = bindings.next();
        }
      }
      root.appendChild(fragment);
      dataMarkers.forEach(dataMarker => {
        const element = root.querySelector(`[${dataMarker}]`);
        const dataEvent = element.getAttribute(dataMarker);
        const [event, marker] = dataEvent.split("|");
        element.removeAttribute(dataMarker);
        element.addEventListener(`${event}`, config[`{{${marker}}}`]);
      });
      defer(() => {
        nestedComponents.forEach(template => {
          const className = template.tagName.toLowerCase().replace(/(^\w|-\w)/g, str => str.replace(/-/, "").toUpperCase());
          $(`#${template.id}`, className, true).add(new window[className]());
        });
      });
      if (scrollTop) {
        root.firstChild.scrollTop = scrollTop;
      }
    }
  }
  class TemplateCSS extends TemplateRoot {
    constructor(string, values) {
      super(string, values);
    }
    inflate(root) {
      let [template, config] = this.consolidate();
      let bindings = new LinkedList();
      let element = document.createElement("style");
      element.innerHTML = this.modifyMarkers(template, config, [], bindings);
      return element;
    }
  }
  function styleMap(object) {
    return Object.keys(object).map(key => object[key] ? key : "").join(" ");
  }
  (function () {
    let markerID = 0;
    function makeMarker() {
      return `{{hydra-${markerID++}}}`;
    }
    function html(strings, ...values) {
      const config = {};
      let string = "";
      for (let i = 0; i < strings.length - 1; i++) {
        const marker = makeMarker();
        string += strings[i];
        string += marker;
        config[marker] = values[i];
      }
      string += strings[strings.length - 1];
      return new TemplateHTML(string, config);
    }
    function css(strings, ...values) {
      const config = {};
      let string = "";
      for (let i = 0; i < strings.length - 1; i++) {
        const marker = makeMarker();
        string += strings[i];
        string += marker;
        config[marker] = values[i];
      }
      string += strings[strings.length - 1];
      return new TemplateCSS(string, config);
    }
    Class(function DOMTemplate() {
      Inherit(this, Element);
      const _this = this;
      this.data = [];
      if (Hydra.LOCAL && window.UILSocket) {
        let name = Utils.getConstructorName(_this);
        _this.events.sub(UILSocket.JS_FILE, e => {
          if (e.file.includes(name)) {
            DOMTemplate.updateGlobalStyles();
            _this.update();
          }
        });
      }
      function update() {
        let cssContent;
        if (_this.dynamicStyle) {
          cssContent = _this.dynamicStyle(css).inflate(_this.element.div);
        }
        _this.render?.(html).inflate?.(_this.element.div, cssContent);
        _this.postRender?.();
      }
      this.update = function () {
        DOMTemplate.clearScheduled(update);
        DOMTemplate.schedule(update);
      };
      this.render = function (html) {
        throw new Error("render() needs to be overwritten.");
      };
      this.setSourceData = function (data) {
        _this.data = data;
        this.update();
        _this.events.sub(data, Events.UPDATE, this.update);
      };
      _this.update();
    }, _ => {
      DOMTemplate.parser = new DOMParser();
      const queue = [];
      const worker = new Render.Worker(_ => {
        let callback = queue.shift();
        if (callback) {
          callback();
        } else {
          worker.pause();
        }
      }, 2);
      var _css;
      worker.pause();
      DOMTemplate.schedule = function (callback) {
        queue.push(callback);
        worker.resume();
      };
      DOMTemplate.clearScheduled = function (callback) {
        for (let i = 0; i < queue.length; i++) {
          if (queue[i] == callback) {
            return queue.splice(i, 1);
          }
        }
      };
      DOMTemplate.updateGlobalStyles = function () {
        Utils.debounce(async _ => {
          let css = await get(Assets.getPath("assets/css/style-scss.css"));
          _css ||= $(document.head).create("DOMTemplate-hotload", "style");
          _css.div.innerHTML = css;
        }, 20);
      };
    });
  })();
  Class(function Interaction(_object) {
    Inherit(this, Events);
    const _this = this;
    var _touchId;
    var _velocity = [];
    var _moved = 0;
    var _time = performance.now();
    function Vec2() {
      this.x = 0;
      this.y = 0;
      this.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };
    }
    var _vec2Pool = new ObjectPool(Vec2, 10);
    let _distance;
    let _timeDown;
    let _timeMove;
    function loop() {
      if (_moved++ > 10) {
        _this.velocity.x = _this.velocity.y = 0;
        _this.delta.x = _this.delta.y = 0;
      }
    }
    function down(e) {
      if (_this.isTouching && !_this.multiTouch || e.target.className == "hit" && e.target.hydraObject != _object || Interaction.hitIsBound(e.target, _object)) {
        return;
      }
      _this.isTouching = true;
      let x = e.x;
      let y = e.y;
      if (e.changedTouches) {
        x = e.changedTouches[0].clientX;
        y = e.changedTouches[0].clientY;
        _touchId = e.changedTouches[0].identifier;
      }
      if (e.touches && typeof e.touches[0].force == "number") {
        e.force = e.touches[0].force;
      }
      e.x = _this.x = x;
      e.y = _this.y = y;
      _this.hold.x = _this.last.x = x;
      _this.hold.y = _this.last.y = y;
      _this.delta.x = _this.move.x = _this.velocity.x = 0;
      _this.delta.y = _this.move.y = _this.velocity.y = 0;
      _distance = 0;
      _this.events.fire(Interaction.START, e, true);
      _timeDown = _timeMove = Render.TIME;
    }
    function move(e) {
      if (!_this.isTouching && !_this.unlocked) {
        return;
      }
      let now = performance.now();
      if (now - _time < 16) {
        return;
      }
      _time = now;
      let x = e.x;
      let y = e.y;
      if (e.touches) {
        for (let i = 0; i < e.touches.length; i++) {
          let touch = e.touches[i];
          if (touch.identifier == _touchId) {
            x = touch.clientX;
            y = touch.clientY;
          }
        }
      }
      if (_this.isTouching) {
        _this.move.x = x - _this.hold.x;
        _this.move.y = y - _this.hold.y;
      }
      if (e.touches && typeof e.touches[0].force == "number") {
        e.force = e.touches[0].force;
      }
      e.x = _this.x = x;
      e.y = _this.y = y;
      _this.delta.x = x - _this.last.x;
      _this.delta.y = y - _this.last.y;
      _this.last.x = x;
      _this.last.y = y;
      _moved = 0;
      _distance += _this.delta.length();
      let delta = Render.TIME - (_timeMove || Render.TIME);
      _timeMove = Render.TIME;
      if (delta > 0.01) {
        let velocity = _vec2Pool.get();
        velocity.x = Math.abs(_this.delta.x) / delta;
        velocity.y = Math.abs(_this.delta.y) / delta;
        _velocity.push(velocity);
        if (_velocity.length > 5) {
          _vec2Pool.put(_velocity.shift());
        }
      }
      _this.velocity.x = _this.velocity.y = 0;
      for (let i = 0; i < _velocity.length; i++) {
        _this.velocity.x += _velocity[i].x;
        _this.velocity.y += _velocity[i].y;
      }
      _this.velocity.x /= _velocity.length;
      _this.velocity.y /= _velocity.length;
      _this.velocity.x = _this.velocity.x || 0;
      _this.velocity.y = _this.velocity.y || 0;
      _this.events.fire(Interaction.MOVE, e, true);
      if (_this.isTouching) {
        _this.events.fire(Interaction.DRAG, e, true);
      }
    }
    function up(e) {
      if (e && e.changedTouches) {
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier != _touchId) {
            return;
          }
        }
      }
      if (!_this.isTouching && !_this.unlocked) {
        return;
      }
      _this.isTouching = false;
      _this.move.x = 0;
      _this.move.y = 0;
      if (Math.max(0.001, Render.TIME - (_timeMove || Render.TIME)) > 100) {
        _this.delta.x = 0;
        _this.delta.y = 0;
      }
      if (_distance < 20 && Render.TIME - _timeDown < 1000 && !e.isLeaveEvent) {
        _this.events.fire(Interaction.CLICK, e, true);
      }
      _this.events.fire(Interaction.END, e, true);
      if (Device.mobile) {
        _this.velocity.x = _this.velocity.y = 0;
      }
    }
    function leave() {
      if (!_this.ignoreLeave) {
        _this.delta.x = 0;
        _this.delta.y = 0;
        up({
          isLeaveEvent: true
        });
      }
    }
    this.x = 0;
    this.y = 0;
    this.hold = new Vec2();
    this.last = new Vec2();
    this.delta = new Vec2();
    this.move = new Vec2();
    this.velocity = new Vec2();
    (function () {
      if (!_object instanceof HydraObject) {
        throw "Interaction.Input requires a HydraObject";
      }
      (function addHandlers() {
        if (_object == Stage || _object == __window) {
          Interaction.bind("touchstart", down);
        } else {
          _object.bind("touchstart", down);
          Interaction.bindObject(_object);
        }
        Interaction.bind("touchmove", move);
        Interaction.bind("touchend", up);
        Interaction.bind("leave", leave);
      })();
      Render.start(loop);
    })();
    this.onDestroy = function () {
      Interaction.unbind("touchstart", down);
      Interaction.unbind("touchmove", move);
      Interaction.unbind("touchend", up);
      Render.stop(loop);
      Interaction.unbindObject(_object);
      if (_object && _object.unbind) {
        _object.unbind("touchstart", down);
      }
    };
  }, () => {
    Namespace(Interaction);
    Interaction.CLICK = "interaction_click";
    Interaction.START = "interaction_start";
    Interaction.MOVE = "interaction_move";
    Interaction.DRAG = "interaction_drag";
    Interaction.END = "interaction_end";
    const _objects = [];
    const _events = {
      touchstart: [],
      touchmove: [],
      touchend: [],
      leave: []
    };
    function touchMove(e) {
      _events.touchmove.forEach(c => c(e));
    }
    function touchStart(e) {
      _events.touchstart.forEach(c => c(e));
    }
    function touchEnd(e) {
      _events.touchend.forEach(c => c(e));
    }
    function leave(e) {
      e.leave = true;
      _events.leave.forEach(c => c(e));
    }
    Hydra.ready(async () => {
      await defer();
      __window.bind("touchstart", touchStart);
      __window.bind("touchmove", touchMove);
      __window.bind("touchend", touchEnd);
      __window.bind("touchcancel", touchEnd);
      __window.bind("contextmenu", touchEnd);
      __window.bind("mouseleave", leave);
      __window.bind("mouseout", leave);
    });
    Interaction.bind = function (evt, callback) {
      _events[evt].push(callback);
    };
    Interaction.unbind = function (evt, callback) {
      _events[evt].remove(callback);
    };
    Interaction.bindObject = function (obj) {
      _objects.push(obj);
    };
    Interaction.unbindObject = function (obj) {
      _objects.remove(obj);
    };
    Interaction.hitIsBound = function (element, boundObj) {
      let obj = element.hydraObject;
      if (!obj) {
        return false;
      }
      while (obj) {
        if (obj != boundObj && _objects.includes(obj)) {
          return true;
        }
        obj = obj._parent;
      }
      return false;
    };
  });
  Class(function Mouse() {
    Inherit(this, Events);
    const _this = this;
    this.x = 0;
    this.y = 0;
    this.normal = {
      x: 0,
      y: 0
    };
    this.tilt = {
      x: 0,
      y: 0
    };
    this.inverseNormal = {
      x: 0,
      y: 0
    };
    this.resetOnRelease = false;
    const _offset = {
      x: 0,
      y: 0
    };
    function init() {
      defer(_ => {
        if (_this.resetOnRelease && Device.mobile) {
          _this.x = Stage.width / 2;
          _this.y = Stage.height / 2;
        }
      });
      _this.input = new Interaction(__window);
      _this.input.unlocked = true;
      _this.events.sub(_this.input, Interaction.START, start);
      _this.events.sub(_this.input, Interaction.MOVE, update);
      _this.events.sub(_this.input, Interaction.END, end);
      _this.hold = _this.input.hold;
      _this.last = _this.input.last;
      _this.delta = _this.input.delta;
      _this.move = _this.input.move;
      _this.velocity = _this.input.velocity;
      defer(() => {
        _this.events.sub(Events.RESIZE, resize);
        resize();
      });
    }
    function start(e) {
      _this.down = true;
      update(e);
    }
    function update(e) {
      _this.x = e.x;
      _this.y = e.y;
      if (Stage.width && Stage.height) {
        _this.normal.x = e.x / Stage.width - _offset.x;
        _this.normal.y = e.y / Stage.height - _offset.y;
        _this.tilt.x = _this.normal.x * 2 - 1;
        _this.tilt.y = 1 - _this.normal.y * 2;
        _this.inverseNormal.x = _this.normal.x;
        _this.inverseNormal.y = 1 - _this.normal.y;
      }
    }
    function end(e) {
      _this.down = false;
      if (Device.mobile && _this.resetOnRelease) {
        update({
          x: Stage.width / 2,
          y: Stage.height / 2
        });
      }
    }
    function resize() {
      if (Stage.css("top")) {
        _offset.y = Stage.css("top") / Stage.height;
      }
      if (Stage.css("left")) {
        _offset.x = Stage.css("left") / Stage.width;
      }
    }
    Hydra.ready(init);
  }, "Static");
  Class(function Keyboard() {
    Inherit(this, Component);
    var _this = this;
    function addListeners() {
      __window.keydown(keydown);
      __window.keyup(keyup);
      __window.keypress(keypress);
    }
    function keydown(e) {
      if (!_this.pressing.includes(e.key)) {
        _this.pressing.push(e.key);
      }
      _this.events.fire(_this.DOWN, e);
    }
    function keyup(e) {
      _this.pressing.remove(e.key);
      _this.events.fire(_this.UP, e);
    }
    function keypress(e) {
      _this.events.fire(_this.PRESS, e);
    }
    this.pressing = [];
    _this.DOWN = "keyboard_down";
    _this.PRESS = "keyboard_press";
    _this.UP = "keyboard_up";
    Hydra.ready(addListeners);
  }, "static");
  Class(function Mobile() {
    Inherit(this, Component);
    Namespace(this);
    const _this = this;
    var $html;
    var $featureDetects;
    var _is100vh = false;
    function preventNativeScroll(e) {
      if (_this.isAllowNativeScroll) {
        return;
      }
      let target = e.target;
      if (target.nodeName == "LABEL" || target.nodeName == "INPUT" || target.nodeName == "TEXTAREA" || target.nodeName == "SELECT" || target.nodeName == "A") {
        return;
      }
      let prevent = target.hydraObject;
      while (target.parentNode && prevent) {
        if (target._scrollParent) {
          prevent = false;
        }
        target = target.parentNode;
      }
      if (prevent) {
        e.preventDefault();
      }
    }
    function resize() {
      updateOrientation();
      checkResizeRefresh();
      updateMobileFullscreen();
      if (!_this.isAllowNativeScroll) {
        document.body.scrollTop = 0;
      }
    }
    function updateOrientation() {
      _this.orientation = Stage.width > Stage.height ? "landscape" : "portrait";
      if (_this.orientationSet && (window.Fullscreen.isOpen || Device.mobile.pwa) && window.screen && window.screen.orientation) {
        window.screen.orientation.lock(_this.orientationSet);
      }
    }
    Hydra.ready(() => {
      if (Device.mobile) {
        (function initFeatureDetects() {
          $featureDetects = __body.create("feature-detects");
        })();
        (function addHandlers() {
          _this.events.sub(Events.RESIZE, resize);
          if (!Device.mobile.native) {
            window.addEventListener("touchstart", preventNativeScroll, {
              passive: false
            });
          }
        })();
        if (Device.mobile?.phone && !Device.mobile.native) {
          $html = $(document.documentElement);
          let ios = Device.system.browser === "safari";
          if (ios) {
            $html.div.classList.add("ios");
          } else {
            $html.div.classList.add("mob");
          }
          _is100vh = true;
          if (ios) {
            __body.css({
              height: "100%"
            }).div.scrollTop = 0;
          }
          updateMobileFullscreen();
        }
        if (Device.mobile.native) {
          Stage.css({
            width: "100vw",
            height: "100vh"
          });
        }
      }
    });
    const checkResizeRefresh = function () {
      let _lastWidth;
      return function () {
        if (!_this.isPreventResizeReload) {
          if (_lastWidth != Stage.width) {
            _lastWidth = Stage.width;
            if (Device.system.os === "ios" || Device.system.os == "android" && Device.system.version >= 7) {
              if (!!Device.mobile.tablet && !(Math.max(Stage.width, Stage.height) > 800)) {
                window.location.reload();
              }
            }
          }
        }
      };
    }();
    function updateMobileFullscreen() {
      if ($html) {
        let vh100 = $featureDetects.div.offsetHeight;
        if ($html.div.offsetHeight !== Stage.height) {
          if (Stage.height === vh100) {
            $html.css({
              height: ""
            });
            _is100vh = true;
          } else {
            $html.css({
              height: Stage.height
            });
            _is100vh = false;
          }
        } else if (!_is100vh && Stage.height === vh100) {
          $html.css({
            height: ""
          });
          _is100vh = true;
        }
      }
    }
    this.vibrate = function (duration) {
      if (navigator.vibrate) {
        navigator.vibrate(duration);
      }
    };
    this.fullscreen = function () {
      if (Device.mobile && !Device.mobile.native && !Device.mobile.pwa && !Dev.emulator) {
        if (!window.Fullscreen) {
          throw "Mobile.fullscreen requires Fullscreen module";
        }
        if (Device.system.os === "android" && !Device.detect("oculus")) {
          __window.bind("touchend", () => {
            Fullscreen.open();
          });
          if (_this.ScreenLock && _this.ScreenLock.isActive) {
            window.onresize();
          }
        }
      }
    };
    this.setOrientation = function (orientation, isForce) {
      if (_this.System && _this.NativeCore.active) {
        return _this.System.orientation = _this.System[orientation.toUpperCase()];
      }
      _this.orientationSet = orientation;
      updateOrientation();
      if (isForce) {
        if (!_this.ScreenLock) {
          throw "Mobile.setOrientation isForce argument requires ScreenLock module";
        }
        if (orientation === "any") {
          _this.ScreenLock.unlock();
        } else {
          _this.ScreenLock.lock();
        }
      }
    };
    this.isKeyboardOpen = function () {
      return Device.mobile && document.activeElement.tagName.toLowerCase().includes(["textarea", "input"]);
    };
    this.allowNativeScroll = function () {
      _this.isAllowNativeScroll = true;
      [$(document.documentElement), __body, Stage].forEach($el => $el.css({
        touchAction: "unset",
        MSContentZooming: "unset",
        MSTouchAction: "unset"
      }));
    };
    this.preventResizeReload = function () {
      _this.isPreventResizeReload = true;
    };
    this._addOverflowScroll = function ($obj) {
      $obj.div._scrollParent = true;
      if (!Device.mobile.native) {
        $obj.div._preventEvent = function (e) {
          e.stopPropagation();
        };
        $obj.bind("touchmove", $obj.div._preventEvent);
      }
    };
    this._removeOverflowScroll = function ($obj) {
      $obj.unbind("touchmove", $obj.div._preventEvent);
    };
    this.get("phone", () => {
      throw "Mobile.phone is removed. Use Device.mobile.phone";
    });
    this.get("tablet", () => {
      throw "Mobile.tablet is removed. Use Device.mobile.tablet";
    });
    this.get("os", () => {
      throw "Mobile.os is removed. Use Device.system.os";
    });
    (function () {
      var _props = ["--safe-area-inset-top", "--safe-area-inset-right", "--safe-area-inset-bottom", "--safe-area-inset-left"];
      function getSafeAreaInset(index) {
        if (!$featureDetects) {
          return 0;
        }
        let style = getComputedStyle($featureDetects.div);
        return parseInt(style.getPropertyValue(_props[index])) || 0;
      }
      _this.getSafeAreaInsets = () => _props.map((_, i) => getSafeAreaInset(i));
      _this.getSafeAreaInsetTop = () => getSafeAreaInset(0);
      _this.getSafeAreaInsetRight = () => getSafeAreaInset(1);
      _this.getSafeAreaInsetBottom = () => getSafeAreaInset(2);
      _this.getSafeAreaInsetLeft = () => getSafeAreaInset(3);
    })();
  }, "Static");
  Class(function PushState(_isHash) {
    const _this = this;
    let _store;
    let _useInternal;
    let _root = "";
    function getState() {
      if (_useInternal) {
        return new String(_store);
      } else if (_isHash) {
        return String(window.location.hash.slice(3));
      } else {
        return (_root !== "/" && _root !== "" ? location.pathname.split(_root)[1] : location.pathname.slice(1)) || "";
      }
    }
    function handleStateChange(state, forced) {
      if (state !== _store || forced) {
        if (!_this.isLocked || forced) {
          _store = state;
          _this.events.fire(Events.UPDATE, {
            value: state,
            split: state.split("/")
          });
        } else {
          if (!_store) {
            return;
          }
          if (_useInternal) {
            _store = _store;
          } else if (_isHash) {
            window.location.hash = "!/" + _store;
          } else {
            window.history.pushState(null, null, _root + _store);
          }
        }
      }
    }
    if (typeof _isHash != "boolean") {
      _isHash = Hydra.LOCAL || !Device.system.pushstate;
    }
    this.isLocked = false;
    (function () {
      if (!_this.flag) {
        throw "Inherit PushState/Router after main class";
      }
      _this.flag("isNotBlocked", true);
      (function addHandlers() {
        if (_isHash) {
          return window.addEventListener("hashchange", () => handleStateChange(getState()), false);
        }
        window.onpopstate = history.onpushstate = () => handleStateChange(getState());
      })();
      _store = getState();
    })();
    this.getState = this._getState = function () {
      if (Device.mobile.native) {
        return Storage.get("app_state") || "";
      } else {
        return getState();
      }
    };
    this.setRoot = function (root) {
      _root = root.charAt(0) === "/" ? root : "/" + root;
    };
    this.setState = this._setState = async function (state, forced) {
      _this.events.fire(PushState.SET_STATE);
      await _this.wait("isNotBlocked");
      if (Device.mobile.native) {
        Storage.set("app_state", state);
      }
      if (state !== _store || forced) {
        if (_useInternal) {
          _store = state;
        } else if (_isHash) {
          window.location.hash = "!/" + state;
        } else {
          window.history.pushState(null, null, _root + state);
        }
        if (_this.fireChangeWhenSet) {
          handleStateChange(getState(), forced);
        }
        _store = state;
        return true;
      }
    };
    this.enableBlocker = function () {
      _this.flag("isNotBlocked", false);
    };
    this.disableBlocker = function () {
      _this.flag("isNotBlocked", true);
    };
    this.replaceState = function (state) {
      if (state !== _store) {
        _store = state;
        if (_useInternal) {
          _store = state;
        }
        if (_isHash) {
          window.location.hash = "!/" + state;
        } else {
          window.history.replaceState(null, null, _root + state);
        }
      }
    };
    this.setTitle = function (title) {
      document.title = title;
    };
    this.lock = function () {
      this.isLocked = true;
      _this.events.fire(PushState.LOCK);
    };
    this.unlock = function () {
      this.isLocked = false;
      _this.events.fire(PushState.UNLOCK);
    };
    this.useHash = function () {
      _isHash = true;
    };
    this.useInternal = function () {
      _useInternal = true;
    };
  }, _ => {
    PushState.SET_STATE = "push_state_set_state";
    PushState.LOCK = "push_state_lock";
    PushState.UNLOCK = "push_state_unlock";
  });
  Class(function Router(_isHash, _rootPath) {
    Inherit(this, PushState, _isHash);
    const _this = this;
    var _debounce;
    var _prevView;
    var _nextView;
    var _404Route;
    var _routes = [];
    function matchRoute(path) {
      let matchedRoute = null;
      _routes.forEach(routesList => {
        const match = routesList.list.find(route => {
          if (route.root === path[0]) {
            if (route.pathSplit.length === path.length && route.pathSplit[path.length - 1] === "*") {
              return true;
            }
            if (!path[1] && !route.params) {
              return true;
            }
            if (path[1] && route.params && (!route.children || !(route.children.length > 0)) && !path[2]) {
              return true;
            }
            if (path[1] && route.children && route.children.length > 0) {
              route.children.forEach(c => {
                c.active = c.path === path[2];
              });
              return true;
            }
            if (path[1] && route.pathSplit.length === path.length) {
              let didMatchAll = true;
              route.pathSplit.forEach((pathSplitPath, index) => {
                if (pathSplitPath !== path[index]) {
                  didMatchAll = false;
                }
              });
              if (didMatchAll) {
                return true;
              }
            }
          }
          return false;
        });
        if (match) {
          matchedRoute = match;
        }
      });
      return matchedRoute;
    }
    function handleState(e) {
      let value = e?.value;
      let split = e?.split;
      if (!value) {
        value = _this.getState();
        split = value.split("/");
      }
      let route = null;
      let cb = null;
      _this.lock();
      _routes.forEach(({
        callback: callback,
        list: list
      }) => {
        if (!route) {
          route = matchRoute(split);
          cb = callback;
        }
      });
      if (route && route.redirect) {
        let redirectedRoute = matchRoute(route.redirect.split("/"));
        if (redirectedRoute) {
          if (route.updateURL) {
            _this.unlock();
            _this.setState(route.redirect);
            return;
          }
          route = redirectedRoute;
        }
      }
      route ||= _404Route;
      (async function doRoute(route, split, callback) {
        _nextView = route.view;
        let params = null;
        params = route.params ? {
          [Object.keys(route.params)[0]]: split?.[1]
        } : split?.[1];
        await callback(_prevView, _nextView, split.join("/"), params, route);
        await _nextView?.onRouteChange?.({
          params: params,
          path: split.join("/"),
          name: route.name,
          children: route.children,
          meta: route.meta
        });
        _prevView = _nextView;
        _this.currentRoute = {
          ...route,
          params: params
        };
        _this.unlock();
      })(route, split, cb);
    }
    _this.currentRoute = null;
    _this.fireChangeWhenSet = true;
    (function setRootPath(val) {
      let rootPath;
      rootPath = typeof _rootPath == "string" ? _rootPath : Hydra.LOCAL ? "" : "/";
      _this.setRoot(rootPath);
    })();
    (function initEvents() {
      _this.events.sub(_this, Events.UPDATE, handleState);
    })();
    this.registerRoutes = function (callback, list) {
      list.forEach(element => {
        const split = element.path.split("/");
        if (element.path.startsWith("/")) {
          throw new Error("router paths should not start with /");
        }
        element.root = split[0];
        element.pathSplit = split;
        if (element.path === "404") {
          _404Route = element;
        }
        split.forEach(s => {
          if (s[0] === ":") {
            element.params = {
              [`${s.substring(1)}`]: ""
            };
          }
        });
      });
      if (!_404Route) {
        throw new Error("Error: no 404 route defined.  Please define a route whos path is \"404\" ");
      }
      _routes.push({
        callback: callback,
        list: list
      });
      clearTimeout(_debounce);
      _debounce = _this.delayedCall(handleState, 1);
    };
    this.navigate = function (path) {
      if (path.startsWith("/")) {
        path = path.substring(1);
      }
      _this.setState(path);
    };
    this.replace = function (path) {
      if (path.startsWith("/")) {
        path = path.substring(1);
      }
      _this.replaceState(path);
    };
  });
  Class(function AppState(_default) {
    Inherit(this, Component);
    const _this = this;
    var _map = new Map();
    var _bindings = new Map();
    const iGLUI = !!window.GLUI;
    class StateBinding {
      constructor(_keys, _obj) {
        this._keys = _keys;
        this._obj = _obj;
        this._string = "";
        this._oldValue = "";
        this._type = "";
        this._bindingLookup = "";
        if (_obj instanceof HTMLElement) {
          if (_obj.nodeName == "INPUT") {
            this._string = _obj.value;
          } else {
            this._string = _obj.innerText;
          }
          this._type = "HTMLElement";
        } else if (_obj instanceof DOMAttribute) {
          this._string = _obj.value;
          this._name = _obj.name;
          this._belongsTo = _obj.belongsTo;
          this._bindingLookup = _obj.bindingLookup;
          this._type = "DOMAttribute";
        } else if (_obj instanceof HydraObject) {
          if (_obj._type == "input") {
            this._string = _obj.val();
          } else {
            this._string = _obj.text();
          }
          this._type = "HydraObject";
        } else if (iGLUI && _obj instanceof GLUIText) {
          this._string = _obj.getTextString();
          this._type = "GLUIText";
        } else {
          if (_obj.createLocal) {
            this._type = "appState";
          }
          if (_obj.onStateChange) {
            this._type = "class";
          }
          if (typeof _obj == "function") {
            this._type = "function";
          }
          if (Array.isArray(_obj) && _obj.every(el => typeof el == "function")) {
            this._type = "piped";
            const lastFunctionInChain = this._obj.pop();
            this._operators = this._obj;
            this._obj = lastFunctionInChain;
            this._count = 0;
          }
        }
      }
      parse(key, value) {
        if (!this._string || !this._string.includes("@[")) {
          return value;
        }
        let string = this._string;
        this._keys.forEach(key => {
          string = string.replace(`@[${key}]`, _this.get(key));
        });
        return string;
      }
      async operateOnValue(value) {
        return await this._operators.reduce(async (prev, fn) => {
          const prevResolved = await prev;
          return (await fn)(prevResolved, this._count++, this);
        }, value);
      }
      update(key, value) {
        let newValue = this.parse(key, value);
        if (newValue !== this._oldValue || value && value.push) {
          this._oldValue = newValue;
          switch (this._type) {
            case "HTMLElement":
              if (this._obj._type == "input") {
                this._obj.value = newValue;
              } else {
                this._obj.innerText = newValue;
              }
              break;
            case "DOMAttribute":
              this._obj.belongsTo.setAttribute(this._obj.name, this._obj.value.replace(this._obj.bindingLookup, newValue));
              break;
            case "HydraObject":
              if (this._obj._type == "input") {
                this._obj.val(newValue);
              } else {
                this._obj.text(newValue);
              }
              break;
            case "GLUIText":
              this._obj.setText(newValue);
              break;
            case "function":
              this._obj(value);
              break;
            case "piped":
              this.operateOnValue(value).then(val => this._obj(val), reject => null);
              break;
            case "class":
              this._obj.onStateChange(value);
              break;
            case "appState":
              this._obj.set(key, value);
          }
          return true;
        }
      }
      destroy() {
        this._keys = null;
        this._obj = null;
        this._string = null;
        this._oldValue = null;
        this._type = null;
        this._operators = null;
        this._count = null;
        this.update = () => null;
      }
    }
    this.set = function (key, value) {
      if (_this.flag("readonly")) {
        return console.warn("This AppState is locked and can not make changes");
      }
      _map.set(key, value);
      if (_this.onUpdate) {
        _this.onUpdate();
      }
      let array = _bindings.get(key);
      if (array) {
        let len = array.length;
        for (let i = 0; i < len; i++) {
          let b = array[i];
          if (b && b.update) {
            b.update(key, value);
          } else {
            array.remove(b);
          }
        }
      }
    };
    this.get = function (key) {
      return _map.get(key);
    };
    this.getMap = function () {
      return _map;
    };
    this.toJSON = function () {
      return Object.fromEntries(_map);
    };
    this.bind = function (keys, ...rest) {
      if (!rest.length) {
        return {
          state: _this,
          key: keys
        };
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      const obj = rest.length === 1 ? rest[0] : rest;
      let binding = new StateBinding(keys, obj);
      keys.forEach(key => {
        if (_bindings.has(key)) {
          _bindings.get(key).push(binding);
        } else {
          _bindings.set(key, [binding]);
        }
        let value = _map.get(key);
        if (value !== undefined) {
          binding.update(key, value);
        }
      });
      return binding;
    };
    this.createLocal = function (obj) {
      let appState = new AppState(obj);
      return new Proxy(appState, {
        set(target, property, value) {
          if (property === "origin") {
            appState[property] = value;
          } else {
            appState.set(property, value);
          }
        },
        get: (target, property) => target[property] ? target[property] : appState.get(property)
      });
    };
    this.setAll = function (obj) {
      for (let key in obj) {
        _this.set(key, obj[key]);
      }
    };
    this.lock = function () {
      _this.flag("readonly", true);
    };
    this.unlock = function () {
      _this.flag("readonly", false);
    };
    if (_default) {
      this.setAll(_default);
    }
  }, "static");
  Class(function AppStateOperators(_default) {
    Inherit(this, Component);
    this.map = fn => value => fn(value);
    this.tap = fn => value => {
      fn(value);
      return value;
    };
    this.filter = fn => (value, emittedCount) => fn(value, emittedCount) ? value : Promise.reject();
    this.skip = skipCount => this.filter((_, emittedCount) => skipCount <= emittedCount);
    this.untilDestroyed = ctx => {
      let checked = false;
      return (value, _, binding) => {
        if (!checked) {
          checked = true;
          ctx._bindOnDestroy(_ => {
            if (Hydra.LOCAL) {
              console.log("binding destroyed ");
            }
            binding.destroy?.();
          });
        }
        return value;
      };
    };
  }, "static");
  Class(function AppStore() {
    const _this = this;
    this.state = AppState.createLocal();
    const _mutations = {};
    const _actions = {};
    let _subscribers = [];
    let _actionSubscribers = [];
    function registerMutation(type, handler) {
      (_mutations[type] ||= []).push(function wrappedMutationHandler(payload) {
        handler.call(_this, _this.state, payload);
      });
    }
    function registerAction(type, handler) {
      (_actions[type] ||= []).push(function wrappedActionHandler(payload) {
        let res = handler.call(_this, {
          dispatch: _this.dispatch,
          commit: _this.commit,
          state: _this.state,
          rootState: _this.state
        }, payload);
        if (!function isPromise(val) {
          return val && typeof val.then == "function";
        }(res)) {
          res = Promise.resolve(res);
        }
        return res;
      });
    }
    function genericSubscribe(fn, subscribers, options) {
      if (subscribers.indexOf(fn) < 0) {
        if (options && options.prepend) {
          subscribers.unshift(fn);
        } else {
          subscribers.push(fn);
        }
      }
      return () => {
        const i = subscribers.indexOf(fn);
        if (i > -1) {
          subscribers.splice(i, 1);
        }
      };
    }
    this.createAppStore = function (_params) {
      (function setInitState(_params) {
        const {
          state: state
        } = _params;
        for (let key in state) {
          _this.state.set(key, state[key]);
        }
      })(_params);
      (function mapMutations(_params) {
        const {
          mutations: mutations
        } = _params;
        for (let key in mutations) {
          registerMutation(key, mutations[key]);
        }
      })(_params);
      (function mapActions(_params) {
        const {
          actions: actions
        } = _params;
        for (let key in actions) {
          registerAction(key, actions[key]);
        }
      })(_params);
    };
    this.commit = function (type, payload) {
      const mutation = {
        type: type,
        payload: payload
      };
      const entry = _mutations[type];
      if (entry) {
        entry.forEach(function commitIterator(handler) {
          handler(payload);
        });
        _subscribers.slice().forEach(sub => sub(mutation, this.state));
      } else if (Hydra.LOCAL) {
        console.error(`Error: no mutation for type ${type}`);
      }
    };
    this.dispatch = function (type, payload) {
      const action = {
        type: type,
        payload: payload
      };
      const entry = _actions[type];
      if (!entry) {
        if (Hydra.LOCAL) {
          console.error(`Error: no action for type ${type}`);
        }
      }
      try {
        _actionSubscribers.slice().filter(sub => sub.before).forEach(sub => sub.before(action, _this.state));
      } catch (e) {
        if (Hydra.LOCAL) {
          console.warn("Error in before action subscribers: ");
          console.error(e);
        }
      }
      const result = entry.length > 1 ? Promise.all(entry.map(handler => handler(payload))) : entry[0](payload);
      return new Promise((resolve, reject) => {
        result.then(res => {
          try {
            _actionSubscribers.filter(sub => sub.after).forEach(sub => sub.after(action, _this.state));
          } catch (e) {
            if (Hydra.LOCAL) {
              console.warn("Error in after action subscribers: ");
              console.error(e);
            }
          }
          resolve(res);
        }, error => {
          try {
            _actionSubscribers.filter(sub => sub.error).forEach(sub => sub.error(action, _this.state, error));
          } catch (e) {
            if (Hydra.LOCAL) {
              console.warn("Error in error action subscribers: ");
              console.error(e);
            }
          }
          reject(error);
        });
      });
    };
    this.subscribeAction = function (key, fn, options) {
      let subs = {};
      if (typeof fn == "function") {
        subs.before = function subscriberEmptyBeforeWrapper(action) {
          if (action.type === key) {
            fn(action);
          }
        };
      } else {
        if (fn.before) {
          subs.before = function subscriberBeforeWrapper(action) {
            if (action.type === key) {
              fn.before(action);
            }
          };
        }
        if (fn.after) {
          subs.after = function subscriberAfterWrapper(action) {
            if (action.type === key) {
              fn.after(action);
            }
          };
        }
      }
      return genericSubscribe(subs, _actionSubscribers, options);
    };
    this.subscribe = function (key, fn, options) {
      return genericSubscribe(function subscriberWrapper(mutation) {
        if (mutation.type === key) {
          fn(mutation);
        }
      }, _subscribers, options);
    };
    this.bind = this.state.bind;
    this.watch = this.state.bind;
    this.get = this.state.get;
  });
  Class(function StateArray(_src = []) {
    Inherit(this, Events);
    const _this = this;
    var _data = [];
    Object.defineProperty(_this, "length", {
      get: function () {
        return _data.length;
      }
    });
    this.push = function (obj) {
      let state = function wrap(obj) {
        if (obj.createLocal) {
          return obj;
        }
        if (typeof obj != "object" || Array.isArray(obj)) {
          throw "StateArray entries must be {objects}!";
        }
        let state = AppState.createLocal();
        for (let key in obj) {
          state.set(key, obj[key]);
        }
        state.origin = obj;
        return state;
      }(obj);
      _data.push(state);
      let index = _data.length - 1;
      if (_this[index] === undefined) {
        Object.defineProperty(_this, index, {
          set: function (v) {
            for (let key in v) {
              _data[index].set(key, v[key]);
            }
          },
          get: function () {
            return _data[index];
          }
        });
      }
      _this.events.fire(Events.UPDATE, {
        type: "add",
        state: state
      });
      return state;
    };
    this.remove = function (obj) {
      for (let i = 0; i < _data.length; i++) {
        let state = _data[i];
        if (state.origin === obj || state === obj) {
          _data.splice(i, 1);
          _this.events.fire(Events.UPDATE, {
            type: "remove",
            state: state
          }, true);
        }
      }
    };
    this.forEach = function (cb) {
      _data.forEach(function (...args) {
        return cb.apply(this, args);
      });
    };
    this.map = function (cb) {
      let array = [];
      _data.forEach(function (...args) {
        return array.push(cb.apply(this, args));
      });
      return array;
    };
    this.toJSON = function () {
      let array = [];
      _data.forEach(appState => {
        array.push(appState.toJSON());
      });
      return array;
    };
    this.getMap = function () {
      let array = [];
      _data.forEach(appState => {
        array.push(appState.getMap());
      });
      return array;
    };
    this.indexOf = function (obj) {
      for (let i = 0; i < _data.length; i++) {
        let state = _data[i];
        if (state.origin === obj || state === obj) {
          return i;
        }
      }
    };
    this.refresh = function (array) {
      _this.events.fire(StateArray.REFRESH, {
        type: "refresh"
      }, true);
      if (!Array.isArray(array)) {
        throw "StateArray can only take an array as a parameter";
      }
      let i = _data.length;
      while (i--) {
        let state = _data.pop();
        _this.events.fire(Events.UPDATE, {
          type: "remove",
          state: state
        }, true);
      }
      _data.length = 0;
      array.forEach(_this.push);
    };
    this.reflow = function () {
      this.refresh(_data.map(d => d.origin));
    };
    if (!Array.isArray(_src)) {
      throw "StateArray can only take an array as a parameter";
    }
    _src.forEach(_this.push);
  }, _ => {
    StateArray.REFRESH = "state_array_refresh";
  });
  Class(function ViewState(ViewClass, ...rest) {
    const _this = this;
    var _stateArray;
    var _instances = this.views = [];
    function dataUpdate(e) {
      switch (e.type) {
        case "add":
          ViewState.schedule(_this, ViewClass, e.state, _stateArray.indexOf(e.state), rest);
          break;
        case "remove":
          (function remove(data) {
            for (let i = 0; i < _instances.length; i++) {
              let inst = _instances[i];
              if (data == inst.data) {
                _this.onRemoveView?.(inst, i);
                _instances.splice(i, 1);
                return;
              }
            }
          })(e.state);
          ViewState.clearScheduled(e.state);
      }
    }
    this.setSourceData = function (array) {
      if (!(array instanceof StateArray)) {
        throw "ViewState::setSourceData must be instance of StateArray";
      }
      _stateArray = _this.stateArray = array;
      _this.events.sub(array, Events.UPDATE, dataUpdate);
      array.forEach(state => {
        ViewState.schedule(_this, ViewClass, state, _stateArray.indexOf(state), rest);
      });
    };
    this.onInitialize = function (instance) {
      _instances.push(instance);
      _this.onAddView?.(instance, _instances.length - 1);
    };
  }, _ => {
    const queue = [];
    const worker = new Render.Worker(_ => {
      let obj = queue.shift();
      if (obj) {
        let {
          ref: ref,
          ViewClass: ViewClass,
          data: data,
          index: index,
          additionalArgs: additionalArgs
        } = obj;
        if (!ref.initClass) {
          return;
        }
        let args = [];
        additionalArgs.forEach(arg => {
          args.push(...arg);
        });
        let inst = ref.initClass(ViewClass, data, index, ...args);
        inst.data = data;
        ref.onInitialize(inst);
      } else {
        worker.pause();
      }
    }, 2);
    worker.pause();
    ViewState.clearScheduled = function (data) {
      for (let i = 0; i < queue.length; i++) {
        if (queue[i].data === data) {
          return queue.splice(i, 1);
        }
      }
    };
    ViewState.schedule = function (ref, ViewClass, data, index, ...rest) {
      if (ref.initClass) {
        queue.push({
          ref: ref,
          ViewClass: ViewClass,
          data: data,
          index: index,
          additionalArgs: rest
        });
        worker.resume();
      }
    };
  });
  Class(function StateComponent() {
    const _this = this;
    let _mutationsUnsubscribers = [];
    let _actionsUnsubscribers = [];
    this.unsubscribeMutations = function () {
      _mutationsUnsubscribers.forEach(u => u());
    };
    this.unsubscribeActions = function () {
      _actionsUnsubscribers.forEach(u => u());
    };
    this.unsubscribeAll = function () {
      _this.unsubscribeMutations();
      _this.unsubscribeActions();
    };
    this.subscribeMutation = function (store, type, fn) {
      _mutationsUnsubscribers.push(store.subscribe(type, fn));
    };
    this.subscribeAction = function (store, type, fn) {
      _actionsUnsubscribers.push(store.subscribeAction(type, fn));
    };
    this.commit = function (store, type, payload) {
      store.commit(type, payload);
    };
    this.dispatch = async function (store, type, payload) {
      await store.dispatch(type, payload);
    };
    this.getState = function (store, key) {
      return store.get(key);
    };
    this.watch = function (store, key, fn, callInitial = true) {
      let hasCalled = false;
      const callback = params => {
        if (hasCalled || callInitial) {
          fn(params);
        } else {
          hasCalled = true;
        }
      };
      if (_this.bindState) {
        return _this.bindState(store, key, callback);
      } else {
        return store.watch(key, callback);
      }
    };
    this.bind = this.watch;
    if (typeof this._bindOnDestroy == "function") {
      this._bindOnDestroy(() => {
        _this.unsubscribeAll();
      });
    }
  });
  Class(function Dev() {
    var _post;
    var _inter;
    var _timerName;
    var _this = this;
    Utils.timestamp();
    function postError(error) {
      let device = {
        gpu: Device.graphics.webgl ? Device.graphics.webgl.gpu : "WEBGL UNAVAILABLE",
        version: Device.graphics.webgl ? Device.graphics.webgl.version : "WEBGL UNAVAILABLE",
        tier: window.GPU ? Device.mobile ? GPU.M_TIER : GPU.TIER : "",
        mobile: JSON.stringify(Device.mobile),
        userAgent: Device.agent,
        dpr: Device.pixelRatio,
        screenSize: `${screen.width} x ${screen.height}`,
        stageSize: `${Stage.width} x ${Stage.height}`,
        href: window.location.href
      };
      let tests = {};
      try {
        if (window.Tests) {
          for (let key in Tests) {
            if (typeof Tests[key] == "function") {
              tests[key] = Tests[key]();
            }
          }
        }
      } catch (e) {}
      post(_post, {
        error: error,
        device: device,
        tests: tests
      }).catch(function () {
        if (Hydra.LOCAL) {
          console.log("Error whle posting to server");
        }
      });
    }
    this.emulator = Device.mobile && navigator.platform && navigator.platform.toLowerCase().includes(["mac", "windows"]);
    this.postErrorsToServer = function (server) {
      _post = server;
      (function catchErrors() {
        window.onerror = function (message, file, line, column, e) {
          postError({
            message: message,
            file: file,
            line: line,
            column: column,
            stack: e && e.stack.toString()
          });
        };
        window.addEventListener("unhandledrejection", e => {
          postError({
            type: "unhandledrejection",
            message: e.reason.message,
            stack: e.reason.stack
          });
        });
      })();
    };
    this.expose = function (name, val, force) {
      if (Hydra.LOCAL || force) {
        window[name] = val;
      }
    };
    this.unsupported = function (needsAlert) {
      if (needsAlert) {
        alert("Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported.");
      }
    };
    this.checkForLeaks = function (flag, array) {
      if (!window.AURA) {
        function matchArray(prop) {
          if (!array) {
            return false;
          }
          for (var i = 0; i < array.length; i++) {
            if (prop.includes(array[i])) {
              return true;
            }
          }
          return false;
        }
        clearInterval(_inter);
        if (flag) {
          _inter = setInterval(function () {
            for (var prop in window) {
              if (!prop.includes("webkit")) {
                if (typeof window[prop] != "function" && prop.length > 2) {
                  if (prop.includes("_ga") || prop.includes("_typeface_js") || prop.includes("sentry") || matchArray(prop)) {
                    continue;
                  }
                  var char1 = prop.charAt(0);
                  var char2 = prop.charAt(1);
                  if ((char1 == "_" || char1 == "$") && char2 !== char2.toUpperCase()) {
                    console.log(window[prop]);
                    throw "Hydra Warning:: " + prop + " leaking into global scope";
                  }
                }
              }
            }
          }, 1000);
        }
      }
    };
    this.startTimer = function (name) {
      _timerName = name || "Timer";
      if (console.time && !window._NODE_) {
        console.time(_timerName);
      } else {
        _timer = performance.now();
      }
    };
    this.stopTimer = function () {
      if (console.time && !window._NODE_) {
        console.timeEnd(_timerName);
      } else {
        console.log("Render " + _timerName + ": " + (performance.now() - _timer));
      }
    };
    this.writeFile = function (file, data) {
      let promise = Promise.create();
      let protocol = location.protocol;
      let port = protocol === "https:" ? ":8018" : ":8017";
      let url = protocol + "//" + location.hostname + port + location.pathname + file;
      post(url, data, {
        headers: {
          "content-type": "text/plain"
        }
      }).then(e => {
        if (e != "OK") {
          console.warn(`Unable to write to ${file}`);
          promise.reject();
        } else {
          promise.resolve();
        }
      });
      return promise;
    };
    this.execUILScript = async function (name, data) {
      if (!Hydra.LOCAL) {
        return;
      }
      let url = location.protocol + "//" + location.hostname + ":8017" + (_this.pathName || location.pathname) + "/uil/" + name;
      let response = await post(url, data, {
        headers: {
          "content-type": "text/plain"
        }
      });
      if (response == "ERROR") {
        throw response;
      }
      return response;
    };
    if (Hydra.LOCAL) {
      _this.checkForLeaks(true);
    }
  }, "Static");
  Class(function Service() {
    Inherit(this, Component);
    var _sw;
    var _this = this;
    function getSWAssets() {
      if (!window.ASSETS.SW || _this.cached) {
        return [];
      }
      var assets = window.ASSETS.SW;
      assets.forEach((asset, i) => {
        if (asset.includes(".js")) {
          asset = assets[i].replace(".js", ".js?" + window._CACHE_);
        }
      });
      return assets;
    }
    function handleRegistration(e) {}
    function handleReady(e) {
      _this.isReady = true;
      _this.events.fire(Events.READY, e, true);
      _sw = navigator.serviceWorker.controller;
      (function checkCache() {
        if (Storage.get("service_cache") != window._CACHE_) {
          _this.post("clearCache");
        }
      })();
    }
    function handleError(e) {
      if (e) {
        _this.events.fire(Events.ERROR, e, true);
        _this.active = false;
      }
    }
    function handleMessage(e) {
      var data = e.data;
      if (data.evt) {
        _this.events.fire(data.evt, data);
      }
    }
    this.active = false;
    this.ready = false;
    this.cached = false;
    this.offline = false;
    this.disabled = false;
    this.ready = function () {
      return this.wait(this, "isReady");
    };
    this.init = function () {
      Hydra.ready(() => {
        if (!!("serviceWorker" in navigator) && (!Hydra.LOCAL || location.port != "") && !window.process && !_this.disabled) {
          (function initWorker() {
            _this.active = true;
            navigator.serviceWorker.register(`${window._SW_PATH_ ? window._SW_PATH_ : ""}sw.js`).then(handleRegistration).then(handleReady).then(handleError);
          })();
        }
      });
    };
    this.cache = function (assets = []) {
      assets = Array.from(assets);
      if (_this.active) {
        _this.wait(_this, "ready", function () {
          _this.post("upload", {
            assets: assets,
            cdn: Assets.CDN,
            hostname: location.hostname,
            sw: getSWAssets(),
            offline: _this.offline
          });
          Storage.set("service_cache", window._CACHE_);
          _this.cached = true;
        });
      }
    };
    this.post = function (fn, data = {}) {
      if (!_this.active) {
        return;
      }
      _this.wait(_this, "ready", function () {
        let mc = new MessageChannel();
        mc.port1.onmessage = handleMessage;
        data.fn = fn;
        if (_sw) {
          _sw.postMessage(data, [mc.port2]);
        }
      });
    };
  }, "static");
  Class(function Storage() {
    var _storage;
    var _this = this;
    var _sessionData = {};
    function cookie(key, value, expires) {
      var options;
      if (arguments.length > 1 && (value === null || typeof value != "object")) {
        (options = {}).path = "/";
        options.expires = expires || 1;
        if (value === null) {
          options.expires = -1;
        }
        if (typeof options.expires == "number") {
          var days = options.expires;
          var t = options.expires = new Date();
          t.setDate(t.getDate() + days);
        }
        return document.cookie = [encodeURIComponent(key), "=", options.raw ? String(value) : encodeURIComponent(String(value)), options.expires ? "; expires=" + options.expires.toUTCString() : "", options.path ? "; path=" + options.path : "", options.domain ? "; domain=" + options.domain : "", options.secure ? "; secure" : ""].join("");
      }
      var result;
      var decode = (options = value || {}).raw ? function (s) {
        return s;
      } : decodeURIComponent;
      if (result = new RegExp("(?:^|; )" + encodeURIComponent(key) + "=([^;]*)").exec(document.cookie)) {
        return decode(result[1]);
      } else {
        return null;
      }
    }
    this.noTracking = false;
    (function testStorage() {
      try {
        if (window.localStorage) {
          try {
            window.localStorage.test = 1;
            window.localStorage.removeItem("test");
            _storage = true;
          } catch (e) {
            _storage = false;
          }
        } else {
          _storage = false;
        }
      } catch (e) {
        _storage = false;
      }
    })();
    this.setCookie = function (key, value, expires) {
      cookie(key, value, expires);
    };
    this.getCookie = function (key) {
      return cookie(key);
    };
    this.set = function (key, value) {
      if (_this.noTracking) {
        _sessionData[key] = value;
      } else {
        if (value != null && typeof value == "object") {
          value = JSON.stringify(value);
        }
        if (_storage) {
          if (value === null) {
            window.localStorage.removeItem(key);
          } else {
            window.localStorage[key] = value;
          }
        } else {
          cookie(key, value, 365);
        }
      }
    };
    this.get = function (key) {
      if (_this.noTracking) {
        return _sessionData[key];
      }
      var val;
      var char0;
      if (val = _storage ? window.localStorage[key] : cookie(key)) {
        if (val.charAt) {
          char0 = val.charAt(0);
        }
        if (char0 == "{" || char0 == "[") {
          val = JSON.parse(val);
        }
        if (val == "true" || val == "false") {
          val = val == "true";
        }
      }
      return val;
    };
  }, "Static");
  Class(function Thread(_class) {
    Inherit(this, Component);
    var _this = this;
    var _worker;
    var _callbacks;
    var _path;
    var _mvc;
    var _msg = {};
    function init() {
      let file = window._ES5_ ? "/hydra-thread-es5.js" : "/hydra-thread.js";
      _callbacks = {};
      _worker = new Worker(Thread.PATH + file);
    }
    function importClasses() {
      importClass(Utils);
      importClass(Component);
      importClass(Events);
      importClass(_class, true);
      importES5();
    }
    function importClass(_class, scoped) {
      if (_class) {
        var code;
        if (scoped) {
          code = (code = _class.toString().replace("{", "!!!")).split("!!!")[1];
          var splitChar = window._MINIFIED_ ? "=" : " ";
          for (; code.includes("this.");) {
            var name = code.slice(code.indexOf("this.")).split("this.")[1].split(splitChar)[0];
            code = code.replace("this", "self");
            createMethod(name);
          }
          code = (code = code.slice(0, -1)).replace(/_self/g, "_this");
        } else if (typeof _class != "function") {
          if ((code = _class.constructor.toString()).includes("[native")) {
            return;
          }
          code = (_class.constructor._namespace ? _class.constructor._namespace + "." : "") + "Class(" + code + ", \"static\");";
        } else {
          code = (_class._namespace ? _class._namespace + "." : "") + "Class(" + _class.toString() + ");";
        }
        _worker.postMessage({
          code: code
        });
      }
    }
    function createMethod(name) {
      _this[name] = function (message = {}, callback, buffer) {
        let promise;
        if (Array.isArray(callback)) {
          buffer = callback;
          callback = undefined;
        }
        if (Array.isArray(buffer)) {
          (message = {
            msg: message,
            transfer: true
          }).buffer = buffer;
        }
        if (callback === undefined) {
          promise = Promise.create();
          callback = promise.resolve;
        }
        _this.send(name, message, callback);
        return promise;
      };
    }
    function importES5() {
      if (window._ES5_) {
        ["_createSuper", "_isNativeReflectConstruct"].forEach(name => {
          let code = window[name].toString();
          if (!code.includes("[native")) {
            _worker.postMessage({
              code: code
            });
          }
        });
        _worker.postMessage({
          code: "function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}"
        });
      }
    }
    function addListeners() {
      _worker.addEventListener("message", workerMessage);
    }
    function workerMessage(e) {
      if (e.data.console) {
        console.log(e.data.message);
      } else if (e.data.id) {
        if (callback = _callbacks[e.data.id]) {
          callback(e.data.message);
        }
        delete _callbacks[e.data.id];
      } else if (e.data.emit) {
        if (callback = _callbacks[e.data.evt]) {
          callback(e.data.msg);
        }
      } else {
        var callback;
        if (callback = _callbacks.transfer) {
          callback(e.data);
        }
      }
    }
    init();
    importClasses();
    addListeners();
    this.on = function (evt, callback) {
      _callbacks[evt] = callback;
    };
    this.off = function (evt) {
      delete _callbacks[evt];
    };
    this.loadFunction = function () {
      let names = [];
      let load = code => {
        var split = (code = (code = code.toString()).replace("(", "!!!")).split("!!!");
        var name = split[0].split(" ")[1];
        code = "self." + name + " = function(" + split[1];
        _worker.postMessage({
          code: code
        });
        createMethod(name);
        names.push(name);
      };
      for (var i = 0; i < arguments.length; i++) {
        load(arguments[i]);
      }
      return names;
    };
    this.importScript = function (path) {
      _worker.postMessage({
        path: Thread.absolutePath(path),
        importScript: true
      });
    };
    this.importCode = function (code) {
      _worker.postMessage({
        code: code
      });
    };
    this.importClass = function () {
      for (var i = 0; i < arguments.length; i++) {
        var code = arguments[i];
        importClass(code);
      }
    };
    this.importModules = this.importModule = function () {
      for (var i = 0; i < arguments.length; i++) {
        let code = Modules.getConstructor(arguments[i]).toString();
        _worker.postMessage({
          code: `Module(${code})`
        });
      }
    };
    this.importES6Class = function (name) {
      if (window._ES5_) {
        let Class = window[name];
        let base = Class.toString();
        let proto = [];
        let sup;
        let matches = /(_this\w+)\s*=\s*(_super\w+)\.call/g.exec(base);
        if (matches) {
          let superVar = matches[2];
          let superConstructor = Object.getPrototypeOf(Class);
          if (!superConstructor.toString().includes("[native")) {
            let superName = Utils.getConstructorName(superConstructor);
            sup = `_inherits(${name}, ${superName}); var ${superVar} = _createSuper(${name});`;
          }
        }
        Object.getOwnPropertyNames(Class.prototype).forEach(fn => {
          if (fn != "constructor" && Class.prototype[fn]) {
            proto.push({
              key: fn,
              string: Class.prototype[fn].toString()
            });
          }
        });
        _worker.postMessage({
          es5: base,
          name: name,
          proto: proto,
          sup: sup
        });
      } else {
        _worker.postMessage({
          es6: `(${eval(name)})`,
          name: name
        });
      }
    };
    this.send = function (name, message, callback) {
      if (typeof name == "string") {
        (message = message || {}).fn = name;
      } else {
        callback = message;
        message = name;
      }
      if (Thread.UNIQUE_ID > 999999) {
        Thread.UNIQUE_ID = 1;
      }
      var id = Thread.UNIQUE_ID++;
      if (callback) {
        _callbacks[id] = callback;
      }
      if (message.transfer) {
        message.msg.id = id;
        message.msg.fn = message.fn;
        message.msg.transfer = true;
        _worker.postMessage(message.msg, message.buffer);
      } else {
        _msg.message = message;
        _msg.id = id;
        _worker.postMessage(_msg);
      }
    };
    this.onDestroy = function () {
      if (_worker.terminate) {
        _worker.terminate();
      }
    };
  }, () => {
    var _shared;
    Thread.PATH = window._THREAD_PATH_ || "assets/js/hydra";
    Thread.UNIQUE_ID = 1;
    Thread.absolutePath = Hydra.absolutePath;
    Thread.cluster = function () {
      return new function () {
        let index = 0;
        let array = [];
        this.push = function (thread) {
          array.push(thread);
        };
        this.get = function () {
          let thread = array[index];
          index++;
          if (index >= array.length) {
            index = 0;
          }
          return thread;
        };
        this.array = array;
      }();
    };
    Thread.upload = function (...args) {
      let name;
      Thread.shared();
      for (let i = 0; i < _shared.array.length; i++) {
        name = _shared.array[i].loadFunction(...args);
      }
      return name;
    };
    Thread.uploadClass = function (...args) {
      let name;
      Thread.shared();
      for (let i = 0; i < _shared.array.length; i++) {
        name = _shared.array[i].importClass(...args);
      }
      return name;
    };
    Thread.shared = function (list) {
      if (!_shared) {
        _shared = Thread.cluster();
        let hardware = navigator.hardwareConcurrency || 4;
        let count = Math.max(Math.min(hardware, 8), 4);
        for (let i = 0; i < count; i++) {
          _shared.push(new Thread());
        }
      }
      if (list) {
        return _shared;
      } else {
        return _shared.get();
      }
    };
  });
  Class(function TweenManager() {
    Namespace(this);
    var _this = this;
    var _tweens = [];
    function updateTweens(time, dt) {
      for (let i = _tweens.length - 1; i >= 0; i--) {
        let tween = _tweens[i];
        if (tween.update) {
          tween.update(dt);
        } else {
          _this._removeMathTween(tween);
        }
      }
    }
    function findEase(name) {
      var eases = _this.CubicEases;
      for (var i = eases.length - 1; i > -1; i--) {
        if (eases[i].name == name) {
          return eases[i];
        }
      }
      return false;
    }
    this.CubicEases = [];
    Render.start(updateTweens);
    this._addMathTween = function (tween) {
      _tweens.push(tween);
    };
    this._removeMathTween = function (tween) {
      _tweens.remove(tween);
    };
    this._getEase = function (name, values) {
      var ease = findEase(name);
      return !!ease && (values ? ease.path ? ease.path.solve : ease.values : ease.curve);
    };
    this._inspectEase = function (name) {
      return findEase(name);
    };
    this.tween = function (object, props, time, ease, delay, complete, isManual, scaledTime) {
      if (typeof delay != "number") {
        update = complete;
        complete = delay;
        delay = 0;
      }
      const tween = new MathTween(object, props, time, ease, delay, complete, isManual, scaledTime);
      let usePromise = null;
      if (complete && complete instanceof Promise) {
        usePromise = complete;
        complete = complete.resolve;
      }
      return usePromise || tween;
    };
    this.clearTween = function (object) {
      if (object._mathTween && object._mathTween.stop) {
        object._mathTween.stop();
      }
      if (object._mathTweens) {
        for (var tweens = object._mathTweens, i = 0; i < tweens.length; i++) {
          var tw = tweens[i];
          if (tw && tw.stop) {
            tw.stop();
          }
        }
        object._mathTweens = null;
      }
    };
    this.addCustomEase = function (ease) {
      var add = true;
      if (typeof ease != "object" || !ease.name || !ease.curve) {
        throw "TweenManager :: addCustomEase requires {name, curve}";
      }
      for (var i = _this.CubicEases.length - 1; i > -1; i--) {
        if (ease.name == _this.CubicEases[i].name) {
          add = false;
        }
      }
      if (add) {
        if (ease.curve.charAt(0).toLowerCase() == "m") {
          if (!window.EasingPath) {
            throw "Using custom eases requires easingpath module";
          }
          ease.path = new EasingPath(ease.curve);
        } else {
          ease.values = function stringToValues(str) {
            for (var values = str.split("(")[1].slice(0, -1).split(","), i = 0; i < values.length; i++) {
              values[i] = parseFloat(values[i]);
            }
            return values;
          }(ease.curve);
        }
        _this.CubicEases.push(ease);
      }
      return ease;
    };
    Math.interpolate = function (start, end, alpha, ease) {
      const fn = _this.Interpolation.convertEase(ease);
      return Math.mix(start, end, typeof fn == "function" ? fn(alpha) : _this.Interpolation.solve(fn, alpha));
    };
    window.tween = this.tween;
    window.clearTween = this.clearTween;
  }, "Static");
  TweenManager.Class(function Interpolation() {
    function calculateBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function A(aA1, aA2) {
      return 1 - aA2 * 3 + aA1 * 3;
    }
    function B(aA1, aA2) {
      return aA2 * 3 - aA1 * 6;
    }
    function C(aA1) {
      return aA1 * 3;
    }
    this.convertEase = function (ease) {
      var fn = function () {
        switch (ease) {
          case "easeInQuad":
            return TweenManager.Interpolation.Quad.In;
          case "easeInCubic":
            return TweenManager.Interpolation.Cubic.In;
          case "easeInQuart":
            return TweenManager.Interpolation.Quart.In;
          case "easeInQuint":
            return TweenManager.Interpolation.Quint.In;
          case "easeInSine":
            return TweenManager.Interpolation.Sine.In;
          case "easeInExpo":
            return TweenManager.Interpolation.Expo.In;
          case "easeInCirc":
            return TweenManager.Interpolation.Circ.In;
          case "easeInElastic":
            return TweenManager.Interpolation.Elastic.In;
          case "easeInBack":
            return TweenManager.Interpolation.Back.In;
          case "easeInBounce":
            return TweenManager.Interpolation.Bounce.In;
          case "easeOutQuad":
            return TweenManager.Interpolation.Quad.Out;
          case "easeOutCubic":
            return TweenManager.Interpolation.Cubic.Out;
          case "easeOutQuart":
            return TweenManager.Interpolation.Quart.Out;
          case "easeOutQuint":
            return TweenManager.Interpolation.Quint.Out;
          case "easeOutSine":
            return TweenManager.Interpolation.Sine.Out;
          case "easeOutExpo":
            return TweenManager.Interpolation.Expo.Out;
          case "easeOutCirc":
            return TweenManager.Interpolation.Circ.Out;
          case "easeOutElastic":
            return TweenManager.Interpolation.Elastic.Out;
          case "easeOutBack":
            return TweenManager.Interpolation.Back.Out;
          case "easeOutBounce":
            return TweenManager.Interpolation.Bounce.Out;
          case "easeInOutQuad":
            return TweenManager.Interpolation.Quad.InOut;
          case "easeInOutCubic":
            return TweenManager.Interpolation.Cubic.InOut;
          case "easeInOutQuart":
            return TweenManager.Interpolation.Quart.InOut;
          case "easeInOutQuint":
            return TweenManager.Interpolation.Quint.InOut;
          case "easeInOutSine":
            return TweenManager.Interpolation.Sine.InOut;
          case "easeInOutExpo":
            return TweenManager.Interpolation.Expo.InOut;
          case "easeInOutCirc":
            return TweenManager.Interpolation.Circ.InOut;
          case "easeInOutElastic":
            return TweenManager.Interpolation.Elastic.InOut;
          case "easeInOutBack":
            return TweenManager.Interpolation.Back.InOut;
          case "easeInOutBounce":
            return TweenManager.Interpolation.Bounce.InOut;
          case "linear":
            return TweenManager.Interpolation.Linear.None;
        }
      }();
      if (!fn) {
        var curve = TweenManager._getEase(ease, true);
        fn = curve || TweenManager.Interpolation.Cubic.Out;
      }
      return fn;
    };
    this.solve = function (values, elapsed) {
      if (values[0] == values[1] && values[2] == values[3]) {
        return elapsed;
      } else {
        return calculateBezier(function getTForX(aX, mX1, mX2) {
          var aT;
          var aA1;
          var aA2;
          var aGuessT = aX;
          for (var i = 0; i < 4; i++) {
            aT = aGuessT;
            var currentSlope = A(aA1 = mX1, aA2 = mX2) * 3 * aT * aT + B(aA1, aA2) * 2 * aT + C(aA1);
            if (currentSlope == 0) {
              return aGuessT;
            }
            aGuessT -= (calculateBezier(aGuessT, mX1, mX2) - aX) / currentSlope;
          }
          return aGuessT;
        }(elapsed, values[0], values[2]), values[1], values[3]);
      }
    };
    this.Linear = {
      None: function (k) {
        return k;
      }
    };
    this.Quad = {
      In: function (k) {
        return k * k;
      },
      Out: function (k) {
        return k * (2 - k);
      },
      InOut: function (k) {
        if ((k *= 2) < 1) {
          return k * 0.5 * k;
        } else {
          return (--k * (k - 2) - 1) * -0.5;
        }
      }
    };
    this.Cubic = {
      In: function (k) {
        return k * k * k;
      },
      Out: function (k) {
        return --k * k * k + 1;
      },
      InOut: function (k) {
        if ((k *= 2) < 1) {
          return k * 0.5 * k * k;
        } else {
          return ((k -= 2) * k * k + 2) * 0.5;
        }
      }
    };
    this.Quart = {
      In: function (k) {
        return k * k * k * k;
      },
      Out: function (k) {
        return 1 - --k * k * k * k;
      },
      InOut: function (k) {
        if ((k *= 2) < 1) {
          return k * 0.5 * k * k * k;
        } else {
          return ((k -= 2) * k * k * k - 2) * -0.5;
        }
      }
    };
    this.Quint = {
      In: function (k) {
        return k * k * k * k * k;
      },
      Out: function (k) {
        return --k * k * k * k * k + 1;
      },
      InOut: function (k) {
        if ((k *= 2) < 1) {
          return k * 0.5 * k * k * k * k;
        } else {
          return ((k -= 2) * k * k * k * k + 2) * 0.5;
        }
      }
    };
    this.Sine = {
      In: function (k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      Out: function (k) {
        return Math.sin(k * Math.PI / 2);
      },
      InOut: function (k) {
        return (1 - Math.cos(Math.PI * k)) * 0.5;
      }
    };
    this.Expo = {
      In: function (k) {
        if (k === 0) {
          return 0;
        } else {
          return Math.pow(1024, k - 1);
        }
      },
      Out: function (k) {
        if (k === 1) {
          return 1;
        } else {
          return 1 - Math.pow(2, k * -10);
        }
      },
      InOut: function (k) {
        if (k === 0) {
          return 0;
        } else if (k === 1) {
          return 1;
        } else if ((k *= 2) < 1) {
          return Math.pow(1024, k - 1) * 0.5;
        } else {
          return (2 - Math.pow(2, (k - 1) * -10)) * 0.5;
        }
      }
    };
    this.Circ = {
      In: function (k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      Out: function (k) {
        return Math.sqrt(1 - --k * k);
      },
      InOut: function (k) {
        if ((k *= 2) < 1) {
          return (Math.sqrt(1 - k * k) - 1) * -0.5;
        } else {
          return (Math.sqrt(1 - (k -= 2) * k) + 1) * 0.5;
        }
      }
    };
    this.Elastic = {
      In: function (k, a = 1, p = 0.4) {
        var s;
        if (k === 0) {
          return 0;
        } else if (k === 1) {
          return 1;
        } else {
          if (!a || a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p * Math.asin(1 / a) / (Math.PI * 2);
          }
          return -a * Math.pow(2, (k -= 1) * 10) * Math.sin((k - s) * (Math.PI * 2) / p);
        }
      },
      Out: function (k, a = 1, p = 0.4) {
        var s;
        if (k === 0) {
          return 0;
        } else if (k === 1) {
          return 1;
        } else {
          if (!a || a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p * Math.asin(1 / a) / (Math.PI * 2);
          }
          return a * Math.pow(2, k * -10) * Math.sin((k - s) * (Math.PI * 2) / p) + 1;
        }
      },
      InOut: function (k, a = 1, p = 0.4) {
        var s;
        if (k === 0) {
          return 0;
        } else if (k === 1) {
          return 1;
        } else {
          if (!a || a < 1) {
            a = 1;
            s = p / 4;
          } else {
            s = p * Math.asin(1 / a) / (Math.PI * 2);
          }
          if ((k *= 2) < 1) {
            return a * Math.pow(2, (k -= 1) * 10) * Math.sin((k - s) * (Math.PI * 2) / p) * -0.5;
          } else {
            return a * Math.pow(2, (k -= 1) * -10) * Math.sin((k - s) * (Math.PI * 2) / p) * 0.5 + 1;
          }
        }
      }
    };
    this.Back = {
      In: function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      Out: function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      InOut: function (k) {
        var s = 2.5949095;
        if ((k *= 2) < 1) {
          return k * k * ((s + 1) * k - s) * 0.5;
        } else {
          return ((k -= 2) * k * ((s + 1) * k + s) + 2) * 0.5;
        }
      }
    };
    this.Bounce = {
      In: function (k) {
        return 1 - this.Bounce.Out(1 - k);
      },
      Out: function (k) {
        if (k < 1 / 2.75) {
          return k * 7.5625 * k;
        } else if (k < 2 / 2.75) {
          return (k -= 1.5 / 2.75) * 7.5625 * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return (k -= 2.25 / 2.75) * 7.5625 * k + 0.9375;
        } else {
          return (k -= 2.625 / 2.75) * 7.5625 * k + 0.984375;
        }
      },
      InOut: function (k) {
        if (k < 0.5) {
          return this.Bounce.In(k * 2) * 0.5;
        } else {
          return this.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        }
      }
    };
  }, "Static");
  Class(function MathTween(_object, _props, _time, _ease, _delay, _callback, _manual, _scaledTime) {
    var _startTime;
    var _startValues;
    var _endValues;
    var _easeFunction;
    var _paused;
    var _newEase;
    var _spring;
    var _damping;
    var _update;
    var _currentTime;
    var _this = this;
    var _elapsed = 0;
    function clear() {
      if (!_object && !_props) {
        return false;
      }
      _object._mathTween = null;
      TweenManager._removeMathTween(_this);
      Utils.nullObject(_this);
      if (_object._mathTweens) {
        _object._mathTweens.remove(_this._tweenWrapper);
      }
    }
    _this.object = _object;
    _this.props = _props;
    _this.time = _time;
    _this.ease = _ease;
    _this.delay = _delay;
    defer(function () {
      if (!_this.stopped) {
        if (_this.overrideValues) {
          let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
          if (values) {
            _this.props = _props = values.props || _props;
            _this.time = _time = values.time || _time;
            _this.ease = _ease = values.ease || _ease;
            _this.delay = _delay = values.delay || _delay;
          }
        }
        if (_object && _props) {
          _this.object = _object;
          if (typeof _time != "number") {
            throw "MathTween Requires object, props, time, ease";
          }
          (function start() {
            if (!_object.multiTween && !!_object._mathTween && !_manual) {
              TweenManager.clearTween(_object);
            }
            if (!_manual) {
              TweenManager._addMathTween(_this);
            }
            _this.time = _time;
            _this.delay = _delay;
            let propString = function getPropString() {
              let string = "";
              for (let key in _props) {
                if (typeof _props[key] == "number") {
                  string += key + " ";
                }
              }
              return string;
            }();
            _object._mathTween = _this;
            if (_object.multiTween) {
              _object._mathTweens ||= [];
              _object._mathTweens.forEach(t => {
                if (t.props == propString) {
                  t.tween.stop();
                }
              });
              _this._tweenWrapper = {
                props: propString,
                tween: _this
              };
              _object._mathTweens.push(_this._tweenWrapper);
            }
            _ease ||= "linear";
            if (typeof _ease == "string") {
              _ease = TweenManager.Interpolation.convertEase(_ease);
              _easeFunction = typeof _ease == "function";
            }
            _startTime = _scaledTime ? Render.now() : performance.now();
            _currentTime = _startTime;
            _startTime += _delay;
            _endValues = _props;
            _startValues = {};
            if (_props.spring) {
              _spring = _props.spring;
            }
            if (_props.damping) {
              _damping = _props.damping;
            }
            _this.startValues = _startValues;
            for (var prop in _endValues) {
              if (typeof _object[prop] == "number") {
                _startValues[prop] = _object[prop];
              }
            }
          })();
        }
      }
    });
    this.update = function (dt) {
      if (_paused) {
        return;
      }
      if ((_currentTime += _scaledTime ? dt : Render.DT) < _startTime) {
        return;
      }
      _elapsed = (_elapsed = (_currentTime - _startTime) / _time) > 1 ? 1 : _elapsed;
      let delta = this.interpolate(_elapsed);
      if (_update) {
        _update(delta);
      }
      if (_elapsed == 1) {
        if (_callback) {
          _callback();
        }
        if (_this.completePromise) {
          _this.completePromise.resolve();
        }
        clear();
      }
    };
    this.pause = function () {
      _paused = true;
    };
    this.resume = function () {
      _paused = false;
    };
    this.stop = function () {
      _this.stopped = true;
      clear();
      return null;
    };
    this.setEase = function (ease) {
      if (_newEase != ease) {
        _newEase = ease;
        _ease = TweenManager.Interpolation.convertEase(ease);
        _easeFunction = typeof _ease == "function";
      }
    };
    this.getValues = function () {
      return {
        start: _startValues,
        end: _endValues
      };
    };
    this.interpolate = function (elapsed) {
      var delta = _easeFunction ? _ease(elapsed, _spring, _damping) : TweenManager.Interpolation.solve(_ease, elapsed);
      for (var prop in _startValues) {
        if (typeof _startValues[prop] == "number" && typeof _endValues[prop] == "number") {
          var start = _startValues[prop];
          var end = _endValues[prop];
          _object[prop] = start + (end - start) * delta;
        }
      }
      return delta;
    };
    this.onUpdate = function (callback) {
      _update = callback;
      return this;
    };
    this.onComplete = function (callback) {
      _callback = callback;
      return this;
    };
    this.promise = function () {
      _this.completePromise = Promise.create();
      return _this.completePromise;
    };
    this.setElapsed = function (elapsed) {
      _startTime = performance.now();
      _currentTime = _startTime + _time * elapsed;
    };
  });
  Class(function TweenTimeline() {
    Inherit(this, Component);
    const _this = this;
    let _tween;
    let _total = 0;
    const _tweens = [];
    function calculate() {
      _tweens.sort(function (a, b) {
        const ta = a.time + a.delay;
        return b.time + b.delay - ta;
      });
      const first = _tweens[0];
      _total = first.time + first.delay;
    }
    function loop() {
      let time = _this.elapsed * _total;
      for (let i = _tweens.length - 1; i > -1; i--) {
        let t = _tweens[i];
        let relativeTime = time - t.delay;
        let elapsed = Math.clamp(relativeTime / t.time, 0, 1);
        t.interpolate(elapsed);
      }
      _this.events.fire(Events.UPDATE, _this, true);
    }
    this.elapsed = 0;
    this.get("timeRemaining", () => _total - _this.elapsed * _total);
    this.add = function (object, props, time, ease, delay = 0) {
      let tween;
      if (object instanceof MathTween || object instanceof FrameTween) {
        props = object.props;
        time = object.time;
        ease = object.ease;
        delay = object.delay;
        object = object.object;
      }
      tween = object instanceof HydraObject ? new FrameTween(object, props, time, ease, delay, null, true) : new MathTween(object, props, time, ease, delay, null, true);
      _tweens.push(tween);
      defer(calculate);
      return tween;
    };
    this.tween = function (to, time, ease, delay, callback) {
      _this.clearTween();
      _tween = tween(_this, {
        elapsed: to
      }, time, ease, delay).onUpdate(loop).onComplete(callback);
      return _tween;
    };
    this.clearTween = function () {
      if (_tween && _tween.stop) {
        _tween.stop();
      }
    };
    this.start = function () {
      _this.startRender(loop);
    };
    this.stop = function () {
      _this.stopRender(loop);
    };
    this.update = function () {
      loop();
    };
    this.onDestroy = function () {
      _this.clearTween();
      Render.stop(loop);
      for (var i = 0; i < _tweens.length; i++) {
        _tweens[i].stop();
      }
    };
  });
  Class(function Data() {
    Inherit(this, Model);
    const _this = this;
    (async function () {
      await Hydra.ready();
      await CMS.ready();
      Config.PAGE = {
        chapter1: [{
          layoutName: "carflyaround",
          height: 10,
          scrollEndPad: 0.5,
          bloom: 0.25,
          title: CMS.get("home.homeSubhead"),
          copy: CMS.get("home.homeBody"),
          text: [{
            start: 0.13,
            end: 0.28,
            copy: CMS.get("chapters.chapter-1.stories")[0].copy
          }, {
            start: 0.22,
            end: 0.37,
            copy: CMS.get("chapters.chapter-1.stories")[1].copy
          }, {
            start: 0.31,
            end: 0.46,
            copy: CMS.get("chapters.chapter-1.stories")[2].copy
          }, {
            start: 0.4,
            end: 0.58,
            copy: CMS.get("chapters.chapter-1.stories")[3].copy,
            right: true
          }, {
            start: 0.55,
            end: 0.8,
            copy: CMS.get("chapters.chapter-1.stories")[4].extra1,
            color: Colors.value.black,
            right: true
          }, {
            start: 0.65,
            end: 0.9,
            copy: CMS.get("chapters.chapter-1.stories")[4].copy.replaceAll("CO2", "CO"),
            color: Colors.value.black,
            right: true
          }],
          instruction: {
            type: "engine",
            start: 0.35,
            end: 0.52,
            copy: "Accelerate the car"
          },
          landingCopy: [{
            start: 0.001,
            end: 0.12,
            title: CMS.get("home.homeSubhead"),
            copy: CMS.get("home.homeBody")
          }],
          scroll: {
            start: -0.1,
            end: 0.1
          }
        }, {
          layoutName: "forgefield2",
          height: 3,
          bloom: 0,
          text: [{
            start: 0.1,
            end: 0.7,
            copy: CMS.get("chapters.chapter-1.stories")[5].copy,
            color: Colors.value.black
          }, {
            start: 0.35,
            end: 1.1,
            copy: CMS.get("chapters.chapter-1.stories")[5].extra1,
            color: Colors.value.black
          }]
        }, {
          layoutName: "fanscene2",
          height: 2,
          bloom: 0.1,
          text: [{
            start: 0.1,
            end: 1,
            copy: CMS.get("chapters.chapter-1.stories")[6].copy,
            color: Colors.value.black,
            right: true
          }]
        }, {
          layout: Molecules,
          height: 9,
          bloom: 0.25,
          text: [{
            start: 0,
            end: 0.15,
            copy: CMS.get("chapters.chapter-1.stories")[7].extra1,
            cta: CMS.get("chapters.chapter-1.stories")[7].userInstruction
          }, {
            start: 0.1,
            end: 0.25,
            copy: CMS.get("chapters.chapter-1.stories")[8].extra1,
            cta: CMS.get("chapters.chapter-1.stories")[8].userInstruction
          }, {
            start: 0.28,
            end: 0.6,
            copy: CMS.get("chapters.chapter-1.stories")[9].extra1,
            cta: CMS.get("chapters.chapter-1.stories")[9].userInstruction
          }, {
            start: 0.52,
            end: 0.7,
            copy: CMS.get("chapters.chapter-1.stories")[10].extra1,
            cta: CMS.get("chapters.chapter-1.stories")[10].userInstruction
          }, {
            start: 0.75,
            end: 1.1,
            copy: CMS.get("chapters.chapter-1.stories")[11].extra1,
            top: true,
            right: true
          }],
          instruction: {
            start: 0.35,
            end: 0.65,
            copy: "energize the molecules",
            color: "#efcd7c"
          }
        }, {
          layoutName: "gasstation3",
          height: 4,
          bloom: 0.25,
          text: [{
            start: 0.05,
            end: 0.55,
            copy: CMS.get("chapters.chapter-1.stories")[12].extra1,
            right: true
          }, {
            start: 0.45,
            end: 1.1,
            copy: CMS.get("chapters.chapter-1.stories")[13].extra1
          }, {
            start: 0.58,
            end: 1.2,
            copy: CMS.get("chapters.chapter-1.stories")[13].extra2,
            color: Colors.value.teal,
            additive: true
          }],
          dashboard: {
            type: "fillup",
            start: 0.5,
            end: 1
          },
          instruction: {
            start: 0.45,
            end: 1.1,
            copy: "fill the tank",
            color: Colors.value.teal
          }
        }],
        chapter2: [{
          layout: GasStation2,
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.4,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[0].copy
          }],
          scroll: {
            start: -0.1,
            end: 0.1
          }
        }, {
          layoutName: "route66",
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[0].extra1
          }]
        }, {
          layoutName: "trucks",
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[1].copy
          }],
          dashboard: {
            type: "truck",
            start: 0.1,
            end: 1.1
          }
        }, {
          layoutName: "planeLayout",
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[2].copy,
            color: Colors.value.black
          }],
          dashboard: {
            type: "plane",
            start: 0.1,
            end: 1.1
          }
        }, {
          layoutName: "oilfieldtransform",
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.1,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[3].copy,
            right: true
          }, {
            start: 0.25,
            end: 1.25,
            copy: CMS.get("chapters.chapter-2.stories")[3].extra1,
            right: true,
            color: Colors.value.teal,
            additive: true
          }]
        }, {
          layoutName: "solarfield2",
          height: 4,
          bloom: 0.25,
          text: [{
            start: 0.1,
            end: 0.7,
            copy: CMS.get("chapters.chapter-2.stories")[4].copy,
            right: true
          }, {
            start: 0.4,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[4].extra1,
            right: true
          }]
        }, {
          layoutName: "distill",
          height: 2,
          bloom: 0.25,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[5].copy,
            top: true
          }],
          dashboard: {
            type: "spirits",
            start: 0.2,
            end: 1.1,
            left: true
          }
        }, {
          layoutName: "campshopsmall",
          height: 2,
          bloom: 1,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[6].copy
          }],
          dashboard: {
            type: "store",
            start: 0.1,
            end: 1.1
          }
        }, {
          layoutName: "tents",
          height: 2,
          bloom: 0.8,
          text: [{
            start: 0.2,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[7].copy
          }],
          dashboard: {
            type: "camp",
            start: 0.1,
            end: 1.1
          }
        }, {
          layoutName: "campfire",
          height: 3,
          bloom: 1.5,
          text: [{
            start: 0.4,
            end: 1.1,
            copy: CMS.get("chapters.chapter-2.stories")[8].copy
          }]
        }],
        chapter3: [{
          layoutName: "ch3newlanding",
          height: 6,
          bloom: 0.25,
          text: [{
            start: 0,
            end: 0.1,
            copy: "Scroll to read our story",
            isA11Y: true
          }, {
            start: 0.1,
            end: 0.6,
            copy: CMS.get("chapters.chapter-3.stories")[0].copy,
            right: true
          }, {
            start: 0.4,
            end: 1,
            copy: CMS.get("chapters.chapter-3.stories")[0].extra1,
            right: true
          }],
          scroll: {
            start: -0.1,
            end: 1
          }
        }, {
          layoutName: "ch3landing",
          height: 3,
          bloom: 0.25,
          text: [{
            start: 0.1,
            end: 1.1,
            copy: CMS.get("chapters.chapter-3.stories")[1].copy,
            right: true
          }]
        }, {
          layoutName: "ch3insidefactory",
          height: 4,
          bloom: 0.25,
          text: [{
            start: 0.1,
            end: 0.6,
            copy: CMS.get("chapters.chapter-3.stories")[2].copy,
            right: false,
            top: false,
            color: Colors.value.white
          }, {
            start: 0.4,
            end: 1,
            copy: CMS.get("chapters.chapter-3.stories")[2].extra1,
            right: true,
            top: false,
            color: Colors.value.white
          }]
        }, {
          layoutName: "ch3caravan",
          height: 4,
          bloom: 0.25,
          text: [{
            start: 0.1,
            end: 0.5,
            copy: CMS.get("chapters.chapter-3.stories")[4].copy,
            right: false
          }]
        }, {
          layoutName: "ch3shipping",
          height: 3,
          bloom: 0.25,
          text: [{
            start: 0.25,
            end: 1.1,
            copy: CMS.get("chapters.chapter-3.stories")[5].copy,
            right: true
          }]
        }, {
          layoutName: "ch3destination",
          height: 3,
          bloom: 0.25,
          text: [{
            start: 0,
            end: 1,
            copy: CMS.get("chapters.chapter-3.stories")[6].copy,
            right: true,
            top: true,
            color: Colors.value.white
          }]
        }, {
          layoutName: "ch3ending",
          height: 7,
          bloom: 0.25,
          text: [{
            start: 0.01,
            end: 0.26,
            copy: CMS.get("chapters.chapter-3.stories")[7].copy,
            right: false
          }, {
            start: 0.3,
            end: 0.45,
            copy: CMS.get("chapters.chapter-3.stories")[7].extra1,
            right: false
          }, {
            start: 0.4,
            end: 0.6,
            copy: CMS.get("chapters.chapter-3.stories")[7].extra2,
            right: false
          }, {
            start: 0.52,
            end: 0.7,
            copy: CMS.get("chapters.chapter-3.stories")[7].extra3,
            right: false
          }, {
            start: 0.7,
            end: 0.875,
            copy: CMS.get("chapters.chapter-3.stories")[7].extra4,
            right: false
          }, {
            start: 0.8,
            end: 1,
            copy: CMS.get("chapters.chapter-3.stories")[7].extra5,
            right: false
          }]
        }, {
          layoutName: "ch3endingsplit",
          mobileCameras: true,
          near: 5,
          height: 4,
          bloom: 0.25,
          text: [{
            start: 0,
            end: 0.3,
            copy: CMS.get("chapters.chapter-3.stories")[8].copy,
            right: false
          }, {
            start: 0.15,
            end: 0.4,
            copy: CMS.get("chapters.chapter-3.stories")[8].extra1,
            right: false
          }, {
            start: 0.35,
            end: 0.7,
            copy: CMS.get("chapters.chapter-3.stories")[8].extra2,
            right: false
          }, {
            start: 0.7,
            end: 0.9,
            copy: CMS.get("chapters.chapter-3.stories")[8].extra3,
            right: false,
            sub: CMS.get("chapters.chapter-3.stories")[9].extra1,
            cta: CMS.get("chapters.chapter-3.stories")[9].userInstruction
          }]
        }],
        news: [{
          layoutName: "newsMain",
          ui: NewsPageUI
        }],
        mission: [{
          layoutName: "aboutMain",
          height: 1
        }],
        menu: [{
          layout: MenuSection,
          ui: MenuUI
        }],
        error: [{
          layout: ErrorSection,
          ui: ErrorUI
        }],
        privacy: [{
          layoutName: "privacySection",
          ui: PrivacyUI
        }],
        contact: [{
          layout: ContactSection,
          ui: ContactUI
        }],
        newsDetail: [{
          layoutName: "newsDetail",
          ui: NewsDetailUI
        }]
      };
      Config.TECHNOLOGY = {
        section1: {
          bg: "black",
          data: {
            text1: `${CMS.get("technology.landing").title}`.replace(/<br>/g, "\n")
          }
        },
        section2: {
          bg: "beige",
          data: {
            text1: CMS.get("technology.titan-fuel-forge").textItems.subhead.value,
            text2: CMS.get("technology.titan-fuel-forge").title.replace(/<br>/g, "\n"),
            text3: CMS.get("technology.titan-fuel-forge").longTextItems.bodycopy1.value.replace(/<br>/g, "\n"),
            text4: CMS.get("technology.titan-fuel-forge").longTextItems.bodycopy2.value.replace(/<br>/g, "\n")
          }
        },
        section3: {
          bg: "black",
          data: {
            text1: CMS.get("technology.carbon-salvage").title.replace(/<br>/g, "\n"),
            text2: CMS.get("technology.carbon-salvage").longTextItems.bodycopy1.value.replace(/<br>/g, "\n")
          }
        },
        section4: {
          bg: "beige",
          data: {
            text1: CMS.get("technology.charging").title.replace(/<br>/g, "\n"),
            text2: CMS.get("technology.charging").longTextItems.bodycopy1.value.replace(/<br>/g, "\n"),
            text3: CMS.get("technology.charging").longTextItems.bodycopy2.value.replace(/<br>/g, "\n")
          }
        },
        section5: {
          bg: "black",
          data: {
            text1: CMS.get("technology.molecular-sorting").title.replace(/<br>/g, "\n"),
            text2: CMS.get("technology.molecular-sorting").longTextItems.bodycopy1.value.replace(/<br>/g, "\n")
          }
        },
        section6: {
          bg: "beige",
          data: {
            text1: CMS.get("technology.custom-assembly").title.replace(/<br>/g, "\n"),
            text2: CMS.get("technology.custom-assembly").longTextItems.bodycopy1.value.replace(/<br>/g, "\n")
          }
        }
      };
      Config.CONTACT = {
        header: CMS.get("contact.formHeader"),
        success: CMS.get("contact.success"),
        description: CMS.get("contact.disclaimer"),
        emailError: "Please verify your email address and try again",
        generalError: CMS.get("contact.error"),
        title: CMS.get("contact.title")
      };
      _this.dataReady = true;
    })();
  }, "static");
  window.ASSETS = ["assets/js/lib/_draco/draco_decoder.js", "assets/js/lib/_draco/draco_decoder.wasm", "assets/js/lib/_draco/draco_wasm_wrapper.js", "assets/js/lib/basis_transcoder.js", "assets/js/lib/basis_transcoder.wasm", "assets/js/lib/firebase-app.js", "assets/js/lib/firebase-auth.js", "assets/js/lib/firebase-database.js", "assets/js/lib/firebase-storage.js", "assets/js/lib/quill.js", "assets/js/lib/video.min.js", "assets/data/bouncingcube-baked.json", "assets/data/test/bouncingcube-baked.json", "assets/data/test/timeline-baked.json", "assets/data/test/toggle_test-baked.json", "assets/data/timeline-baked.json", "assets/data/timeline-ch3caravan_theatre.json", "assets/data/timeline-ch3ending_theatre.json", "assets/data/timeline-ch3endingsplit_theatre.json", "assets/data/timeline-ch3landing_theatre.json", "assets/data/timeline-ch3newlanding_theatre.json", "assets/data/timeline-ch3shipping_theatre.json", "assets/data/uil.1740684676441.json", "assets/shaders/compiled.1740684676441.vs"];
  ASSETS.SW = ["assets/fonts/FuturaLT-Bold.json", "assets/fonts/FuturaLT-Bold.png", "assets/fonts/FuturaLT-Bold.ttf", "assets/fonts/FuturaLT-Book.json", "assets/fonts/FuturaLT-Book.otf", "assets/fonts/FuturaLT-Book.png", "assets/fonts/FuturaLT-Heavy.json", "assets/fonts/FuturaLT-Heavy.png", "assets/fonts/FuturaLT-Heavy.ttf", "assets/fonts/FuturaLT-Light.json", "assets/fonts/FuturaLT-Light.otf", "assets/fonts/FuturaLT-Light.png", "assets/fonts/FuturaLT-Medium.json", "assets/fonts/FuturaLT-Medium.png", "assets/fonts/FuturaLT-Medium.ttf", "assets/fonts/marscondensed-regular-TRIAL.json", "assets/fonts/marscondensed-regular-TRIAL.otf", "assets/fonts/marscondensed-regular-TRIAL.png", "assets/fonts/marscondensedweb-regular-TRIAL.eot", "assets/fonts/marscondensedweb-regular-TRIAL.woff", "assets/fonts/marsextended-regular-TRIAL.json", "assets/fonts/marsextended-regular-TRIAL.otf", "assets/fonts/marsextended-regular-TRIAL.png", "assets/fonts/marsextendedweb-regular-TRIAL.eot", "assets/fonts/marsextendedweb-regular-TRIAL.woff", "assets/css/style-scss.css", "assets/css/style.css", "assets/css/video-js.min.css", "assets/js/app.1740684676441.js"];
  Class(function Config() {
    Inherit(this, Model);
    this.ANALYTICS_ID = "UA-160159103-1";
    this.ENV = window._CONFIG_ && window._CONFIG_.ENV;
    this.CMS = window._CONFIG_ && window._CONFIG_.CMS;
    this.API = window._CONFIG_ && window._CONFIG_.API;
    this.NEWSLETTER_URL = "https://prometheus-website-at.uc.r.appspot.com/newsletter";
    this.SCROLL_PAGE_OFFSET = Device.mobile ? 0 : 12;
  }, "static");
  Mobile.Class(function Accelerometer() {
    var _this = this;
    function updateAccel(e) {
      switch (window.orientation) {
        case 0:
          _this.x = -e.accelerationIncludingGravity.x;
          _this.y = e.accelerationIncludingGravity.y;
          _this.z = e.accelerationIncludingGravity.z;
          if (e.rotationRate) {
            _this.rotationRate.alpha = e.rotationRate.beta * _this.toRadians;
            _this.rotationRate.beta = -e.rotationRate.alpha * _this.toRadians;
            _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
          }
          break;
        case 180:
          _this.x = e.accelerationIncludingGravity.x;
          _this.y = -e.accelerationIncludingGravity.y;
          _this.z = e.accelerationIncludingGravity.z;
          if (e.rotationRate) {
            _this.rotationRate.alpha = -e.rotationRate.beta * _this.toRadians;
            _this.rotationRate.beta = e.rotationRate.alpha * _this.toRadians;
            _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
          }
          break;
        case 90:
          _this.x = e.accelerationIncludingGravity.y;
          _this.y = e.accelerationIncludingGravity.x;
          _this.z = e.accelerationIncludingGravity.z;
          if (e.rotationRate) {
            _this.rotationRate.alpha = e.rotationRate.alpha * _this.toRadians;
            _this.rotationRate.beta = e.rotationRate.beta * _this.toRadians;
            _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
          }
          break;
        case -90:
          _this.x = -e.accelerationIncludingGravity.y;
          _this.y = -e.accelerationIncludingGravity.x;
          _this.z = e.accelerationIncludingGravity.z;
          if (e.rotationRate) {
            _this.rotationRate.alpha = -e.rotationRate.alpha * _this.toRadians;
            _this.rotationRate.beta = -e.rotationRate.beta * _this.toRadians;
            _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
          }
      }
      if (Device.system.os == "android") {
        _this.x *= -1;
        _this.y *= -1;
        _this.z *= -1;
      }
    }
    function updateOrientation(e) {
      for (var key in e) {
        if (key.toLowerCase().includes("heading")) {
          _this.heading = e[key];
        }
      }
      switch (window.orientation) {
        case 0:
          _this.alpha = e.beta * _this.toRadians;
          _this.beta = -e.alpha * _this.toRadians;
          _this.gamma = e.gamma * _this.toRadians;
          break;
        case 180:
          _this.alpha = -e.beta * _this.toRadians;
          _this.beta = e.alpha * _this.toRadians;
          _this.gamma = e.gamma * _this.toRadians;
          break;
        case 90:
          _this.alpha = e.alpha * _this.toRadians;
          _this.beta = e.beta * _this.toRadians;
          _this.gamma = e.gamma * _this.toRadians;
          break;
        case -90:
          _this.alpha = -e.alpha * _this.toRadians;
          _this.beta = -e.beta * _this.toRadians;
          _this.gamma = e.gamma * _this.toRadians;
      }
      _this.tilt = e.beta * _this.toRadians;
      _this.yaw = e.alpha * _this.toRadians;
      _this.roll = -e.gamma * _this.toRadians;
      if (Device.system.os == "android") {
        _this.heading = function compassHeading(alpha, beta, gamma) {
          var degtorad = Math.PI / 180;
          var _x = beta ? beta * degtorad : 0;
          var _y = gamma ? gamma * degtorad : 0;
          var _z = alpha ? alpha * degtorad : 0;
          Math.cos(_x);
          var cY = Math.cos(_y);
          var cZ = Math.cos(_z);
          var sX = Math.sin(_x);
          var sY = Math.sin(_y);
          var sZ = Math.sin(_z);
          var Vx = -cZ * sY - sZ * sX * cY;
          var Vy = -sZ * sY + cZ * sX * cY;
          var compassHeading = Math.atan(Vx / Vy);
          if (Vy < 0) {
            compassHeading += Math.PI;
          } else if (Vx < 0) {
            compassHeading += Math.PI * 2;
          }
          return compassHeading * (180 / Math.PI);
        }(e.alpha, e.beta, e.gamma);
      }
    }
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.alpha = 0;
    this.beta = 0;
    this.gamma = 0;
    this.heading = 0;
    this.rotationRate = {};
    this.rotationRate.alpha = 0;
    this.rotationRate.beta = 0;
    this.rotationRate.gamma = 0;
    this.toRadians = Device.system.os == "ios" ? Math.PI / 180 : 1;
    this.capture = function () {
      if (!this.active) {
        this.active = true;
        if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission == "function") {
          DeviceMotionEvent.requestPermission().then(permissionState => {
            if (permissionState === "granted") {
              window.addEventListener("devicemotion", updateAccel);
            }
          }).catch(console.error);
        } else {
          window.addEventListener("devicemotion", updateAccel);
        }
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission == "function") {
          DeviceOrientationEvent.requestPermission().then(permissionState => {
            if (permissionState === "granted") {
              window.addEventListener("deviceorientation", updateOrientation);
            }
          }).catch(console.error);
        } else {
          window.addEventListener("deviceorientation", updateOrientation);
        }
      }
    };
    this.stop = function () {
      this.active = false;
      window.ondevicemotion = null;
      _this.x = _this.y = _this.z = 0;
      window.removeEventListener("deviceorientation", updateOrientation);
    };
  }, "Static");
  Class(function Antimatter(_num, _config, _renderer = World.RENDERER) {
    Inherit(this, AntimatterFBO);
    var _geometry;
    var _this = this;
    var _drawLimit = _num;
    var _size = function findSize() {
      if (_config.pot) {
        return Math.pow(2, Math.ceil(Math.log(Math.sqrt(_num)) / Math.log(2)));
      } else {
        return Math.ceil(Math.sqrt(_num));
      }
    }();
    async function createBuffer() {
      let {
        geometry: geometry,
        vertices: vertices,
        attribs: attribs,
        usedDepth: usedDepth
      } = await AntimatterUtil.createBufferArray(_size, _num, _config);
      _this.vertices = _this.cloneVertices ? vertices.clone() : vertices;
      (_geometry = geometry.clone(true)).drawRange.end = _drawLimit;
      _this.vertices.geometry = _geometry;
      _this.attribs = _this.random = attribs;
      _this.textureUsedDepth = usedDepth;
      _this.init(_geometry, _renderer, _size);
    }
    defer(createBuffer);
    this.createFloatArray = function (components = 3) {
      return new Float32Array(_size * _size * components);
    };
    this.createFloatArrayAsync = async function (components = 3, freshCopy) {
      let {
        array: array
      } = await AntimatterUtil.createFloatArray(_size * _size * components, freshCopy);
      return array;
    };
    this.ready = function (callback) {
      return _this.wait(_this, "vertices");
    };
    this.useShader = function (vs, fs, params) {
      if (typeof fs == "object") {
        params = fs;
        fs = null;
      }
      this.vertexShader = vs;
      this.fragmentShader = fs || vs;
      this.uniforms = params;
    };
    this.createMesh = this.getMesh = function () {
      let shader = _this.createShader(_this.fragmentShader || "AntimatterBasicFrag");
      _this.mesh = new Points(_geometry, shader);
      _this.mesh.frustumCulled = false;
      _this.shader = shader;
      _this.geometry = _geometry;
      return _this.mesh;
    };
    this.createShader = function (fs) {
      let uniforms = _this.uniforms || {};
      let obj = {
        tPos: {
          type: "t",
          value: _this.vertices.texture,
          ignoreUIL: true
        },
        tPrevPos: {
          type: "t",
          value: _this.vertices.texture,
          ignoreUIL: true
        }
      };
      for (let key in uniforms) {
        obj[key] = uniforms[key];
      }
      let shader = new Shader(_this.vertexShader || "AntimatterPosition", fs, obj);
      let vs = shader.vertexShader;
      if (vs && !vs.includes("uniform sampler2D tPos")) {
        let split = vs.split("__ACTIVE_THEORY_LIGHTS__");
        let defined = "uniform sampler2D tPos;";
        shader.vertexShader = split[0] + "\n" + defined + "\n__ACTIVE_THEORY_LIGHTS__\n" + split[1];
      }
      return shader;
    };
    this.getLookupArray = function () {
      return new Float32Array(_this.vertices.geometry.attributes.position.array);
    };
    this.getRandomArray = function () {
      return _geometry.attributes.random.array;
    };
    this.overrideShader = function (original) {
      let shader = original.clone();
      original.copyUniformsTo(shader);
      shader.uniforms.tPos = {
        type: "t",
        value: _this.vertices.texture,
        ignoreUIL: true
      };
      shader.uniforms.tPrevPos = {
        type: "t",
        value: _this.vertices.texture,
        ignoreUIL: true
      };
      _this.shader = shader;
      _this.mesh.shader = shader;
    };
    this.upload = async function (needsMesh) {
      _this.preventRender = true;
      _geometry.distributeBufferData = true;
      await _this.ready();
      await _this.vertices.uploadAsync();
      await defer();
      await _this.random.uploadAsync();
      await defer();
      if (_this.mesh && needsMesh) {
        _this.mesh.upload();
        await _geometry.uploadBuffersAsync();
      }
      for (let key in _this.shader.uniforms) {
        let uniform = _this.shader.uniforms[key];
        if (uniform.value) {
          if (uniform.value.uploadAsync) {
            await uniform.value.uploadAsync();
          } else if (uniform.value.upload) {
            uniform.value.upload();
            await defer();
          }
        }
      }
      await _this.wait(100);
      for (let i = 0; i < _this.passes.length; i++) {
        await _this.passes[i].upload();
      }
      _this.preventRender = false;
    };
    this.uploadSync = async function (needsMesh) {
      await _this.ready();
      if (_this.customClass && _this.customClass.loaded) {
        await _this.customClass.loaded();
      }
      if (_this.mesh && needsMesh) {
        _this.mesh.upload();
      }
      for (let i = 0; i < 4; i++) {
        _this.update();
      }
    };
    this.get("particleCount", _ => _num);
    this.get("textureSize", _ => _size);
    this.get("powerOf2", _ => Math.pow(2, Math.ceil(Math.log(Math.sqrt(_num)) / Math.log(2))));
  });
  Class(function AntimatterAttribute(_data, _components) {
    Inherit(this, Component);
    var _this = this;
    var _size = Math.sqrt(_data.length / (_components || 3));
    this.size = _size;
    this.count = _size * _size;
    this.buffer = _data;
    this.texture = new DataTexture(_data, _size, _size, _components == 4 ? Texture.RGBAFormat : Texture.RGBFormat, Texture.FLOAT);
    this.set("needsUpdate", function () {
      if (_this.texture) {
        _this.texture.needsUpdate = true;
      }
    });
    this.bufferData = function (data, components) {
      _this.buffer = data;
      if (components != _components) {
        _this.texture.destroy();
        _this.texture = new DataTexture(data, _size, _size, components == 4 ? Texture.RGBAFormat : Texture.RGBFormat, Texture.FLOAT);
      } else {
        _this.texture.data = data;
        _this.texture.needsUpdate = true;
      }
      _components = components;
      _data = data;
    };
    this.upload = function () {
      _this.texture.upload();
    };
    this.uploadAsync = function () {
      _this.texture.distributeTextureData = true;
      _this.texture.upload();
      return _this.texture.uploadAsync();
    };
    this.clone = function () {
      return new AntimatterAttribute(_data, _components);
    };
    this.onDestroy = function () {
      if (_this.texture && _this.texture.destroy) {
        _this.texture.destroy();
      }
    };
  });
  Class(function AntimatterFBO() {
    var _this;
    var _gpuGeom;
    var _renderer;
    var _size;
    var _prevRT;
    var _scene;
    var _mesh;
    var _camera;
    var _copy;
    var _geometry;
    Inherit(this, Component);
    var _output = {
      type: "t",
      value: null,
      ignoreUIL: true
    };
    var _prevOutput = {
      type: "t",
      value: null,
      ignoreUIL: true
    };
    function copy(input, output) {
      if (!World.RENDERER.blit(input, output)) {
        _copy.visible = true;
        _mesh.visible = false;
        _copy.shader.uniforms.tMap.value = input;
        _renderer.renderSingle(_copy, _camera, output);
        _copy.visible = false;
        _mesh.visible = true;
      }
    }
    this.passes = [];
    this.init = function (geometry, renderer, size) {
      _this = this;
      _gpuGeom = geometry.attributes.position.array;
      _renderer = renderer;
      _size = size;
      (function initPasses() {
        _camera = World.CAMERA;
        _geometry = World.QUAD;
        _scene = new Scene();
        (_mesh = new Mesh(_geometry, null)).frustumCulled = false;
        _mesh.noMatrices = true;
        _mesh.transient = true;
        _scene.add(_mesh);
        let copyShader = AntimatterFBO.getCopyShader();
        (_copy = new Mesh(_geometry, copyShader)).noMatrices = true;
        _scene.add(_copy);
        _copy.visible = false;
      })();
    };
    this.getGPUGeom = function () {
      return _gpuGeom;
    };
    this.addPass = function (pass, index) {
      _this = this;
      if (!pass.init) {
        pass.initialize(_size);
      }
      if (typeof index != "number") {
        _this.passes.push(pass);
      } else {
        _this.passes.splice(index, 0, pass);
      }
    };
    this.findPass = function (name) {
      _this = this;
      for (var i = 0; i < _this.passes.length; i++) {
        var pass = _this.passes[i];
        if (pass.name == name) {
          return pass;
        }
      }
    };
    this.removePass = function (pass) {
      _this = this;
      if (typeof pass == "number") {
        _this.passes.splice(pass);
      } else {
        _this.passes.remove(pass);
      }
    };
    this.update = function () {
      if ((_this = this).mesh && !_this.preventRender) {
        var output = _output.value || _this.vertices.texture;
        if (_this.storeVelocity) {
          if (_prevRT) {
            copy(_output.value, _prevRT);
            _prevOutput.value = _prevRT;
          } else {
            _prevOutput.value = output;
            (_prevRT = _this.passes[0].getRT(0).clone()).upload();
          }
        }
        for (var i = 0; i < _this.passes.length; i++) {
          var pass = _this.passes[i];
          var needsInit = !pass.init;
          var firstRender = !pass.first;
          if (needsInit) {
            pass.initialize(_size);
          }
          pass.first = true;
          _mesh.shader = pass.shader;
          _mesh.shader.uniforms.tInput.value = firstRender ? _this.vertices.texture : pass.output;
          if (!pass.ready) {
            _mesh.shader.uniforms.tInput.value = _this.vertices.texture;
          }
          var rt = firstRender ? pass.getRT(0) : pass.getWrite();
          output = pass.output;
          _renderer.renderSingle(_scene.children[0], _camera, rt);
          copy(rt, output);
          pass.swap();
        }
        if (output) {
          _output.value = output;
          _this.mesh.shader.uniforms.tPos.value = _output.value;
          _this.mesh.shader.uniforms.tPrevPos.value = _prevOutput.value;
        }
      }
    };
    this.onDestroy = function () {
      if (_this.vertices && _this.vertices.destroy) {
        _this.vertices.destroy();
      }
      if (_this.attribs && _this.attribs.destroy) {
        _this.attribs.destroy();
      }
      _this.passes.forEach(function (pass) {
        pass.first = false;
        if (!_this.persistPasses) {
          if (pass && pass.destroy) {
            pass.destroy();
          }
        }
      });
      _this.mesh.destroy();
    };
    this.getOutput = function () {
      return _output;
    };
    this.getPrevOutput = function () {
      return _prevOutput;
    };
  }, function () {
    var _shader;
    AntimatterFBO.getCopyShader = function () {
      if (!_shader) {
        (_shader = new Shader("ScreenQuad")).addUniforms({
          tMap: {
            type: "t",
            value: null
          }
        });
        _shader._attachmentData = {
          format: Texture.RGBAFormat,
          type: Texture.FLOAT,
          attachments: 1
        };
      }
      return _shader;
    };
  });
  Class(function AntimatterPass(_shader, _uni, _clone) {
    var _this = this;
    this.UILPrefix = "am_" + _shader;
    const _uniforms = {
      tInput: {
        type: "t",
        value: null,
        ignoreUIL: true
      },
      fSize: {
        type: "f",
        value: 64,
        ignoreUIL: true
      }
    };
    var _rts = [];
    var _read = 0;
    var _write = 0;
    function prepareShader(code, type) {
      if (type == "vs") {
        return code;
      }
      let header = ["uniform sampler2D tInput;", "uniform float fSize;", "varying vec2 vUv;", Shaders.getShader("antimatter.glsl")].join("\n");
      let mainAt = code.indexOf("void main()");
      let before = code.slice(0, mainAt);
      let after = code.slice(mainAt);
      code = before + header + after;
      if (_this.onCreateShader) {
        code = _this.onCreateShader(code);
      }
      return code;
    }
    function initRT(size) {
      var type = Device.system.os == "ios" ? Texture.HALF_FLOAT : Texture.FLOAT;
      var parameters = {
        minFilter: Texture.NEAREST,
        magFilter: Texture.NEAREST,
        format: Texture.RGBAFormat,
        type: type
      };
      var rt = new RenderTarget(size, size, parameters);
      rt.texture.generateMipmaps = false;
      return rt;
    }
    this.uniforms = _uniforms;
    this.output = initRT(64);
    this.name = _shader;
    this.id = Utils.timestamp();
    this.ready = false;
    (function () {
      if (_uni) {
        if (_uni.unique) {
          _this.UILPrefix += "_" + _uni.unique.replace("/", "_");
          delete _uni.unique;
        }
        if (_uni.customCompile) {
          _this.customCompile = _uni.customCompile || "";
          delete _uni.customCompile;
        }
        for (var key in _uni) {
          _uniforms[key] = _uni[key];
        }
      }
    })();
    this.addInput = function (name, attribute) {
      var uniform = typeof attribute != "object" || attribute.height || typeof attribute.type != "string" ? attribute instanceof AntimatterAttribute ? {
        type: "t",
        value: attribute.texture,
        ignoreUIL: true
      } : attribute instanceof AntimatterPass ? {
        type: "t",
        value: attribute.output,
        ignoreUIL: true
      } : {
        type: "t",
        value: attribute,
        ignoreUIL: true
      } : attribute;
      let lookup = UILStorage.parse(_this.UILPrefix + name);
      if (lookup) {
        uniform.value = lookup.value;
      }
      let uniforms = _shader && _shader.uniforms ? _shader.uniforms : _uniforms;
      uniforms[name] = uniform;
      uniform.ignoreUIL = true;
      return uniforms[name];
    };
    this.addUniforms = function (object) {
      let uniforms = _shader && _shader.uniforms ? _shader.uniforms : _uniforms;
      for (let key in object) {
        let uniform = object[key];
        let lookup = UILStorage.parse(_this.UILPrefix + key);
        if (lookup) {
          if (Array.isArray(lookup.value)) {
            switch (lookup.value.length) {
              case 2:
                lookup.value = new Vector2().fromArray(lookup.value);
                break;
              case 3:
                lookup.value = new Vector3().fromArray(lookup.value);
                break;
              case 4:
                lookup.value = new Vector4().fromArray(lookup.value);
            }
          }
          uniform.value = lookup.value;
        }
        uniforms[key] = uniform;
      }
    };
    this.getRT = function (index) {
      return _rts[index];
    };
    this.getRead = function () {
      return _rts[_read];
    };
    this.getWrite = function () {
      return _rts[_write];
    };
    this.setRead = function (index) {
      _read = index;
    };
    this.setWrite = function (index) {
      _write = index;
    };
    this.swap = function () {
      if (++_write > 2) {
        _write = 0;
        _this.ready = true;
      }
      if (++_read > 2) {
        if (_this.onInit) {
          _this.onInit();
          _this.onInit = null;
        }
        _read = 0;
      }
    };
    this.initialize = function (size) {
      if (!_this.init) {
        _this.init = true;
        for (var i = 0; i < 3; i++) {
          _rts.push(initRT(size));
        }
        _this.output.setSize(size, size);
        if (!(_shader instanceof Shader)) {
          (_shader = new Shader("AntimatterPass", _shader, {
            customCompile: _this.customCompile
          }))._attachmentData = {
            format: Texture.RGBAFormat,
            type: Texture.FLOAT,
            attachments: 1
          };
          _shader.preCompile = prepareShader;
          _shader.addUniforms(_uniforms);
          _this.uniforms = _shader.uniforms;
          _shader.UILPrefix = _this.UILPrefix;
          _shader.id = Utils.timestamp();
        }
        _this.shader = _shader;
        _shader.uniforms.fSize.value = size;
      }
    };
    this.setUniform = function (key, value) {
      _uniforms[key] ||= {
        value: value
      };
      _uniforms[key].value = value;
      if (_shader && _shader.uniforms) {
        _shader.uniforms[key].value = value;
      }
    };
    this.getUniform = function (key) {
      if (_shader && _shader.uniforms) {
        return _shader.uniforms[key].value;
      } else {
        return null;
      }
    };
    this.tween = function (key, value, time, ease, delay, callback, update) {
      return tween(_shader.uniforms[key], {
        value: value
      }, time, ease, delay, callback, update);
    };
    this.clone = function () {
      return new AntimatterPass(_shader, _uni);
    };
    this.destroy = function () {
      _rts.forEach(function (rt) {
        if (rt && rt.destroy) {
          rt.destroy();
        }
      });
    };
    this.upload = async function () {
      _shader.upload();
      await defer();
      for (let i = 0; i < _rts.length; i++) {
        _rts[i].upload();
        await defer();
      }
      for (let key in _shader.uniforms) {
        let uniform = _shader.uniforms[key];
        if (uniform.value) {
          if (uniform.value.uploadAsync) {
            await uniform.value.uploadAsync();
          } else if (uniform.value.upload) {
            uniform.value.upload();
            await defer();
          }
        }
      }
    };
  });
  Class(function AntimatterSpawn(_proton, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _life;
    var _pass;
    var _velocity;
    var _color;
    var _index = -1;
    var _total = _proton.particleCount;
    var _releasedA = [];
    var _releasedB = [];
    var _temp0 = [];
    var _temp1 = [];
    var _temp2 = [];
    var _vec = new Vector3();
    function loop() {
      let count = _releasedA.length;
      for (let i = count - 1; i > -1; i--) {
        let index = _releasedA[i];
        _life.buffer[index * 4 + 0] = 0;
      }
      _releasedA.length = 0;
      if (count) {
        _life.needsUpdate = true;
      }
      let hold = _releasedA;
      _releasedA = _releasedB;
      _releasedB = hold;
    }
    (async function () {
      await async function initPass() {
        let [lifeBuffer, velocityBuffer] = await Promise.all([_proton.antimatter.createFloatArrayAsync(4, true), _proton.antimatter.createFloatArrayAsync(3, true)]);
        _life = _this.initClass(AntimatterAttribute, lifeBuffer, 4);
        _velocity = _this.initClass(AntimatterAttribute, velocityBuffer, 3);
        _pass = _this.initClass(AntimatterPass, "AntimatterSpawn", {
          unique: _input.prefix,
          uMaxCount: _proton.behavior.uniforms.uMaxCount,
          tAttribs: _proton.behavior.uniforms.tAttribs,
          tLife: {
            value: _life,
            ignoreUIL: true
          },
          uSetup: {
            value: 1,
            ignoreUIL: true
          },
          decay: {
            value: 1
          },
          HZ: {
            value: Render.HZ_MULTIPLIER,
            ignoreUIL: true
          },
          decayRandom: {
            value: new Vector2(1, 1)
          }
        });
        ShaderUIL.add(_pass, _group).setLabel("Life Shader");
        _pass.onInit = _ => {
          _pass.setUniform("uSetup", 0);
          _this.canEmit = true;
        };
        _proton.behavior.addInput("tSpawn", _pass);
        _proton.behavior.addInput("tVelocity", _velocity);
        _proton.shader.addUniforms({
          tLife: {
            value: _pass.output
          }
        });
        _proton.antimatter.addPass(_pass, 0);
        _this.lifeOutput = _pass.output;
      }();
      _this.startRender(loop);
    })();
    this.emit = function (position, velocity, color) {
      if (!_this.canEmit) {
        return;
      }
      if (velocity && position.length != velocity.length) {
        throw "Position and velocity need to be the same length";
      }
      if (color && position.length != color.length) {
        throw "Position and color need to be the same length";
      }
      let count = position.length / 3;
      for (let i = 0; i < count; i++) {
        let index = ++_index;
        if (_index >= _total) {
          _index = -1;
        }
        _life.buffer[index * 4 + 0] = 1;
        _life.buffer[index * 4 + 1] = position[i * 3 + 0];
        _life.buffer[index * 4 + 2] = position[i * 3 + 1];
        _life.buffer[index * 4 + 3] = position[i * 3 + 2];
        if (velocity) {
          _velocity.buffer[index * 3 + 0] = velocity[i * 3 + 0];
          _velocity.buffer[index * 3 + 1] = velocity[i * 3 + 1];
          _velocity.buffer[index * 3 + 2] = velocity[i * 3 + 2];
        }
        if (color && _color) {
          _color.buffer[index * 3 + 0] = color[i * 3 + 0];
          _color.buffer[index * 3 + 1] = color[i * 3 + 1];
          _color.buffer[index * 3 + 2] = color[i * 3 + 2];
        }
        _releasedB.push(index);
      }
      _life.needsUpdate = true;
      if (velocity) {
        _velocity.needsUpdate = true;
      }
      if (color && _color) {
        _color.needsUpdate = true;
      }
    };
    this.release = function (pos, count = 1, radius = 0, velocity, color) {
      if (!_this.canEmit) {
        return;
      }
      let positions = _temp0;
      let velocities = velocity ? _temp1 : null;
      let colors = color ? _temp2 : null;
      let radX = Array.isArray(radius) ? radius[0] : radius;
      let radY = Array.isArray(radius) ? radius[1] : radius;
      let radZ = Array.isArray(radius) ? radius[2] : radius;
      for (let i = 0; i < count; i++) {
        if (pos.spherical) {
          _vec.set(Math.random(-1, 1, 4), Math.random(-1, 1, 4), Math.random(-1, 1, 4)).normalize().multiplyScalar(radX);
          positions[i * 3 + 0] = pos.x + _vec.x;
          positions[i * 3 + 1] = pos.y + _vec.y;
          positions[i * 3 + 2] = pos.z + _vec.z;
        } else {
          positions[i * 3 + 0] = pos.x + Math.random(-1, 1, 4) * radX;
          positions[i * 3 + 1] = pos.y + Math.random(-1, 1, 4) * radY;
          positions[i * 3 + 2] = pos.z + Math.random(-1, 1, 4) * radZ;
        }
        if (velocities) {
          velocities[i * 3 + 0] = velocity.x;
          velocities[i * 3 + 1] = velocity.y;
          velocities[i * 3 + 2] = velocity.z;
        }
        if (colors) {
          colors[i * 3 + 0] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
        }
      }
      _this.emit(positions, velocities, colors);
      _temp0.length = 0;
      _temp1.length = 0;
      _temp2.length = 0;
    };
    this.upload = async function () {
      await _life?.uploadAsync();
      await _velocity?.uploadAsync();
    };
    this.useColor = async function (shader) {
      let colorBuffer = await _proton.antimatter.createFloatArrayAsync(3, true);
      _color = _this.initClass(AntimatterAttribute, colorBuffer, 3);
      shader ||= _proton.shader;
      shader.addUniforms({
        tColor: {
          value: _color
        }
      });
      _proton.behavior.addInput("tColor", _color);
    };
    this.applyToShader = function (shader) {
      shader.uniforms.tLife = _proton.shader.uniforms.tLife;
      if (_velocity) {
        shader.uniforms.tVelocity = {
          value: _velocity
        };
      }
      if (_color) {
        shader.uniforms.tColor = {
          value: _color
        };
      }
    };
    this.ready = function () {
      return this.wait("canEmit");
    };
    this.get("total", _ => _total);
    this.get("index", _ => _index);
    this.set("index", i => _index = i);
  });
  Class(function AntimatterUtil() {
    Inherit(this, Component);
    var _thread;
    var _this = this;
    var _promises = {};
    function createBufferArrayAntimatter(e, id) {
      let size = e.size;
      let num = e.num;
      let position = new Float32Array(size * size * 3);
      if (window.NativeUtils) {
        NativeUtils.fillBufferUV(position, num, size);
      } else {
        let h = 0.5 / size;
        for (let i = 0; i < num; i++) {
          position[i * 3 + 0] = h + i % size / size;
          position[i * 3 + 1] = h + Math.floor(i / size) / size;
          position[i * 3 + 2] = i;
        }
      }
      let {
        w: w,
        h: h,
        d: d
      } = e.dimensions;
      let usedDepth = num / (size * size);
      let grid = w[0] == 0 && w[1] == 0 && h[0] == 0 && h[1] == 0;
      var vertices = new Float32Array(size * size * 4);
      if (window.NativeUtils) {
        if (grid) {
          NativeUtils.fillBufferGrid(vertices, num, size, usedDepth);
        } else {
          NativeUtils.fillBufferRange(vertices, num, w[0], w[1], h[0], h[1], d[0], d[1]);
        }
      } else {
        for (let i = 0; i < num; i++) {
          if (grid) {
            vertices[i * 4 + 0] = Math.range(i % size, 0, size, -1, 1);
            vertices[i * 4 + 1] = Math.range(i / size, size * usedDepth * usedDepth, 0, -1, 1);
          } else {
            vertices[i * 4 + 0] = Math.random(w[0], w[1], 10);
            vertices[i * 4 + 1] = Math.random(h[0], h[1], 10);
            vertices[i * 4 + 2] = Math.random(d[0], d[1], 10);
          }
          vertices[i * 4 + 3] = 1;
        }
      }
      var attribs = new Float32Array(size * size * 4);
      if (window.NativeUtils) {
        NativeUtils.fillBufferRandom(attribs, attribs.length);
      } else {
        for (let i = 0; i < num; i++) {
          attribs[i * 4 + 0] = Math.random(0, 1, 10);
          attribs[i * 4 + 1] = Math.random(0, 1, 10);
          attribs[i * 4 + 2] = Math.random(0, 1, 10);
          attribs[i * 4 + 3] = Math.random(0, 1, 10);
        }
      }
      resolve({
        geometry: position,
        vertices: vertices,
        attribs: attribs,
        usedDepth: usedDepth
      }, id, [position.buffer, vertices.buffer, attribs.buffer]);
    }
    function createFloatArrayAntimatter({
      size: size
    }, id) {
      let array = new Float32Array(size);
      resolve({
        array: array
      }, id, [array.buffer]);
    }
    this.cache = true;
    this.createBufferArray = function (size, num, config = {}) {
      let key;
      if (!_thread) {
        (function initThread() {
          _thread = true;
          Thread.upload(createBufferArrayAntimatter);
          Thread.upload(createFloatArrayAntimatter);
        })();
      }
      if (_this.cache && (key = `buffer_${JSON.stringify(config)}_${size}_${num}`, _promises[key])) {
        return _promises[key];
      }
      let promise = Promise.create();
      if (key) {
        _promises[key] = promise;
      }
      Thread.shared().createBufferArrayAntimatter({
        size: size,
        num: num,
        dimensions: config
      }).then(data => {
        data.attribs = new AntimatterAttribute(data.attribs, 4);
        data.vertices = new AntimatterAttribute(data.vertices, 4);
        let geometry = data.geometry;
        data.geometry = new Geometry();
        data.geometry.addAttribute("position", new GeometryAttribute(geometry, 3));
        data.geometry.addAttribute("random", new GeometryAttribute(data.attribs.buffer, 4));
        promise.resolve(data);
      });
      return promise;
    };
    this.createFloatArray = function (size, freshCopy) {
      if (freshCopy || !_this.cache) {
        return Thread.shared().createFloatArrayAntimatter({
          size: size
        });
      }
      if (_promises[`float_size${size}`]) {
        return _promises[`float_size${size}`];
      }
      return _promises[`float_size${size}`] = Thread.shared().createFloatArrayAntimatter({
        size: size
      });
    };
  }, "static");
  Class(function Audio3D(_options) {
    Inherit(this, Component);
    const _this = this;
    var _bindingLabel;
    const _config = require("Audio3DConfig");
    function onVisibility(e) {
      if (!_this.context || !GlobalAudio3D.blurs) {
        return;
      }
      let hasFocus = e.type === "focus";
      _this.context.visibilityMuted = !hasFocus;
      if (_this.context.playing || _this.flag("wasPlaying")) {
        if (hasFocus) {
          _this.flag("wasPlaying", false);
          _this.context.play();
        } else {
          _this.flag("wasPlaying", true);
          _this.context.pause();
        }
      }
    }
    (function initContext() {
      _options ||= {};
      if (GlobalAudio3D.native) {
        if (window._al) {
          _this.context = _this.initClass(Audio3DALBuffer);
        }
        if (window.AVFSound) {
          _this.context = _this.initClass(Audio3DNBuffer, "AVF");
        }
        if (window.MPAudio) {
          if (_options.stream) {
            _this.context = _this.initClass(Audio3DNBuffer, "MP");
          } else {
            _this.context = _this.initClass(Audio3DNBuffer, "GVR");
          }
        }
      } else if (_options.fallback || GlobalAudio3D.fallback) {
        _this.context = _this.initClass(Audio3DFallback);
      } else if (_options.positional && GlobalAudio3D.resonanceAudio) {
        _this.context = _this.initClass(Audio3DResonanceAudio);
      } else if (_options.simpleBuffer && Device.system.browser !== "ie") {
        _this.context = _this.initClass(Audio3DWASimpleBuffer);
      } else if (_options.stream !== true && Device.system.browser !== "ie") {
        _this.context = _this.initClass(Audio3DWABuffer);
      } else {
        _this.context = _this.initClass(Audio3DWAStream);
      }
    })();
    (function initInterface() {
      for (let command of _config.commands) {
        _this[command] = _this.context[command];
      }
      for (let setter of _config.setters) {
        _this.set(setter, e => {
          if (_this.context) {
            _this.context[setter] = e;
          }
        });
      }
      for (let getter of _config.getters) {
        _this.get(getter, _ => {
          if (_this.context) {
            return _this.context[getter];
          }
        });
      }
    })();
    (function addHandlers() {
      _this.events.sub(_this.context, Events.END, e => _this.events.fire(Events.END, e));
      _this.events.sub(_this.context, Events.LOADED, e => _this.events.fire(Events.LOADED, e));
      _this.events.sub(Events.VISIBILITY, onVisibility);
    })();
    (function initOptions() {
      if (_options) {
        for (let option in _options) {
          if (_config.setters.includes(option)) {
            _this.context[option] = _options[option];
          }
        }
        if (_options.label) {
          _bindingLabel = GlobalAudio3D.getLabelState(_options.label).bind("mute", async bool => {
            if (!_this.context) {
              return _bindingLabel.destroy();
            }
            _this.context.muted = bool;
          });
        }
      }
    })();
    this.tween = function () {
      return tween(_this, ...arguments);
    };
    this.clone = function () {
      return new Audio3D(_options);
    };
    this.onDestroy = function () {
      _this.context.unload();
      _bindingLabel?.destroy?.();
    };
  });
  Class(function Audio3DLayer(...args) {
    Inherit(this, Component);
    const _this = this;
    var _group;
    var _input;
    var _mesh;
    var _audio3D;
    var _config;
    var _key;
    var _autoplay;
    var _volume = {
      value: 0
    };
    var _captionsSetup = typeof CaptionsController != "undefined";
    async function fadeIn() {
      if (!_this.flag("init")) {
        await _this.wait("init");
      }
      let captionsPath = _config.get("captions");
      if (_captionsSetup && captionsPath && _config.get("enableCaptions")) {
        await async function loadCaptions(path) {
          await CaptionsController.instance().load(path);
        }(captionsPath);
      }
      let delay = _config.getNumber("delay");
      if (delay) {
        await _this.wait(delay);
      }
      _audio3D.play();
      if (_captionsSetup && captionsPath && _config.get("enableCaptions")) {
        toggleCaptions(true);
      }
      if (_config.getNumber("fadeInTime") != 0) {
        _volume.value = 0;
        _audio3D.volume = 0;
        let volumeTween = tween(_volume, {
          value: _config.getNumber("volume")
        }, _config.getNumber("fadeInTime"), "easeOutExpo");
        volumeTween.onUpdate(() => {
          _audio3D.volume = _volume.value;
        });
        await volumeTween.promise();
      }
    }
    async function fadeOut() {
      if (!_this.flag("init")) {
        await _this.wait("init");
      }
      if (_captionsSetup && _config.get("captions") && _config.get("enableCaptions")) {
        toggleCaptions(false);
      }
      if (_config.getNumber("fadeOutTime") != 0) {
        _volume.value = _config.getNumber("volume");
        let volumeTween = tween(_volume, {
          value: 0
        }, _config.getNumber("fadeOutTime"), "easeOutExpo", 0);
        volumeTween.onUpdate(() => {
          _audio3D.volume = _volume.value;
        });
        volumeTween.onComplete(() => {
          if (!_audio3D.context || !_audio3D.context.stream || !(Audio3DWA.getActiveStreamCount(_audio3D.context.stream) > 1)) {
            _audio3D.pause();
          }
        });
        await volumeTween.promise();
      } else {
        if (_audio3D.context && _audio3D.context.stream && Audio3DWA.getActiveStreamCount(_audio3D.context.stream) > 1) {
          return;
        }
        _audio3D.pause();
      }
    }
    function toggleCaptions(bool = false) {
      if (bool) {
        CaptionsController.instance().start();
      } else {
        CaptionsController.instance().stop();
      }
    }
    (function parseArgs() {
      args.forEach(arg => {
        switch (Utils.getConstructorName(arg)) {
          case "InputUILConfig":
            _input = arg;
            break;
          case "UILFolder":
            _group = arg;
            break;
          case "Mesh":
            _mesh = arg;
            _this.parent = _mesh;
            if (_mesh.audioCount) {
              _mesh.audioCount++;
            } else {
              _mesh.audioCount = 1;
            }
            if (!_mesh.findSound) {
              _mesh.shader.visible = false;
              _mesh.findSound = async function (key) {
                if (!Array.isArray(_mesh.scriptClass)) {
                  return _mesh.scriptClass;
                }
                for (let scriptClass of _mesh.scriptClass) {
                  if ((await scriptClass.key) == key) {
                    return scriptClass;
                  }
                }
              };
            }
        }
      });
      _this.visible = _input.get("visible");
    })();
    (function initConfig() {
      let config = InputUIL.create(_input.prefix + "audio3dLayer" + (_mesh ? _mesh.audioCount : ""), _group);
      config.add("path").add("key").add("label").addToggle("autoplay", false).addToggle("loop", false).addToggle("stream", false).addToggle("positional", false).addNumber("volume", 1).addNumber("rolloff", 1).addNumber("fadeInTime", 0).addNumber("fadeOutTime", 0).addNumber("delay", 0).addNumber("gain", 1).setLabel("Audio");
      config.addButton("preview", {
        label: "Preview",
        actions: [{
          title: "Play",
          callback: fadeIn
        }, {
          title: "Stop",
          callback: fadeOut
        }]
      });
      if (_captionsSetup) {
        config.add("captions").addToggle("enableCaptions", false);
      }
      config.onUpdate = key => {
        if (_audio3D) {
          switch (key) {
            case "autoplay":
            case "loop":
              _audio3D[key] = _config.get(key);
              break;
            case "volume":
            case "rolloff":
            case "gain":
              _audio3D[key] = _config.getNumber(key);
          }
        }
      };
      _config = config;
    })();
    (async function initAudio() {
      if (!GlobalAudio3D.initialized) {
        await GlobalAudio3D.interacted;
      }
      _key = _config.get("key");
      _autoplay = _config.get("autoplay");
      let path = _config.get("path");
      if (path) {
        _audio3D = _this.initClass(Audio3D, {
          src: path,
          autoplay: false,
          volume: _config.getNumber("volume"),
          loop: _config.get("loop"),
          stream: _config.get("stream"),
          positional: _config.get("positional"),
          label: _config.get("label"),
          rolloff: _config.getNumber("rolloff")
        });
        let gain = _config.get("gain");
        if (typeof gain == "string") {
          gain = Number(gain);
        }
        if (isFinite(gain)) {
          _audio3D.gain = gain;
        }
        if (_mesh) {
          _mesh.add(_audio3D.group);
        }
        _this.flag("init", true);
      }
    })();
    _this.startRender(() => {});
    this.get("audio", () => _audio3D);
    this.play = async function () {
      await fadeIn();
    };
    this.stop = async function () {
      await fadeOut();
    };
    this.get("key", async () => {
      await _this.wait("init");
      return _key;
    });
    _this.set("volume", volume => {
      _audio3D.volume = volume;
    });
    _this.set("rolloff", rolloff => {
      _audio3D.rolloff = rolloff;
    });
    this.onVisible = async function () {
      if (!_this.flag("init")) {
        await _this.wait("init");
      }
      if (_audio3D && _autoplay) {
        await fadeIn();
      }
    };
    this.onInvisible = async function () {
      if (!_this.flag("init")) {
        await _this.wait("init");
      }
      if (_audio3D) {
        await fadeOut();
      }
    };
  });
  Class(function GlobalAudio3D() {
    Inherit(this, Component);
    const _this = this;
    var _volume = 1;
    var _muted = false;
    var _blurs = true;
    var _playbackRate = 1;
    var _poolSize = 3;
    var _interacted = Promise.create();
    var _labelStates = {};
    function initInteraction(e) {
      if (!_this.initialized) {
        if (e && e.preventDefault) {
          e.preventDefault();
        }
        document.removeEventListener(Device.mobile ? "touchend" : "mouseup", initInteraction, {
          passive: false
        });
        if (typeof XRDeviceManager != "undefined") {
          _this.events.unsub(XRDeviceManager.SESSION_START, initInteraction);
        }
        Audio3DWA.createPool(_poolSize);
        Audio3DWA.purge();
        _this.initialized = true;
        _this.events.fire(Events.READY);
        _interacted.resolve();
      }
    }
    this.native = false;
    this.TRANSPARENT = 0;
    this.ACOUSTIC_CEILING_TILES = 1;
    this.BRICK_BARE = 2;
    this.BRICK_PAINTED = 3;
    this.CONCRETE_BLOCK_COARSE = 4;
    this.CONCRETE_BLOCK_PAINTED = 5;
    this.CURTAIN_HEAVY = 6;
    this.FIBER_GLASS_INSULATION = 7;
    this.GLASS_THICK = 8;
    this.GLASS_THIN = 9;
    this.GRASS = 10;
    this.LINOLEUM_ON_CONCRETE = 11;
    this.MARBLE = 12;
    this.METAL = 13;
    this.PARQUET_ON_CONCRETE = 14;
    this.PLASTER_ROUGH = 15;
    this.PLASTER_SMOOTH = 16;
    this.PLYWOOD_PANEL = 17;
    this.POLISHED_CONCRETE_OR_TILE = 18;
    this.SHEET_ROCK = 19;
    this.WATER_OR_ICE_SURFACE = 20;
    this.WOOD_CEILING = 21;
    this.WOOD_PANEL = 22;
    this.LOW = 0;
    this.MED = 1;
    this.HIGH = 2;
    this.RESONANCE_AUDIO = "resonance_audio";
    this.quality = this.HIGH;
    (async function () {
      await defer();
      if (window.AURA) {
        (function initNative() {
          _this.native = true;
          if (window._al) {
            Audio3DAL.init();
          }
          _this.initialized = true;
          _interacted.resolve();
        })();
      }
      (function initDebug() {
        if (Hydra.LOCAL && Utils.query("audioDebug")) {
          AudioNode.prototype.connect = (func = AudioNode.prototype.connect, function () {
            var target = arguments[0];
            (this.outputs ||= []).push(arguments[0]);
            (target.inputs ||= []).push(this);
            return func.apply(this, arguments);
          });
        }
        var func;
      })();
    })();
    this.set("volume", v => {
      _volume = v;
      _this.events.fire(Events.UPDATE, {
        volume: _volume
      });
    });
    this.get("volume", _ => _volume);
    this.set("muted", v => {
      _muted = v;
      _this.events.fire(Events.UPDATE, {
        muted: _muted
      });
    });
    this.get("muted", _ => _muted);
    this.set("blurs", v => {
      _blurs = v;
      _this.events.fire(Events.UPDATE, {
        blurs: _blurs
      });
    });
    this.get("blurs", _ => _blurs);
    this.set("playbackRate", v => {
      _playbackRate = v;
      _this.events.fire(Events.UPDATE, {
        playbackRate: _playbackRate
      });
    });
    this.get("playbackRate", _ => _playbackRate);
    this.get("pool", _ => _poolSize);
    this.set("pool", n => {
      _poolSize = n;
    });
    this.get("interacted", _ => _interacted);
    this.get("fallback", _ => Device.system.browser === "ie" && Device.system.browserVersion <= 11 || Device.system.os === "ios" && Device.system.version >= 13 && Device.system.version < 13.6);
    this.setup = function (type = "default") {
      if (Utils.query("muted") && Hydra.LOCAL) {
        _muted = true;
      }
      document.addEventListener(Device.mobile ? "touchend" : "mouseup", initInteraction, {
        passive: false
      });
      if (typeof XRDeviceManager != "undefined") {
        _this.events.sub(XRDeviceManager.SESSION_START, initInteraction);
      }
      if (type == "resonance_audio" && !_this.native && !_this.fallback) {
        _this.resonanceAudio = true;
        AssetLoader.loadAssets(["assets/js/lib/_resonance/resonance-audio.min.js"]);
      }
    };
    this.ready = function () {
      return _this.wait(_this, "initialized");
    };
    this.enableRoom = function (bool) {
      if (window.GVRAudio) {
        GVRAudio.enableRoom(bool);
      }
    };
    this.setRoomProperties = function (x, y, z, wall, ceiling, floor) {
      if (window.GVRAudio) {
        GVRAudio.setRoomProperties(x, y, z, wall, ceiling, floor);
      }
    };
    this.setRoomReverbAdjustments = function (gain, time, brightness) {
      if (window.GVRAudio) {
        GVRAudio.setRoomReverbAdjustments(gain, time, brightness);
      }
    };
    this.muteLabel = function (label) {
      _this.getLabelState(label).set("mute", true);
    };
    this.unmuteLabel = function (label) {
      _this.getLabelState(label).set("mute", false);
    };
    this.getLabelState = function (label) {
      _labelStates[label] ||= AppState.createLocal();
      return _labelStates[label];
    };
  }, "static");
  Module(function Audio3DConfig() {
    this.exports = {
      getters: ["playbackRate", "loop", "autoplay", "volume", "rolloff", "preload", "visibilityMuted", "selfDestruct", "src", "frequency", "group", "duration", "currentTime", "activity", "playing", "filter", "panner", "delay", "progress", "reverb", "gain", "sourceWidth", "directivitySharpness", "directivityAlpha"],
      setters: ["playbackRate", "loop", "autoplay", "volume", "rolloff", "preload", "visibilityMuted", "selfDestruct", "src", "gain", "sourceWidth", "directivitySharpness", "directivityAlpha"],
      commands: ["play", "pause", "stop", "seek", "load", "unload", "convolve"]
    };
  });
  Module(function Audio3DSilence() {
    this.exports = "data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAADAAAGhgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr///////////////////////////////////////////8AAAA5TEFNRTMuOThyAc0AAAAAAAAAABSAJAiqQgAAgAAABobxtI73AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uQxAACFEII9ACZ/sJZwWEoEb8w/////N//////JcxjHjf+7/v/H2PzCCFAiDtGeyBCIx7bJJ1mmEEMy6g8mm2c8nrGABB4h2Mkmn//4z/73u773R5qHHu/j/w7Kxkzh5lWRWdsifCkNAnY9Zc1HvDAhjhSHdFkHFzLmabt/AQxSg2wwzLhHIJOBnAWwVY4zrhIYhhc2kvhYDfQ4hDi2Gmh5KyFn8EcGIrHAngNgIwVIEMf5bzbAiTRoAD///8z/KVhkkWEle6IX+d/z4fvH3BShK1e5kmjkCMoxVmXhd4ROlTKo3iipasvTilY21q19ta30/v/0/idPX1v8PNxJL6ramnOVsdvMv2akO0iSYIzdJFirtzWXCZicS9vHqvSKyqm5XJBdqBwPxyfJdykhWTZ0G0ZyTZGpLKxsNwwoRhsx3tZfhwmeOBVISm3impAC/IT/8hP/EKEM1KMdVdVKM2rHV4x7HVXZvbVVKN/qq8CiV9VL9jjH/6l6qf7MBCjZmOqsAibjcP+qqqv0oxqpa/NVW286hPo1nz2L/h8+jXt//uSxCmDU2IK/ECN98KKtE5IYzNoCfbw+u9i5r8PoadUMFPKqWL4LK3T/LCraMSHGkW4bpLXR/E6LlHOVQxmslKVJ8IULktMN06N0FKCpHCoYsjC4F+Z0NVqdNFoGSTjSiyjzLdnZ2fNqTi2eHKONONKLMPMKLONKLMPQRJGlFxZRoKcJFAYEeIFiRQkUWUeYfef//Ko04soswso40UJAgMw8wosososy0EalnZyjQUGBRQGIFggOWUacWUeYmuadrZziQKKEgQsQLAhQkUJAgMQDghltLO1onp0cpkNInSFMqlYeSEJ5AHsqFdOwy1DA2sRmRJKxdKRfLhfLw5BzUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7ksRRA8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=";
  });
  Class(function Audio3DBase() {
    Inherit(this, Object3D);
    const _this = this;
    var _quaternion;
    var _euler;
    var _position = new Vector3();
    this.audioPosition = function () {
      return _position = _this.group._parent ? _this.group.getWorldPosition() : Audio3DWA.getCamera().getWorldPosition();
    };
    this.audioPositionInverse = function () {
      _position = _this.audioPosition();
      if (_this.group._parent) {
        _position.applyMatrix4(Audio3DWA.getCamera().matrixWorldInverse);
      }
      return _position;
    };
    this.audioOrientationInverse = function () {
      if (!_quaternion) {
        _quaternion = new Quaternion();
        _euler = new Euler();
      }
      if (_this.group.parent) {
        _this.group.getWorldQuaternion(_quaternion);
        _euler.setFromQuaternion(_quaternion);
      } else {
        _euler.set(0, 0, 0);
      }
      return _euler;
    };
    this.listenerPosition = function () {
      if (_this.group._parent) {
        _position = Audio3DWA.getCamera().getWorldPosition();
      }
      return _position;
    };
  });
  Class(function Audio3DFallback() {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _stream;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _currentTime = 0;
    function initOptions() {
      _options.loop = _options.loop || false;
      _options.autoplay = _options.autoplay || false;
      _options.volume = _options.volume === undefined ? 1 : _options.volume;
      _options.playbackRate = _options.playbackRate || 1;
      _options.preload = _options.preload || false;
      _options.muted = _options.muted || false;
      _options.rolloff = _options.rolloff || 1;
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.playbackRate = _this.playbackRate;
    }
    function ready() {
      initOptions();
      if (_settings.autoplay || _options.autoplay) {
        _this.play();
      }
    }
    initOptions();
    (function addListeners() {
      _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
      _this.events.sub(GlobalAudio3D, Events.READY, ready);
    })();
    this.set("src", src => {
      _this.unload();
      (function destroyStream() {
        if (_stream && _stream.element && GlobalAudio3D.initialized) {
          Audio3DWA.unloadStream(_settings.src);
          _stream = null;
        }
      })();
      _settings.src = src;
    });
    this.get("src", _ => _settings.src);
    this.set("volume", v => {
      v = Math.clamp(v, 0, 1);
      _options.volume = v;
      if (_stream && _stream.element) {
        _stream.element.volume = _options.muted || _options.globalMuted ? 0 : v * Math.clamp(_options.globalVolume);
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.set("loop", l => {
      l = !!l;
      if (_stream) {
        _stream.element.loop = l;
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => _this.ready);
    this.get("frequency", _ => 0);
    this.get("activity", _ => 0);
    this.get("playing", _ => _settings.playing);
    this.set("rolloff", r => {});
    this.get("rolloff", _ => 0);
    this.get("loaded", _ => true);
    this.get("duration", _ => _stream ? _stream.element.duration : 0);
    this.get("currentTime", _ => _stream ? _stream.element.currentTime : 0);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.set("playbackRate", v => {
      _options.playbackRate = v;
      if (_stream && _stream.element) {
        _stream.element.playbackRate = v * _options.globalPlaybackRate;
      }
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.play = function () {
      _settings.autoplay = true;
      if (_settings.src && GlobalAudio3D.initialized && (function createStream() {
        if (!_stream && GlobalAudio3D.initialized) {
          (_stream = Audio3DWA.loadStream(_settings.src)).element.onended = _ => {
            _this.unload();
            _this.events.fire(Events.END);
          };
          _this.loop = _this.loop;
          _this.volume = _this.volume;
          _this.rolloff = _this.rolloff;
          _this.muted = _this.muted;
          if (_options.autoplay || _settings.autoplay) {
            _this.play();
          }
        }
      }(), _settings.playing !== true && (_settings.playing = true, _this.volume = _options.volume, _stream))) {
        _stream.element.playbackRate = _options.playbackRate;
        _stream.element.play();
        try {
          _stream.element.currentTime = _currentTime;
        } catch (e) {}
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_stream && GlobalAudio3D.initialized && _settings.src && _settings.playing) {
        try {
          _currentTime = _stream.element.currentTime;
        } catch (e) {}
        _stream.element.pause();
        _settings.playing = false;
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.src && GlobalAudio3D.initialized && (_currentTime = 0, _settings.playing = false, _stream && _stream.element && _stream.element.stop)) {
        _stream.element.stop();
        try {
          _stream.element.currentTime = 0;
        } catch (e) {}
      }
    };
    this.seek = function (time) {
      if (_settings.src && (_currentTime = time, _stream && _stream.element)) {
        try {
          _stream.element.currentTime = time;
        } catch (e) {}
      }
    };
    this.load = function () {
      return true;
    };
    this.unload = function () {
      _settings.autoplay = false;
      if (_stream && GlobalAudio3D.initialized && _settings.src) {
        _this.stop();
      }
    };
    this.convolve = function (src) {};
  });
  Class(function Audio3DN() {
    Inherit(this, Component);
    const _this = this;
    var _init;
    function loop() {
      if (window.GVRAudio) {
        GVRAudio.setHeadPos(World.CAMERA.position.x, World.CAMERA.position.y, World.CAMERA.position.z);
        GVRAudio.setHeadRotation(World.CAMERA.quaternion.x, World.CAMERA.quaternion.y, World.CAMERA.quaternion.z, World.CAMERA.quaternion.w);
      }
    }
    this.audioContext = function () {
      if (window.GVRAudio && !_init) {
        GVRAudio.initEngine(GlobalAudio3D.quality);
        _init = true;
        _this.startRender(loop);
      }
    };
  }, "static");
  Class(function Audio3DNBuffer(_backingType) {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _backing;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _currentTime = 0;
    function loop() {
      let pos;
      let orientation;
      switch (_backingType) {
        case "AVF":
          pos = _this.audioPositionInverse();
          orientation = _this.audioOrientationInverse();
          break;
        case "GVR":
          pos = _this.audioPosition();
      }
      if (pos && _backing) {
        _backing.setPos(pos.x, pos.y, pos.z);
        if (orientation) {
          _backing.setOrientation(orientation.x, orientation.y, orientation.z, 0, 1, 0);
        }
      }
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.playbackRate = _this.playbackRate;
    }
    Audio3DN.audioContext();
    (function initOptions() {
      _options.loop = _options.loop || false;
      _options.autoplay = _options.autoplay || false;
      _options.volume = _options.volume === undefined ? 1 : _options.volume;
      _options.playbackRate = _options.playbackRate || 1;
      _options.preload = _options.preload || false;
      _options.muted = _options.muted || false;
      _options.rolloff = _options.rolloff || 1;
      _options.selfDestruct = _options.selfDestruct || false;
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
    })();
    (function addListeners() {
      _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
    })();
    this.set("src", src => {
      _this.stop();
      _settings.src = src;
      defer(_ => {
        if (_options.autoplay) {
          return _this.play();
        }
        if (_options.preload) {
          _this.load();
        }
        _this.volume = _options.volume;
      });
    });
    this.get("src", _ => _settings.src);
    this.get("selfDestruct", _ => _options.selfDestruct);
    this.set("selfDestruct", d => {
      _options.selfDestruct = d;
    });
    this.set("volume", v => {
      _options.volume = v;
      if (_backing) {
        _backing.volume(v);
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.set("loop", l => {
      l = !!l;
      if (_backing) {
        _backing.loop(l);
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => _this.ready);
    this.get("frequency", _ => []);
    this.get("activity", _ => 0);
    this.get("playing", _ => _settings.playing);
    this.set("rolloff", r => {
      _options.rolloff = r;
    });
    this.get("rolloff", _ => _options.rolloff);
    this.get("loaded", _ => _settings.loaded);
    this.get("currentTime", _ => _currentTime);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("duration", _ => 0);
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.set("playbackRate", v => {
      _options.playbackRate = v;
      if (_backing) {
        _backing.setRate(v);
      }
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.play = async function () {
      _settings.autoplay = true;
      if (_settings.src) {
        _settings.loadingPlay = true;
        if (!_settings.loading && !_settings.playing) {
          if (!_settings.loaded) {
            await _this.load();
          }
          _settings.playing = true;
          _this.volume = _options.volume;
          _this.playbackRate = _options.playbackRate;
          _this.startRender(loop);
          _backing.seek(_currentTime);
          _backing.play(_options.loop);
        }
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_settings.src && _settings.loaded && _settings.playing) {
        _currentTime = _currentTime;
        _settings.loadingPlay = false;
        _settings.playing = false;
        if (_backing) {
          _backing.pause();
        }
        _this.stopRender(loop);
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.loaded) {
        _currentTime = 0;
        if (_backing) {
          _backing.stop();
        }
        _settings.playing = false;
        _this.stopRender(loop);
      }
    };
    this.seek = function (time) {
      if (_settings.src) {
        _settings.loadingPlay = false;
        var wasPlaying = _settings.playing;
        _currentTime = time;
        if (_backing) {
          _backing.seek(_currentTime);
          if (wasPlaying) {
            _backing.play();
          }
        }
      }
    };
    this.load = async function () {
      if (_settings.src) {
        if (!_settings.loading && !_settings.loaded) {
          _settings.loading = true;
          _this.ready = await function createBuffer() {
            let promise = Promise.create();
            let url = _settings.src;
            if (!url.includes("http")) {
              url = AURA.rootPath + url;
            }
            switch (_backingType) {
              case "AVF":
                _backing = AVFSound.create(url);
                break;
              case "MP":
                _backing = new MPAudio(url);
                break;
              case "GVR":
                _backing = new GVRAudio(url);
            }
            _backing.onComplete = _ => {
              _this.events.fire(Events.END);
              if (_options.selfDestruct) {
                _this.parent.destroy();
              }
            };
            _backing.onUpdate = t => {
              _currentTime = t;
            };
            _backing.onReady = promise.resolve;
            return promise;
          }();
          _this.events.fire(Events.LOADED);
          _settings.loadingPlay = false;
          _settings.loading = false;
          _settings.loaded = true;
        }
      }
    };
    this.unload = function () {
      if (_settings.src && _settings.loaded) {
        _this.stop();
        _backing.destroy();
      }
    };
    this.convolve = async function (src) {};
  });
  Class(function Audio3DResonance() {
    Inherit(this, Component);
    const _this = this;
    require("Audio3DSilence");
    var _context;
    var _resonance;
    var _orientation;
    var _cam;
    function loop() {
      if ((_cam = Audio3DWA.getCamera()) && _context && _context.listener) {
        _orientation.set(0, 0, -1).applyQuaternion(_cam.quaternion);
        _resonance.setListenerOrientation(_orientation.x, _orientation.y, _orientation.z, _cam.up.x, _cam.up.y, _cam.up.z);
        _resonance.setListenerPosition(_cam.position.x, _cam.position.y, _cam.position.z);
      }
    }
    this.createAudioInput = async function (url) {
      if (!_context) {
        await _this.resonance();
      }
      let audioElementSource;
      let stream = {};
      stream.element = Audio3DWA.getElement();
      stream.element.crossOrigin = "anonymous";
      stream.element.src = url;
      audioElementSource = stream.element.mediaSrc ? stream.element.mediaSrc : _context.createMediaElementSource(stream.element);
      stream.element.mediaSrc = audioElementSource;
      let source = _resonance.createSource();
      audioElementSource.connect(source.input);
      stream.source = source;
      return stream;
    };
    this.unloadStream = function (stream) {
      stream.element.mediaSrc.disconnect(stream.source.input);
      Audio3DWA.putElement(stream.element);
    };
    this.resonance = async function (refresh) {
      if (!window.ResonanceAudio) {
        await AssetLoader.waitForLib("ResonanceAudio");
      }
      await GlobalAudio3D.ready();
      if (!_context || !!refresh) {
        if (_context) {
          _context.close();
          _context = null;
        }
        _orientation = new Vector3();
        if ((_context = Audio3DWA.audioContext()).state !== "running") {
          _context.resume();
        }
        (_resonance = new ResonanceAudio(_context)).output.connect(_context.destination);
        Render.start(loop);
      }
      return _resonance;
    };
    this.setRoomProperties = function (dimensions, materials) {
      _resonance.setRoomProperties(dimensions, materials);
    };
    this.get("initialized", () => !!_context);
  }, "static");
  Class(function Audio3DResonanceAudio() {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _stream;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _orientation = new Vector3();
    var _currentTime = 0;
    function loop() {
      let pos;
      pos = _this.audioPosition();
      if (pos && _stream) {
        _stream.source.setPosition(pos.x, pos.y, pos.z);
        let euler = _this.audioOrientationInverse();
        _orientation.set(0, 0, -1).applyEuler(euler);
        _stream.source.setOrientation(_orientation.x, _orientation.y, _orientation.z, _this.group.up.x, _this.group.up.y, _this.group.up.z);
      }
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.gain = _this.gain;
      _this.playbackRate = _this.playbackRate;
    }
    function handleEnded() {
      _this.unload();
      _this.events.fire(Events.END);
    }
    (async function () {
      if (!Audio3DResonance.initialized) {
        await Audio3DResonance.resonance();
      }
      (function initOptions() {
        _options.loop = _options.loop || false;
        _options.autoplay = _options.autoplay || false;
        _options.volume = _options.volume === undefined ? 1 : _options.volume;
        _options.playbackRate = _options.playbackRate || 1;
        _options.preload = _options.preload || false;
        _options.muted = _options.muted || false;
        _options.rolloff = _options.rolloff || 1;
        _options.selfDestruct = _options.selfDestruct || false;
        _options.globalMuted = GlobalAudio3D.muted;
        _options.globalVolume = GlobalAudio3D.volume;
        _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
        _options.gain = typeof _options.gain == "number" ? _options.gain : ResonanceAudio.Utils.DEFAULT_SOURCE_GAIN;
        _options.sourceWidth = typeof _options.sourceWidth == "number" ? _options.sourceWidth : ResonanceAudio.Utils.DEFAULT_SOURCE_WIDTH;
        _options.directivitySharpness = typeof _options.directivitySharpness == "number" ? _options.directivitySharpness : ResonanceAudio.Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
        _options.directivityAlpha = typeof _options.directivityAlpha == "number" ? _options.directivityAlpha : ResonanceAudio.Utils.DEFAULT_DIRECTIVITY_ALPHA;
      })();
      (function addListeners() {
        _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
      })();
    })();
    this.set("src", src => {
      _this.stop();
      _settings.src = src;
      defer(_ => {
        if (_options.autoplay) {
          return _this.play();
        }
        if (_options.preload) {
          _this.load();
        }
        _this.volume = _this.volume;
        _this.gain = _this.gain;
      });
    });
    this.get("src", _ => _settings.src);
    this.get("selfDestruct", _ => _options.selfDestruct);
    this.set("selfDestruct", d => {
      _options.selfDestruct = d;
    });
    this.set("volume", v => {
      _options.volume = v;
      if (_stream) {
        _stream.element.volume = _options.muted || _options.globalMuted ? 0 : v * Math.clamp(_options.globalVolume);
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.get("gain", () => _options.gain);
    this.set("gain", v => {
      _options.gain = v;
      if (_stream) {
        _stream.source.setGain(_options.gain * Math.max(1, _options.globalVolume));
      }
    });
    this.set("loop", l => {
      l = !!l;
      if (_stream) {
        _stream.element.loop = l;
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => _this.ready);
    this.get("frequency", _ => []);
    this.get("activity", _ => 0);
    this.get("playing", _ => _settings.playing);
    this.set("rolloff", r => {
      _options.rolloff = r;
    });
    this.get("rolloff", _ => _options.rolloff);
    this.get("loaded", _ => _settings.loaded);
    this.get("currentTime", _ => _currentTime);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("duration", _ => _stream ? _stream.element.duration : 0);
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.set("playbackRate", v => {
      _options.playbackRate = v;
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.get("sourceWidth", () => _options.sourceWidth);
    this.set("sourceWidth", v => {
      _options.sourceWidth = v;
      if (_stream) {
        _stream.source.setSourceWidth(_options.sourceWidth);
      }
    });
    this.get("directivitySharpness", () => _options.directivitySharpness);
    this.set("directivitySharpness", v => {
      _options.directivitySharpness = v;
      if (_stream) {
        _stream.source.setDirectivityPattern(_options.directivityAlpha, _options.directivitySharpness);
      }
    });
    this.get("directivityAlpha", () => _options.directivityAlpha);
    this.set("directivityAlpha", v => {
      _options.directivityAlpha = v;
      if (_stream) {
        _stream.source.setDirectivityPattern(_options.directivityAlpha, _options.directivitySharpness);
      }
    });
    this.play = async function () {
      _settings.autoplay = true;
      if (_settings.src) {
        _settings.loadingPlay = true;
        if (!_settings.loading && !_settings.playing) {
          if (!_settings.loaded) {
            await _this.load();
          }
          _settings.playing = true;
          _this.volume = _options.volume;
          _this.playbackRate = _options.playbackRate;
          _this.startRender(loop);
          _stream.element.currentTime = _currentTime;
          _stream.element.play();
        }
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_settings.src && _settings.loaded && _settings.playing) {
        _currentTime = _currentTime;
        _settings.loadingPlay = false;
        _settings.playing = false;
        if (_stream) {
          _stream.element.pause();
        }
        _this.stopRender(loop);
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.loaded) {
        _currentTime = 0;
        if (_stream) {
          _stream.element.pause();
          _stream.element.currentTime = 0;
        }
        _settings.playing = false;
        _this.stopRender(loop);
      }
    };
    this.seek = function (time) {
      if (_settings.src) {
        _settings.loadingPlay = false;
        var wasPlaying = _settings.playing;
        _currentTime = time;
        if (_stream) {
          _stream.element.seek(_currentTime);
          if (wasPlaying) {
            _stream.element.play();
          }
        }
      }
    };
    this.load = async function () {
      if (_settings.src) {
        if (!_settings.loading && !_settings.loaded) {
          _settings.loading = true;
          _this.ready = await async function createBuffer() {
            let promise = Promise.create();
            let url = _settings.src;
            (_stream = await Audio3DResonance.createAudioInput(url)).element.addEventListener("ended", handleEnded);
            _this.loop = _this.loop;
            _this.volume = _this.volume;
            _this.rolloff = _this.rolloff;
            _this.muted = _this.muted;
            _this.gain = _this.gain;
            _this.sourceWidth = _this.sourceWidth;
            _this.directivitySharpness = _this.directivitySharpness;
            _this.directivityAlpha = _this.directivityAlpha;
            _stream.element.currentTime = _currentTime;
            _stream.element.volume = _this.volume;
            _stream.element.onloadeddata = promise.resolve;
            _stream.element.load();
            if (_options.autoplay || _settings.autoplay) {
              _this.play();
            }
            return promise;
          }();
          _this.events.fire(Events.LOADED);
          _settings.loadingPlay = false;
          _settings.loading = false;
          _settings.loaded = true;
        }
      }
    };
    this.unload = function () {
      if (_settings.src && _settings.loaded) {
        _this.stop();
        (function destroyStream() {
          if (_stream) {
            _settings.loaded = false;
            _stream.element.removeEventListener("ended", handleEnded);
            Audio3DResonance.unloadStream(_stream);
            _stream = null;
          }
        })();
      }
    };
  });
  Class(function Audio3DWA() {
    Inherit(this, Component);
    const _this = this;
    const _silence = require("Audio3DSilence");
    var _context;
    var _orientation;
    var _cam;
    var _pool;
    var _streams = {};
    var _buffers = {};
    function loop() {
      if ((_cam = _this.getCamera()) && _cam.getWorldQuaternion && _context && _context.listener) {
        _orientation.set(0, 0, -1).applyQuaternion(_cam.getWorldQuaternion());
        if (_context.listener.forwardX) {
          _context.listener.forwardX.setValueAtTime(_orientation.x, _context.currentTime);
          _context.listener.forwardY.setValueAtTime(_orientation.y, _context.currentTime);
          _context.listener.forwardZ.setValueAtTime(_orientation.z, _context.currentTime);
          _context.listener.upX.setValueAtTime(_cam.up.x, _context.currentTime);
          _context.listener.upY.setValueAtTime(_cam.up.y, _context.currentTime);
          _context.listener.upZ.setValueAtTime(_cam.up.z, _context.currentTime);
        } else {
          if (_context.listener.setOrientation) {
            _context.listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, _cam.up.x, _cam.up.y, _cam.up.z);
          }
          if (_context.listener.setPosition) {
            _context.listener.setPosition(_cam.position.x, _cam.position.y, _cam.position.z);
          }
          if (_context.listener.setVelocity) {
            _context.listener.setVelocity(0, 0, 0);
          }
        }
      }
    }
    function createAudioElement() {
      let audio;
      if (GlobalAudio3D.fallback) {
        audio = document.createElement("audio");
        audio.style.visibility = "hidden";
        document.body.appendChild(audio);
        audio.source = document.createElement("source");
        audio.appendChild(audio.source);
        audio.setAttribute("controls", "");
        audio.source.setAttribute("src", _silence);
        audio.source.setAttribute("type", "audio/mp3");
        audio.play();
      } else {
        audio = new Audio();
        audio.src = _silence;
        audio.play().catch(e => {});
      }
      return audio;
    }
    this.createPool = function (n = 10) {
      _pool = _this.initClass(ObjectPool, createAudioElement, n);
      _this.flag("init", true);
    };
    this.audioContext = function (refresh) {
      if (!_context || !!refresh) {
        if (_context) {
          _context.close();
          _context = null;
        }
        _orientation = new Vector3();
        (_context = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 48000
        })).dest = _context.createMediaStreamDestination();
        Render.start(loop);
      }
      return _context;
    };
    this.unloadBuffer = function (url) {
      if (_buffers[url]) {
        delete _buffers[url];
      }
    };
    this.loadBuffer = async function (url) {
      if (!_buffers[url]) {
        _buffers[url] = {
          loaded: Promise.create(),
          data: null
        };
        var response = await fetch(url);
        var buffer = await response.arrayBuffer();
        _this.audioContext().decodeAudioData(buffer, data => {
          _buffers[url].data = data;
          _buffers[url].loaded.resolve();
        });
      }
      await _buffers[url].loaded;
      return _buffers[url].data;
    };
    this.unloadStream = function (url) {
      if (_streams[url]) {
        _streams[url].stream.element.src = _silence;
        _streams[url].stream.element.load();
        _streams[url].count--;
        _pool.put(_streams[url].stream.element);
        if (_streams[url].count == 0) {
          defer(_ => {
            delete _streams[url];
          });
        }
      }
    };
    this.loadStream = function (url) {
      let isElement = typeof url != "string" && url !== undefined;
      let element = null;
      if (isElement) {
        element = url;
        url = element.src ? element.src : element.srcObject ? element.srcObject.id : "";
      }
      if (!_streams[url]) {
        let stream = {};
        _streams[url] = {
          stream: null,
          count: 0
        };
        if (isElement) {
          stream.element = element;
          element.setAttribute("muted", true);
          element.muted = true;
        } else {
          stream.element = _this.getElement();
          stream.element.crossOrigin = "anonymous";
          stream.element.src = url;
        }
        if (GlobalAudio3D.fallback) {
          stream.element.setAttribute("src", url);
        } else {
          if (stream.element.mediaSrc) {
            stream.source = stream.element.mediaSrc;
          } else if (stream.element.srcObject) {
            stream.source = _this.audioContext().createMediaStreamSource(stream.element.srcObject);
            new Audio().srcObject = element.srcObject;
          } else {
            stream.source = _this.audioContext().createMediaElementSource(stream.element);
          }
          stream.element.mediaSrc = stream.source;
        }
        if (!isElement) {
          stream.element.load();
        }
        _streams[url].stream = stream;
      }
      _streams[url].count++;
      return _streams[url].stream;
    };
    this.getActiveStreamCount = function (stream) {
      for (let key in _streams) {
        if (_streams[key].stream == stream) {
          return _streams[key].count;
        }
      }
      return -1;
    };
    this.purge = function () {
      for (let stream in _streams) {
        _this.unloadStream(stream);
      }
      for (let buffer in _buffers) {
        _this.unloadBuffer(buffer);
      }
    };
    this.getElement = function () {
      if (!_pool) {
        _this.createPool();
      }
      return _pool.get();
    };
    this.putElement = function (audio) {
      audio.src = _silence;
      audio.load();
      _pool.put(audio);
    };
    this.useCamera = function (camera) {
      _this.CAMERA = camera;
    };
    this.getCamera = function () {
      _this.CAMERA ||= World.CAMERA;
      return _this.CAMERA;
    };
  }, "static");
  Class(function Audio3DWABuffer() {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _context;
    var _buffer;
    var _stream;
    var _gain;
    var _panner;
    var _analyser;
    var _filter;
    var _delay;
    var _convolver;
    var _position;
    var _frequency;
    var _convolution;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _currentTime = 0;
    function loop() {
      if (_context) {
        _position = _context.listener.forwardX ? _this.audioPosition().sub(_this.listenerPosition()) : _this.audioPosition();
        _panner.setPosition(_position.x, _position.y, _position.z);
      }
    }
    function initContext() {
      if (GlobalAudio3D.initialized) {
        _context = Audio3DWA.audioContext();
        _gain = _context.createGain ? _context.createGain() : _context.createGainNode();
        _panner = _context.createPanner();
        (_filter = _context.createBiquadFilter()).type = "lowshelf";
        _filter.frequency.value = 0;
        _filter.gain.value = 1;
        _analyser = _context.createAnalyser();
        (_delay = _context.createDelay(10)).delayTime.value = 0;
        _analyser.fftSize = 32;
        _frequency = new Uint8Array(_analyser.frequencyBinCount);
        _analyser.connect(_context.destination);
        _delay.connect(_analyser);
        _filter.connect(_delay);
        if (_convolver) {
          _convolver.connect(_filter);
          _gain.connect(_convolver);
        } else {
          _gain.connect(_filter);
        }
        _panner.connect(_gain);
      }
    }
    function initOptions() {
      _options.loop = _options.loop || false;
      _options.autoplay = _options.autoplay || false;
      _options.volume = _options.volume === undefined ? 1 : _options.volume;
      _options.playbackRate = _options.playbackRate || 1;
      _options.preload = _options.preload || false;
      _options.muted = _options.muted || false;
      _options.rolloff = _options.rolloff || 1;
      _options.selfDestruct = _options.selfDestruct || false;
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
    }
    function destroyBuffer() {
      if (_buffer && _stream) {
        _settings.loaded = false;
        try {
          _stream.disconnect(_panner);
          if (_convolver) {
            _convolver.disconnect(_filter);
            _gain.disconnect(_convolver);
          } else {
            _gain.disconnect(_filter);
          }
          _analyser.disconnect(_context.destination);
          _buffer.stop();
          _buffer = null;
          Audio3DWA.unloadBuffer(_settings.src);
        } catch (e) {}
      }
    }
    async function createStream() {
      if (!_stream) {
        (_stream = _context.createBufferSource()).buffer = _buffer.buffer;
        _stream.loop = _options.loop;
        _stream.playbackRate = _options.playbackRate;
        _stream.onended = _ => {
          if (_this && _this.stop) {
            _this.stop();
            _this.events.fire(Events.END);
            if (_options.selfDestruct) {
              _this.parent.destroy();
            }
          }
        };
        _this.volume = _this.volume;
        _this.rolloff = _this.rolloff;
        _this.muted = _this.muted;
        _stream.connect(_panner);
        _stream.start(0, _currentTime);
      }
    }
    function destroyStream() {
      if (_stream) {
        try {
          _stream.disconnect(_panner);
          _stream.stop();
          _stream = null;
        } catch (e) {}
      }
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.playbackRate = _this.playbackRate;
    }
    function ready() {
      destroyBuffer();
      destroyStream();
      _context = null;
      _gain = null;
      _panner = null;
      _analyser = null;
      _delay = null;
      _frequency = null;
      _filter = null;
      initContext();
      initOptions();
      if (_convolution) {
        _this.convolve(_convolution);
      }
      if (_options.autoplay || _settings.autoplay) {
        _this.play();
      }
    }
    (async function () {
      initContext();
      initOptions();
      (function addListeners() {
        _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
        _this.events.sub(GlobalAudio3D, Events.READY, ready);
      })();
    })();
    this.set("src", src => {
      _this.stop();
      _settings.src = src;
      defer(_ => {
        if (_options.autoplay) {
          return _this.play();
        }
        if (_options.preload) {
          _this.load();
        }
        _this.volume = _options.volume;
      });
    });
    this.get("src", _ => _settings.src);
    this.get("selfDestruct", _ => _options.selfDestruct);
    this.set("selfDestruct", d => {
      _options.selfDestruct = d;
    });
    this.set("volume", v => {
      _options.volume = v;
      if (_gain) {
        _gain.gain.value = _options.muted || _options.globalMuted ? 0 : v * _options.globalVolume;
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.set("loop", l => {
      l = !!l;
      if (_stream) {
        _stream.loop = l;
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => _this.ready);
    this.get("frequency", _ => _analyser ? (_analyser.getByteFrequencyData(_frequency), _frequency) : []);
    this.get("activity", _ => _analyser ? (_analyser.getByteFrequencyData(_frequency), Math.clamp(_frequency.slice(3, 13).reduce((n1, n2) => n1 + n2, 0) / 2560, 0, 1)) : 0);
    this.get("playing", _ => _settings.playing);
    this.set("rolloff", r => {
      _options.rolloff = r;
      if (_panner) {
        _panner.rolloffFactor = r;
      }
    });
    this.get("rolloff", _ => _options.rolloff);
    this.get("loaded", _ => _settings.loaded);
    this.get("currentTime", _ => _context && _buffer ? _context.currentTime % _buffer.buffer.duration : 0);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.set("playbackRate", v => {
      _options.playbackRate = v;
      if (_stream) {
        _stream.playbackRate.value = v * _options.globalPlaybackRate;
      }
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.get("filter", _ => _filter);
    this.get("delay", _ => _delay);
    this.get("panner", _ => _panner);
    this.get("duration", _ => _buffer ? _buffer.buffer.duration : 0);
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.play = async function () {
      _settings.autoplay = true;
      if (_settings.src && GlobalAudio3D.initialized) {
        _settings.loadingPlay = true;
        if (!_stream && !_settings.loading && !_settings.playing) {
          if (!_settings.loaded) {
            await _this.load();
          }
          await createStream();
          _settings.playing = true;
          _this.volume = _options.volume;
          _this.startRender(loop);
        }
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_stream && GlobalAudio3D.initialized && _settings.src && _settings.loaded && _settings.playing) {
        _currentTime = _context.currentTime;
        destroyStream();
        _settings.loadingPlay = false;
        _settings.playing = false;
        _this.stopRender(loop);
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.src && GlobalAudio3D.initialized && _settings.loaded) {
        _currentTime = 0;
        destroyStream();
        _settings.loading = false;
        _settings.loaded = false;
        _settings.loadingPlay = false;
        _settings.playing = false;
        _this.stopRender(loop);
      }
    };
    this.seek = function (time) {
      if (_settings.src) {
        _settings.loadingPlay = false;
        var wasPlaying = _settings.playing;
        _this.stop();
        _currentTime = time;
        if (wasPlaying) {
          _this.play();
        }
      }
    };
    this.load = async function () {
      if (_settings.src) {
        if (!_settings.loading && !_settings.loaded) {
          _settings.loading = true;
          _this.ready = await async function createBuffer() {
            if (!GlobalAudio3D.initialized) {
              await GlobalAudio3D.ready();
            }
            if (!_context) {
              await defer();
            }
            (_buffer = _context.createBufferSource()).buffer = await Audio3DWA.loadBuffer(_settings.src);
            _settings.loaded = true;
          }();
          await createStream();
          if (!_options.autoplay && !_settings.loadingPlay) {
            destroyStream();
          }
          _this.events.fire(Events.LOADED);
          _settings.loadingPlay = false;
          _settings.loading = false;
          _settings.loaded = true;
        }
      }
    };
    this.unload = function () {
      if (_settings.src && _settings.loaded) {
        _this.stop();
        destroyBuffer();
      }
    };
    this.convolve = async function (src) {
      _convolution = src;
      if (!GlobalAudio3D.initialized) {
        return;
      }
      if (src === false) {
        if (_convolver) {
          _convolver.disconnect();
          _gain.disconnect();
          _gain.connect(_filter);
          _convolver = null;
        }
        return;
      }
      let buffer = await Audio3DWA.loadBuffer(src);
      if (!_convolver) {
        _convolver = _context.createConvolver();
        _gain.disconnect();
        _convolver.connect(_filter);
        _gain.connect(_convolver);
      }
      _convolver.buffer = buffer;
    };
  });
  Class(function Audio3DWASimpleBuffer() {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _context;
    var _buffer;
    var _stream;
    var _gain;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _currentTime = 0;
    function initContext() {
      if (GlobalAudio3D.initialized) {
        _context = Audio3DWA.audioContext();
        (_gain = _context.createGain ? _context.createGain() : _context.createGainNode()).connect(_context.destination);
      }
    }
    function initOptions() {
      _options.loop = _options.loop || false;
      _options.autoplay = _options.autoplay || false;
      _options.volume = _options.volume === undefined ? 1 : _options.volume;
      _options.playbackRate = _options.playbackRate || 1;
      _options.preload = _options.preload || false;
      _options.muted = _options.muted || false;
      _options.selfDestruct = _options.selfDestruct || false;
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
    }
    function destroyBuffer() {
      if (_buffer && _stream) {
        _settings.loaded = false;
        _stream.disconnect(_gain);
        _gain.disconnect(_context.destination);
        _buffer.stop();
        _buffer = null;
        Audio3DWA.unloadBuffer(_settings.src);
      }
    }
    async function createStream() {
      if (!_stream && GlobalAudio3D.initialized) {
        (_stream = _context.createBufferSource()).buffer = _buffer.buffer;
        _stream.loop = _options.loop;
        _stream.playbackRate = _options.playbackRate;
        _stream.onended = _ => {
          _this.stop();
          _this.events.fire(Events.END);
          if (_options.selfDestruct) {
            _this.parent.destroy();
          }
        };
        _this.volume = _this.volume;
        _this.rolloff = _this.rolloff;
        _this.muted = _this.muted;
        _stream.connect(_gain);
        _stream.start(0, _currentTime);
      }
    }
    function destroyStream() {
      if (_stream) {
        _stream.disconnect(_gain);
        _stream.stop();
        _stream = null;
      }
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.playbackRate = _this.playbackRate;
    }
    function ready() {
      destroyBuffer();
      destroyStream();
      _context = null;
      _gain = null;
      initContext();
      initOptions();
      if (_options.autoplay || _settings.autoplay) {
        _this.play();
      }
    }
    initContext();
    initOptions();
    (function addListeners() {
      _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
      _this.events.sub(GlobalAudio3D, Events.READY, ready);
    })();
    this.set("src", src => {
      _this.stop();
      _settings.src = src;
      defer(_ => {
        if (_options.autoplay) {
          return _this.play();
        }
        if (_options.preload) {
          _this.load();
        }
        _this.volume = _options.volume;
      });
    });
    this.get("src", _ => _settings.src);
    this.get("selfDestruct", _ => _options.selfDestruct);
    this.set("selfDestruct", d => {
      _options.selfDestruct = d;
    });
    this.set("volume", v => {
      _options.volume = v;
      if (_gain) {
        _gain.gain.value = _options.muted || _options.globalMuted ? 0 : v * _options.globalVolume;
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.set("loop", l => {
      l = !!l;
      if (_stream) {
        _stream.loop = l;
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => _this.ready);
    this.get("playing", _ => _settings.playing);
    this.get("loaded", _ => _settings.loaded);
    this.get("currentTime", _ => _context && _buffer ? _context.currentTime % _buffer.buffer.duration : 0);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.set("playbackRate", v => {
      _options.playbackRate = v;
      if (_stream) {
        _stream.playbackRate.value = v * _options.globalPlaybackRate;
      }
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.get("duration", _ => _buffer ? _buffer.buffer.duration : 0);
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.play = async function () {
      _settings.autoplay = true;
      if (_settings.src && GlobalAudio3D.initialized) {
        _settings.loadingPlay = true;
        if (!_stream && !_settings.loading && !_settings.playing) {
          if (!_settings.loaded) {
            await _this.load();
          }
          await createStream();
          _settings.playing = true;
          _this.volume = _options.volume;
        }
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_stream && GlobalAudio3D.initialized && _settings.src && _settings.loaded && _settings.playing) {
        _currentTime = _context.currentTime;
        destroyStream();
        _settings.loadingPlay = false;
        _settings.playing = false;
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.src && GlobalAudio3D.initialized && _settings.loaded) {
        _currentTime = 0;
        destroyStream();
        _settings.loading = false;
        _settings.loaded = false;
        _settings.loadingPlay = false;
        _settings.playing = false;
      }
    };
    this.seek = function (time) {
      if (_settings.src) {
        _settings.loadingPlay = false;
        var wasPlaying = _settings.playing;
        if (_stream) {
          _stream.onended = null;
        }
        _this.stop();
        _currentTime = time;
        if (wasPlaying) {
          _this.play();
        }
      }
    };
    this.load = async function () {
      if (_settings.src) {
        if (!_settings.loading && !_settings.loaded) {
          _settings.loading = true;
          _this.ready = await async function createBuffer() {
            if (GlobalAudio3D.initialized) {
              (_buffer = _context.createBufferSource()).buffer = await Audio3DWA.loadBuffer(_settings.src);
              _settings.loaded = true;
            }
          }();
          await createStream();
          if (!_options.autoplay && !_settings.loadingPlay) {
            _stream.onended = null;
            destroyStream();
          }
          _this.events.fire(Events.LOADED);
          _settings.loadingPlay = false;
          _settings.loading = false;
          _settings.loaded = true;
        }
      }
    };
    this.unload = function () {
      if (_settings.src && _settings.loaded) {
        _this.stop();
        destroyBuffer();
      }
    };
    this.convolve = async function (src) {};
  });
  Class(function Audio3DWAStream() {
    Inherit(this, Audio3DBase);
    const _this = this;
    var _context;
    var _stream;
    var _gain;
    var _panner;
    var _analyser;
    var _filter;
    var _delay;
    var _convolver;
    var _position;
    var _frequency;
    var _convolution;
    var _options = {};
    var _settings = {
      playing: false,
      loaded: false,
      loading: false
    };
    var _currentTime = 0;
    function loop() {
      if (_context) {
        _position = _context.listener.forwardX ? _this.audioPosition().sub(_this.listenerPosition()) : _this.audioPosition();
        _panner.setPosition(_position.x, _position.y, _position.z);
      }
    }
    function initContext() {
      if (GlobalAudio3D.initialized) {
        _context = Audio3DWA.audioContext();
        _gain = _context.createGain ? _context.createGain() : _context.createGainNode();
        _panner = _context.createPanner();
        (_analyser = _context.createAnalyser()).fftSize = 32;
        _frequency = new Uint8Array(_analyser.frequencyBinCount);
        (_filter = _context.createBiquadFilter()).type = "lowshelf";
        _filter.frequency.value = 0;
        _filter.gain.value = 1;
        (_delay = _context.createDelay(10)).delayTime.value = 0;
      }
    }
    function initOptions() {
      _options.loop = _options.loop || false;
      _options.autoplay = _options.autoplay || false;
      _options.volume = _options.volume === undefined ? 1 : _options.volume;
      _options.playbackRate = _options.playbackRate || 1;
      _options.preload = _options.preload || false;
      _options.muted = _options.muted || false;
      _options.rolloff = _options.rolloff || 1;
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
    }
    function createStream() {
      if (!_stream) {
        (_stream = Audio3DWA.loadStream(_settings.src)).element.addEventListener("ended", handleEnded);
        _this.loop = _this.loop;
        _this.volume = _this.volume;
        _this.rolloff = _this.rolloff;
        _this.muted = _this.muted;
        _stream.source.connect(_panner);
        _panner.connect(_gain);
        if (_convolver) {
          _gain.connect(_convolver);
          _convolver.connect(_filter);
        } else {
          _gain.connect(_filter);
        }
        _filter.connect(_delay);
        _delay.connect(_analyser);
        _analyser.connect(_context.destination);
        _stream.element.currentTime = _currentTime;
        if (_options.autoplay || _settings.autoplay) {
          _this.play();
        }
      }
    }
    function destroyStream() {
      if (_stream) {
        _stream.element.removeEventListener("ended", handleEnded);
        _stream.source.disconnect(_panner);
        _stream = null;
      }
    }
    function update(e) {
      _options.globalMuted = GlobalAudio3D.muted;
      _options.globalVolume = GlobalAudio3D.volume;
      _options.globalPlaybackRate = GlobalAudio3D.playbackRate;
      _this.volume = _this.volume;
      _this.playbackRate = _this.playbackRate;
    }
    function ready() {
      destroyStream();
      _context = null;
      _gain = null;
      _panner = null;
      _analyser = null;
      _delay = null;
      _filter = null;
      _frequency = null;
      initContext();
      initOptions();
      if (_convolution) {
        _this.convolve(_convolution);
      }
      if (_settings.autoplay || _options.autoplay) {
        _this.play();
      }
    }
    function handleEnded() {
      _this.unload();
      _this.events.fire(Events.END);
    }
    initOptions();
    initContext();
    (function addListeners() {
      _this.events.sub(GlobalAudio3D, Events.UPDATE, update);
      _this.events.sub(GlobalAudio3D, Events.READY, ready);
    })();
    this.set("src", src => {
      destroyStream();
      _settings.src = src;
      if (_options.autoplay) {
        return _this.play();
      }
      if (_options.preload) {
        _this.load();
      }
    });
    this.get("src", _ => _settings.src);
    this.set("volume", v => {
      v = Math.clamp(v, 0, 1);
      _options.volume = v;
      if (_gain) {
        _gain.gain.value = _options.muted || _options.globalMuted ? 0 : v * _options.globalVolume;
      }
      return _options.volume;
    });
    this.get("volume", _ => _options.volume);
    this.set("loop", l => {
      l = !!l;
      if (_stream) {
        _stream.element.loop = l;
      }
      return _options.loop = l;
    });
    this.get("loop", _ => _options.loop);
    this.set("autoplay", autoplay => {
      _options.autoplay = autoplay;
    });
    this.get("autoplay", _ => _options.autoplay);
    this.set("preload", preload => {
      _options.preload = preload;
    });
    this.get("preload", _ => _options.preload);
    this.get("ready", _ => !!_stream);
    this.get("frequency", _ => {
      if (_analyser) {
        _analyser.getByteFrequencyData(_frequency);
      }
      return _frequency;
    });
    this.get("activity", _ => _analyser ? (_analyser.getByteFrequencyData(_frequency), Math.clamp(_frequency.slice(3, 13).reduce((n1, n2) => n1 + n2, 0) / 2560, 0, 1)) : 0);
    this.get("playing", _ => _settings.playing);
    this.set("rolloff", r => {
      _options.rolloff = r;
      if (_panner) {
        _panner.rolloffFactor = r;
      }
    });
    this.get("rolloff", _ => _options.rolloff);
    this.get("loaded", _ => true);
    this.get("duration", _ => _stream ? _stream.element.duration : 0);
    this.get("currentTime", _ => _stream ? _stream.element.currentTime : 0);
    this.set("currentTime", t => {
      _this.seek(t);
    });
    this.get("progress", _ => _this.currentTime / _this.duration);
    this.set("playbackRate", v => {
      _options.playbackRate = v;
      if (_stream && _stream.element) {
        _stream.element.playbackRate = v * _options.globalPlaybackRate;
      }
    });
    this.get("playbackRate", _ => _options.playbackRate);
    this.get("visibilityMuted", _ => _options.muted);
    this.set("visibilityMuted", muted => {
      if (muted === true) {
        _options.muteState = _options.muted;
      } else if (_options.muteState !== undefined) {
        muted = _options.muteState;
        delete _options.muteState;
      }
      if (_options.muted !== muted) {
        _options.muted = muted;
        _this.volume = _this.volume;
      }
    });
    this.get("muted", _ => _options.muted);
    this.set("muted", muted => {
      _options.muted = muted;
      _this.volume = _this.volume;
    });
    this.get("filter", _ => _filter);
    this.get("delay", _ => _delay);
    this.get("panner", _ => _panner);
    this.play = function () {
      _settings.autoplay = true;
      if (_settings.src) {
        createStream();
        if (_stream && _settings.playing !== true) {
          _settings.playing = true;
          _this.volume = _this.volume;
          _this.startRender(loop);
          _stream.element.playbackRate = _options.playbackRate ? _options.playbackRate : 1;
          _stream.element.play().catch(e => {});
        }
      }
    };
    this.pause = function () {
      _settings.autoplay = false;
      if (_stream && _settings.src && _settings.playing) {
        _currentTime = _stream.element.currentTime;
        _stream.element.pause();
        _settings.playing = false;
        _this.stopRender(loop);
      }
    };
    this.stop = function () {
      _settings.autoplay = false;
      if (_settings.src) {
        _currentTime = 0;
        _settings.playing = false;
        _this.stopRender(loop);
        if (_stream && _stream.element && _stream.element.stop) {
          _stream.element.stop();
          _stream.element.currentTime = 0;
        }
      }
    };
    this.seek = function (time) {
      if (_settings.src) {
        _currentTime = time;
        if (_stream) {
          _stream.element.currentTime = time;
        }
      }
    };
    this.load = function () {
      if (_settings.src) {
        if (!_settings.playing) {
          createStream();
          _stream.element.load();
        }
      }
    };
    this.unload = function () {
      _settings.autoplay = false;
      if (_settings.src) {
        if (_this.stop) {
          _this.stop();
        }
        destroyStream();
        Audio3DWA.unloadStream(_settings.src);
      }
    };
    this.convolve = async function (src) {
      _convolution = src;
      if (src === false) {
        if (_convolver) {
          _convolver.disconnect();
          _gain.disconnect();
          _gain.connect(_analyser);
          _convolver = null;
        }
        return;
      }
      let buffer = await Audio3DWA.loadBuffer(src);
      if (!_convolver) {
        _convolver = _context.createConvolver();
        _gain.disconnect();
        _convolver.connect(_analyser);
        _gain.connect(_convolver);
      }
      _convolver.buffer = buffer;
    };
    this.get("stream", _ => _stream);
  });
  Class(function ImageDecoder() {
    Inherit(this, Component);
    var _ktx1Settings;
    var _this = this;
    const ACTIVE = !!window.fetch && !!window.createImageBitmap && !!Device.system.browser.includes("chrome") && !window.AURA;
    function decodeImage(data, id) {
      (async _ => {
        try {
          let e = await fetch(data.path, {
            mode: "cors"
          });
          if (e.status != 200) {
            resolve({
              fail: true
            }, id);
            throw `Image not found :: ${data.path}`;
          }
          let blob = await e.blob();
          let obj = {
            imageOrientation: "flipY",
            crossOrigin: "anonymous"
          };
          if (data.params && data.params.premultiplyAlpha === false) {
            obj.premultiplyAlpha = "none";
          }
          obj.imageOrientation = data.params && data.params.flipY === false ? undefined : "flipY";
          let bitmap = await createImageBitmap(blob, obj);
          let message = {
            post: true,
            id: id,
            message: bitmap
          };
          self.postMessage(message, [bitmap]);
        } catch (e) {
          resolve({
            fail: `${data.path} could not be decoded: ${e.message || e}`
          }, id);
          throw e;
        }
      })();
    }
    function decodeKtx1CompressedImage(data, id) {
      (async _ => {
        let ext;
        if (data.settings.dxt) {
          ext = "dxt";
        } else if (data.settings.etc) {
          ext = "astc";
        } else if (data.settings.pvrtc) {
          ext = "pvrtc";
        } else if (data.settings.astc) {
          ext = "astc";
        }
        let fileName = data.path.split("/");
        fileName = fileName[fileName.length - 1];
        let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
        if (e.status != 200) {
          throw `Image not found :: ${data.path}`;
        }
        let arrayBuffer = await e.arrayBuffer();
        let header = new Int32Array(arrayBuffer, 12, 13);
        header[1];
        header[2];
        header[3];
        let gliFormat = header[4];
        header[5];
        let baseWidth = header[6];
        let baseHeight = header[7];
        let width = baseWidth;
        let height = baseHeight;
        let numberOfArrayElements = header[9];
        let numberOfFaces = header[10];
        let miplevels = header[11];
        let buffers = [];
        let compressedData = [];
        let sizes = [];
        let cube = numberOfFaces === 6 && numberOfArrayElements === 0;
        let dataOffset = 64 + header[12];
        for (let level = 0; level < miplevels; level++) {
          let imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0];
          dataOffset += 4;
          if (cube) {
            imageSize *= 6;
          }
          let byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);
          dataOffset += imageSize;
          dataOffset += 3 - (imageSize + 3) % 4;
          sizes.push(width);
          width = Math.max(1, width * 0.5);
          height = Math.max(1, height * 0.5);
          let clone = new Uint8Array(byteArray);
          compressedData.push(clone);
          buffers.push(clone.buffer);
        }
        resolve({
          gliFormat: gliFormat,
          compressedData: compressedData,
          sizes: sizes,
          width: baseWidth,
          height: baseHeight,
          cube: cube
        }, id, buffers);
      })().catch(e => {
        console.log(e.toString());
        resolve({
          fail: `${data.path} could not be decoded: ${e.message || e}`
        }, id);
      });
    }
    function findDominantColors(e, id) {
      let imageData = e.imageData;
      (async _ => {
        try {
          let threshold = 40 / 255;
          let colors = [];
          for (let i = 0; i < imageData.length; i += 4) {
            let r = imageData[i + 0] / 255;
            let g = imageData[i + 1] / 255;
            let b = imageData[i + 2] / 255;
            let color = new Color(r, g, b);
            if (i == 0) {
              colors.push([color, 1]);
            } else {
              let below = colors.filter(data => {
                let c = data[0];
                return Math.pow(c.r - r, 2) + Math.pow(c.g - g, 2) + Math.pow(c.b - b, 2) < threshold * threshold;
              });
              if (below.length == 0) {
                colors.push([color, 1]);
              } else {
                let closestColor = below.sort((a, b) => {
                  let d1 = a[0];
                  d1 = Math.pow(d1.r - r, 2) + Math.pow(d1.g - g, 2) + Math.pow(d1.b - b, 2);
                  let d2 = b[0];
                  d2 = Math.pow(d2.r - r, 2) + Math.pow(d2.g - g, 2) + Math.pow(d2.b - b, 2);
                  return d1 - d2;
                })[0][0];
                closestColor = colors.filter(el => el[0].equals(closestColor));
                closestColor = closestColor[0];
                let index = colors.indexOf(closestColor);
                colors[index][1]++;
              }
            }
          }
          let l = Math.floor(colors.length / 8);
          let c = [colors[0][0], colors[l * 1][0], colors[l * 2][0], colors[l * 3][0]];
          resolve({
            colors: c
          }, id);
        } catch (e) {
          resolve({
            fail: true
          }, id);
          throw e;
        }
      })();
    }
    this.scale = 1;
    (async function () {
      await Hydra.ready();
      Thread.upload(decodeImage);
      Thread.upload(findDominantColors);
      Thread.upload(decodeKtx1CompressedImage);
    })();
    this.decode = async function (path, params = {}) {
      let fallback = Thread.absolutePath(Assets.getPath("assets/images/_scenelayout/uv.jpg"));
      path = Thread.absolutePath(Assets.getPath(path));
      if (_ktx1Settings === undefined) {
        _ktx1Settings = {
          dxt: !!Renderer.extensions.s3tc,
          etc: !!Renderer.extensions.etc1,
          pvrtc: !!Renderer.extensions.pvrtc,
          astc: !!Renderer.extensions.astc
        };
        let found = false;
        for (let key in _ktx1Settings) {
          if (_ktx1Settings[key] === true) {
            found = true;
          }
        }
        if (!found) {
          _ktx1Settings = null;
        }
      }
      let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0];
      let compressed = !!compressedIdentifier && (compressedIdentifier.endsWith("2") ? "ktx2" : "ktx1");
      if (Utils.query("noKtx") || !_ktx1Settings && compressed === "ktx1") {
        path = path.replace(compressedIdentifier, "");
        compressed = false;
      }
      if (/\.ktx2(?:\?|#|$)/.test(path)) {
        compressed = "ktx2";
        if (Utils.query("noKtx")) {
          params.uncompressed = true;
        }
      }
      if (compressed) {
        try {
          let bitmap;
          path = path.substring(0, path.lastIndexOf("."));
          bitmap = compressed === "ktx1" ? await Thread.shared().decodeKtx1CompressedImage({
            path: path,
            params: params,
            settings: _ktx1Settings
          }) : await Ktx2Transcoder.transcode({
            path: `${path}.ktx2`,
            params: params
          });
          if (!bitmap.fail) {
            return bitmap;
          }
        } catch (e) {}
        return _this.decode(fallback, params);
      }
      {
        let getBitmap = (path, params) => ACTIVE ? Thread.shared().decodeImage({
          path: path,
          params: params
        }) : Assets.decodeImage(path, params);
        try {
          let bitmap = await getBitmap(path, params);
          if (bitmap.fail && (bitmap = await getBitmap(fallback, params), bitmap.fail)) {
            throw "could not decode " + path;
          }
          return function process(bitmap, scale) {
            if (scale * _this.scale == 1) {
              return bitmap;
            }
            let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height);
            let canvas = document.createElement("canvas");
            canvas.context = canvas.getContext("2d");
            canvas.width = Math.round(bitmap.width * _this.scale * scale);
            canvas.height = Math.round(bitmap.height * _this.scale * scale);
            if (pow2 && scale * _this.scale < 1) {
              canvas.width = canvas.height = Math.floorPowerOf2(Math.max(canvas.width, canvas.height));
            }
            canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
            return canvas;
          }(bitmap, params.scale || 1);
        } catch (e) {
          throw "could not decode " + path;
        }
      }
    };
    this.parseColors = async function (imageData) {
      return await Thread.shared().findDominantColors({
        imageData: imageData
      });
    };
  }, "static");
  Class(function Ktx2Transcoder() {
    Inherit(this, Component);
    const _this = this;
    var _transcoderReady;
    var _basisAssets = ["~assets/js/lib/basis_transcoder.js", "~assets/js/lib/basis_transcoder.wasm"].map(Assets.getPath).map(Thread.absolutePath);
    async function initBasisTranscoder() {
      if (_transcoderReady) {
        await _transcoderReady;
      } else {
        _transcoderReady = Promise.create();
        let [js, wasmBinary] = await Promise.all(_basisAssets.map(async (path, i) => {
          let response = await fetch(path);
          if (i === 0) {
            return response.text();
          } else {
            return response.arrayBuffer();
          }
        }));
        let formats = function getSupportedFormats() {
          let supported = {
            astc: !!Renderer.extensions.astc,
            etc1: !!Renderer.extensions.etc1,
            etc2: !!Renderer.extensions.etc,
            dxt: !!Renderer.extensions.s3tc,
            bptc: !!Renderer.extensions.bptc,
            pvrtc: !!Renderer.extensions.pvrtc,
            uncompressed: true
          };
          if (Renderer.type === Renderer.WEBGL2) {
            supported.etc1 = false;
          }
          let formats = {};
          Object.keys(supported).filter(id => supported[id]).forEach(id => {
            let format = {
              id: id,
              needsPowerOfTwo: false
            };
            formats[id] = format;
            switch (id) {
              case "astc":
                format.gliFormat = [Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR];
                break;
              case "bptc":
                format.gliFormat = [Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT];
                break;
              case "dxt":
                format.gliFormat = [Renderer.extensions.s3tc.COMPRESSED_RGB_S3TC_DXT1_EXT, Renderer.extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT];
                break;
              case "etc2":
                format.gliFormat = [Renderer.extensions.etc.COMPRESSED_RGB8_ETC2, Renderer.extensions.etc.COMPRESSED_RGBA8_ETC2_EAC];
                break;
              case "etc1":
                format.gliFormat = [Renderer.extensions.etc.COMPRESSED_RGB_ETC1_WEBGL];
                break;
              case "pvrtc":
                format.gliFormat = [Renderer.extensions.pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG, Renderer.extensions.pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG];
                format.needsPowerOfTwo = true;
                break;
              case "uncompressed":
                format.gliFormat = [Renderer.context.RGBA, Renderer.context.RGBA];
            }
          });
          return formats;
        }();
        let threads = Thread.shared(true).array;
        await Promise.all(threads.map(async thread => {
          thread.importCode(js);
          thread.loadFunction(initKtx2TranscoderThread);
          thread.loadFunction(function transcodeKtx2() {});
          await thread.initKtx2TranscoderThread({
            wasmBinary: wasmBinary,
            formats: formats
          });
        }));
        _transcoderReady.resolve();
        _this.flag("transcoderLoaded", true);
      }
    }
    function initKtx2TranscoderThread(e, id) {
      var _formats;
      async function transcodeKtx2({
        path: path,
        params: params
      }, id) {
        let ktx2File;
        try {
          let response = await fetch(path);
          if (response.status !== 200) {
            throw new Error(`Image not found :: ${path}`);
          }
          let arrayBuffer = await response.arrayBuffer();
          ktx2File = new BasisModule.KTX2File(new Uint8Array(arrayBuffer));
          if (!ktx2File.isValid()) {
            throw new Error("Invalid or unsupported .ktx2 file");
          }
          let basisFormat = ktx2File.isUASTC() ? "uastc" : "etc1s";
          let baseWidth = ktx2File.getWidth();
          let baseHeight = ktx2File.getHeight();
          let layers = ktx2File.getLayers() || 1;
          let levels = ktx2File.getLevels();
          let faceCount = ktx2File.getFaces();
          let hasAlpha = ktx2File.getHasAlpha();
          let premultiplyAlpha = !!(ktx2File.getDFDFlags() & 1);
          let {
            transcoderFormat: transcoderFormat,
            gliFormat: gliFormat,
            uncompressed: uncompressed
          } = function getTranscoderFormat(basisFormat, width, height, hasAlpha, params) {
            let format;
            format = params.uncompressed ? _formats.uncompressed : _formats[basisFormat].find(format => (!hasAlpha || !(format.transcoderFormat.length < 2)) && (!format.needsPowerOfTwo || !!Math.isPowerOf2(width, height)));
            let uncompressed = format.id === "uncompressed";
            if (uncompressed && !params.uncompressed) {
              console.warn("No suitable compressed texture format found. Decoding to RGBA32.");
            }
            let which = hasAlpha ? 1 : 0;
            return {
              transcoderFormat: format.transcoderFormat[which],
              gliFormat: format.gliFormat[which],
              uncompressed: uncompressed
            };
          }(basisFormat, baseWidth, baseHeight, hasAlpha, params);
          if (!baseWidth || !baseHeight || !levels) {
            throw new Error("Invalid texture");
          }
          if (layers > 1) {
            throw new Error("Array textures not implemented");
          }
          if (!ktx2File.startTranscoding()) {
            throw new Error("startTranscoding failed");
          }
          let buffers = [];
          let compressedData = [];
          let sizes = [];
          let cube = faceCount === 6;
          for (let level = 0; level < levels; level++) {
            let width;
            let height;
            let data;
            let faces = [];
            for (let faceIndex = 0; faceIndex < faceCount; ++faceIndex) {
              let levelInfo = ktx2File.getImageLevelInfo(level, 0, faceIndex);
              width = levelInfo.origWidth;
              height = levelInfo.origHeight;
              let data = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(level, 0, faceIndex, transcoderFormat));
              if (!ktx2File.transcodeImage(data, level, 0, faceIndex, transcoderFormat, 0, -1, -1)) {
                throw new Error("transcodeImage failed");
              }
              faces.push(data);
            }
            if (faces.length > 1) {
              let totalLength = 0;
              faces.forEach(face => {
                totalLength += face.byteLength;
              });
              data = new Uint8Array(totalLength);
              let offset = 0;
              faces.forEach(face => {
                data.set(face, offset);
                offset += face.byteLength;
              });
            } else {
              data = faces[0];
            }
            compressedData.push(data);
            buffers.push(data.buffer);
            sizes.push({
              width: width,
              height: height
            });
          }
          resolve({
            gliFormat: gliFormat,
            compressedData: compressedData,
            sizes: sizes,
            width: baseWidth,
            height: baseHeight,
            cube: cube,
            premultiplyAlpha: premultiplyAlpha,
            uncompressed: uncompressed
          }, id, buffers);
        } catch (e) {
          console.log(e.toString());
          resolve({
            fail: `${path} could not be decoded: ${e.message || e}`
          }, id);
        } finally {
          if (ktx2File) {
            ktx2File.close();
            ktx2File.delete();
          }
        }
      }
      var BasisModule = {
        wasmBinary: e.wasmBinary,
        onRuntimeInitialized: function () {
          BasisModule.initializeBasis();
          (function initFormats(formats) {
            Object.keys(formats).forEach(id => {
              let format = formats[id];
              switch (id) {
                case "astc":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA.value, BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA.value];
                  break;
                case "bptc":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFBC7_RGBA.value, BasisModule.transcoder_texture_format.cTFBC7_RGBA.value];
                  break;
                case "dxt":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFBC1_RGB.value, BasisModule.transcoder_texture_format.cTFBC3_RGBA.value];
                  break;
                case "etc2":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFETC1_RGB.value, BasisModule.transcoder_texture_format.cTFETC2_RGBA.value];
                  break;
                case "etc1":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFETC1_RGB.value];
                  break;
                case "pvrtc":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGB.value, BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGBA.value];
                  break;
                case "uncompressed":
                  format.transcoderFormat = [BasisModule.transcoder_texture_format.cTFRGBA32.value, BasisModule.transcoder_texture_format.cTFRGBA32.value];
              }
            });
            _formats = {
              uastc: [formats.astc, formats.bptc, formats.etc2, formats.etc1, formats.dxt, formats.pvrtc, formats.uncompressed].filter(Boolean),
              etc1s: [formats.etc2, formats.etc1, formats.bptc, formats.dxt, formats.pvrtc, formats.uncompressed].filter(Boolean),
              uncompressed: formats.uncompressed
            };
          })(e.formats);
          self.transcodeKtx2 = transcodeKtx2;
          delete self.initKtx2TranscoderThread;
          resolve(id);
        }
      };
      BASIS(BasisModule);
    }
    _this.transcode = async function ({
      path: path,
      params: params
    }) {
      if (!_this.flag("transcoderLoaded")) {
        await initBasisTranscoder();
      }
      let result = await Thread.shared().transcodeKtx2({
        path: path,
        params: params
      });
      if (result.fail) {
        throw new Error(result.fail);
      }
      return result;
    };
  }, "static");
  Class(function BaseCamera(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _debugCamera;
    var _type = "perspective";
    function resize() {
      if (_this.overrideResize) {
        if (typeof _this.overrideResize == "function") {
          _this.overrideResize();
        }
      } else {
        switch (_type) {
          case "perspective":
            _this.camera.aspect = Stage.width / Stage.height;
            _this.camera.updateProjectionMatrix();
            break;
          case "orthographic":
            if (_this.width || _this.height) {
              _this.camera.setViewport(_this.width, _this.height);
            } else {
              let m = 900 / Stage.height / 100;
              _this.camera.setViewport(Stage.width * m, Stage.height * m);
            }
        }
      }
    }
    this.camera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
    this.group.add(this.camera);
    this.playgroundLock = function (camera = Camera.instance()) {
      if (!Global.PLAYGROUND) {
        return;
      }
      if (Utils.getConstructorName(_this.parent).includes(Global.PLAYGROUND.split("/")[0]) && RenderManager.type == RenderManager.NORMAL) {
        camera.lock(_this.camera);
      }
    };
    this.lock = function (camera = Camera.instance()) {
      if (_type == "orthographic" && !camera.worldCamera.isOrthographicCamera) {
        return console.error("You can't lock an orthographic camera to the main camera. Use an FXScene .setCamera");
      }
      if (RenderManager.type == RenderManager.NORMAL) {
        camera.lock(_this.camera);
      }
    };
    this.transition = function (time, ease, delay, camera = Camera.instance()) {
      if (typeof delay == "object") {
        camera = delay;
        delay = 0;
      }
      let p = Promise.create();
      camera.transition(_this.camera, time, ease, delay || 0);
      _this.delayedCall(_ => p.resolve(), time + (delay || 0));
      return p;
    };
    this.manualTransition = function (camera = Camera.instance()) {
      return camera.manualTransition(_this.camera);
    };
    this.setFOV = function (fov) {
      if (_type !== "orthographic" && fov != this.camera.fov) {
        this.camera.fov = fov;
        this.camera.updateProjectionMatrix();
      }
    };
    this.getFOV = function () {
      return this.camera.fov;
    };
    this.useOrthographic = function (w, h) {
      if (_type !== "orthographic") {
        if (!isNaN(w)) {
          this.width = w;
        }
        if (!isNaN(h)) {
          this.height = h;
        }
        if (this.camera) {
          this.group.remove(this.camera);
        }
        this.camera = new OrthographicCamera();
        this.group.add(this.camera);
        this.camera.position.z = 1;
        _type = "orthographic";
        resize();
      }
    };
    this.usePerspective = function () {
      if (_type !== "perspective") {
        if (this.camera) {
          this.group.remove(this.camera);
        }
        this.camera = new PerspectiveCamera();
        this.group.add(this.camera);
        _type = "perspective";
        resize();
      }
    };
    this.useCurve = function (curve) {
      _this.camera.curve = curve;
      return this;
    };
    _this.get("zoom", () => _this.camera.zoom);
    _this.set("zoom", zoom => {
      _this.camera.zoom = zoom;
      _this.camera.updateProjectionMatrix();
    });
    _this.get("near", () => _this.camera.near);
    _this.set("near", near => {
      _this.camera.near = near;
      _this.camera.updateProjectionMatrix();
    });
    _this.get("far", () => _this.camera.far);
    _this.set("far", far => {
      _this.camera.far = far;
      _this.camera.updateProjectionMatrix();
    });
    (function init() {
      _this.startRender(_ => {
        _this.group.updateMatrixWorld(true);
        if (_debugCamera && _debugCamera.visible) {
          Utils3D.decompose(_this.camera, _debugCamera);
          let viewportHeight;
          let active = AppState.get("playground_camera_active");
          viewportHeight = active.isOrthographicCamera ? (active.top - active.bottom) / active.zoom : Utils3D.getHeightFromCamera(active, _this.camera.position.distanceTo(active.position));
          _debugCamera.scale.setScalar(viewportHeight * 0.025 / 0.1);
        }
      });
      _this.onResize(resize);
      if (_input) {
        _this.prefix = _input.prefix;
        let cameraUIL = CameraUIL.add(_this, _group);
        cameraUIL.setLabel("Camera");
        _this.group._cameraUIL = cameraUIL;
      }
      if (Global.PLAYGROUND) {
        AppState.bind("playground_camera_active", active => {
          if (_this.group._parent) {
            if (active) {
              if (!_debugCamera) {
                (_debugCamera = new Mesh(new BoxGeometry(0.1, 0.1, 0.2), new Shader("DebugCamera", {
                  uColor: {
                    value: new Color("#ffffff")
                  },
                  transparent: true,
                  depthTest: false
                }))).renderOrder = 9999;
                _this.delayedCall(_ => _this.group._parent.add(_debugCamera), 50);
              }
              _debugCamera.visible = true;
            } else if (_debugCamera) {
              _debugCamera.visible = false;
            }
          }
        });
      }
    })();
  });
  Class(function Camera(_worldCamera) {
    Inherit(this, Component);
    const _this = this;
    var _prevCamera;
    var _lockCamera;
    var _curve;
    var _manual;
    var _scheduleSlot;
    var _calc = new Vector3();
    var _target = new Group();
    var _anim = {
      weight: 0,
      weight2: 0
    };
    new Vector3();
    var _cameraTarget = new Group();
    var _cameraTarget2 = new Group();
    function loop() {
      if (!_scheduleSlot) {
        render();
      }
    }
    function render() {
      if (_manual) {
        _anim.weight2 = _manual.value;
      }
      _anim.weight += (_anim.weight2 - _anim.weight) * _this.lerp;
      if (_prevCamera) {
        _prevCamera.updateMatrixWorld();
        _lockCamera.updateMatrixWorld();
        if (_curve) {
          _curve.lerpPos ||= new Vector3().copy(_prevCamera.getWorldPosition());
          _curve.lerpOffset ||= new Vector3().copy(_curve.getPointAt(1)).multiplyScalar(-2).add(_lockCamera.getWorldPosition());
          let pos = _calc.copy(_curve.getPointAt(_anim.weight)).add(_curve.lerpOffset).add(_lockCamera.getWorldPosition());
          _curve.lerpPos.lerp(pos, _curve.lerp || 1, false);
          _target.position.copy(_curve.lerpPos);
          if (_anim.weight >= 1) {
            _curve = _curve.lerpPos = _curve.lerpOffset = null;
            if (_this.onCurveComplete) {
              _this.onCurveComplete();
            }
          }
        } else {
          _target.position.copy(_prevCamera.getWorldPosition()).lerp(_lockCamera.getWorldPosition(), _anim.weight, false);
        }
        _target.quaternion.copy(_prevCamera.getWorldQuaternion()).slerp(_lockCamera.getWorldQuaternion(), _anim.weight, false);
        let needsUpdate = false;
        let zoom = Math.mix(_prevCamera.zoom, _lockCamera.zoom, _anim.weight);
        if (_worldCamera.zoom !== zoom) {
          _worldCamera.zoom = zoom;
          needsUpdate = true;
        }
        let fov = !_worldCamera.isOrthographicCamera && Math.mix(_prevCamera.fov, _lockCamera.fov, _anim.weight);
        if (fov && _worldCamera.fov !== fov) {
          _worldCamera.fov = fov;
          needsUpdate = true;
        }
        let near = Math.mix(_prevCamera.near, _lockCamera.near, _anim.weight);
        if (_worldCamera.near !== near) {
          _worldCamera.near = near;
          needsUpdate = true;
        }
        let far = Math.mix(_prevCamera.far, _lockCamera.far, _anim.weight);
        if (_worldCamera.far !== far) {
          _worldCamera.far = far;
          needsUpdate = true;
        }
        if (needsUpdate) {
          _worldCamera.updateProjectionMatrix();
        }
        _cameraTarget.position.lerp(_target.position, _this.lerp2, false);
        _cameraTarget.quaternion.slerp(_target.quaternion, _this.lerp2, false);
      } else if (_lockCamera) {
        _lockCamera.updateMatrixWorld();
        Utils3D.decompose(_lockCamera, _cameraTarget);
        let needsUpdate = false;
        if (_lockCamera.zoom && _worldCamera.zoom != _lockCamera.zoom) {
          _worldCamera.zoom = _lockCamera.zoom;
          needsUpdate = true;
        }
        if (!_worldCamera.isOrthographicCamera && _worldCamera.fov != _lockCamera.fov) {
          _worldCamera.fov = _lockCamera.fov;
          needsUpdate = true;
        }
        if (_worldCamera.near !== _lockCamera.near) {
          _worldCamera.near = _lockCamera.near;
          needsUpdate = true;
        }
        if (_worldCamera.far !== _lockCamera.far) {
          _worldCamera.far = _lockCamera.far;
          needsUpdate = true;
        }
        if (needsUpdate) {
          _worldCamera.updateProjectionMatrix();
        }
      }
      _cameraTarget2.position.lerp(_cameraTarget.position, _this.finalLerp, false);
      _cameraTarget2.quaternion.slerp(_cameraTarget.quaternion, _this.finalLerp, false);
      _worldCamera.position.lerp(_cameraTarget2.position, _this.finalLerp, false);
      _worldCamera.quaternion.slerp(_cameraTarget2.quaternion, _this.finalLerp, false);
      _worldCamera.updateMatrixWorld();
      RenderManager.fire(_this);
    }
    this.lerp = 1;
    this.lerp2 = 1;
    this.worldCamera = _worldCamera;
    this.finalLerp = 1;
    this.multiTween = true;
    (function () {
      if (RenderManager.type != RenderManager.NORMAL) {
        _worldCamera = undefined;
        _this.worldCamera = _worldCamera;
        return;
      }
      _worldCamera.controllingCamera = _this;
      _this.startRender(loop, RenderManager.AFTER_LOOPS);
    })();
    this.lock = function (camera, scheduleSlot) {
      if (camera instanceof Camera) {
        scheduleSlot = camera;
        camera = camera.worldCamera;
      } else if (camera.controllingCamera) {
        scheduleSlot = camera.controllingCamera;
      }
      _lockCamera = camera;
      _prevCamera = null;
      if (_worldCamera) {
        if (_scheduleSlot) {
          _this.stopRender(render, _scheduleSlot);
        }
        if (_scheduleSlot = scheduleSlot) {
          _this.startRender(render, _scheduleSlot);
        }
        if (_lockCamera.zoom) {
          _worldCamera.zoom = _lockCamera.zoom;
        }
        if (!_worldCamera.isOrthographicCamera) {
          _worldCamera.fov = _lockCamera.fov;
        }
        _worldCamera.updateProjectionMatrix();
        render();
      }
    };
    this.transition = function (camera, duration = 1000, ease = "easeInOutCubic", scheduleSlotOrDelay) {
      let delay;
      let scheduleSlot;
      if (typeof scheduleSlotOrDelay == "number") {
        delay = scheduleSlotOrDelay;
      } else if (scheduleSlotOrDelay) {
        scheduleSlot = scheduleSlotOrDelay;
      }
      if (camera instanceof Camera) {
        scheduleSlot = camera;
        camera = camera.worldCamera;
      } else if (camera.controllingCamera) {
        scheduleSlot = camera.controllingCamera;
      }
      _curve &&= _curve.lerpPos = _curve.lerpOffset = null;
      if (camera.curve) {
        (_curve = camera.curve).lerpPos = camera.lerpPos;
      }
      if (_prevCamera === camera) {
        duration *= Math.smoothStep(0.5, 1, _anim.weight) * 0.5 + 0.5;
        _anim.weight = 1 - _anim.weight;
      } else {
        _anim.weight = 0;
      }
      _manual = undefined;
      if (scheduleSlot && _worldCamera) {
        if (_scheduleSlot) {
          _this.stopRender(render, _scheduleSlot);
        }
        _scheduleSlot = scheduleSlot;
        _this.startRender(render, _scheduleSlot);
      }
      _anim.weight2 = _anim.weight;
      _prevCamera = _lockCamera;
      _lockCamera = camera;
      return tween(_anim, {
        weight2: 1
      }, duration, ease, delay);
    };
    this.manualTransition = function (camera) {
      this.transition(camera).stop();
      return _manual = {
        value: 0
      };
    };
    this.setPrevCamera = function (camera) {
      _prevCamera = camera.camera || camera;
    };
    this.get("worldCamera", _ => _worldCamera);
    this.get("lockCamera", _ => _lockCamera);
    this.set("debugScale", s => {
      undefined;
    });
    this.createLocal = function (camera) {
      if (!camera) {
        camera = World.CAMERA.clone();
        _this.onResize(_ => {
          camera.aspect = Stage.width / Stage.height;
          camera.updateProjectionMatrix();
        });
      }
      return new Camera(camera.camera || camera);
    };
  }, "singleton");
  Class(function GazeCamera(_input, _group) {
    Inherit(this, BaseCamera);
    const _this = this;
    var _strength = {
      v: 1
    };
    var _cacheObj = {};
    var _move = new Vector3();
    var _position = new Vector3();
    var _wobble = new Vector3();
    var _rotation = 0;
    var _wobbleAngle = Math.radians(Math.rand(0, 360));
    var _innerGroup = new Group();
    var _viewportFocusOffset = new Vector3();
    var _hasViewportFocusOffset = false;
    var _manualRender = false;
    var _quaternion = new Quaternion();
    const V3_ZERO = new Vector3(0);
    function loop() {
      if (_hasViewportFocusOffset) {
        _this.camera.position.sub(_viewportFocusOffset);
      }
      if (_this.useAccelerometer && Mobile.Accelerometer && Mobile.Accelerometer.connected) {
        _move.x = _this.position.x + Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, true) * _strength.v * _this.moveXY.x * _this.strength;
        _move.y = _this.position.y;
      } else {
        _move.x = _this.position.x + Math.range(Mouse.x, 0, Stage.width, -1, 1, true) * _strength.v * _this.moveXY.x * _this.strength;
        _move.y = _this.position.y + Math.range(Mouse.y, 0, Stage.height, -1, 1, true) * _strength.v * _this.moveXY.y * _this.strength;
        let rotateStrength = Math.range(Math.abs(Mouse.delta.x) / Stage.width, 0, 0.02, 0, 1, true);
        _rotation = Math.lerp(Math.radians(_this.deltaRotate) * rotateStrength * Math.sign(Mouse.delta.x), _rotation, _this.deltaLerp * 0.02 * _strength.v);
        _innerGroup.rotation.z = Math.lerp(_rotation, _innerGroup.rotation.z, _this.deltaLerp * 0.07);
      }
      _move.z = _this.position.z;
      _position.lerp(_move, _this.lerpSpeed2);
      _position.z += _this.zoomOffset;
      _this.camera.position.lerp(_position, _this.lerpSpeed);
      _this.camera.lookAt(_this.lookAt);
      if (Math.abs(_this.cameraRotation.x) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.y) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.z) > Base3D.DIRTY_EPSILON) {
        _quaternion.setFromEuler(_this.cameraRotation);
        _this.camera.quaternion.multiply(_quaternion);
      }
      (function focusViewport() {
        let nextHasViewportFocusOffset = Math.abs(_this.viewportFocus.x) > 0.0001 || Math.abs(_this.viewportFocus.y) > 0.0001;
        if (nextHasViewportFocusOffset !== _hasViewportFocusOffset) {
          if (!nextHasViewportFocusOffset) {
            _viewportFocusOffset.setScalar(0);
          }
          _hasViewportFocusOffset = nextHasViewportFocusOffset;
        }
        if (!_hasViewportFocusOffset) {
          return;
        }
        let localCamera = _cacheObj;
        let camera = _this.camera;
        if (camera.matrixDirty) {
          camera.updateMatrix();
        }
        localCamera.matrixWorld = camera.matrix;
        localCamera.projectionMatrix = camera.projectionMatrix;
        _viewportFocusOffset.copy(_this.lookAt).project(localCamera);
        _viewportFocusOffset.x -= _this.viewportFocus.x;
        _viewportFocusOffset.y -= _this.viewportFocus.y;
        _viewportFocusOffset.unproject(localCamera);
        _viewportFocusOffset.sub(_this.lookAt);
        _this.camera.position.add(_viewportFocusOffset);
      })();
      if (_this.wobbleStrength > 0) {
        let t = Render.TIME;
        _wobble.x = Math.cos(_wobbleAngle + t * (_this.wobbleSpeed * 0.00075)) * (_wobbleAngle + Math.sin(t * (_this.wobbleSpeed * 0.00095)) * 200);
        _wobble.y = Math.sin(Math.asin(Math.cos(_wobbleAngle + t * (_this.wobbleSpeed * 0.00085)))) * (Math.sin(_wobbleAngle + t * (_this.wobbleSpeed * 0.00075)) * 150);
        _wobble.x *= Math.sin(_wobbleAngle + t * (_this.wobbleSpeed * 0.00075)) * 2;
        _wobble.y *= Math.cos(_wobbleAngle + t * (_this.wobbleSpeed * 0.00065)) * 1.75;
        _wobble.x *= Math.cos(_wobbleAngle + t * (_this.wobbleSpeed * 0.00075)) * 1.1;
        _wobble.y *= Math.sin(_wobbleAngle + t * (_this.wobbleSpeed * 0.00025)) * 1.15;
        _wobble.z = Math.sin(_wobbleAngle + _wobble.x * 0.0025) * (_this.wobbleZ * 100);
        _wobble.multiplyScalar(_this.wobbleStrength * 0.001 * _strength.v);
        _innerGroup.position.lerp(_wobble, 0.07);
        _this.flag("hasWobble", true);
      } else if (_this.flag("hasWobble")) {
        _innerGroup.position.lerp(V3_ZERO, 0.07);
        if (_innerGroup.position.length() < 0.001) {
          _innerGroup.position.set(0, 0, 0);
          _this.flag("hasWobble", false);
        }
      }
    }
    this.strength = 1;
    this.moveXY = new Vector2(4, 4);
    this.position = new function Position() {
      Inherit(this, Component);
      var _x = 0;
      var _y = 0;
      var _z = 0;
      this.get("x", _ => _x);
      this.get("y", _ => _y);
      this.get("z", _ => _z);
      this.set("x", x => {
        _x = x;
      });
      this.set("y", y => {
        _y = y;
      });
      this.set("z", z => {
        _z = z;
        _move.z = _z;
        _this.camera.position.copy(_move);
        _position.copy(_move);
      });
      this.set = function (x, y, z, noCopy) {
        _x = x;
        _y = y;
        _z = z;
        _move.z = z;
        if (!noCopy) {
          _this.camera.position.copy(_move);
        }
        _position.copy(_move);
      };
      this.toArray = function () {
        return [_x, _y, _z];
      };
      this.fromArray = function (array) {
        _x = array[0];
        _y = array[1];
        _z = array[2];
        _move.set(_x, _y, _z);
        _this.camera.position.copy(_move);
        _position.copy(_move);
      };
      this.copy = function (vec) {
        _x = vec.x;
        _y = vec.y;
        _z = vec.z;
        _move.set(_x, _y, _z);
        _this.camera.position.copy(_move);
        _position.copy(_move);
      };
    }();
    this.lerpSpeed = 0.05;
    this.lerpSpeed2 = 1;
    this.lookAt = new Vector3(0, 0, 0);
    this.cameraRotation = new Euler();
    this.viewportFocus = new Vector2(0, 0);
    this.deltaRotate = 0;
    this.deltaLerp = 1;
    this.wobbleSpeed = 1;
    this.wobbleStrength = 0;
    this.wobbleZ = 1;
    this.zoomOffset = 0;
    (function () {
      if (_input) {
        _this.prefix = _input.prefix;
        let cameraUIL = CameraUIL.add(_this, _group);
        cameraUIL.setLabel("Camera");
        _this.group._cameraUIL = cameraUIL;
      }
      _this.startRender(loop);
      _innerGroup.add(_this.camera);
      _this.group.add(_innerGroup);
    })();
    this.orbit = function (time = 1000, ease = "easeInOutSine") {
      return tween(_strength, {
        v: 1
      }, time, ease);
    };
    this.still = function (time = 300, ease = "easeInOutSine") {
      return tween(_strength, {
        v: 0
      }, time, ease);
    };
    var _v1 = new Vector3();
    var _v2 = new Vector3();
    var _v3 = new Vector3();
    this.move = function (vec) {
      let moveDiff = _v1.subVectors(_move, _this.position);
      let positionDiff = _v2.subVectors(_move, _position);
      let cameraPosDiff = _v3.subVectors(_this.camera.position, _position);
      _this.position.set(vec.x, vec.y, vec.z, true);
      _move.copy(vec).add(moveDiff);
      _position.copy(_move).add(positionDiff);
      _this.camera.position.copy(_position).add(cameraPosDiff);
    };
    this.get("manualRender", () => _manualRender);
    this.set("manualRender", value => {
      if ((value = !!value) !== _manualRender) {
        if (_manualRender = value) {
          _this.stopRender(loop);
        } else {
          _this.startRender(loop);
        }
      }
    });
    this.update = function () {
      if (!_manualRender && !!Hydra.LOCAL && !_this.flag("manualRenderWarned")) {
        console.warn("Set manualRender to true if using GazeCamera.update()");
        _this.flag("manualRenderWarned", true);
      }
      loop();
    };
  });
  class Base3D {
    constructor() {
      this.position = new Vector3D();
      this.rotation = new Euler();
      this.quaternion = new Quaternion();
      this.scale = new Vector3D(1, 1, 1);
      this._parent = null;
      this.up = new Vector3(0, 1, 0);
      this.isObject3D = true;
      this.children = [];
      this.childrenLength = 0;
      this.modelViewMatrix = new Matrix4();
      this.normalMatrix = new Matrix3();
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = true;
      this.matrixWorldNeedsUpdate = false;
      this.matrixDirty = true;
      this.decomposeDirty = true;
      this.visible = true;
      this.hidden = false;
      this.castShadow = false;
      this.frustumCulled = true;
      this.occlusionCulled = false;
      this._renderOrder = 0;
      this.worldPos = new Vector3();
      this.worldQuat = new Quaternion();
      const _this = this;
      this.quaternion.onChange(_ => {
        _this.matrixDirty = true;
        _this.decomposeDirty = true;
        if (_this.onMatrixDirty) {
          _this.onMatrixDirty();
        }
        _this.rotation.setFromQuaternion(_this.quaternion, undefined, false);
      });
      this.rotation.onChange(_ => {
        _this.matrixDirty = true;
        _this.decomposeDirty = true;
        if (_this.onMatrixDirty) {
          _this.onMatrixDirty();
        }
        _this.quaternion.setFromEuler(_this.rotation, false);
      });
      this.scale.onChange(_ => {
        _this.matrixDirty = true;
        _this.decomposeDirty = true;
        if (_this.onMatrixDirty) {
          _this.onMatrixDirty();
        }
      });
      this.position.onChange(_ => {
        _this.matrixDirty = true;
        _this.decomposeDirty = true;
        if (_this.onMatrixDirty) {
          _this.onMatrixDirty();
        }
      });
    }
    get renderOrder() {
      return this._renderOrder;
    }
    set renderOrder(value) {
      this._renderOrder = value;
      let p = this._parent;
      while (p) {
        if (p instanceof Scene) {
          p.displayNeedsUpdate = true;
        }
        p = p._parent;
      }
      for (let i = 0; i < this.children.length; i++) {
        this.children[i].renderOrder += value;
      }
    }
    applyMatrix(matrix) {
      this.matrix.multiplyMatrices(matrix, this.matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
      return this;
    }
    applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    }
    localToWorld(v) {
      return v.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(v) {
      let m1 = this.M1 || new Matrix4();
      this.M1 = m1;
      return v.applyMatrix4(m1.getInverse(this.matrixWorld));
    }
    lookAt(x, y, z) {
      let m1 = this.M1 || new Matrix4();
      this.M1 = m1;
      let v = this.V1 || new Vector3();
      this.V1 = v;
      if (x.isVector3) {
        v.copy(x);
      } else {
        v.set(x, y, z);
      }
      if (this.isCamera) {
        m1.lookAt(this.position, v, this.up);
      } else {
        m1.lookAt(v, this.position, this.up);
      }
      this.quaternion.setFromRotationMatrix(m1);
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        return this;
      }
      if (object && object.isObject3D) {
        if (object._parent !== null) {
          object._parent.remove(object);
        }
        object._parent = this;
        this.children.push(object);
        this.childrenLength = this.children.length;
      } else {
        console.error("Object is not instance of Object3D", object);
      }
      if (this.isScene) {
        this.displayNeedsUpdate = true;
      } else {
        let p = this._parent;
        while (p) {
          if (p instanceof Scene) {
            p.displayNeedsUpdate = true;
          }
          p = p._parent;
        }
      }
      return this;
    }
    attach(object) {
      this.updateMatrixWorld(true);
      let m1 = this.M1 || new Matrix4();
      this.M1 = m1;
      const worldInverse = this.M1.getInverse(this.matrixWorld);
      if (object._parent !== null) {
        object._parent.updateMatrixWorld(true);
        worldInverse.multiply(object._parent.matrixWorld);
      }
      object.applyMatrix(worldInverse);
      this.add(object);
      object.updateMatrixWorld(true);
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      if (this.isScene) {
        this.displayNeedsUpdate = true;
      } else {
        let p = this._parent;
        while (p) {
          if (p instanceof Scene) {
            p.displayNeedsUpdate = true;
          }
          p = p._parent;
        }
      }
      this.children.remove(object);
      this.childrenLength = this.children.length;
    }
    getWorldPosition(target) {
      let v = this.V1 || new Vector3();
      this.V1 = v;
      target ||= v;
      this.updateMatrixWorld();
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldScale(target) {
      let v = this.V1S || new Vector3();
      this.V1S = v;
      let v2 = this.V12 || new Vector3();
      this.V2 = v2;
      let q = this.Q1 || new Quaternion();
      this.Q1 = q;
      target ||= v2;
      this.updateMatrixWorld();
      this.matrixWorld.decompose(v, q, target);
      return target;
    }
    getWorldQuaternion(target) {
      let v = this.V1Q || new Vector3();
      this.V1Q = v;
      let q = this.Q1 || new Quaternion();
      this.Q1 = q;
      target ||= q;
      this.updateMatrixWorld();
      this.matrixWorld.decompose(v, target, v);
      return target;
    }
    traverse(callback) {
      callback(this);
      let children = this.children;
      for (let i = 0; i < children.length; i++) {
        children[i].traverse(callback);
      }
    }
    updateMatrix() {
      if (this.matrixAutoUpdate !== false) {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate === false) {
        return;
      }
      if (!force && !this.determineVisible()) {
        return;
      }
      if ((this.determineDirty() || force) && this.matrixAutoUpdate === true) {
        this.updateMatrix();
      }
      if (this.matrixWorldNeedsUpdate === true || force === true) {
        if (this._parent === null || this.determineNoTransform()) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this._parent.matrixWorld, this.matrix);
          if (RenderStats.active) {
            RenderStats.update("updateMatrixWorld");
          }
        }
        this.decomposeDirty = true;
        this.matrixWorldNeedsUpdate = false;
      }
      for (let i = this.childrenLength - 1; i > -1; i--) {
        this.children[i].updateMatrixWorld(force);
      }
      this.matrixDirty = false;
    }
    clone(recursive) {
      new this.constructor().copy(this, recursive);
    }
    copy(source, recursive) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          let child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
    render() {}
    determineVisible() {
      if (!this.visible) {
        return false;
      }
      let p = this._parent;
      while (p) {
        if (!p.visible) {
          return false;
        }
        p = p._parent;
      }
      return true;
    }
    determineDirty() {
      let p = this._parent;
      while (p) {
        if (p.matrixDirty) {
          return true;
        }
        p = p._parent;
      }
      return this.matrixDirty;
    }
    determineNoTransform() {
      if (this._parent) {
        return this._parent.determineNoTransform() && this.matrix.isIdentity();
      } else {
        return this.matrix.isIdentity();
      }
    }
    translateX(distance) {
      this.xAxis ||= new Vector3(1, 0, 0);
      this.translateOnAxis(this.xAxis, distance);
    }
    translateY(distance) {
      this.yAxis ||= new Vector3(0, 1, 0);
      this.translateOnAxis(this.yAxis, distance);
    }
    translateZ(distance) {
      this.zAxis ||= new Vector3(0, 0, 1);
      this.translateOnAxis(this.zAxis, distance);
    }
    translateOnAxis(axis, distance) {
      let v = this.V1 || new Vector3();
      this.V1 = v;
      v.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v.multiplyScalar(distance));
      return this;
    }
    upload() {
      if (this.shader) {
        this.shader.upload(this, this.geometry);
        if (this.shader.shadow) {
          this.shader.shadow.upload(this, this.geometry);
        }
      }
      if (this.geometry) {
        this.geometry.upload(this, this.shader);
      }
    }
    destroy() {
      if (this.geometry && this.geometry.destroy) {
        this.geometry.destroy(this);
      }
      if (this.shader && this.shader.destroy) {
        this.shader.destroy(this);
      }
      if (this.hitDestroy) {
        this.hitDestroy();
      }
      if (this._gl && this._gl.ubo) {
        this._gl.ubo.destroy();
      }
      if (this._gl && this._gl.vao) {
        this._gl.vao.destroy();
      }
      this._gl &&= null;
      if (this._parent) {
        this._parent.remove(this);
      }
      if (this.parent && this.parent.__destroyChild) {
        this.parent.__destroyChild(this.__id);
      }
    }
  }
  Base3D.DIRTY_EPSILON = 0.0001;
  Class(function Renderer(_params = {}) {
    Inherit(this, Component);
    const _this = this;
    var _canvas;
    var _gl;
    var _width;
    var _height;
    var _anisotropy;
    var _clearColor;
    var _projScreenMatrix;
    var _frustum;
    var _ubo;
    var _dpr = 1;
    var _resolution = new Vector2();
    var _m0 = new Matrix4();
    var _m1 = new Matrix4();
    var _time = {
      value: 0
    };
    var _stencilActive = false;
    function initCameraUBO(camera) {
      camera._ubo = new UBO(0, _gl);
      camera._ubo.push({
        value: camera.projectionMatrix
      });
      camera._ubo.push({
        value: camera.matrixWorldInverse
      });
      camera._ubo.push({
        value: camera.worldPos
      });
      camera._ubo.push({
        value: camera.worldQuat
      });
      camera._ubo.push({
        value: _resolution
      });
      camera._ubo.push(_time);
      camera._ubo.push(Render.timeScaleUniform);
      camera._ubo.upload();
    }
    function sortFrontToBack(array, sortOrder, camera) {
      for (let i = array.length - 1; i > -1; i--) {
        let obj = array[i];
        obj.__sortVec ||= new Vector3();
        if (sortOrder == Scene.FRONT_TO_BACK_BOUNDING && obj.geometry && obj.geometry.boundingSphere) {
          obj.__sortVec.copy(obj.geometry.boundingSphere.center);
        } else {
          obj.__sortVec.setFromMatrixPosition(camera.modelViewMatrix);
        }
      }
      array.sort((a, b) => b.__sortVec.z - a.__sortVec.z);
    }
    function projectObject(object, camera, scene) {
      if (object.isOcclusionMesh && scene.displayNeedsUpdate) {
        scene.toRender[0].push(object);
      }
      if (object.doNotProject) {
        return;
      }
      let isVisible = false;
      if (object.shader !== undefined) {
        let visible = object.determineVisible() && object.shader.visible && !object.shader.neverRender && !object.hidden;
        if (visible) {
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          if (object._occlusionMesh !== null && object.isMesh) {
            object.updateOcclusionMesh();
            object._occlusionMesh.matrixWorld.copy(object.matrixWorld);
            object._occlusionMesh.normalMatrix.copy(object.normalMatrix);
            object._occlusionMesh.modelViewMatrix.copy(object.modelViewMatrix);
          }
        }
        isVisible = visible;
        if (scene.displayNeedsUpdate || object.shader.transparent && !scene.disableAutoSort && visible) {
          object.getWorldPosition(object.worldPos);
        }
        if (scene.displayNeedsUpdate) {
          scene.toRender[object.shader.transparent ? 1 : 0].push(object);
        }
      } else {
        isVisible = object.visible && !object.hidden;
      }
      if (isVisible || scene.displayNeedsUpdate) {
        for (let i = object.childrenLength - 1; i > -1; i--) {
          projectObject(object.children[i], camera, scene);
        }
      }
    }
    function attachSceneUniforms(object, scene, camera) {
      Shader.renderer.appendUniform(object.shader, "normalMatrix", object.normalMatrix);
      Shader.renderer.appendUniform(object.shader, "modelMatrix", object.matrixWorld);
      Shader.renderer.appendUniform(object.shader, "modelViewMatrix", object.modelViewMatrix);
      if (_ubo) {
        camera._ubo.bind(object.shader._gl.program, "global");
      } else {
        Shader.renderer.appendUniform(object.shader, "projectionMatrix", camera.projectionMatrix);
        Shader.renderer.appendUniform(object.shader, "viewMatrix", camera.matrixWorldInverse);
        Shader.renderer.appendUniform(object.shader, "cameraPosition", camera.worldPos);
        Shader.renderer.appendUniform(object.shader, "cameraQuaternion", camera.worldQuat);
        Shader.renderer.appendUniform(object.shader, "resolution", _resolution);
        Shader.renderer.appendUniform(object.shader, "time", _time.value);
        Shader.renderer.appendUniform(object.shader, "timeScale", Render.timeScaleUniform.value);
      }
      if (_this.shadows && object.shader.receiveShadow && !_this.overridePreventShadows) {
        let lights = Lighting.getShadowLights();
        object._gl ||= {};
        object._gl.shadowData ||= {
          combined: new Float32Array(lights.length * 16)
        };
        for (let i = 0; i < lights.length; i++) {
          let light = lights[i];
          _m1.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
          _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1);
          _m0.toArray(object._gl.shadowData.combined, i * 16);
        }
        if (scene._shadowData && scene._shadowData.count) {
          object.shader.uniforms.shadowMap.value = scene._shadowData[_this.overridePreventShadows ? "emptyMaps" : "maps"];
          Shader.renderer.appendUniform(object.shader, "shadowMatrix", object._gl.shadowData.combined, "matrix");
          Shader.renderer.appendUniform(object.shader, "shadowLightPos", scene._shadowData.pos, "vec3");
          Shader.renderer.appendUniform(object.shader, "shadowSize", scene._shadowData.size, "float");
        }
      }
    }
    function attachShadowUniforms(object, scene, light) {
      light._mvm ||= new Matrix4();
      light._nm ||= new Matrix3();
      light._mvm.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
      light._nm.getNormalMatrix(object.modelViewMatrix);
      Shader.renderer.appendUniform(object.shader.shadow, "normalMatrix", light._nm);
      Shader.renderer.appendUniform(object.shader.shadow, "modelMatrix", object.matrixWorld);
      Shader.renderer.appendUniform(object.shader.shadow, "modelViewMatrix", light._mvm);
      if (_ubo) {
        light.shadow.camera._ubo.bind(object.shader._gl.program, "global");
      } else {
        Shader.renderer.appendUniform(object.shader.shadow, "projectionMatrix", light.shadow.camera.projectionMatrix);
        Shader.renderer.appendUniform(object.shader.shadow, "viewMatrix", light.shadow.camera.matrixWorldInverse);
      }
    }
    function loop(t, dt) {
      _time.value += dt * 0.001;
    }
    function render(scene, camera, rt) {
      if (rt && rt.width) {
        _resolution.set(rt.width, rt.height);
        if (rt.multisample) {
          RenderTarget.renderer.bind(rt._rtMultisample);
        } else {
          RenderTarget.renderer.bind(rt);
        }
      } else {
        if (!Renderer.overrideViewport) {
          _gl.viewport(0, 0, _width * _dpr, _height * _dpr);
          _resolution.set(_canvas.width, _canvas.height);
        }
        if (_this.autoClear) {
          _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
          _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
        }
      }
      if (!camera.parent) {
        camera.updateMatrixWorld();
      }
      camera.getWorldPosition(camera.worldPos);
      camera.getWorldQuaternion(camera.worldQuat);
      _frustum.setFromCamera(camera);
      if (_ubo) {
        if (camera._ubo) {
          camera._ubo.update();
        } else {
          initCameraUBO(camera);
        }
      }
      for (let l = 0; l < 2; l++) {
        let len = scene.toRender[l].length;
        for (let i = 0; i < len; i++) {
          let object = scene.toRender[l][i];
          if (object.onBeforeRender) {
            object.onBeforeRender();
          }
          object._drawing = false;
          if (object.determineVisible() && object.shader.visible && !object.shader.neverRender && !object.neverRender && (object._occlusionGroup && (object._occlusionGroup.updateOcclusionBoundingBox(), object._occlusionGroup.updateOcclusionVisibility(object?._gl?.occluded)), _this.useOcclusionQuery && object.isOcclusionMesh && _this.type == Renderer.WEBGL2 && object._queryMesh.occlusionCulled && (object.shader.draw(object, object.geometry), attachSceneUniforms(object, scene, camera), object.geometry.draw(object, object.shader, true)), object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            object._drawing = true;
            if (object.shader.nullRender || object?._gl?.occluded || object.isOcclusionMesh) {
              continue;
            }
            let doubleSideTransparency = object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;
            if (doubleSideTransparency) {
              object.shader.side = Shader.BACK_SIDE;
            }
            object.shader.draw(object, object.geometry);
            attachSceneUniforms(object, scene, camera);
            object.geometry.draw(object, object.shader);
            if (doubleSideTransparency) {
              object.shader.side = Shader.FRONT_SIDE;
              object.shader.draw(object, object.geometry);
              attachSceneUniforms(object, scene, camera);
              object.geometry.draw(object, object.shader);
              object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY;
            }
          }
        }
      }
      if (rt && rt.width) {
        if (rt.texture.generateMipmaps) {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);
          _gl.generateMipmap(_gl.TEXTURE_2D);
          _gl.bindTexture(_gl.TEXTURE_2D, null);
        }
        if (rt.multisample) {
          _this.blit(rt._rtMultisample, rt);
          RenderTarget.renderer.unbind(rt._rtMultisample);
        } else {
          RenderTarget.renderer.unbind(rt);
        }
      }
    }
    this.autoClear = true;
    this.shadows = Renderer.SHADOWS_MED;
    this.useOcclusionQuery = true;
    Renderer.instance = _this;
    Renderer.CLEAR = [0, 0, 0, 1];
    (function initContext() {
      let contextAttributes = {
        antialias: _params.antialias !== undefined && _params.antialias,
        powerPreference: _params.powerPreference,
        preserveDrawingBuffer: _params.preserveDrawingBuffer,
        xrCompatible: _params.xrCompatible,
        alpha: _params.alpha !== undefined && _params.alpha,
        stencil: _params.stencil
      };
      _this.stencil = !!_params.stencil;
      _canvas = _params.canvas || document.createElement("canvas");
      if (_params.gl) {
        _gl = _params.gl;
        _this.type = Device.graphics.webgl.version.includes(["webgl 2", "webgl2"]) ? Renderer.WEBGL2 : Renderer.WEBGL1;
      } else if (Device.graphics.webgl) {
        ["webgl2", "webgl", "experimental-webgl"].forEach(name => {
          if (!_gl && (name != "webgl2" || !_params.forceWebGL1)) {
            _gl = _canvas.getContext(name, contextAttributes);
            _this.type = _gl && name == "webgl2" ? Renderer.WEBGL2 : Renderer.WEBGL1;
          }
        });
      } else {
        _gl = new NoGLPolyfill();
        _this.type = Renderer.WEBGL2;
      }
      if (!_gl) {
        throw "Error! Could not create WebGL context";
      }
      _this.domElement = _canvas;
      _canvas.style.background = "black";
      Renderer.type = _this.type;
      Renderer.context = _this.context = _gl;
    })();
    (function setExtensions() {
      _this.extensions = {};
      if (_this.type != Renderer.WEBGL2) {
        _this.extensions.VAO = _gl.getExtension("OES_vertex_array_object");
        _this.extensions.instancedArrays = _gl.getExtension("ANGLE_instanced_arrays");
        _this.extensions.standardDerivatives = _gl.getExtension("OES_standard_derivatives");
        _this.extensions.elementIndexUint = _gl.getExtension("OES_element_index_uint");
        _this.extensions.depthTextures = _gl.getExtension("WEBGL_depth_texture");
        _this.extensions.drawBuffers = _gl.getExtension("WEBGL_draw_buffers");
        _this.extensions.halfFloat = _gl.getExtension("OES_texture_half_float");
        _this.extensions.float = _gl.getExtension("OES_texture_float");
        _this.extensions.colorBufferFloat = _gl.getExtension("WEBGL_color_buffer_float");
        _this.extensions.lod = _gl.getExtension("EXT_shader_texture_lod");
        _this.extensions.minMax = _gl.getExtension("EXT_blend_minmax");
      } else {
        _this.extensions.colorBufferFloat = _gl.getExtension("EXT_color_buffer_float");
      }
      _this.extensions.filterFloat = _gl.getExtension("OES_texture_float_linear");
      _this.extensions.anisotropy = _gl.getExtension("EXT_texture_filter_anisotropic") || _gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
      _this.extensions.astc = _gl.getExtension("WEBGL_compressed_texture_astc");
      _this.extensions.atc = _gl.getExtension("WEBGL_compressed_texture_atc");
      _this.extensions.etc = _gl.getExtension("WEBGL_compressed_texture_etc");
      _this.extensions.etc1 = _gl.getExtension("WEBGL_compressed_texture_etc1");
      _this.extensions.pvrtc = _gl.getExtension("WEBGL_compressed_texture_pvrtc") || _gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
      _this.extensions.s3tc = _gl.getExtension("WEBGL_compressed_texture_s3tc") || _gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
      _this.extensions.bptc = _gl.getExtension("EXT_texture_compression_bptc");
      _this.extensions.s3tc_srgb = _gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
      Renderer.extensions = _this.extensions;
    })();
    (function initRenderers() {
      Geometry.renderer = new GeometryRendererWebGL(_gl);
      Texture.renderer = new TextureRendererWebGL(_gl);
      Shader.renderer = new ShaderRendererWebGL(_gl);
      RenderTarget.renderer = new FBORendererWebGL(_gl);
    })();
    (function initMath() {
      _projScreenMatrix = new Matrix4();
      new Vector3();
      _frustum = new Frustum();
    })();
    (function initUBO() {
      if (_this.type == Renderer.WEBGL2) {
        _ubo = true;
      }
      Renderer.UBO = _ubo;
    })();
    _this.startRender(loop);
    this.render = function (scene, camera, rt, forceToScreen) {
      if (scene.displayNeedsUpdate) {
        scene.toRender[0].length = 0;
        scene.toRender[1].length = 0;
      }
      if (_this.modifyCameraBeforeRender) {
        camera.renderCamera ||= camera.clone();
        camera.renderCamera.copy(camera);
        camera = camera.renderCamera;
        _this.modifyCameraBeforeRender(camera);
      }
      scene.updateMatrixWorld();
      projectObject(scene, camera, scene);
      if (scene.displayNeedsUpdate || scene.opaqueSortOrder == Scene.FRONT_TO_BACK) {
        (function sortOpaque(array, sortOrder, camera) {
          for (let i = array.length - 1; i > -1; i--) {
            let obj = array[i];
            if (!obj.shader._gl) {
              obj.shader.upload();
            }
          }
          if (sortOrder == Scene.FRONT_TO_BACK) {
            sortFrontToBack(array, sortOrder, camera);
          } else {
            array.sort((a, b) => {
              if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
              }
              let aid = a.shader._gl._id;
              let bid = b.shader._gl._id;
              if (aid !== bid) {
                return aid - bid;
              } else {
                return a.id - b.id;
              }
            });
          }
        })(scene.toRender[0], scene.opaqueSortOrder, camera);
      }
      if (scene.displayNeedsUpdate || scene.toRender[1].length && !scene.disableAutoSort) {
        (function sortTransparent(array, sortOrder, camera) {
          RenderStats.update("SortTransparent", array.length);
          if (sortOrder == Scene.FRONT_TO_BACK || sortOrder == Scene.FRONT_TO_BACK_BOUNDING) {
            sortFrontToBack(array, sortOrder, camera);
          } else {
            array.sort((a, b) => a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.worldPos.z !== b.worldPos.z ? a.worldPos.z - b.worldPos.z : a.id - b.id);
          }
        })(scene.toRender[1], scene.transparentSortOrder, camera);
      }
      if (_this.shadows && !_this.overridePreventShadows && !_this.pauseShadowRendering && scene.hasShadowLight) {
        (function renderShadows(scene, camera) {
          let render = (light, lightIndex) => {
            RenderTarget.renderer.bind(light.shadow.rt);
            RenderStats.update("ShadowLights");
            light.shadow.camera.updateMatrixWorld();
            camera.getWorldPosition(camera.worldPos);
            _frustum.setFromCamera(camera);
            if (_ubo) {
              if (light.shadow.camera._ubo) {
                light.shadow.camera._ubo.update();
              } else {
                initCameraUBO(light.shadow.camera);
              }
            }
            for (let l = 0; l < 2; l++) {
              for (let i = 0; i < scene.toRender[l].length; i++) {
                let object = scene.toRender[l][i];
                if (!object.onBeforeRenderShadow || !object.onBeforeRenderShadow(light, lightIndex)) {
                  if (object.castShadow === true && object.determineVisible() && object.shader.visible && !object.shader.neverRender) {
                    if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
                      if (!object.shader.shadow) {
                        Lighting.initShadowShader(object);
                      }
                      object.shader.shadow.draw(object, object.geometry);
                      attachShadowUniforms(object, 0, light);
                      object.geometry.draw(object, object.shader.shadow);
                      if (_ubo) {
                        light.shadow.camera._ubo.unbind();
                      }
                      RenderStats.update("ShadowMesh");
                    }
                  }
                }
              }
            }
            RenderTarget.renderer.unbind(light.shadow.rt);
          };
          let lights = Lighting.getShadowLights();
          scene._shadowData ||= {
            maps: [],
            emptyMaps: [],
            size: new Float32Array(lights.length),
            pos: new Float32Array(lights.length * 3),
            count: lights.length
          };
          if (scene._shadowData.count != lights.length) {
            scene._shadowData.size = new Float32Array(lights.length);
            scene._shadowData.pos = new Float32Array(lights.length * 3);
            scene._shadowData.count = lights.length;
          }
          for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            light.prepareRender();
            scene._shadowData.maps[i] = light.shadow.rt.depth;
            scene._shadowData.emptyMaps[i] = Utils3D.getEmptyTexture();
            scene._shadowData.size[i] = light.shadow.size;
            light.position.toArray(scene._shadowData.pos, i * 3);
          }
          for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            if (!light.shadow.frozen && light.determineVisible()) {
              render(light, i);
            }
          }
        })(scene, camera);
      }
      if (rt && !rt.vrRT || !_this.vrRenderingPath || forceToScreen) {
        if (rt || !_this.arRenderingPath || forceToScreen) {
          render(scene, camera, rt);
        } else {
          _this.arRenderingPath(render, scene, camera);
        }
      } else {
        _this.vrRenderingPath(scene, camera, _projScreenMatrix, _frustum, attachSceneUniforms, rt);
      }
      scene.displayNeedsUpdate = false;
      Shader.renderer.resetState();
    };
    this.renderSingle = function (object, camera, rt) {
      if (rt) {
        _resolution.set(rt.width, rt.height);
        if (rt.multisample) {
          RenderTarget.renderer.bind(rt._rtMultisample);
        } else {
          RenderTarget.renderer.bind(rt);
        }
      } else {
        if (!Renderer.overrideViewport) {
          _gl.viewport(0, 0, _width * _dpr, _height * _dpr);
          _resolution.set(_canvas.width, _canvas.height);
        }
        if (_this.autoClear) {
          _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
          _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
        }
      }
      camera.getWorldPosition(camera.worldPos);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      object.getWorldPosition(object.worldPos);
      if (_ubo) {
        if (camera._ubo) {
          if (!camera.pauseUBO) {
            camera._ubo.update();
          }
        } else {
          initCameraUBO(camera);
        }
      }
      let doubleSideTransparency = object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;
      if (doubleSideTransparency) {
        object.shader.side = Shader.BACK_SIDE;
        if (object.shader._renderFrontFirst) {
          object.shader.side = Shader.FRONT_SIDE;
        }
      }
      object.shader.draw(object, object.geometry);
      if (!object.noMatrices) {
        Shader.renderer.appendUniform(object.shader, "normalMatrix", object.normalMatrix);
        Shader.renderer.appendUniform(object.shader, "modelMatrix", object.matrixWorld);
        Shader.renderer.appendUniform(object.shader, "modelViewMatrix", object.modelViewMatrix);
      }
      if (_ubo) {
        camera._ubo.bind(object.shader._gl.program, "global");
      } else {
        Shader.renderer.appendUniform(object.shader, "projectionMatrix", camera.projectionMatrix);
        Shader.renderer.appendUniform(object.shader, "viewMatrix", camera.matrixWorldInverse);
        Shader.renderer.appendUniform(object.shader, "cameraPosition", camera.worldPos);
        Shader.renderer.appendUniform(object.shader, "cameraQuaternion", camera.worldQuat);
        Shader.renderer.appendUniform(object.shader, "resolution", _resolution);
        Shader.renderer.appendUniform(object.shader, "time", _time.value);
        Shader.renderer.appendUniform(object.shader, "timeScale", Render.timeScaleUniform.value);
      }
      object.geometry.draw(object, object.shader);
      if (doubleSideTransparency) {
        object.shader.side = Shader.FRONT_SIDE;
        if (object.shader._renderFrontFirst) {
          object.shader.side = Shader.BACK_SIDE;
        }
        object.shader.draw(object, object.geometry);
        object.geometry.draw(object, object.shader);
        object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY;
      }
      if (_ubo) {
        camera._ubo.unbind();
      }
      if (rt) {
        if (rt.texture.generateMipmaps) {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);
          _gl.generateMipmap(_gl.TEXTURE_2D);
          _gl.bindTexture(_gl.TEXTURE_2D, null);
        }
        if (rt.multisample) {
          _this.blit(rt._rtMultisample, rt);
          RenderTarget.renderer.unbind(rt._rtMultisample);
        } else {
          RenderTarget.renderer.unbind(rt);
        }
      }
      Shader.renderer.resetState();
    };
    this.setClearColor = function (color, alpha = 1) {
      _clearColor = new Color(color);
      Renderer.CLEAR = [_clearColor.r, _clearColor.g, _clearColor.b, alpha];
    };
    this.setClearAlpha = function (alpha) {
      Renderer.CLEAR[3] = alpha;
    };
    this.getClearColor = function () {
      _clearColor ||= new Color(0, 0, 0);
      return _clearColor;
    };
    this.getClearAlpha = function () {
      return Renderer.CLEAR[3];
    };
    this.setPixelRatio = function (dpr) {
      _dpr = dpr;
      this.setSize(_width, _height);
    };
    this.setSize = function (width, height) {
      _width = width;
      _height = height;
      _canvas.width = width * _dpr;
      _canvas.height = height * _dpr;
      _canvas.style.width = `${width}px`;
      _canvas.style.height = `${height}px`;
      _resolution.set(_canvas.width, _canvas.height);
    };
    this.getMaxAnisotropy = function () {
      if (Device.graphics.webgl && _this.extensions.anisotropy) {
        _anisotropy ||= _gl.getParameter(_this.extensions.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        return _anisotropy;
      } else {
        return 0;
      }
    };
    this.readPixels = function (rt, x = 0, y = 0, width, height, array, type = _gl.UNSIGNED_BYTE) {
      width ||= rt ? rt.width : 1;
      height ||= rt ? rt.height : 1;
      width = Math.round(width);
      height = Math.round(height);
      type = type || _gl.UNSIGNED_BYTE;
      let w = Math.round(width - x);
      let h = Math.round(height - y);
      array ||= new Uint8Array(w * h * 4);
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt ? rt._gl : null);
      _gl.readPixels(x, y, width, height, _gl.RGBA, type, array);
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
      return array;
    };
    this.blit = function (input, output, mask = _gl.COLOR_BUFFER_BIT) {
      if (_this.type != Renderer.WEBGL2) {
        return false;
      }
      if (!input._gl) {
        input.upload();
      }
      if (!output._gl) {
        output.upload();
      }
      _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, input._gl);
      _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, output._gl);
      if (input === output._rtMultisample) {
        if (output.depth) {
          mask |= _gl.DEPTH_BUFFER_BIT;
        }
        if (output.stencil) {
          mask |= _gl.STENCIL_BUFFER_BIT;
        }
      }
      _gl.blitFramebuffer(0, 0, input.width, input.height, 0, 0, output.width, output.height, mask, _gl.NEAREST);
      if (input === output._rtMultisample && output.multi) {
        let attachments = output.attachments;
        for (let i = 1; i < attachments.length; i++) {
          let texture = attachments[i];
          _gl.readBuffer(_gl[`COLOR_ATTACHMENT${i}`]);
          _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, texture._blitFramebuffer);
          _gl.blitFramebuffer(0, 0, input.width, input.height, 0, 0, output.width, output.height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
        }
        _gl.readBuffer(_gl.COLOR_ATTACHMENT0);
      }
      _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      return true;
    };
    this.setupStencilMask = function (ref = 1) {
      if (!_stencilActive) {
        _gl.enable(_gl.STENCIL_TEST);
        _gl.clear(_gl.STENCIL_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
      }
      _stencilActive = true;
      _gl.stencilFunc(_gl.ALWAYS, ref, 255);
      _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE);
      _gl.stencilMask(255);
      _gl.colorMask(false, false, false, false);
      _gl.disable(_gl.DEPTH_TEST);
    };
    this.setupStencilDraw = function (mode, ref = 1) {
      _gl.colorMask(true, true, true, true);
      _gl.enable(_gl.DEPTH_TEST);
      _gl.stencilFunc(mode == "inside" ? _gl.EQUAL : _gl.NOTEQUAL, ref, 255);
      _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);
    };
    this.clearStencil = function () {
      _gl.disable(_gl.STENCIL_TEST);
      _stencilActive = false;
    };
    this.clearDepth = function (rt) {
      if (rt && !rt._gl) {
        rt.upload();
      }
      if (rt) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
      }
      _gl.clear(_gl.DEPTH_BUFFER_BIT);
      if (rt) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    };
    this.clearColor = function (rt) {
      if (rt && !rt._gl) {
        rt.upload();
      }
      if (rt) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
      }
      _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
      _gl.clear(_gl.COLOR_BUFFER_BIT);
      if (rt) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    };
    this.get("resolution", _ => _resolution);
    this.get("time", _ => _time);
    this.get("canvas", _ => _canvas);
  }, _ => {
    Renderer.WEBGL1 = "webgl1";
    Renderer.WEBGL2 = "webgl2";
    Renderer.STATIC_SHADOWS = "static_shadows";
    Renderer.SHADOWS_LOW = "shadows_low";
    Renderer.SHADOWS_MED = "shadows_med";
    Renderer.SHADOWS_HIGH = "shadows_high";
    Renderer.ID = 0;
  });
  class CameraBase3D extends Base3D {
    constructor() {
      super();
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.isCamera = true;
    }
    copy(source, recursive) {
      Base3D.prototype.copy.call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      return this;
    }
    updateMatrixWorld(force) {
      Base3D.prototype.updateMatrixWorld.call(this, force);
      if (this.offsetMatrixWorld) {
        this.matrixWorld.multiply(this.offsetMatrixWorld);
      }
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class CubeCamera extends Base3D {
    constructor(near = 0.1, far = 1000, cubeResolution = 512) {
      super();
      this.px = new PerspectiveCamera(90, 1, near, far);
      this.px.up.set(0, -1, 0);
      this.px.lookAt(new Vector3(1, 0, 0));
      this.add(this.px);
      this.nx = new PerspectiveCamera(90, 1, near, far);
      this.nx.up.set(0, -1, 0);
      this.nx.lookAt(new Vector3(-1, 0, 0));
      this.add(this.nx);
      this.py = new PerspectiveCamera(90, 1, near, far);
      this.py.up.set(0, 0, 1);
      this.py.lookAt(new Vector3(0, 1, 0));
      this.add(this.py);
      this.ny = new PerspectiveCamera(90, 1, near, far);
      this.ny.up.set(0, 0, -1);
      this.ny.lookAt(new Vector3(0, -1, 0));
      this.add(this.ny);
      this.pz = new PerspectiveCamera(90, 1, near, far);
      this.pz.up.set(0, -1, 0);
      this.pz.lookAt(new Vector3(0, 0, 1));
      this.add(this.pz);
      this.nz = new PerspectiveCamera(90, 1, near, far);
      this.nz.up.set(0, -1, 0);
      this.nz.lookAt(new Vector3(0, 0, -1));
      this.add(this.nz);
      this.rt = new CubeRenderTarget(cubeResolution, cubeResolution);
    }
    render(scene = World.SCENE, renderer = World.RENDERER) {
      let rt = this.rt;
      this.updateMatrixWorld(true);
      if (this.beforeRender) {
        this.beforeRender(this.px);
      }
      rt.activeFace = 0;
      renderer.render(scene, this.px, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
      if (this.beforeRender) {
        this.beforeRender(this.nx);
      }
      rt.activeFace = 1;
      renderer.render(scene, this.nx, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
      if (this.beforeRender) {
        this.beforeRender(this.py);
      }
      rt.activeFace = 2;
      renderer.render(scene, this.py, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
      if (this.beforeRender) {
        this.beforeRender(this.ny);
      }
      rt.activeFace = 3;
      renderer.render(scene, this.ny, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
      if (this.beforeRender) {
        this.beforeRender(this.pz);
      }
      rt.activeFace = 4;
      renderer.render(scene, this.pz, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
      if (this.beforeRender) {
        this.beforeRender(this.nz);
      }
      rt.activeFace = 5;
      renderer.render(scene, this.nz, rt);
      if (this.afterRender) {
        this.afterRender(rt);
      }
    }
  }
  class OrthographicCamera extends CameraBase3D {
    constructor(left, right, top, bottom, near, far) {
      super();
      this.isOrthographicCamera = true;
      this.zoom = 1;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.position.z = 1;
      this.updateProjectionMatrix();
    }
    clone() {
      return new OrthographicCamera().copy(this);
    }
    copy(source, recursive) {
      CameraBase3D.prototype.copy.call(this, source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    updateProjectionMatrix() {
      let dx = (this.right - this.left) / (this.zoom * 2);
      let dy = (this.top - this.bottom) / (this.zoom * 2);
      let cx = (this.right + this.left) / 2;
      let cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    }
    setViewport(width, height) {
      this.left = width / -2;
      this.right = width / 2;
      this.top = height / 2;
      this.bottom = height / -2;
      this.updateProjectionMatrix();
    }
  }
  class PerspectiveCamera extends CameraBase3D {
    constructor(fov, aspect, near, far) {
      super();
      this.type = "PerspectiveCamera";
      this.fov = fov || 50;
      this.zoom = 1;
      this.near = near || 0.1;
      this.far = far || 2000;
      this.focus = 10;
      this.aspect = aspect || 1;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    clone() {
      return new PerspectiveCamera().copy(this);
    }
    copy(source, recursive) {
      CameraBase3D.prototype.copy.call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    setFocalLength(focalLength) {
      let vExtentSlope = this.getFilmHeight() * 0.5 / focalLength;
      this.fov = Math.degrees(Math.atan(vExtentSlope) * 2);
      this.updateProjectionMatrix();
    }
    getFocalLength() {
      let vExtentSlope = Math.tan(Math.radians(this.fov * 0.5));
      return this.getFilmHeight() * 0.5 / vExtentSlope;
    }
    getEffectiveFOV() {
      return Math.degrees(Math.atan(Math.tan(Math.radians(this.fov * 0.5)) / this.zoom) * 2);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    updateProjectionMatrix() {
      let near = this.near;
      let top = near * Math.tan(Math.radians(this.fov * 0.5)) / this.zoom;
      let height = top * 2;
      let width = this.aspect * height;
      let left = width * -0.5;
      this.view;
      let skew = this.filmOffset;
      if (skew !== 0) {
        left += near * skew / this.getFilmWidth();
      }
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    }
  }
  class Geometry {
    constructor() {
      this.attributes = Geometry.createAttributes(this);
      this.drawRange = {
        start: 0,
        end: 0
      };
      this.boundingBox = null;
      this.boundingSphere = null;
      this.index = null;
      this.maxInstancedCount = undefined;
      this.keepAlive = false;
      this.id = Utils.timestamp();
    }
    draw(mesh, shader, isQuery = false) {
      Geometry.renderer.draw(this, mesh, shader, isQuery);
    }
    upload(mesh, shader) {
      Geometry.renderer.upload(this, mesh, shader);
    }
    destroy(mesh) {
      if (!this.keepAlive) {
        Geometry.renderer.destroy(this, mesh);
      }
    }
    addAttribute(name, attribute) {
      if (attribute.meshPerAttribute >= 1) {
        this.isInstanced = true;
        this.maxInstancedCount = attribute.count;
      }
      this.attributes[name] = attribute;
    }
    setIndex(attribute) {
      this.index = attribute.array || attribute;
    }
    toNonIndexed() {
      let geometry2 = new Geometry();
      let indices = this.index;
      let attributes = this.attributes;
      for (let name in attributes) {
        let attribute = attributes[name];
        let array = attribute.array;
        let itemSize = attribute.itemSize;
        let array2 = new array.constructor(indices.length * itemSize);
        let index = 0;
        let index2 = 0;
        for (let i = 0, l = indices.length; i < l; i++) {
          index = indices[i] * itemSize;
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        geometry2.addAttribute(name, new GeometryAttribute(array2, itemSize));
      }
      return geometry2;
    }
    normalizeNormals() {
      let vector = this._V1 || new Vector3();
      this._V1 = vector;
      let x;
      let y;
      let z;
      let normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        x = i * 3 + 0;
        y = i * 3 + 1;
        z = i * 3 + 2;
        vector.x = normals.array[x];
        vector.y = normals.array[y];
        vector.z = normals.array[z];
        vector.normalize();
        normals.array[x] = vector.x;
        normals.array[y] = vector.y;
        normals.array[z] = vector.z;
      }
    }
    computeFaceNormals() {
      let cb = new Vector3();
      let ab = new Vector3();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        let face = this.faces[f];
        let vA = this.vertices[face.a];
        let vB = this.vertices[face.b];
        let vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    }
    computeVertexNormals() {
      let index = this.index;
      let attributes = this.attributes;
      let groups = this.groups;
      if (attributes.position) {
        let positions = attributes.position.array;
        if (attributes.normal === undefined) {
          this.addAttribute("normal", new GeometryAttribute(new Float32Array(positions.length), 3));
        } else {
          let array = attributes.normal.array;
          for (let i = 0, il = array.length; i < il; i++) {
            array[i] = 0;
          }
        }
        let vA;
        let vB;
        let vC;
        let normals = attributes.normal.array;
        let pA = new Vector3();
        let pB = new Vector3();
        let pC = new Vector3();
        let cb = new Vector3();
        let ab = new Vector3();
        if (index) {
          let indices = index.array;
          if (groups.length === 0) {
            this.addGroup(0, indices.length);
          }
          for (let j = 0, jl = groups.length; j < jl; ++j) {
            let group = groups[j];
            let start = group.start;
            for (let i = start, il = start + group.count; i < il; i += 3) {
              vA = indices[i + 0] * 3;
              vB = indices[i + 1] * 3;
              vC = indices[i + 2] * 3;
              pA.fromArray(positions, vA);
              pB.fromArray(positions, vB);
              pC.fromArray(positions, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[vA] += cb.x;
              normals[vA + 1] += cb.y;
              normals[vA + 2] += cb.z;
              normals[vB] += cb.x;
              normals[vB + 1] += cb.y;
              normals[vB + 2] += cb.z;
              normals[vC] += cb.x;
              normals[vC + 1] += cb.y;
              normals[vC + 2] += cb.z;
            }
          }
        } else {
          for (let i = 0, il = positions.length; i < il; i += 9) {
            pA.fromArray(positions, i);
            pB.fromArray(positions, i + 3);
            pC.fromArray(positions, i + 6);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[i] = cb.x;
            normals[i + 1] = cb.y;
            normals[i + 2] = cb.z;
            normals[i + 3] = cb.x;
            normals[i + 4] = cb.y;
            normals[i + 5] = cb.z;
            normals[i + 6] = cb.x;
            normals[i + 7] = cb.y;
            normals[i + 8] = cb.z;
          }
        }
        this.normalizeNormals();
        attributes.normal.needsUpdate = true;
      }
    }
    computeBoundingBox() {
      this.boundingBox ||= new Box3();
      let position = this.attributes.position;
      if (position) {
        this.boundingBox.setFromBufferAttribute(position);
      } else {
        this.boundingBox.makeEmpty();
      }
    }
    computeBoundingSphere() {
      let box = new Box3();
      let vector = new Vector3();
      this.boundingSphere ||= new Sphere();
      let position = this.attributes.position;
      if (position) {
        let center = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        box.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          vector.x = position.array[i * 3 + 0];
          vector.y = position.array[i * 3 + 1];
          vector.z = position.array[i * 3 + 2];
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error("Bounding Sphere came up NaN, broken position buffer.", this);
        }
      }
    }
    merge(geometry) {
      let Float32ArrayConcat = (first, second) => {
        let firstLength = first.length;
        let result = new Float32Array(firstLength + second.length);
        result.set(first);
        result.set(second, firstLength);
        return result;
      };
      let attributes = this.attributes;
      if (this.index) {
        let indices = geometry.index;
        let offset = attributes.position.count;
        for (let i = 0, il = indices.length; i < il; i++) {
          indices[i] = offset + indices[i];
        }
        this.index = ((first, second) => {
          let firstLength = first.length;
          let result = new (Geometry.arrayNeedsUint32(second) ? Uint32Array : Uint16Array)(firstLength + second.length);
          result.set(first);
          result.set(second, firstLength);
          return result;
        })(this.index, indices);
      }
      for (let key in attributes) {
        if (geometry.attributes[key] !== undefined) {
          attributes[key].array = Float32ArrayConcat(attributes[key].array, geometry.attributes[key].array);
          attributes[key].count = attributes[key].array.length / attributes[key].itemSize;
        }
      }
      return this;
    }
    clone(noCopy) {
      return new Geometry().copy(this, noCopy);
    }
    copy(source, noCopy) {
      this.index = null;
      this.boundingBox = null;
      this.boundingSphere = null;
      this.index = source.index;
      let attributes = source.attributes;
      for (let name in attributes) {
        this.addAttribute(name, attributes[name].clone(noCopy));
      }
      let boundingBox = source.boundingBox;
      if (boundingBox && boundingBox.clone) {
        this.boundingBox = boundingBox.clone();
      }
      let boundingSphere = source.boundingSphere;
      if (boundingSphere && boundingSphere.clone) {
        this.boundingSphere = boundingSphere.clone();
      }
      return this;
    }
    center() {
      let offset = new Vector3();
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.applyMatrix(new Matrix4().makeTranslation(offset.x, offset.y, offset.z));
      return this;
    }
    applyMatrix(matrix) {
      let position = this.attributes.position;
      if (position) {
        matrix.applyToBufferAttribute(position);
        position.needsUpdate = true;
      }
      let normal = this.attributes.normal;
      if (normal) {
        new Matrix3().getNormalMatrix(matrix).applyToBufferAttribute(normal);
        normal.needsUpdate = true;
      }
      if (this.boundingBox) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere) {
        this.computeBoundingSphere();
      }
      return this;
    }
    scale(x, y, z) {
      this.applyMatrix(new Matrix4().makeScale(x, y, z));
    }
    setFromPoints(points) {
      let position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        let point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.addAttribute("position", new GeometryAttribute(new Float32Array(position), 3));
      return this;
    }
    instanceFrom(geom) {
      return geom.clone();
    }
    uploadBuffersAsync() {
      return Geometry.renderer.uploadBuffersAsync(this);
    }
    toJSON() {
      let props = {};
      if (this.index) {
        props.index = Array.from(this.index);
      }
      for (let key in this.attributes) {
        props[key] = Array.from(this.attributes[key].array);
      }
      return JSON.stringify(props);
    }
  }
  class GeometryAttribute {
    constructor(_array, _itemSize, _meshPerAttribute, _dynamic = false) {
      this.array = _array;
      this.itemSize = _itemSize;
      this.count = _array !== undefined ? _array.length / _itemSize : 0;
      this.dynamic = _dynamic;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.meshPerAttribute = _meshPerAttribute;
    }
    setArray(array) {
      let newCount = array !== undefined ? array.length / this.itemSize : 0;
      if (newCount != this.count) {
        this.needsNewBuffer = true;
      }
      this.array = array;
      this.count = newCount;
      this.needsUpdate = true;
    }
    clone(noCopy) {
      if (noCopy) {
        return this;
      } else {
        return new GeometryAttribute(new Float32Array(this.array), this.itemSize, this.meshPerAttribute);
      }
    }
    getX(index) {
      return this.array[index * this.itemSize];
    }
    setX(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    }
    getY(index) {
      return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
    getZ(index) {
      return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
    getW(index) {
      return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
    setXY(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
  }
  class InterleavedBuffer {
    constructor(array, stride) {
      this.array = array;
      this.stride = stride;
      this.count = array ? array.length / stride : 0;
      this.isInterleaved = true;
      this.needsUpdate = false;
      this.dynamic = false;
      this.updateRange = {
        offset: 0,
        count: -1
      };
    }
  }
  class InterleavedGeometryAttribute {
    constructor(interleavedBuffer, itemSize, offset) {
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.isInterleaved = true;
    }
  }
  class Group extends Base3D {
    constructor() {
      super();
      this.isGroup = true;
      this._occlusionMesh = null;
      this._bbVertices = [];
      for (let i = 0; i < 8; i++) {
        this._bbVertices.push(new Vector3());
      }
    }
    generateOcclusionMesh() {
      if (!this.occlusionCulled) {
        this.occlusionCulled = true;
        let occShader = new Shader("OcclusionMaterial", {
          bbMin: {
            value: new Vector3(0, 0, 0)
          },
          bbMax: {
            value: new Vector3(1, 1, 1)
          }
        });
        occShader.wireframe = true;
        let _occlusionMesh = new Mesh(World.BOX, occShader);
        _occlusionMesh.occlusionCulled = true;
        _occlusionMesh._occlusionGroup = this;
        _occlusionMesh.renderOrder = -1000;
        _occlusionMesh.hideByOcclusion = true;
        _occlusionMesh._occlusionMesh.renderOrder = 1000;
        this.add(_occlusionMesh);
        this._occlusionMesh = _occlusionMesh;
        this.bb = new Box3();
      }
    }
    updateOcclusionBoundingBox() {
      this.bb.makeEmpty();
      const _this = this;
      _this.children.forEach(child => {
        if (child._occlusionGroup === undefined) {
          child.updateOcclusionMesh();
          let bb = child._geometry.boundingBox;
          let m = bb.min;
          let M = bb.max;
          _this._bbVertices[0].set(m.x, m.y, m.z);
          _this._bbVertices[1].set(m.x, m.y, M.z);
          _this._bbVertices[2].set(m.x, M.y, m.z);
          _this._bbVertices[3].set(M.x, m.y, m.z);
          _this._bbVertices[4].set(M.x, M.y, m.z);
          _this._bbVertices[5].set(M.x, m.y, M.z);
          _this._bbVertices[6].set(m.x, M.y, M.z);
          _this._bbVertices[7].set(M.x, M.y, M.z);
          _this._bbVertices.forEach(vertex => {
            vertex.applyMatrix4(child.matrix);
            _this.bb.min.x = Math.min(_this.bb.min.x, vertex.x);
            _this.bb.min.y = Math.min(_this.bb.min.y, vertex.y);
            _this.bb.min.z = Math.min(_this.bb.min.z, vertex.z);
            _this.bb.max.x = Math.max(_this.bb.max.x, vertex.x);
            _this.bb.max.y = Math.max(_this.bb.max.y, vertex.y);
            _this.bb.max.z = Math.max(_this.bb.max.z, vertex.z);
          });
        }
      });
      this._occlusionMesh?.shader?.set("bbMin", this.bb.min);
      this._occlusionMesh?.shader?.set("bbMax", this.bb.max);
      this._occlusionMesh?._occlusionMesh?.shader?.set("bbMin", this.bb.min.add(new Vector3(-0.01, -0.01, -0.01)));
      this._occlusionMesh?._occlusionMesh?.shader?.set("bbMax", this.bb.max.add(new Vector3(0.01, 0.01, 0.01)));
      this._occlusionMesh.position.copy(this.bb.max.clone().add(this.bb.min).multiplyScalar(0.5));
    }
    updateOcclusionVisibility(doHide) {
      this.children.forEach(child => {
        if (child._occlusionGroup === undefined) {
          child.hideByOcclusion = doHide;
        }
      });
    }
  }
  class BaseLight extends Base3D {
    constructor(color = 16777215, intensity = 1, distance = 9999) {
      super();
      this.color = new Color(color);
      this.data = new Vector4();
      this.data2 = new Vector4();
      this.data3 = new Vector4();
      this.properties = new Vector4(intensity, distance, 0, 0);
    }
    destroy() {
      if (this.shadow) {
        Lighting.removeFromShadowGroup(this);
        this.shadow.destroy();
      }
    }
    prepareRender() {
      this.shadow.camera.position.copy(this.position);
      this.shadow.camera.lookAt(this.shadow.target);
    }
    set castShadow(bool) {
      if (this.shadow || bool) {
        this.shadow ||= new Shadow(this);
        this.shadow.enabled = bool;
        if (!this.silentShadow) {
          if (bool) {
            Lighting.addToShadowGroup(this);
          } else {
            Lighting.removeFromShadowGroup(this);
          }
        }
      }
    }
    set intensity(v) {
      this.properties.x = v;
    }
    get intensity() {
      return this.properties.x;
    }
    set distance(v) {
      this.properties.y = v;
    }
    get distance() {
      return this.properties.y;
    }
    set bounce(v) {
      this.properties.z = v;
    }
    get bounce() {
      return this.properties.z;
    }
  }
  class Line extends Base3D {
    constructor(geometry, shader) {
      super();
      this.geometry = geometry;
      this.shader = shader;
      this.isLine = true;
      this.id = Renderer.ID++;
    }
    clone() {
      return new Line(this.geometry, this.shader).copy(this);
    }
  }
  class Mesh extends Base3D {
    constructor(geometry, shader, isQuery = false) {
      super();
      if (!shader && !window.THREAD) {
        shader = new Shader("TestMaterial");
      }
      this._geometry = geometry;
      this._shader = shader && shader.shader ? shader.shader : shader;
      this.isMesh = true;
      this.occlusionMesh = null;
      if (!isQuery && !window.THREAD) {
        let occShader = new Shader("OcclusionMaterial", {
          bbMin: {
            value: new Vector3()
          },
          bbMax: {
            value: new Vector3()
          }
        });
        occShader.side = Shader.DOUBLE_SIDE;
        let _occlusionMesh = new Mesh(World.BOX, occShader, true);
        _occlusionMesh.occlusionCulled = false;
        _occlusionMesh.doNotProject = true;
        _occlusionMesh._queryMesh = this;
        _occlusionMesh.isOcclusionMesh = true;
        this.add(_occlusionMesh);
        this._occlusionMesh = _occlusionMesh;
        this._occlusionDirty = true;
      }
      this.id = Utils.timestamp();
      if (shader) {
        this._shader.mesh = this;
      }
    }
    clone() {
      return new Mesh(this._geometry, this.shader).copy(this);
    }
    set geometry(g) {
      Geometry.renderer.resetMeshGeom(this);
      this._geometry = g;
    }
    get geometry() {
      return this._geometry;
    }
    set shader(shader) {
      this._shader = shader && shader.shader ? shader.shader : shader;
    }
    get shader() {
      return this._shader;
    }
    isInsideOf(mesh) {
      this.box3 ||= new Box3();
      this.box3.setFromObject(this);
      return mesh.isMeshInside(this);
    }
    isMeshInside(mesh) {
      this.box3 ||= new Box3();
      this.box3.setFromObject(this);
      return mesh.box3.intersectsBox(this.box3);
    }
    updateOcclusionMesh(force) {
      if (this.occlusionCulled && (this._occlusionDirty || force)) {
        this._geometry.computeBoundingBox();
        let bb = this._geometry.boundingBox;
        this._occlusionMesh?.shader?.set("bbMin", bb.min.add(new Vector3(-0.01, -0.01, -0.01)));
        this._occlusionMesh?.shader?.set("bbMax", bb.max.add(new Vector3(0.01, 0.01, 0.01)));
        this._occlusionMesh.renderOrder = this.renderOrder + 1000;
        this._occlusionDirty = false;
      }
    }
  }
  class Points extends Base3D {
    constructor(geometry, shader) {
      super();
      this._geometry = geometry;
      this.shader = shader;
      this.isPoints = true;
      this.id = Renderer.ID++;
      if (shader) {
        this.shader.mesh = this;
      }
    }
    clone() {
      return new Points(this._geometry, this.shader).copy(this);
    }
    set geometry(g) {
      Geometry.renderer.resetMeshGeom(this);
      this._geometry = g;
    }
    get geometry() {
      return this._geometry;
    }
  }
  class Scene extends Base3D {
    constructor() {
      super();
      this.autoUpdate = true;
      this.toRender = [[], []];
      this._displayNeedsUpdate = true;
      this.isScene = true;
      this.changes = [];
    }
    set displayNeedsUpdate(v) {
      if (v === true) {
        this.changes.forEach(cb => cb());
      }
      this._displayNeedsUpdate = v;
    }
    get displayNeedsUpdate() {
      return this._displayNeedsUpdate;
    }
    bindSceneChange(cb) {
      this.changes.push(cb);
    }
  }
  Class(function FBORendererWebGL(_gl) {
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    let _maxSamples = WEBGL2 && _gl.getParameter(_gl.MAX_SAMPLES);
    const {
      getFormat: getFormat,
      getInternalFormat: getInternalFormat,
      getProperty: getProperty,
      getType: getType,
      getFloatParams: getFloatParams
    } = require("GLTypes");
    function prepareTexture(texture) {
      texture._gl = _gl.createTexture();
      _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
      _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
      _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
      _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
      _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));
      texture.needsUpdate = false;
    }
    function texImageDB(rt, texture) {
      if (texture.type.includes("float")) {
        let {
          internalformat: internalformat,
          format: format,
          type: type
        } = getFloatParams(texture);
        _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
      } else {
        _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
      }
      _gl.bindTexture(_gl.TEXTURE_2D, null);
    }
    function getRenderBufferInternalFormat(texture) {
      if (texture.type.includes("float")) {
        return getFloatParams(texture).internalformat;
      } else {
        return getInternalFormat(texture);
      }
    }
    this.upload = function (rt) {
      if (!rt._gl) {
        if (rt.cube) {
          return function uploadCube(rt) {
            rt._gl = _gl.createFramebuffer();
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
            let texture = rt.texture;
            texture._gl = _gl.createTexture();
            texture.cube = true;
            texture.needsUpdate = false;
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
            for (let i = 0; i < 6; i++) {
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), _gl.UNSIGNED_BYTE, null);
            }
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));
            rt._depthBuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, rt.width, rt.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            _gl.bindTexture(_gl.TEXTURE_2D, null);
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          }(rt);
        }
        if (rt.texture.isTexture3D) {
          return function upload3DTexture(rt) {
            rt.texture.upload();
            let colorAttachments = [];
            rt._gl = _gl.createFramebuffer();
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
            for (let i = 0; i < rt.indices.length; i++) {
              let key = "COLOR_ATTACHMENT" + i;
              colorAttachments.push(_gl[key]);
              _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl[key], rt.texture._gl, 0, rt.indices[i]);
            }
            _gl.drawBuffers(colorAttachments);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
          }(rt);
        }
        rt._gl = _gl.createFramebuffer();
        if (!rt.depth && !rt.disableDepth) {
          rt._depthBuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);
          if (rt.internalMultisample) {
            let samples = Math.min(_maxSamples, rt._samplesAmount);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24, rt.width, rt.height);
          } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, rt.stencil ? WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL : WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16, rt.width, rt.height);
          }
        }
        RenderCount.add(`fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`, rt);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
        if (rt.multi) {
          if (WEBGL2) {
            let colorAttachments = [];
            for (let i = 0; i < rt.attachments.length; i++) {
              let key = "COLOR_ATTACHMENT" + i;
              let texture = rt.attachments[i];
              colorAttachments.push(_gl[key]);
              prepareTexture(texture);
              texImageDB(rt, texture);
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl[key], _gl.TEXTURE_2D, texture._gl, 0);
              if (rt.multisample && i > 0) {
                texture._blitFramebuffer = _gl.createFramebuffer();
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, texture._blitFramebuffer);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, texture._gl, 0);
              }
            }
            _gl.drawBuffers(colorAttachments);
          } else {
            let ext = Renderer.extensions.drawBuffers;
            let colorAttachments = [];
            for (let i = 0; i < rt.attachments.length; i++) {
              let key = "COLOR_ATTACHMENT" + i + "_WEBGL";
              let texture = rt.attachments[i];
              colorAttachments.push(ext[key]);
              prepareTexture(texture);
              texImageDB(rt, texture);
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, ext[key], _gl.TEXTURE_2D, texture._gl, 0);
            }
            ext.drawBuffersWEBGL(colorAttachments);
          }
        } else if (rt.internalMultisample) {
          let samples = Math.min(_maxSamples, rt._samplesAmount);
          if (rt.parent.multi) {
            let colorAttachments = [];
            let attachments = rt.parent.attachments;
            for (let i = 0; i < attachments.length; i++) {
              let key = "COLOR_ATTACHMENT" + i;
              let texture = attachments[i];
              colorAttachments.push(_gl[key]);
              texture._colorBuffer = _gl.createRenderbuffer();
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(texture), rt.width, rt.height);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl[key], _gl.RENDERBUFFER, texture._colorBuffer);
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            }
            _gl.drawBuffers(colorAttachments);
          } else {
            rt._colorBuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(rt.texture), rt.width, rt.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, rt._colorBuffer);
          }
        } else {
          prepareTexture(rt.texture);
          if (rt.texture.type.includes("float")) {
            let {
              internalformat: internalformat,
              format: format,
              type: type
            } = getFloatParams(rt.texture);
            _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
          }
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, rt.texture._gl, 0);
        }
        if (rt.depth) {
          prepareTexture(rt.depth);
          let iformat = rt.stencil ? WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL : WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT;
          let type = rt.stencil ? WEBGL2 ? _gl.UNSIGNED_INT_24_8 : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL : _gl.UNSIGNED_INT;
          _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT, type, null);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0);
        } else if (!rt.disableDepth) {
          rt.internalMultisample;
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _gl.bindTexture(_gl.TEXTURE_2D, null);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      }
    };
    this.bind = function (rt) {
      if (!rt._gl) {
        this.upload(rt);
      }
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
      if (rt.cube) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + rt.activeFace, rt.texture._gl, 0);
      }
      if (rt.scissor) {
        _gl.enable(_gl.SCISSOR_TEST);
        _gl.scissor(rt.scissor.x, rt.scissor.y, rt.scissor.width, rt.scissor.height);
      }
      _gl.viewport(rt.viewport.x, rt.viewport.y, rt.width, rt.height);
      if (rt.customViewport) {
        _gl.viewport(rt.customViewport.x, rt.customViewport.y, rt.customViewport.z, rt.customViewport.w);
      }
      if (Renderer.instance.autoClear) {
        _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
        if (rt.sharedRenderbuffer) {
          if (rt.clearDepth) {
            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
          } else {
            _gl.clear(_gl.COLOR_BUFFER_BIT);
          }
        } else {
          _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT);
        }
      }
    };
    this.unbind = function (rt) {
      if (rt.scissor) {
        _gl.disable(_gl.SCISSOR_TEST);
      }
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    };
    this.resize = function (rt) {
      if (rt.texture._gl && rt._gl) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
        if (rt.multi) {
          for (let i = 0; i < rt.attachments.length; i++) {
            let texture = rt.attachments[i];
            _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
            if (texture.type.includes("float")) {
              let {
                internalformat: internalformat,
                format: format,
                type: type
              } = getFloatParams(texture);
              _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
            } else {
              _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
            }
          }
        } else if (rt.internalMultisample) {
          let samples = Math.min(_maxSamples, rt._samplesAmount);
          if (rt.parent.multi) {
            let attachments = rt.parent.attachments;
            for (let i = 0; i < attachments.length; i++) {
              let texture = attachments[i];
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer);
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(texture), rt.width, rt.height);
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            }
          } else {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(rt.texture), rt.width, rt.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, rt._colorBuffer);
          }
        } else {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);
          if (rt.texture.type.includes("float")) {
            let {
              internalformat: internalformat,
              format: format,
              type: type
            } = getFloatParams(rt.texture);
            _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
          }
        }
        if (rt.depth) {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.depth._gl);
          let iformat = rt.stencil ? WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL : WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT;
          let type = rt.stencil ? WEBGL2 ? _gl.UNSIGNED_INT_24_8 : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL : _gl.UNSIGNED_INT;
          _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT, type, null);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0);
        } else if (!rt.disableDepth) {
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);
          if (rt.internalMultisample) {
            let samples = Math.min(_maxSamples, rt._samplesAmount);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24, rt.width, rt.height);
          } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, rt.stencil ? WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL : WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16, rt.width, rt.height);
          }
        }
        _gl.bindTexture(_gl.TEXTURE_2D, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      }
    };
    this.destroy = function (rt) {
      _gl.deleteFramebuffer(rt._gl);
      if (rt._depthBuffer) {
        _gl.deleteRenderbuffer(rt._depthBuffer);
      }
      Texture.renderer.destroy(rt.texture);
      RenderCount.remove(`fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`);
      if (rt.multi) {
        rt.attachments.forEach(t => {
          if (t._colorBuffer) {
            _gl.deleteRenderbuffer(t._colorBuffer);
          }
          if (t._blitFramebuffer) {
            _gl.deleteFramebuffer(t._blitFramebuffer);
          }
          Texture.renderer.destroy(t);
        });
      }
      rt._gl = null;
    };
  });
  Class(function GeometryRendererWebGL(_gl) {
    var _cache = {};
    var _isDebbugingShader = Utils.query("displayShaderError");
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    function updateBuffer(attrib) {
      if (!attrib._gl) {
        return;
      }
      attrib.needsUpdate = false;
      _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
      RenderStats.update("BufferUpdates");
      let array = attrib.array;
      let updateRange = attrib.updateRange;
      if (updateRange.count === -1) {
        if (attrib.needsNewBuffer) {
          _gl.bufferData(_gl.ARRAY_BUFFER, attrib.array, _gl.DYNAMIC_DRAW);
          attrib.needsNewBuffer = false;
        } else {
          _gl.bufferSubData(_gl.ARRAY_BUFFER, 0, array);
        }
      } else if (Array.isArray(updateRange)) {
        for (let i = updateRange.length - 1; i > -1; i--) {
          let {
            offset: offset,
            count: count
          } = updateRange[i];
          _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT, array.subarray(offset, offset + count));
        }
        updateRange.length = 0;
      } else {
        _gl.bufferSubData(_gl.ARRAY_BUFFER, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
    }
    function renderingCount(count, mode, instanceCount = 1) {
      if (RenderStats.active) {
        switch (mode) {
          case _gl.TRIANGLES:
            RenderStats.update("Triangles", instanceCount * (count / 3));
            break;
          case _gl.LINES:
            RenderStats.update("Lines", instanceCount * (count / 2));
            break;
          case _gl.LINE_STRIP:
            RenderStats.update("LineStrip", instanceCount * (count - 1));
            break;
          case _gl.LINE_LOOP:
            RenderStats.update("LineLoop", instanceCount * count);
            break;
          case _gl.POINTS:
            RenderStats.update("Points", instanceCount * count);
        }
      }
    }
    this.draw = function (geom, mesh, shader, isQuery) {
      if (!geom._gl || !!geom.needsUpdate || !mesh._gl || !mesh._gl.geomInit) {
        this.upload(geom, mesh, shader);
      }
      if (RenderStats.active) {
        RenderStats.update("DrawCalls", 1, shader.vsName + "|" + shader.fsName, mesh);
      }
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        let key = geom._attributeKeys[i];
        let attrib = geom._attributeValues[i];
        if (mesh._gl.program != shader._gl.program || mesh._gl[key] === undefined) {
          mesh._gl[key] = _gl.getAttribLocation(shader._gl.program, key);
        }
        if (mesh._gl[key] !== -1) {
          if (attrib.isInterleaved && attrib.data.needsUpdate) {
            updateBuffer(attrib.data);
          } else if (attrib.needsUpdate || attrib.dynamic) {
            updateBuffer(attrib);
          }
        }
      }
      mesh._gl.program = shader._gl.program;
      if (geom.indexNeedsUpdate) {
        geom._gl.indexType = geom.index instanceof Uint16Array ? _gl.UNSIGNED_SHORT : _gl.UNSIGNED_INT;
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
        if (geom.indexUpdateRange) {
          let updateRange = geom.indexUpdateRange;
          _gl.bufferSubData(_gl.ELEMENT_ARRAY_BUFFER, updateRange.offset * geom.index.BYTES_PER_ELEMENT, geom.index.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        } else {
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
        }
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
        geom.indexNeedsUpdate = false;
      }
      mesh._gl.vao.bind();
      let mode = mesh._gl.mode;
      if (!mode) {
        mesh._gl.mode = mode = function getMode(mesh, shader) {
          if (mesh.isPoints) {
            return _gl.POINTS;
          } else if (mesh.isLine) {
            return _gl.LINE_STRIP;
          } else if (shader.wireframe) {
            return _gl.LINES;
          } else {
            return _gl.TRIANGLES;
          }
        }(mesh, shader);
      }
      let drawStart = geom.drawRange.start || 0;
      let drawEnd = geom.drawRange.end || geom.attributes.position.count;
      if (isQuery && WEBGL2) {
        let queryMesh = mesh._queryMesh;
        if (queryMesh._gl !== undefined) {
          if (queryMesh._gl.queryInProgress && _gl.getQueryParameter(queryMesh._gl.query, _gl.QUERY_RESULT_AVAILABLE)) {
            queryMesh._gl.occluded = !_gl.getQueryParameter(queryMesh._gl.query, _gl.QUERY_RESULT);
            queryMesh._gl.queryInProgress = false;
          }
          if (!queryMesh._gl.queryInProgress) {
            _gl.beginQuery(_gl.ANY_SAMPLES_PASSED_CONSERVATIVE, queryMesh._gl.query);
            _gl.colorMask(false, false, false, false);
            _gl.depthMask(false);
            if (geom.index) {
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
              _gl.drawElements(mode, geom.index.length, geom._gl.indexType, 0);
            } else {
              _gl.drawArrays(mode, drawStart, drawEnd);
            }
            _gl.colorMask(true, true, true, true);
            _gl.depthMask(true);
            _gl.endQuery(_gl.ANY_SAMPLES_PASSED_CONSERVATIVE);
            queryMesh._gl.queryInProgress = true;
          }
        }
      } else {
        if (geom.isInstanced) {
          let maxInstancedCount = mesh.maxInstancedCount ? Math.min(mesh.maxInstancedCount, geom.maxInstancedCount) : geom.maxInstancedCount;
          if (shader.maxInstancedCount) {
            maxInstancedCount = Math.min(maxInstancedCount || 9999, shader.maxInstancedCount);
          }
          if (WEBGL2) {
            if (geom.index) {
              _gl.drawElementsInstanced(mode, geom.index.length, geom._gl.indexType, 0, maxInstancedCount);
            } else {
              _gl.drawArraysInstanced(mode, drawStart, drawEnd, maxInstancedCount);
            }
          } else if (geom.index) {
            Renderer.extensions.instancedArrays.drawElementsInstancedANGLE(mode, geom.index.length, geom._gl.indexType, 0, maxInstancedCount);
          } else {
            Renderer.extensions.instancedArrays.drawArraysInstancedANGLE(mode, drawStart, drawEnd, maxInstancedCount);
          }
          renderingCount(geom.index ? geom.index.length : drawEnd, mode, maxInstancedCount);
        } else if (!mesh.hideByOcclusion) {
          if (geom.index) {
            _gl.drawElements(mode, geom.index.length, geom._gl.indexType, 0);
          } else {
            _gl.drawArrays(mode, drawStart, drawEnd);
          }
          renderingCount(geom.index ? geom.index.length : drawEnd, mode, 1);
        }
        if (_isDebbugingShader && _gl.getError() != _gl.NO_ERROR) {
          console.log(mesh, shader);
        }
        mesh._gl.vao.unbind();
      }
    };
    this.upload = function (geom, mesh, shader, hotload) {
      if (!mesh) {
        return;
      }
      geom._gl ||= {
        id: Utils.timestamp()
      };
      mesh._gl ||= {};
      mesh._gl.geomInit = true;
      geom.uploaded = true;
      if (!mesh.isOcclusionMesh && WEBGL2) {
        mesh._gl.query = _gl.createQuery();
        mesh._gl.queryInProgress = false;
        mesh._gl.occluded = false;
      }
      const KEY = `${geom._gl.id}_${shader._gl._id}`;
      let cached = _cache[KEY];
      if (cached && !hotload) {
        cached.count++;
        mesh._gl.vao = cached.vao;
        mesh._gl.lookup = KEY;
        return;
      }
      if (Utils.query("debugUpload")) {
        console.log("?debugUpload  upload geometry", geom);
      }
      RenderCount.add("geometry");
      if (mesh._gl.vao) {
        mesh._gl.vao.destroy();
      }
      mesh._gl.vao = new VAO(_gl);
      if (!geom.distributeBufferData) {
        RenderCount.add("geom_upload", geom);
      }
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        let key = geom._attributeKeys[i];
        let attrib = geom._attributeValues[i];
        let location = mesh._gl.program === shader._gl.program && mesh._gl[key] || _gl.getAttribLocation(shader._gl.program, key);
        mesh._gl[key] = location;
        if (attrib._gl) {
          continue;
        }
        attrib._gl = {};
        let {
          array: array,
          dynamic: dynamic
        } = attrib;
        if (attrib.isInterleaved) {
          attrib.data._gl ||= attrib._gl;
          attrib._gl = attrib.data._gl;
          array = attrib.data.array;
          dynamic = attrib.data.dynamic;
        }
        if (!attrib._gl.buffer) {
          attrib._gl.buffer = _gl.createBuffer();
          attrib._gl.bufferUploaded = !geom.distributeBufferData;
          _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, geom.distributeBufferData ? array.length * array.BYTES_PER_ELEMENT : array, dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
          _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
        }
        attrib.needsUpdate = false;
      }
      if (geom.index) {
        if (!geom._gl.index) {
          geom._gl.index = _gl.createBuffer();
          geom._gl.indexType = geom.index instanceof Uint16Array ? _gl.UNSIGNED_SHORT : _gl.UNSIGNED_INT;
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
        }
      }
      mesh._gl.vao.bind();
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        let key = geom._attributeKeys[i];
        let attrib = geom._attributeValues[i];
        let location = mesh._gl[key];
        if (location == -1) {
          continue;
        }
        let stride = 0;
        let offset = 0;
        if (attrib.isInterleaved) {
          let bytes = attrib.data.array.BYTES_PER_ELEMENT;
          stride = attrib.data.stride * bytes;
          offset = attrib.offset * bytes;
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
        _gl.vertexAttribPointer(location, attrib.itemSize, _gl.FLOAT, false, stride, offset);
        _gl.enableVertexAttribArray(location);
        if (geom.isInstanced) {
          if (WEBGL2) {
            _gl.vertexAttribDivisor(location, attrib.meshPerAttribute);
          } else {
            Renderer.extensions.instancedArrays.vertexAttribDivisorANGLE(location, attrib.meshPerAttribute);
          }
        }
      }
      if (geom.index) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
      }
      mesh._gl.vao.unbind();
      _cache[KEY] = {
        count: 1,
        vao: mesh._gl.vao
      };
    };
    this.destroy = function (geom, mesh) {
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        geom._attributeKeys[i];
        let attrib = geom._attributeValues[i];
        if (attrib._gl) {
          _gl.deleteBuffer(attrib._gl.buffer);
          attrib._gl = null;
        }
      }
      if (geom._gl?.index) {
        _gl.deleteBuffer(geom._gl.index);
      }
      RenderCount.remove("geometry");
      if (mesh && mesh._gl && mesh._gl.vao) {
        let cache = _cache[mesh._gl.lookup];
        if (cache) {
          cache.count--;
          if (cache.count == 0) {
            cache.vao.destroy();
            delete _cache[mesh._gl.lookup];
          }
        } else {
          mesh._gl.vao.destroy();
        }
        delete mesh._gl.vao;
      }
      delete geom._gl;
    };
    this.resetMeshGeom = function (mesh) {
      if (mesh._gl) {
        mesh._gl.geomInit = false;
      }
    };
    this.uploadBuffersAsync = async function (geom) {
      if (geom._gl && geom._gl.uploadedAsync) {
        return;
      }
      let upload = attrib => {
        let array = attrib.array;
        let buffer = attrib._gl.buffer;
        let promise = Promise.create();
        let amt = 4;
        let match = false;
        while (!match) {
          amt--;
          if (array.length % amt == 0) {
            match = true;
          }
        }
        let chunk = array.length / amt;
        let i = 0;
        let worker = new Render.Worker(function uploadBuffersAsync() {
          let offset = i * chunk;
          let subarray = array.subarray(offset, offset + chunk);
          if (!attrib._gl) {
            worker.stop();
            return promise.resolve();
          }
          if (subarray.length) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
            _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT, subarray);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
          }
          if (++i == amt) {
            promise.resolve();
            worker.stop();
          }
        });
        return promise;
      };
      let uploaded = false;
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        geom._attributeKeys[i];
        let attrib = geom._attributeValues[i];
        if (!attrib._gl) {
          geom.distributeBufferData = true;
          let {
            array: array,
            dynamic: dynamic
          } = attrib;
          attrib._gl = {};
          if (attrib.isInterleaved) {
            attrib.data._gl ||= attrib._gl;
            attrib._gl = attrib.data._gl;
            array = attrib.data.array;
            dynamic = attrib.data.dynamic;
          }
          if (!attrib._gl.buffer) {
            attrib._gl.buffer = _gl.createBuffer();
            attrib._gl.bufferUploaded = !geom.distributeBufferData;
            if (attrib.array.length) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
              _gl.bufferData(_gl.ARRAY_BUFFER, array.length * array.BYTES_PER_ELEMENT, dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
              _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
            }
          }
          attrib.needsUpdate = false;
          geom.needsUpdate = true;
        }
        if (!attrib._gl.bufferUploaded) {
          attrib._gl.bufferUploaded = true;
          uploaded = true;
          await upload(attrib);
          attrib.needsUpdate = false;
        }
      }
      geom._gl.uploadedAsync = true;
      if (uploaded) {
        RenderCount.add("geom_uploadAsync", geom);
      }
    };
  });
  Class(function ShaderRendererWebGL(_gl) {
    var _pool = {};
    var _programID = 0;
    var _cached = {};
    var _uboCache = {};
    const PROFILER = !!window.OptimizationProfiler;
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    const GLOBAL_UNIFORMS = ["normalMatrix", "modelMatrix", "modelViewMatrix", "projectionMatrix", "viewMatrix", "cameraPosition", "cameraQuaternion", "resolution", "time", "shadowMatrix", "shadowLightPos", "shadowSize"];
    const DEPTH_FUNC_KEYS = {
      [Shader.DEPTH_FUNC_NEVER]: "NEVER",
      [Shader.DEPTH_FUNC_LESS]: "LESS",
      [Shader.DEPTH_FUNC_EQUAL]: "EQUAL",
      [Shader.DEPTH_FUNC_LEQUAL]: "LEQUAL",
      [Shader.DEPTH_FUNC_GREATER]: "GREATER",
      [Shader.DEPTH_FUNC_NOTEQUAL]: "NOTEQUAL",
      [Shader.DEPTH_FUNC_GEQUAL]: "GEQUAL",
      [Shader.DEPTH_FUNC_ALWAYS]: "ALWAYS"
    };
    function toTypedArray(uni) {
      uni.value;
      uni._gl ||= {};
      if (uni._gl.array && uni._gl.array.length == uni.value.length) {
        uni._gl.array.set(uni.value);
      } else {
        uni._gl.array = new Float32Array(uni.value);
      }
      return uni._gl.array;
    }
    function createShader(str, type, name = "Shader") {
      let shader = _gl.createShader(type);
      if (window.SPECTOR !== undefined) {
        shader.__SPECTOR_Metadata = {
          name: name
        };
      }
      _gl.shaderSource(shader, str);
      _gl.compileShader(shader);
      if (Hydra.LOCAL) {
        if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
          (function logPrettyShaderError(shader) {
            const shaderSrc = _gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
            const shaderLog = _gl.getShaderInfoLog(shader);
            const splitShader = shaderLog.split("\n");
            const dedupe = {};
            const lineNumbers = splitShader.map(line => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(n => !!n && !dedupe[n] && (dedupe[n] = true, true));
            const logArgs = [""];
            lineNumbers.forEach(number => {
              shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
              logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
            });
            const fragmentSourceToLog = shaderSrc.join("\n");
            logArgs[0] = fragmentSourceToLog;
            console.error(shaderLog);
            console.groupCollapsed("click to view full shader code");
            console.warn(...logArgs);
            console.groupEnd();
          })(shader);
          _gl.deleteShader(shader);
        }
      }
      return shader;
    }
    function createProgram(shader) {
      if (!shader.vertexShader) {
        Shader.runPreProcess(shader);
      }
      let vsCode = shader.onBeforeCompile(shader.vertexShader, "vs");
      let fsCode = shader.onBeforeCompile(shader.fragmentShader, "fs");
      if (PROFILER && OptimizationProfiler.active) {
        [vsCode, fsCode] = OptimizationProfiler.override(shader, vsCode, fsCode);
      }
      RenderCount.add("shader", shader);
      let vs = createShader(vsCode, _gl.VERTEX_SHADER, `${shader.vsName} - ${shader.UILPrefix}`);
      let fs = createShader(fsCode, _gl.FRAGMENT_SHADER, `${shader.fsName} - ${shader.UILPrefix}`);
      if (Hydra.LOCAL && window.GLSLLinter) {
        GLSLLinter.lint(shader, vsCode, fsCode);
      }
      let program = _gl.createProgram();
      _gl.attachShader(program, vs);
      _gl.attachShader(program, fs);
      _gl.linkProgram(program);
      if (Hydra.LOCAL) {
        if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
          console.warn(`Shader: ${shader.vsName} | ${shader.vsName}`);
          console.error(`Could not compile WebGL program. ${shader.vsName} ${shader.fsName} \n\n${_gl.getProgramInfoLog(program)}`);
        }
      }
      _gl.deleteShader(vs);
      _gl.deleteShader(fs);
      return program;
    }
    function setupShaders(shader) {
      for (let i = shader._uniformKeys.length - 1; i > -1; i--) {
        let key = shader._uniformKeys[i];
        let uniform = shader._uniformValues[i];
        if (shader._gl[key] === undefined && uniform) {
          if (uniform.ubo) {
            if (WEBGL2) {
              if (_uboCache[shader.UILPrefix] && !shader.ubo) {
                shader.ubo = _uboCache[shader.UILPrefix];
              }
              if (_uboCache[shader.UILPrefix]) {
                shader._gl[key] = "U";
                continue;
              }
              shader.ubo ||= new UBO(1, _gl);
              shader.ubo.push(uniform);
              shader._gl[key] = "U";
            } else {
              shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
            }
          } else if (WEBGL2 && uniform.lightUBO) {
            shader._gl[key] = "U";
            shader.uboLight = true;
          } else {
            shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
          }
        }
      }
      if (shader.ubo && !_uboCache[shader.UILPrefix]) {
        _uboCache[shader.UILPrefix] = shader.ubo;
      }
      if (!shader._gl.setupGlobals) {
        shader._gl.setupGlobals = true;
        GLOBAL_UNIFORMS.forEach(key => {
          shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
        });
      }
      if (shader.uboLight) {
        _gl.getUniformBlockIndex(shader._gl.program, "lights");
      }
      if (WEBGL2) {
        _gl.getUniformBlockIndex(shader._gl.program, "global");
      }
    }
    function uniformTextureArray(uni, uLoc, shader) {
      let array = shader._gl.texArray || [];
      array.length = 0;
      shader._gl.texArray = array;
      for (let i = 0; i < uni.value.length; i++) {
        array.push(shader._gl.texIndex);
        let texture = uni.value[i];
        if (texture.loaded === false) {
          texture = Utils3D.getEmptyTexture();
        }
        if (texture._gl === undefined || texture.needsReupload) {
          Texture.renderer.upload(texture);
        }
        _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]);
        _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
      }
      _gl.uniform1iv(uLoc, array);
    }
    this.upload = function (shader) {
      if (PROFILER && OptimizationProfiler.active) {
        OptimizationProfiler.setupShader(shader);
      }
      if (!shader._gl) {
        shader._gl = {};
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
        let cached = _pool[key];
        if (cached) {
          shader._gl.program = cached.program;
          shader._gl._id = cached.id;
          shader.onBeforePrecompilePromise.resolve();
          cached.count++;
          if (Hydra.LOCAL) {
            _pool[key].references.push(shader);
          }
        } else {
          shader._gl.program = createProgram(shader);
          shader._gl._id = _programID++;
          _pool[key] = {
            count: 1,
            program: shader._gl.program,
            id: shader._gl._id
          };
          Shader.registerPreProcess(shader);
          if (Hydra.LOCAL) {
            _pool[key].references = [shader];
          }
        }
      }
      setupShaders(shader);
      if (shader.ubo) {
        shader.ubo.upload();
      }
      if (Renderer.type != Renderer.WEBGL1 || !FXLayer.exists) {
        shader.vertexShader = shader.fragmentShader = "";
      }
    };
    this.findCachedProgram = function (shader) {
      let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
      let cached = _pool[key];
      return !!cached && (shader._gl = {}, shader._gl.program = cached.program, shader._gl._id = cached.id, shader.onBeforePrecompilePromise.resolve(), _uboCache[shader.UILPrefix] && (shader.ubo = shader.UILPrefix), cached.count++, Hydra.LOCAL && _pool[key].references.push(shader), true);
    };
    this.draw = function (shader) {
      if (shader._gl === undefined) {
        this.upload(shader);
      }
      shader._gl.texIndex = 0;
      if (shader._gl.program != _cached.program) {
        _gl.useProgram(shader._gl.program);
        _cached.program = shader._gl.program;
      }
      if (shader.ubo) {
        shader.ubo.bind(shader._gl.program, "ubo");
      }
      if (shader.uboLight) {
        Lighting.bindUBO(shader._gl.program);
      }
      for (let i = shader._uniformKeys.length - 1; i > -1; i--) {
        let key = shader._uniformKeys[i];
        let uni = shader._uniformValues[i];
        if (!uni) {
          continue;
        }
        let uLoc = shader._gl[key];
        if (uLoc === undefined) {
          setupShaders(shader);
          uLoc = shader._gl[key];
        }
        if (uLoc !== null && uLoc !== -1 && uLoc !== "U") {
          if (uni.value === null) {
            uni.value = Utils3D.getEmptyTexture();
          }
          if (Hydra.LOCAL && uni.value === undefined) {
            throw `Uniform ${key} value is undefined. | ${shader.vsName} ${shader.fsName}`;
          }
          uni.type ||= typeof (uniform = uni).type == "string" ? uniform.type : typeof uniform.value == "boolean" ? "b" : uniform.value === null || uniform.value instanceof Texture || uniform.value.texture || uniform.value.rt && uniform.value.rt.texture ? "t" : uniform.value instanceof Vector2 ? "v2" : uniform.value instanceof Vector3 || uniform.value instanceof Vector3D ? "v3" : uniform.value instanceof Vector4 ? "v4" : uniform.value instanceof Matrix4 ? "m4" : uniform.value instanceof Matrix3 ? "m3" : uniform.value instanceof Color ? "c" : uniform.value instanceof Quaternion ? "q" : Array.isArray(uniform.value) && uniform.value[0] instanceof Texture ? "tv" : "f";
          switch (uni.type) {
            case "f":
              _gl.uniform1f(uLoc, uni.value);
              break;
            case "i":
              _gl.uniform1i(uLoc, Math.floor(uni.value));
              break;
            case "b":
              _gl.uniform1i(uLoc, uni.value);
              break;
            case "v2":
              _gl.uniform2f(uLoc, uni.value.x, uni.value.y);
              break;
            case "v3":
              _gl.uniform3f(uLoc, uni.value.x, uni.value.y, uni.value.z);
              break;
            case "c":
              _gl.uniform3f(uLoc, uni.value.r, uni.value.g, uni.value.b);
              break;
            case "q":
            case "v4":
              _gl.uniform4f(uLoc, uni.value.x, uni.value.y, uni.value.z, uni.value.w);
              break;
            case "v3v":
              _gl.uniform3fv(uLoc, toTypedArray(uni));
              break;
            case "v4v":
              _gl.uniform4fv(uLoc, toTypedArray(uni));
              break;
            case "v2v":
              _gl.uniform2fv(uLoc, toTypedArray(uni));
              break;
            case "fv":
              _gl.uniform1fv(uLoc, toTypedArray(uni));
              break;
            case "m4":
              _gl.uniformMatrix4fv(uLoc, false, uni.value.elements);
              break;
            case "m3":
              _gl.uniformMatrix3fv(uLoc, false, uni.value.elements);
              break;
            case "tv":
              uniformTextureArray(uni, uLoc, shader);
              break;
            case "t":
              let texture = uni.value;
              if (!texture.isTexture) {
                if (uni.value.rt) {
                  texture = uni.value.rt.overrideTexture || uni.value.rt.texture;
                }
                if (uni.value.texture) {
                  texture = uni.value.texture;
                }
              }
              if (texture.loaded === false) {
                texture = Utils3D.getEmptyTexture();
              }
              let texIndex = shader._gl.texIndex++;
              if (uni.value.vrRT) {
                shader._gl.vrRT = true;
                uni.value._glTexIndex = texIndex;
              }
              Texture.renderer.draw(texture, uLoc, key, texIndex);
          }
        }
      }
      var uniform;
      if (!shader.glCustomState) {
        if (shader.polygonOffset) {
          let key = shader.polygonOffsetFactor + "_" + shader.polygonOffsetUnits;
          if (_cached.polygonOffset != key) {
            _gl.enable(_gl.POLYGON_OFFSET_FILL);
            _gl.polygonOffset(shader.polygonOffsetFactor, shader.polygonOffsetUnits);
          }
          _cached.polygonOffset = key;
        } else {
          if (_cached.polygonOffset) {
            _gl.disable(_gl.POLYGON_OFFSET_FILL);
          }
          _cached.polygonOffset = false;
        }
        if (shader.transparent || shader.opacity) {
          if (!_cached.transparent) {
            _gl.enable(_gl.BLEND);
          }
          _cached.transparent = true;
        } else {
          if (_cached.transparent) {
            _gl.disable(_gl.BLEND);
          }
          _cached.transparent = false;
        }
        if (_cached.blending != shader.blending) {
          switch (shader.blending) {
            case Shader.ADDITIVE_BLENDING:
              _gl.blendEquation(_gl.FUNC_ADD);
              _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
              break;
            case Shader.PREMULTIPLIED_ALPHA_BLENDING:
              _gl.blendEquation(_gl.FUNC_ADD);
              _gl.blendFunc(_gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
              break;
            case Shader.ADDITIVE_COLOR_ALPHA:
              _gl.blendEquation(_gl.FUNC_ADD);
              _gl.blendFunc(_gl.ONE, _gl.ONE);
              break;
            case Shader.MAX:
              _gl.blendEquation(WEBGL2 ? _gl.MAX : Renderer.extensions.minMax.MAX_EXT);
              _gl.blendFunc(_gl.ONE, _gl.ONE);
              break;
            case Shader.MIN:
              _gl.blendEquation(WEBGL2 ? _gl.MIN : Renderer.extensions.minMax.MIN_EXT);
              _gl.blendFunc(_gl.ONE, _gl.ONE);
              break;
            default:
              _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
              _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
          }
          _cached.blending = shader.blending;
        }
        if (shader.depthTest) {
          if (!_cached.depthTest) {
            _gl.enable(_gl.DEPTH_TEST);
          }
          _cached.depthTest = true;
        } else {
          if (_cached.depthTest) {
            _gl.disable(_gl.DEPTH_TEST);
          }
          _cached.depthTest = false;
        }
        let depthFunc = _gl[DEPTH_FUNC_KEYS[shader.depthFunc || Shader.DEPTH_FUNC_LESS]];
        if (_cached.depthFunc !== depthFunc) {
          _gl.depthFunc(depthFunc);
          _cached.depthFunc = depthFunc;
        }
        if (shader.stencilTest) {
          if (!_cached.stencilTest) {
            _gl.enable(_gl.STENCIL_TEST);
          }
          _cached.stencilTest = true;
          if (shader.stencilMask) {
            _gl.stencilFunc(_gl.ALWAYS, 1, 255);
            _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE);
            _gl.stencilMask(255);
            _gl.colorMask(false, false, false, false);
            _gl.disable(_gl.DEPTH_TEST);
          } else {
            _gl.colorMask(true, true, true, true);
            _gl.enable(_gl.DEPTH_TEST);
            let mode = "inside";
            _gl.stencilFunc(mode == "inside" ? _gl.EQUAL : _gl.NOTEQUAL, 1, 255);
            _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);
          }
        } else {
          if (_cached.stencilTest) {
            _gl.disable(_gl.STENCIL_TEST);
          }
          _cached.stencilTest = false;
        }
        switch (shader.side) {
          case Shader.BACK_SIDE:
            if (_cached.side != Shader.BACK_SIDE) {
              _gl.enable(_gl.CULL_FACE);
              _gl.cullFace(_gl.FRONT);
              _cached.side = Shader.BACK_SIDE;
            }
            break;
          case Shader.DOUBLE_SIDE:
            if (_cached.side != Shader.DOUBLE_SIDE) {
              _gl.disable(_gl.CULL_FACE);
              _cached.side = Shader.DOUBLE_SIDE;
            }
            break;
          default:
            if (_cached.side != Shader.FRONT_SIDE) {
              _gl.enable(_gl.CULL_FACE);
              _gl.cullFace(_gl.BACK);
              _cached.side = Shader.FRONT_SIDE;
            }
        }
        if (_cached.depthMask != shader.depthWrite) {
          _gl.depthMask(!!shader.depthWrite);
          _cached.depthMask = shader.depthWrite;
        }
        if (shader.colorMask && shader.colorMask.push) {
          _gl.colorMask(shader.colorMask[0] || false, shader.colorMask[1] || false, shader.colorMask[2] || false, shader.colorMask[3] || false);
        } else {
          switch (shader.colorMask) {
            case Shader.COLOR_MASK_NONE:
              if (_cached.colorMask != shader.colorMask) {
                _gl.colorMask(true, true, true, true);
                _cached.colorMask = shader.colorMask;
              }
              break;
            case Shader.COLOR_MASK_RGB:
              if (_cached.colorMask != shader.colorMask) {
                _gl.colorMask(false, false, false, true);
                _cached.colorMask = shader.colorMask;
              }
              break;
            case Shader.COLOR_MASK_RGBA:
              if (_cached.colorMask != shader.colorMask) {
                _gl.colorMask(false, false, false, false);
                _cached.colorMask = shader.colorMask;
              }
          }
        }
      }
      if (shader.customState) {
        for (let i = 0; i < shader.customState.length; i++) {
          let obj = shader.customState[i];
          _gl[obj.fn].apply(_gl, obj.params);
        }
      }
    };
    this.destroy = function (shader) {
      delete shader._gl;
      if (shader.ubo) {
        shader.ubo.destroy();
      }
    };
    this.appendUniform = function (shader, key, value, hint) {
      let loc = shader._gl[key];
      if (loc === undefined) {
        loc = loc = _gl.getUniformLocation(shader._gl.program, key);
      }
      if (loc !== null) {
        if (value.isMatrix4) {
          _gl.uniformMatrix4fv(loc, false, value.elements);
        } else if (value.isMatrix3) {
          _gl.uniformMatrix3fv(loc, false, value.elements);
        } else if (value.isVector4) {
          _gl.uniform4f(loc, value.x, value.y, value.z, value.w);
        } else if (value.isQuaternion) {
          _gl.uniform4f(loc, value.x, value.y, value.z, value.w);
        } else if (value.isVector3) {
          _gl.uniform3f(loc, value.x, value.y, value.z);
        } else if (value.isVector2) {
          _gl.uniform2f(loc, value.x, value.y);
        } else if (value instanceof Float32Array) {
          switch (hint) {
            case "matrix":
              _gl.uniformMatrix4fv(loc, false, value);
              break;
            case "float":
              _gl.uniform1fv(loc, value);
              break;
            case "vec3":
              _gl.uniform3fv(loc, value);
          }
        } else if (Array.isArray(value)) {
          let array = shader._gl.texArray || [];
          array.length = 0;
          shader._gl.texArray = array;
          for (let i = 0; i < value.length; i++) {
            array.push(shader._gl.texIndex);
            _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]);
            _gl.bindTexture(_gl.TEXTURE_2D, value[i]._gl);
          }
          _gl.uniform1iv(loc, array);
        } else {
          _gl.uniform1f(loc, value);
        }
      }
    };
    this.resetState = function () {
      if (!_cached.depthMask) {
        _gl.depthMask(true);
        _cached.depthMask = true;
      }
      if (!_cached.depthTest) {
        _gl.enable(_gl.DEPTH_TEST);
      }
      _cached.depthTest = true;
      if (_cached.depthFunc !== _gl.LESS) {
        _gl.depthFunc(_gl.LESS);
      }
      _cached.depthFunc = _gl.LESS;
      if (_cached.colorMask != Shader.COLOR_MASK_NONE) {
        _gl.colorMask(true, true, true, true);
        _cached.colorMask = Shader.COLOR_MASK_NONE;
      }
      _cached.program = null;
    };
    this.clearState = function () {
      _cached = {};
    };
    this.hotReload = function (file) {
      file = file.split(".")[0].trim();
      for (let key in _pool) {
        if (key.includes(file) && !["|instance", "|Line3D", "|MergedLine"].find(part => key.includes(part))) {
          let obj = _pool[key];
          let rootShader = obj.references[0];
          for (let i = 0; i < obj.references.length; i++) {
            let shader = obj.references[i];
            if (i === 0) {
              shader.restoreFS = shader.restoreVS = null;
              shader.resetProgram();
              shader._gl = {};
              shader._gl.program = createProgram(shader);
              shader._gl._id = _programID++;
              obj.program = shader._gl.program;
              obj.id = shader._gl._id;
            } else {
              shader.destroy();
              shader.restoreFS = rootShader.restoreFS;
              shader.restoreVS = rootShader.restoreVS;
              shader.vertexShader = rootShader.vertexShader;
              shader.fragmentShader = rootShader.fragmentShader;
              shader._gl = {};
              shader._gl.program = obj.program;
              shader._gl._id = obj.id;
            }
            setupShaders(rootShader);
          }
        }
      }
    };
    this.hotReloadClearProgram = function (id) {
      for (let key in _pool) {
        if (key.includes(id)) {
          delete _pool[key];
        }
      }
    };
  });
  Class(function TextureRendererWebGL(_gl) {
    const _this = this;
    var _state = {};
    const FLOAT_DATA = new Float32Array([0, 0, 0, 0]);
    const UINT_DATA = new Uint32Array([0, 0, 0, 0]);
    const INT_DATA = new Int32Array([0, 0, 0, 0]);
    const DATA = new Uint8Array([0, 0, 0, 0]);
    const {
      getFormat: getFormat,
      getProperty: getProperty,
      getType: getType,
      getFloatParams: getFloatParams,
      getInternalFormat: getInternalFormat
    } = require("GLTypes");
    function setTextureParams(texture, textureType = _gl.TEXTURE_2D) {
      let format = getFormat(texture);
      let internalFormat = getInternalFormat(texture);
      let type = getType(texture);
      let data = DATA;
      switch (texture.type) {
        case Texture.FLOAT:
          data = FLOAT_DATA;
          break;
        case Texture.UNSIGNED_INTEGER:
          data = UINT_DATA;
          break;
        case Texture.INTEGER:
          data = INT_DATA;
          break;
        case Texture.HALF_FLOAT:
          data = null;
      }
      if (textureType == _gl.TEXTURE_2D && !texture.compressed) {
        _gl.texImage2D(textureType, 0, internalFormat, 1, 1, 0, format, type, data);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));
      if (texture.data || texture.format != Texture.RGBAFormat) {
        if (_state.premultiply == 1) {
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          _state.premultiply = false;
        }
      } else if (texture.premultiplyAlpha === false) {
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        _state.premultiply = false;
      } else {
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        _state.premultiply = true;
      }
      if (texture.anisotropy > 1) {
        _gl.texParameterf(textureType, Renderer.extensions.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, texture.anisotropy);
      }
    }
    function updateDynamic(texture) {
      if (texture.isDataTexture) {
        if (texture.flipY === true) {
          if (!_state.flipY) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
            _state.flipY = true;
          }
        } else if (_state.flipY) {
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
          _state.flipY = false;
        }
        if (_state.premultiply) {
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          _state.premultiply = false;
        }
        if (!texture.glFormat) {
          let {
            internalformat: internalformat,
            format: format,
            type: type
          } = getFloatParams(texture);
          texture.iformat = internalformat;
          texture.glFormat = format;
          texture.glType = type;
        }
        _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, texture.width, texture.height, texture.glFormat, texture.glType, texture.data);
      } else {
        if (!_state.flipY) {
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
          _state.flipY = true;
        }
        if (texture.format == Texture.RGBAFormat) {
          if (texture.premultiplyAlpha === false) {
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            _state.premultiply = false;
          } else {
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            _state.premultiply = true;
          }
        } else if (_state.premultiply) {
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
          _state.premultiply = false;
        }
        texture.glFormat ||= getFormat(texture);
        try {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, texture.glFormat, texture.glFormat, getType(texture), texture.image);
        } catch (e) {}
      }
    }
    this.draw = function (texture, loc, key, id) {
      if (texture._gl === undefined || texture.needsReupload) {
        this.upload(texture);
      }
      _gl.activeTexture(_gl[`TEXTURE${id}`]);
      if (texture.cube) {
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
      } else if (texture.isTexture3D) {
        _gl.bindTexture(_gl.TEXTURE_3D, texture._gl);
      } else {
        let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
        _gl.bindTexture(texType, texture._gl);
      }
      _gl.uniform1i(loc, id);
      if (texture.dynamic || texture.needsUpdate) {
        updateDynamic(texture);
      }
      texture.needsUpdate = false;
    };
    this.upload = function (texture) {
      if (texture._gl && !texture.needsReupload && !texture.needsUpdate) {
        return;
      }
      let format = getFormat(texture);
      if (Utils.query("debugUpload")) {
        console.log("?debugUpload  upload texture", texture);
      }
      if (texture.cube) {
        if (texture.compressed) {
          if (texture.cube.length !== 1) {
            throw "Compressed cube texture requires 1 file with 6 faces";
          }
        } else if (texture.cube.length !== 6) {
          throw "Cube texture requires 6 images";
        }
        return function uploadCube(texture) {
          if (texture._gl === undefined) {
            texture._gl = _gl.createTexture();
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
            let needsFlipY = texture.flipY === true;
            if (needsFlipY !== !!_state.flipY) {
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, needsFlipY);
              _state.flipY = needsFlipY;
            }
            setTextureParams(texture, _gl.TEXTURE_CUBE_MAP);
          }
          let format = getFormat(texture);
          if (texture.compressed) {
            let image = texture.cube[0];
            for (let i = 0; i < image.compressedData.length; i++) {
              let size = image.sizes[i];
              let data = image.compressedData[i];
              let faceLength = data.length / 6;
              for (let j = 0; j < 6; j++) {
                if (image.uncompressed) {
                  let view = new Uint8Array(data.buffer, j * faceLength, faceLength);
                  _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, _gl.RGBA, size.width, size.height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, view);
                } else {
                  let view = new DataView(data.buffer, j * faceLength, faceLength);
                  _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, image.gliFormat, size.width || size, size.height || size, 0, view);
                }
              }
            }
          } else {
            for (let i = 0; i < 6; i++) {
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, format, format, getType(texture), texture.cube[i]);
            }
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          }
          texture.needsUpdate = texture.needsReupload = false;
          if (texture.onUpdate) {
            texture.onUpdate();
          }
        }(texture);
      }
      if (texture.isTexture3D) {
        return function uploadTexture3D(texture) {
          if (texture._gl === undefined) {
            let format = getFormat(texture);
            let internalFormat = getInternalFormat(texture);
            let type = getType(texture);
            texture._gl = _gl.createTexture();
            _gl.bindTexture(_gl.TEXTURE_3D, texture._gl);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_R, getProperty(texture.wrapR));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));
            _gl.texImage3D(_gl.TEXTURE_3D, 0, internalFormat, texture.width, texture.height, texture.depth, 0, format, type, texture.image);
            texture.needsUpdate = texture.needsReupload = false;
            if (texture.onUpdate) {
              texture.onUpdate();
            }
          }
        }(texture);
      }
      let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
      if (texture._gl === undefined) {
        texture._gl = _gl.createTexture();
        RenderCount.add("texture");
        _gl.bindTexture(texType, texture._gl);
        setTextureParams(texture, texType);
      } else {
        _gl.bindTexture(texType, texture._gl);
      }
      if (texture.isDataTexture || texture.type && texture.type.includes("float")) {
        if (texture.flipY === true) {
          if (!_state.flipY) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
            _state.flipY = true;
          }
        } else if (_state.flipY) {
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
          _state.flipY = false;
        }
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, 1);
        let {
          internalformat: internalformat,
          format: format,
          type: type
        } = getFloatParams(texture);
        if (Device.system.browser === "ie") {
          try {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data);
          } catch (e) {
            console.log(e);
          }
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data);
        }
        if (texture.destroyDataAfterUpload) {
          texture.data = null;
          delete texture.data;
        }
      } else {
        let needsFlipY = !texture.compressed && texture.flipY !== false;
        if (needsFlipY !== !!_state.flipY) {
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, needsFlipY);
          _state.flipY = needsFlipY;
        }
        if (texture.image && texture.compressed) {
          let data = texture.image.compressedData;
          for (let i = 0; i < data.length; i++) {
            let size = texture.image.sizes[i];
            if (texture.image.uncompressed) {
              _gl.texImage2D(_gl.TEXTURE_2D, i, _gl.RGBA, size.width, size.height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, data[i]);
            } else {
              _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, texture.image.gliFormat, size.width || size, size.height || size, 0, data[i]);
            }
          }
          data.length = 0;
        } else if (texture.image && !(texture.image instanceof HTMLVideoElement)) {
          try {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, format, format, getType(texture), texture.image);
          } catch (e) {
            console.log("error loading texture", e, texture.image);
          }
        }
        if (!texture.distributeTextureData) {
          RenderCount.add("tex_upload", texture);
        }
      }
      if ((texture.image || texture.data) && texture.generateMipmaps && !texture.compressed) {
        _gl.generateMipmap(_gl.TEXTURE_2D);
      }
      texture.needsUpdate = texture.needsReupload = false;
      if (texture.onUpdate) {
        texture.onUpdate();
      }
    };
    this.manualUpdateDynamic = function (texture) {
      if (texture._gl === undefined || texture.needsReupload) {
        this.upload(texture);
      }
      _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
      updateDynamic(texture);
    };
    this.uploadAsync = function (texture) {
      let {
        format: format,
        type: type
      } = getFloatParams(texture);
      if (texture._uploadAsyncPromise) {
        return texture._uploadAsyncPromise;
      }
      texture._uploadAsyncPromise = Promise.create();
      RenderCount.add("tex_uploadAsync", texture);
      if (!texture._gl) {
        texture.distributeTextureData = true;
        _this.upload(texture);
      }
      let pixelsPerChunk = texture.height / 4;
      let dataPerChunk = texture.data.length / 4;
      let i = 0;
      let worker = new Render.Worker(function workerUploadAsync() {
        let pixelOffset = pixelsPerChunk * i;
        let dataOffset = dataPerChunk * i;
        let subarray = texture.data.subarray(dataOffset, dataOffset + dataPerChunk);
        if (texture.flipY === true) {
          if (!_state.flipY) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
            _state.flipY = true;
          }
        } else if (_state.flipY) {
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
          _state.flipY = false;
        }
        _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
        _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, pixelOffset, texture.width, pixelsPerChunk, format, type, subarray);
        _gl.bindTexture(_gl.TEXTURE_2D, null);
        if (++i == 4) {
          worker.stop();
          texture._uploadAsyncPromise.resolve();
        }
      });
      return texture._uploadAsyncPromise;
    };
    this.destroy = function (texture) {
      if (texture._gl) {
        _gl.deleteTexture(texture._gl);
        RenderCount.remove("texture");
        RenderCount.add("tex_destroy", texture);
      }
      if (texture.data) {
        texture.data = null;
        delete texture.data;
      }
      delete texture._gl;
    };
  });
  class RenderTarget {
    constructor(width, height, options = {}) {
      this.width = width;
      this.height = height;
      this.options = options;
      this.viewport = new Vector2(0, 0);
      if (options.minFilter === undefined) {
        options.minFilter = Texture.LINEAR;
      }
      this.stencil = typeof options.stencil == "boolean" && options.stencil;
      if (options.sharedRenderbuffer) {
        this.sharedRenderbuffer = true;
        this.clearDepth = typeof options.clearDepth != "boolean" || options.clearDepth;
        this._depthBuffer = options.sharedRenderbuffer.rt._depthBuffer;
      }
      this.texture = new Texture(null);
      this.texture.generateMipmaps = options.generateMipmaps;
      this.texture.rt = this;
      this.texture.width = width;
      this.texture.height = height;
      this.texture.minFilter = options.minFilter || Texture.LINEAR;
      this.texture.magFilter = options.magFilter || Texture.LINEAR;
      this.texture.wrapS = options.wrapS || Texture.CLAMP_TO_EDGE;
      this.texture.wrapT = options.wrapT || Texture.CLAMP_TO_EDGE;
      this.texture.format = options.format || Texture.RGBFormat;
      if (options.type) {
        this.texture.type = options.type;
      }
      if (options.multisample && (Renderer.type ? Renderer.type == Renderer.WEBGL2 : Device.graphics.webgl.webgl2)) {
        options.multisample = false;
        this.multisample = true;
        this._rtMultisample = new RenderTarget(width, height, options);
        this._rtMultisample.internalMultisample = true;
        this._rtMultisample.parent = this;
        this._rtMultisample._samplesAmount = options.samplesAmount === undefined ? 100 : options.samplesAmount;
      }
      this.isRT = true;
    }
    setSize(width, height) {
      this.width = width;
      this.height = height;
      this.texture.width = width;
      this.texture.height = height;
      this.viewport.set(0, 0);
      RenderTarget.renderer.resize(this);
      if (!!this.multisample && (this._rtMultisample.width !== width || this._rtMultisample.height !== height)) {
        this._rtMultisample.destroy();
        this._rtMultisample = new RenderTarget(width, height, this.options);
        this._rtMultisample.internalMultisample = true;
        this._rtMultisample.parent = this;
        this._rtMultisample._samplesAmount = this.options.samplesAmount === undefined ? 100 : this.options.samplesAmount;
      }
    }
    clone() {
      return new RenderTarget(this.width, this.height, {
        ...this.options
      }).copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      let options = {
        ...this.options
      };
      this.options = options;
      this.viewport.copy(source.viewport);
      this.stencil = source.stencil;
      if (source.sharedRenderbuffer) {
        this.sharedRenderbuffer = true;
        this.clearDepth = source.clearDepth;
        this._depthBuffer = source._depthBuffer;
      }
      this.texture = source.texture.clone();
      if (source.multisample) {
        options.multisample = false;
        this.multisample = true;
        this._rtMultisample = new RenderTarget(this.width, this.height, options);
        this._rtMultisample.internalMultisample = true;
        this._rtMultisample.parent = this;
        this._rtMultisample._samplesAmount = source._rtMultisample._samplesAmount;
      }
      return this;
    }
    createDepthTexture() {
      this.depth = new Texture(null);
      this.depth.generateMipmaps = false;
      this.depth.minFilter = Texture.NEAREST;
      this.depth.magFilter = Texture.NEAREST;
      this.depth.wrapS = Texture.CLAMP_TO_EDGE;
      this.depth.wrapT = Texture.CLAMP_TO_EDGE;
      return this.depth;
    }
    destroy() {
      RenderTarget.renderer.destroy(this);
    }
    upload() {
      if (!this._gl) {
        RenderTarget.renderer.upload(this);
      }
      if (this._rtMultisample) {
        this._rtMultisample.upload();
      }
    }
  }
  class MultiRenderTarget extends RenderTarget {
    constructor(width, height, options = {}) {
      super(width, height, options);
      this.multi = true;
      this.attachments = [this.texture];
    }
  }
  class CubeRenderTarget extends RenderTarget {
    constructor(width, height, options = {}) {
      super(width, height, options);
      this.activeFace = 0;
      this.cube = true;
    }
  }
  Class(function Shader(_vertexShader, _fragmentShader, _params, _onBeforeBuild, _postfix) {
    if (typeof _vertexShader == "object") {
      _fragmentShader = _vertexShader.uniforms;
      _vertexShader = _vertexShader.name;
    }
    const _this = this;
    this.uniforms = Shader.createUniforms(this);
    this.side = Shader.FRONT_SIDE;
    this.blending = Shader.NORMAL_BLENDING;
    this.colorMask = Shader.COLOR_MASK_NONE;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 1;
    this.depthTest = true;
    this.depthWrite = true;
    this.ssReflections = _params?.ssReflections || false;
    this.depthFunc = Shader.DEPTH_FUNC_LESS;
    this.stencilTest = false;
    this.stencilMask = false;
    this.wireframe = false;
    this.transparent = false;
    this.visible = true;
    this.persists = false;
    this.precision = "high";
    this.customCompile = _params?.customCompile || "";
    this.onBeforePrecompilePromise = Promise.create();
    if (typeof _fragmentShader != "string") {
      _params = _fragmentShader;
      _fragmentShader = _vertexShader;
    }
    _params = _params || {};
    _this.vsParam = _vertexShader;
    _this.fsParam = _fragmentShader;
    _this.params = _params;
    _this.onBeforeBuild = _onBeforeBuild;
    _this.vsName = _vertexShader;
    _this.fsName = (_fragmentShader || _vertexShader) + (_postfix || "");
    if (_params.vsName) {
      _this.vsName = _params.vsName;
      delete _params.vsName;
    }
    if (_params.precision) {
      _this.precision = _params.precision;
    }
    if (_params.receiveShadow) {
      _this.receiveLight = true;
      if (World.RENDERER.shadows) {
        _this.precision = "high";
      }
    }
    let vs = _vertexShader;
    let fs = _fragmentShader;
    if (_params.uilFrom) {
      vs = _params.uilFrom;
      fs = _params.uilFrom;
      delete _params.uilFrom;
    }
    _this.UILPrefix = _params.UILPrefix || `${vs}/${fs}/${_params.unique ? _params.unique + "/" : ""}`;
    Shader.parseParams(_params, _this);
    if (!Shader.renderer.findCachedProgram(_this) && !Shader.hasAlreadyPreProcessed(_this)) {
      Shader.runPreProcess(_this);
    }
  }, _ => {
    function getLightingCode(_this) {
      if (!_this.receiveShadow && Shader.shouldReceiveShadow(_this)) {
        _this.receiveShadow = true;
      }
      if (!_this.receiveLight || _this.isShadow) {
        return "";
      }
      let numLights = Lighting.getLighting(_this).position.length / 4;
      if (numLights == 0) {
        return Lighting.getShadowUniforms(_this);
      } else {
        return [`#define NUM_LIGHTS ${numLights}`, "uniform lights {", `vec4 lightPos[${numLights}];`, `vec4 lightColor[${numLights}];`, `vec4 lightData[${numLights}];`, `vec4 lightData2[${numLights}];`, `vec4 lightData3[${numLights}];`, `vec4 lightProperties[${numLights}];`, "};"].join("\n") + Lighting.getShadowUniforms(_this);
      }
    }
    function setupssReflections(code, type, _this) {
      if (type == "vs") {
        if (!code.includes("vec3 pos = position;")) {
          throw `Shader ${_this.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
        }
        let vsDeferred = "\n            vPosDeferred = modelViewMatrix * vec4(pos, 1.);\n            vNormalDeferred = normalMatrix * normal;\n            vST = uv;\n            ";
        let main = code.split("vec3 pos = position;");
        main[1] = "\n" + vsDeferred + main[1];
        code = main.join("vec3 pos = position;");
      }
      return code;
    }
    Shader.FRONT_SIDE = "shader_front_side";
    Shader.BACK_SIDE = "shader_back_side";
    Shader.DOUBLE_SIDE = "shader_double_side";
    Shader.DOUBLE_SIDE_TRANSPARENCY = "shader_double_side_trasparency";
    Shader.ADDITIVE_BLENDING = "shader_additive_blending";
    Shader.NORMAL_BLENDING = "shader_normal_blending";
    Shader.PREMULTIPLIED_ALPHA_BLENDING = "shader_premultiplied_alpha_blending";
    Shader.ADDITIVE_COLOR_ALPHA = "shader_additive_color_alpha";
    Shader.MAX = "shader_max";
    Shader.MIN = "shader_min";
    Shader.CUSTOM_DEPTH = "shader_custom_depth";
    Shader.COLOR_MASK_RGB = "shader_colormask_rgb";
    Shader.COLOR_MASK_RGBA = "shader_colormask_rgba";
    Shader.COLOR_MASK_NONE = "shader_colormask_none";
    Shader.DEPTH_FUNC_NEVER = "shader_depth_func_never";
    Shader.DEPTH_FUNC_LESS = "shader_depth_func_less";
    Shader.DEPTH_FUNC_EQUAL = "shader_depth_func_equal";
    Shader.DEPTH_FUNC_LEQUAL = "shader_depth_func_lequal";
    Shader.DEPTH_FUNC_GREATER = "shader_depth_func_greater";
    Shader.DEPTH_FUNC_NOTEQUAL = "shader_depth_func_notequal";
    Shader.DEPTH_FUNC_GEQUAL = "shader_depth_func_gequal";
    Shader.DEPTH_FUNC_ALWAYS = "shader_depth_func_always";
    Shader.parseParams = function (_params, _this) {
      for (let key in _params) {
        if (key == "receiveShadow") {
          _this.receiveShadow = _params[key];
        } else if (key == "receiveLight") {
          _this.receiveLight = _params[key];
        } else if (_params[key] && _params[key].value !== undefined) {
          if (window.UILStorage && UILStorage.hasData()) {
            _this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _params[key].value) || _params[key];
            if (_params[key].ubo) {
              _this.uniforms[key].ubo = true;
            }
          } else {
            _this.uniforms[key] = _params[key];
          }
        } else {
          if (key == "unique") {
            continue;
          }
          _this[key] = _params[key];
        }
      }
    };
    Shader.runPreProcess = function (shader) {
      shader.vertexShader = Shader.process(Shaders.getShader(shader.vsParam + ".vs"), "vs", shader, shader.onBeforeBuild);
      shader.fragmentShader = Shader.process(Shaders.getShader(shader.fsParam + ".fs"), "fs", shader, shader.onBeforeBuild);
      if (shader.vertexShader.includes("//js") && !window[shader.vsName]) {
        let code = shader.vertexShader.split("\n");
        let adders = [];
        code.forEach(line => {
          if (line.includes("//js")) {
            let name = line.split(" ")[2].replace(";", "");
            let value = line.split("//js ")[1].replace(";", "");
            adders.push(obj => {
              obj[name] = {
                value: eval(value)
              };
            });
          } else if (line.includes("sampler2D")) {
            let name = line.split(" ")[2].replace(";", "");
            adders.push(obj => {
              obj[name] = {
                value: null
              };
            });
          }
        });
        window[shader.vsName] = function (_mesh, _shader) {
          let uniforms = {};
          adders.forEach(addTo => addTo(uniforms));
          _shader.addUniforms(uniforms);
        };
      }
    };
    Shader.process = function (code, type, _this, _onBeforeBuild) {
      const WEBGL2 = Renderer.type == Renderer.WEBGL2;
      if (!code) {
        throw "No shader found! " + _this.vsName + " | " + _this.fsName;
      }
      const externalOES = code.includes("samplerExternalOES") && window.AURA && Device.system.os == "android";
      const standardDeriv = !WEBGL2 && code.includes(["fwidth", "dFdx", "dFdy"]);
      const drawBuffers = !WEBGL2 && code.includes(["gl_FragData", "#drawbuffer"]) && window.World && World.NUKE.useDrawBuffers;
      let levelOfDetail = !WEBGL2 && code.includes(["textureGrad", "textureProjGrad", "texture2DGrad", "textureCubeGrad", "texture2DProjGrad"]);
      if (!levelOfDetail && !WEBGL2 && type === "fs") {
        levelOfDetail = code.includes(["textureLod", "texture2DLod", "textureCubeLod", "texture2DProjLod"]);
      }
      const layoutsDefined = code.includes("layout") || _this.ssReflections;
      let header;
      header = type == "vs" ? ["#version 300 es", externalOES ? "#extension GL_OES_EGL_image_external_essl3 : require" : "", levelOfDetail ? "#extension GL_EXT_shader_texture_lod : enable" : "", `precision ${_this.precision}p float;`, `precision ${_this.precision}p int;`, WEBGL2 ? `precision ${_this.precision}p sampler3D;` : "", WEBGL2 ? `precision ${_this.precision}p usampler2D;` : "", WEBGL2 ? `precision ${_this.precision}p isampler2D;` : "", "attribute vec2 uv;", "attribute vec3 position;", "attribute vec3 normal;", "uniform mat3 normalMatrix;", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform global {", "mat4 projectionMatrix;", "mat4 viewMatrix;", "vec3 cameraPosition;", "vec4 cameraQuaternion;", "vec2 resolution;", "float time;", "float timeScale;", "};"].join("\n") : ["#version 300 es", externalOES ? "#extension GL_OES_EGL_image_external_essl3 : require" : "", standardDeriv ? "#extension GL_OES_standard_derivatives : enable" : "", drawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", levelOfDetail ? "#extension GL_EXT_shader_texture_lod : enable" : "", `precision ${_this.precision}p float;`, `precision ${_this.precision}p int;`, WEBGL2 ? `precision ${_this.precision}p sampler3D;` : "", WEBGL2 ? `precision ${_this.precision}p usampler2D;` : "", WEBGL2 ? `precision ${_this.precision}p isampler2D;` : "", "uniform mat3 normalMatrix;", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform global {", "mat4 projectionMatrix;", "mat4 viewMatrix;", "vec3 cameraPosition;", "vec4 cameraQuaternion;", "vec2 resolution;", "float time;", "float timeScale;", "};", layoutsDefined ? "" : "out vec4 FragColor;"].join("\n");
      header += "\n__ACTIVE_THEORY_LIGHTS__\n\n";
      if (window.AURA) {
        header += "#define AURA\n";
      }
      if (_this.defines) {
        _this.defines.forEach(d => header += `#define ${d.toUpperCase()}\n`);
      }
      if (_onBeforeBuild) {
        code = _onBeforeBuild(code, type);
      }
      if (_this.ssReflections) {
        let GIVaryings = ["uniform float ssReflectivity;", "uniform float ssIORrefl;", "uniform float ssRougness;", "uniform float ssgiIntensity;", "uniform sampler2D tReflectivity;", "uniform sampler2D tRoughness;", "varying vec4 vPosDeferred;", "varying vec3 vNormalDeferred;", "varying vec2 vST;"].join("\n");
        header += GIVaryings;
      }
      let split = code.split("\n");
      for (let i = split.length - 1; i > -1; i--) {
        let line = split[i];
        if (line.includes("uniform sampler2D")) {
          let name = line.split("sampler2D ")[1].replace(";", "").trim();
          _this.uniforms[name] ||= {
            value: null
          };
        }
      }
      code = header + code;
      if (_this.ssReflections && type == "fs") {
        let buffersDeferred = "\n            float ssReflectionMap = texture(tReflectivity, vST).r;\n            float ssRougnessMap = texture(tRoughness, vST).r;\n            #drawbuffer PositionLayer gl_FragColor = vPosDeferred;\n            #drawbuffer NormalsLayer gl_FragColor = vec4(vNormalDeferred, 1.);\n            #drawbuffer ReflectivityLayer gl_FragColor = vec4(ssIORrefl, ssReflectivity * ssReflectionMap, ssRougness * ssRougnessMap, ssgiIntensity);\n            ";
        let main = code.split("main() {");
        main[1] = "\n" + buffersDeferred + main[1];
        code = main.join("main() {");
      }
      return code;
    };
    const prototype = Shader.prototype;
    prototype.copyUniformsTo = function (shader, linked, ignore) {
      for (let key in this.uniforms) {
        if (this.uniforms[key] !== undefined) {
          if (!ignore || !ignore.includes?.(key)) {
            shader.uniforms[key] = linked ? this.uniforms[key] : {
              type: this.uniforms[key].type,
              value: this.uniforms[key].value
            };
          }
        }
      }
    };
    prototype.replicateUniformsTo = function (shader) {
      shader.uniforms = this.uniforms;
      shader._uniformKeys = this._uniformKeys;
      shader._uniformValues = this._uniformValues;
    };
    prototype.addUniforms = function (uniforms) {
      if (uniforms.UILPrefix) {
        this.UILPrefix = uniforms.UILPrefix;
        delete uniforms.UILPrefix;
      }
      for (let key in uniforms) {
        if (!this.hotReloading || !this.uniforms[key]) {
          this.uniforms[key] = uniforms[key];
        }
      }
    };
    prototype.draw = function (mesh, geom) {
      if (this.receiveLight && !this.__lighting) {
        Lighting.getLighting(this);
      }
      Shader.renderer.draw(this, mesh, geom);
    };
    prototype.upload = function (mesh, geom) {
      if (!this.receiveShadow && Shader.shouldReceiveShadow(this)) {
        this.receiveShadow = true;
      }
      Shader.renderer.upload(this, mesh, geom);
      if (this.receiveShadow && !this.shadow) {
        Lighting.initShadowShader(this, mesh);
      }
    };
    prototype.destroy = function () {
      if (!this.persists) {
        Shader.renderer.destroy(this);
        if (this.shadow) {
          this.shadow.destroy();
        }
      }
      if (this.receiveLight) {
        Lighting.destroyShader(this);
      }
    };
    prototype.onBeforeCompile = function (code, type) {
      const WEBGL2 = Renderer.type == Renderer.WEBGL2;
      if ((code = code.trim())[code.length - 1] != "}") {
        code += "\n}";
      }
      let p = this.mesh;
      let scene = World.SCENE;
      while (p) {
        if (p instanceof Scene) {
          scene = p;
        }
        p = p._parent;
      }
      if (scene.nuke && scene.nuke.onBeforeShaderCompile) {
        scene.nuke.onBeforeShaderCompile(this.mesh);
      } else {
        this.onBeforePrecompilePromise.resolve();
      }
      if (this.receiveShadow) {
        this.receiveLight = true;
      }
      let varyings = [];
      let uniforms = [];
      if (this.ssReflections) {
        code = setupssReflections(code, type, this);
      }
      (code = code.split("\n")).forEach((line, index) => {
        if (type == "fs" && line.includes("#drawbuffer")) {
          if (line.includes("#drawbuffer Color")) {
            code[index] = line.replace("#drawbuffer Color", "");
          } else {
            code[index] = "";
          }
        }
        if (line.includes("varying")) {
          varyings.push(line.trim());
        }
        if (line.includes("uniform")) {
          uniforms.push(line.trim());
        }
      });
      code = code.join("\n");
      const process = function (array) {
        let replace;
        let counts = [];
        array.forEach(value => {
          let count = 0;
          array.forEach(v2 => {
            if (value == v2) {
              count++;
            }
          });
          if (count > 1) {
            replace ||= [];
            if (!replace.includes(value)) {
              replace.push(value);
              counts.push(count);
            }
          }
        });
        if (replace) {
          replace.forEach((value, i) => {
            let count = counts[i];
            for (let j = 0; j < count - 1; j++) {
              let index = code.lastIndexOf(value);
              code = code.substring(0, index) + code.substring(index + value.length);
            }
          });
        }
      };
      process(varyings);
      process(uniforms);
      if (type == "fs") {
        if (WEBGL2) {
          if (code.includes("gl_FragColor")) {
            code = code.replace(/gl_FragColor/g, "FragColor");
          }
        } else if (code.includes("#applyShadow")) {
          code = code.replace("#applyShadow", "");
        }
      }
      code = code.replace("__ACTIVE_THEORY_LIGHTS__", getLightingCode(this));
      if (type == "fs" && code.includes("SHADOW_MAPS")) {
        code = require("GLSLOptimizer")(code.replaceAll("SHADOW_COUNT", Lighting.getShadowCount(this)));
      }
      if (this.preCompile) {
        code = this.preCompile(code, type);
      }
      let converter = require("ShaderCode");
      return code = WEBGL2 ? converter.convertWebGL2(code, type) : converter.convertWebGL1(code, type);
    };
    prototype.set = function (key, value, ref) {
      let _this = ref || this;
      if (_this.uniforms[key]) {
        if (value !== undefined) {
          TweenManager.clearTween(_this.uniforms[key]);
          _this.uniforms[key].value = value;
          if (_this.ubo) {
            _this.ubo.needsUpdate = true;
          }
        }
        return _this.uniforms[key].value;
      } else {
        return console.warn(`No key ${key} found on shader`, _this);
      }
    };
    prototype.get = function (key, ref) {
      let _this = ref || this;
      return _this.uniforms[key] && _this.uniforms[key].value;
    };
    prototype.tween = function (key, value, time, ease, delay, callback, update, scaledTime) {
      if (typeof value == "number") {
        return tween(this.uniforms[key], {
          value: value
        }, time, ease, delay, callback, update, null, scaledTime);
      } else {
        return tween(this.uniforms[key].value, value, time, ease, delay, callback, update, null, scaledTime);
      }
    };
    prototype.clone = function (noShadows, postfix) {
      const _this = this;
      if (noShadows) {
        _this.params.receiveShadow = false;
      }
      let shader = new Shader(_this.vsParam, _this.fsParam, _this.params, null, postfix);
      for (let key in _this) {
        if (!key.includes(["vsName", "fsName", "uniforms", "_uniform", "_gl"]) && typeof _this[key] != "function") {
          shader[key] = _this[key];
        }
      }
      for (let key in _this.uniforms) {
        shader.uniforms[key] = {
          type: _this.uniforms[key].type,
          value: _this.uniforms[key].value
        };
      }
      return shader;
    };
    prototype.resetProgram = function () {
      this.destroy();
      this.vertexShader = this.restoreVS || Shader.process(Shaders.getShader(this.vsName + ".vs"), "vs", this, this.onBeforeBuild);
      this.fragmentShader = this.restoreFS || Shader.process(Shaders.getShader(this.fsName + ".fs"), "fs", this, this.onBeforeBuild);
    };
    var _shaderShadowMap = {};
    var _emptyShadowMap;
    Object.defineProperty(prototype, "receiveShadow", {
      set: function (v) {
        _shaderShadowMap[this.vsName + "_" + this.fsName] = v;
        this._receiveShadow = v;
        if (v && !this.uniforms.shadowMap) {
          _emptyShadowMap ||= [Utils3D.getEmptyTexture()];
          this.uniforms.shadowMap = {
            value: _emptyShadowMap
          };
        }
      },
      get: function () {
        return this._receiveShadow;
      }
    });
    let shaders = {};
    Shader.hasAlreadyPreProcessed = function (shader) {
      let key = shader.vsName + "_" + shader.vsName + "_" + shader.customCompile;
      return shaders[key];
    };
    Shader.registerPreProcess = function (shader) {
      let key = shader.vsName + "_" + shader.vsName + "_" + shader.customCompile;
      shaders[key] = true;
    };
    Shader.shouldReceiveShadow = function (shader) {
      return _shaderShadowMap[shader.vsName + "_" + shader.fsName];
    };
  });
  Shader.createUniforms = function (shader) {
    let uniforms = {};
    let handler = {
      set(target, property, value) {
        target[property] = value;
        shader._uniformKeys.length = 0;
        shader._uniformValues.length = 0;
        for (let key in uniforms) {
          shader._uniformKeys.push(key);
          shader._uniformValues.push(uniforms[key]);
        }
        return true;
      }
    };
    shader._uniformValues = [];
    shader._uniformKeys = [];
    return new Proxy(uniforms, handler);
  };
  class Texture {
    constructor(img) {
      this.magFilter = Texture.LINEAR;
      this.minFilter = Texture.LINEAR_MIPMAP;
      this.format = Texture.RGBAFormat;
      this.wrapS = this.wrapT = Texture.CLAMP_TO_EDGE;
      this._image = img;
      this.needsUpdate = true;
      this.generateMipmaps = true;
      this.anisotropy = 1;
      this.type = Texture.UNSIGNED_BYTE;
      this.isTexture = true;
      if (img && img.onCreateTexture) {
        img.onCreateTexture(this);
      }
    }
    set image(img) {
      this._image = img;
      if (img && img.onCreateTexture) {
        img.onCreateTexture(this);
      }
    }
    get image() {
      return this._image;
    }
    upload() {
      if (!this._gl) {
        Texture.renderer.upload(this);
      }
    }
    destroy() {
      Texture.renderer.destroy(this);
      this._image = null;
    }
    clone() {
      let texture = new Texture(this.img);
      texture.format = this.format;
      texture.type = this.type;
      texture.anisotropy = this.anisotropy;
      texture.wrapS = this.wrapS;
      texture.wrapT = this.wrapT;
      texture.generateMipmaps = this.generateMipmaps;
      texture.minFilter = this.minFilter;
      texture.magFilter = this.magFilter;
      return texture;
    }
  }
  class DataTexture extends Texture {
    constructor(data, width, height, format, type, filter = null) {
      super();
      if (format) {
        this.format = format;
      }
      this.width = width;
      this.height = height;
      this.data = data;
      this.minFilter = this.magFilter = filter || Texture.NEAREST;
      this.generateMipmaps = false;
      this.type = type || Texture.FLOAT;
      this.isDataTexture = true;
      this.destroyDataAfterUpload = false;
    }
    uploadAsync() {
      return Texture.renderer.uploadAsync(this);
    }
  }
  class Texture3D extends Texture {
    constructor(image, width, height, depth, format, type, filter = null) {
      super();
      this.format = format || Texture.RGBAFormat;
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.image = image;
      this.minFilter = this.magFilter = filter || Texture.LINEAR;
      this.wrapS = this.wrapT = this.wrapR = Texture.CLAMP_TO_EDGE;
      this.generateMipmaps = false;
      this.type = type || Texture.FLOAT;
      this.isTexture3D = true;
    }
  }
  Texture.NEAREST = "texture_nearest";
  Texture.CLAMP_TO_EDGE = "texture_clamp";
  Texture.REPEAT = "texture_repeat";
  Texture.MIRROR_REPEAT = "texture_mirror_repeat";
  Texture.LINEAR = "texture_linear";
  Texture.LINEAR_MIPMAP = "texture_linear_mip";
  Texture.LINEAR_MIPMAP_NEAREST = "texture_linear_mip_nearest";
  Texture.NEAREST_MIPMAP = "texture_nearest_mip";
  Texture.RFormat = "texture_rFormat";
  Texture.RGFormat = "texture_rgFormat";
  Texture.RGBFormat = "texture_rgbFormat";
  Texture.RGBAFormat = "texture_rgbaFormat";
  Texture.UNSIGNED_BYTE = "texture_unsigned_byte";
  Texture.DEPTH = "texture_depth";
  Texture.FLOAT = "texture_float";
  Texture.HALF_FLOAT = "texture_half_float";
  Texture.UNSIGNED_INTEGER = "texture_unsigned_integer";
  Texture.INTEGER = "texture_integer";
  Module(function GLSLOptimizer() {
    this.exports = function (code) {
      return function unrollLoops(string) {
        return string.replace(/#pragma unroll_loop[\s]+?for \(int i \= (\d+)\; i < (\d+)\; i\+\+\) \{([\s\S]+?)(?=\})\}/g, function replace(match, start, end, snippet) {
          let unroll = "";
          for (let i = parseInt(start); i < parseInt(end); i++) {
            unroll += snippet.replace(/\[i\]/g, "[" + i + "]");
          }
          return unroll;
        });
      }(code);
    };
  });
  Module(function GLTypes() {
    function getFormat(texture) {
      let _gl = Renderer.context;
      let integer = texture.type === Texture.UNSIGNED_INTEGER || texture.type === Texture.INTEGER;
      switch (texture.format) {
        case Texture.RGBAFormat:
          if (integer) {
            return _gl.RGBA_INTEGER;
          } else {
            return _gl.RGBA;
          }
        case Texture.RGBFormat:
          if (integer) {
            return _gl.RGB_INTEGER;
          } else {
            return _gl.RGB;
          }
        case Texture.RGFormat:
          if (integer) {
            return _gl.RG_INTEGER;
          } else {
            return _gl.RG;
          }
        case Texture.RFormat:
          if (integer) {
            return _gl.RED_INTEGER;
          } else {
            return _gl.RED;
          }
      }
    }
    function getInternalFormat(texture) {
      let _gl = Renderer.context;
      if (Renderer.type !== Renderer.WEBGL2) {
        if (texture.format === Texture.RGBAFormat) {
          return _gl.RGBA;
        } else {
          return _gl.RGB;
        }
      }
      switch (texture.format) {
        case Texture.RGBAFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RGBA32F;
            case Texture.HALF_FLOAT:
              return _gl.RGBA16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RGBA32UI;
            case Texture.INTEGER:
              return _gl.RGBA32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RGBA8;
          }
          break;
        case Texture.RGBFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RGB32F;
            case Texture.HALF_FLOAT:
              return _gl.RGB16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RGB32UI;
            case Texture.INTEGER:
              return _gl.RGB32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RGB8;
          }
          break;
        case Texture.RGFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RG32F;
            case Texture.HALF_FLOAT:
              return _gl.RG16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RG32UI;
            case Texture.INTEGER:
              return _gl.RG32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RG8;
          }
          break;
        case Texture.RFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.R32F;
            case Texture.HALF_FLOAT:
              return _gl.R16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.R32UI;
            case Texture.INTEGER:
              return _gl.R32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.R8;
          }
      }
    }
    function getType(texture) {
      let _gl = Renderer.context;
      switch (texture.type) {
        case Texture.FLOAT:
          return _gl.FLOAT;
        case Texture.HALF_FLOAT:
          if (Renderer.type == Renderer.WEBGL2) {
            return _gl.HALF_FLOAT;
          } else {
            return Renderer.extensions.halfFloat.HALF_FLOAT_OES;
          }
        case Texture.UNSIGNED_INTEGER:
          return _gl.UNSIGNED_INT;
        case Texture.INTEGER:
          return _gl.INT;
        default:
          return _gl.UNSIGNED_BYTE;
      }
    }
    this.exports = {
      getFormat: getFormat,
      getInternalFormat: getInternalFormat,
      getProperty: function getProperty(property) {
        let _gl = Renderer.context;
        switch (property) {
          case Texture.NEAREST:
            return _gl.NEAREST;
          case Texture.LINEAR:
            return _gl.LINEAR;
          case Texture.LINEAR_MIPMAP:
            return _gl.LINEAR_MIPMAP_LINEAR;
          case Texture.NEAREST_MIPMAP:
            return _gl.NEAREST_MIPMAP_LINEAR;
          case Texture.LINEAR_MIPMAP_NEAREST:
            return _gl.LINEAR_MIPMAP_NEAREST;
          case Texture.CLAMP_TO_EDGE:
            return _gl.CLAMP_TO_EDGE;
          case Texture.REPEAT:
            return _gl.REPEAT;
          case Texture.MIRROR_REPEAT:
            return _gl.MIRRORED_REPEAT;
        }
      },
      getType: getType,
      getFloatParams: function getFloatParams(texture) {
        return {
          internalformat: getInternalFormat(texture),
          format: getFormat(texture),
          type: getType(texture)
        };
      }
    };
  });
  Module(function ShaderCode() {
    let textureExpression = /texture(2D|Cube)?(\w+)?\s*\(/g;
    function removeUBO(code, name) {
      let uniforms = code.split(`uniform ${name} {`)[1];
      uniforms = uniforms.split("};")[0];
      uniforms = uniforms.split("\n");
      uniforms.forEach(u => {
        if ((u = u.trim()).length) {
          code = code.replace(u, "uniform " + u);
        }
      });
      let split = code.split(`uniform ${name} {`);
      split[1] = split[1].replace("};", "");
      return code = (code = split.join("")).replace(`uniform ${name} {`, "");
    }
    this.exports = {
      convertWebGL1: function convertWebGL1(code, type) {
        if ((code = (code = code.replace("#version 300 es", "")).replace("out vec4 FragColor;", "")).includes("samplerExternalOES")) {
          code = code.replace("samplerExternalOES", "sampler2D");
        }
        if ((code = code.replace(textureExpression, function (match, samplerType, suffix = "", offset, origCode) {
          if (!samplerType) {
            let name = origCode.substring(offset + match.length).split(",", 1)[0]?.trim();
            if (name) {
              samplerType = new RegExp(`sampler(\\w+)\\s+${name}`).exec(origCode)?.[1];
            }
            samplerType ||= "2D";
          }
          if (suffix.endsWith("EXT")) {
            suffix = suffix.slice(0, -3);
          }
          if (type === "vs" && ["Lod", "ProjLod"].includes(suffix)) {
            return `texture${samplerType}${suffix}(`;
          }
          if (["Lod", "Grad", "ProjLod", "ProjGrad"].includes(suffix)) {
            if (Renderer.extensions.lod) {
              return `texture${samplerType}${suffix}EXT(`;
            }
            if (suffix.endsWith("Lod")) {
              suffix = suffix.slice(0, -3);
            }
          }
          return `texture${samplerType}${suffix}(`;
        })).includes("uniform global {")) {
          code = removeUBO(code, "global");
        }
        if (code.includes("uniform ubo {")) {
          code = removeUBO(code, "ubo");
        }
        if (code.includes("uniform lights {")) {
          code = removeUBO(code, "lights");
        }
        return code;
      },
      convertWebGL2: function convertWebGL2(code, type) {
        if (!!(code = (code = type == "vs" ? (code = code.replace(/attribute/g, "in")).replace(/varying/g, "out") : code.replace(/varying/g, "in")).replace(textureExpression, function (match, samplerType, suffix = "") {
          if (suffix.endsWith("EXT")) {
            suffix = suffix.slice(0, -3);
          }
          return `texture${suffix}(`;
        })).includes("samplerExternalOES") && (Device.system.os != "android" || !window.AURA)) {
          code = code.replace("samplerExternalOES", "sampler2D");
        }
        if (Renderer.UBO) {
          if (code.includes("uniform global {")) {
            code = code.replace("uniform global", "layout(std140) uniform global");
          }
          if (code.includes("uniform ubo {")) {
            code = code.replace("uniform ubo", "layout(std140) uniform ubo");
          }
          if (Lighting.UBO) {
            if (code.includes("uniform lights {")) {
              code = code.replace("uniform lights", "layout(std140) uniform lights");
            }
          } else if (code.includes("uniform lights {")) {
            code = removeUBO(code, "lights");
          }
        } else {
          if (code.includes("uniform global {")) {
            code = removeUBO(code, "global");
          }
          if (code.includes("uniform ubo {")) {
            code = removeUBO(code, "ubo");
          }
          if (code.includes("uniform lights {")) {
            code = removeUBO(code, "lights");
          }
        }
        return code;
      }
    };
  });
  class UBO {
    constructor(location, gl = Renderer.context) {
      this.gl = gl;
      this.arrays = [];
      for (let i = 0; i < 30; i++) {
        this.arrays.push([]);
      }
      this.arrayIndex = 0;
      this.objects = [];
      this.location = location;
      this.data = null;
      this.lastUpdate = 0;
    }
    _getSize(uniform) {
      let obj = uniform.value;
      if (Array.isArray(obj)) {
        if (uniform.components) {
          return obj.length / uniform.components * 16;
        } else {
          return obj.length * 16;
        }
      } else if (obj instanceof Vector2) {
        return 8;
      } else if (obj instanceof Vector3 || obj instanceof Vector4 || obj instanceof Color) {
        return 16;
      } else if (obj instanceof Matrix4) {
        return 64;
      } else if (obj instanceof Matrix3) {
        return 48;
      } else if (obj instanceof Quaternion) {
        return 16;
      } else {
        return 4;
      }
    }
    _getValues(uniform) {
      let obj = uniform.value;
      if (Array.isArray(obj)) {
        return obj;
      } else if (obj instanceof Vector2) {
        return this._array(obj.x, obj.y);
      } else if (obj instanceof Vector3) {
        return this._array(obj.x, obj.y, obj.z);
      } else if (obj instanceof Matrix4 || obj instanceof Matrix3) {
        return obj.elements;
      } else if (obj instanceof Color) {
        return this._array(obj.r, obj.g, obj.b);
      } else if (obj instanceof Quaternion) {
        return this._array(obj.x, obj.y, obj.z, obj.w);
      } else {
        return this._array(obj);
      }
    }
    _array() {
      if (this.arrayIndex++ >= this.arrays.length - 1) {
        this.arrayIndex = 0;
      }
      let array = this.arrays[this.arrayIndex];
      array.length = 0;
      array.push.apply(array, arguments);
      return array;
    }
    clear() {
      for (let i = 0; i < this.arrays.length; i++) {
        this.arrays[i].length = 0;
      }
    }
    calculate() {
      let len = this.objects.length;
      let chunk = 16;
      let tsize = 0;
      let offset = 0;
      let size = 0;
      for (let i = 0; i < len; i++) {
        let obj = this.objects[i];
        size = this._getSize(obj);
        tsize = chunk - size;
        if (tsize < 0 && chunk < 16) {
          offset += chunk;
          if (i > 0) {
            this.objects[i - 1].chunkLen += chunk;
          }
          chunk = 16;
        } else if (!(tsize < 0) || chunk != 16) {
          if (tsize == 0) {
            chunk = 16;
          } else {
            chunk -= size;
          }
        }
        obj.offset = offset / 4;
        obj.chunkLen = size / 4;
        obj.dataLen = size / 4;
        offset += size;
      }
      if (offset % 16 != 0) {
        this.objects[this.objects.length - 1].chunkLen += chunk / 4;
        offset += chunk;
      }
      return offset / 4;
    }
    compileData() {
      let i;
      let array = this._array();
      let len = this.calculate();
      for (i = 0; i < len; i++) {
        array[i] = 0;
      }
      for (i = 0; i < this.objects.length; i++) {
        let obj = this.objects[i];
        let values = this._getValues(obj);
        for (let j = 0; j < values.length; j++) {
          array[obj.offset + j] = values[j];
        }
      }
      return array;
    }
    upload() {
      if (this.data) {
        return;
      }
      let gl = Renderer.context;
      let array = this.compileData();
      if (array.length) {
        this.data = new Float32Array(array);
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
        gl.bufferData(gl.UNIFORM_BUFFER, this.data, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer);
      }
    }
    bind(program, name) {
      if (!this.data) {
        this.upload();
      }
      if (this.needsUpdate) {
        this.update();
      }
      let location;
      let gl = Renderer.context;
      location = program == this.lastProgram && name == this.lastName && this.lastLocation !== undefined ? this.lastLocation : gl.getUniformBlockIndex(program, name);
      if (!(location > 99999) && location != -1) {
        gl.uniformBlockBinding(program, location, this.location);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer);
        this.lastProgram = program;
        this.lastName = name;
        this.lastLocation = location;
      }
    }
    update() {
      if (!this.data) {
        this.upload();
      }
      if (!this.data) {
        return;
      }
      let gl = Renderer.context;
      let array = this.compileData();
      if (array.length != this.data.length) {
        this.data = new Float32Array(array);
        this.upload();
      }
      this.data.set(array);
      gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
      gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);
      this.needsUpdate = false;
    }
    unbind() {}
    push() {
      if (this.data) {
        throw "Can't modify UBO after initial upload!";
      }
      for (let i = 0; i < arguments.length; i++) {
        this.objects.push(arguments[i]);
      }
    }
    destroy() {
      this.gl.deleteBuffer(this.buffer);
    }
  }
  class VAO {
    constructor(gl) {
      this.gl = gl;
      this.WEBGL2 = Renderer.type == Renderer.WEBGL2;
      if (this.WEBGL2) {
        this.vao = gl.createVertexArray();
      } else {
        this.vao = Renderer.extensions.VAO.createVertexArrayOES();
      }
    }
    bind() {
      const gl = this.gl;
      if (this.WEBGL2) {
        gl.bindVertexArray(this.vao);
      } else {
        Renderer.extensions.VAO.bindVertexArrayOES(this.vao);
      }
    }
    unbind() {
      const gl = this.gl;
      if (this.WEBGL2) {
        gl.bindVertexArray(null);
      } else {
        Renderer.extensions.VAO.bindVertexArrayOES(null);
      }
    }
    destroy() {
      const gl = this.gl;
      if (this.WEBGL2) {
        gl.deleteVertexArray(this.vao);
      } else {
        Renderer.extensions.VAO.deleteVertexArrayOES(this.vao);
      }
      this.vao = null;
    }
  }
  class BoxGeometry extends Geometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      let indices = [];
      let vertices = [];
      let normals = [];
      let uvs = [];
      let numberOfVertices = 0;
      function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
        let ix;
        let iy;
        let segmentWidth = width / gridX;
        let segmentHeight = height / gridY;
        let widthHalf = width / 2;
        let heightHalf = height / 2;
        let depthHalf = depth / 2;
        let gridX1 = gridX + 1;
        let gridY1 = gridY + 1;
        let vertexCounter = 0;
        let vector = new Vector3();
        for (iy = 0; iy < gridY1; iy++) {
          let y = iy * segmentHeight - heightHalf;
          for (ix = 0; ix < gridX1; ix++) {
            let x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            let a = numberOfVertices + ix + gridX1 * iy;
            let b = numberOfVertices + ix + gridX1 * (iy + 1);
            let c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            let d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
        numberOfVertices += vertexCounter;
      }
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class CircleGeometry extends Geometry {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      var i;
      var s;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var vertex = new Vector3();
      var uv = new Vector2();
      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);
      s = 0;
      i = 3;
      for (; s <= segments; s++, i += 3) {
        var segment = thetaStart + s / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertices[i] / radius + 1) / 2;
        uv.y = (vertices[i + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      for (i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class CylinderGeometry extends Geometry {
    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2, planarMapping = false) {
      super();
      radialSegments = Math.floor(radialSegments);
      heightSegments = Math.floor(heightSegments);
      let indices = [];
      let vertices = [];
      let normals = [];
      let uvs = [];
      let index = 0;
      let indexArray = [];
      let halfHeight = height / 2;
      function generateCap(top) {
        let x;
        let centerIndexStart;
        let centerIndexEnd;
        let uv = new Vector2();
        let vertex = new Vector3();
        let radius = top === true ? radiusTop : radiusBottom;
        let sign = top === true ? 1 : -1;
        let signV = planarMapping ? 1 : sign;
        centerIndexStart = index;
        x = 1;
        for (; x <= radialSegments; x++) {
          vertices.push(0, halfHeight * sign, 0);
          normals.push(0, sign, 0);
          uvs.push(0.5, 0.5);
          index++;
        }
        centerIndexEnd = index;
        x = 0;
        for (; x <= radialSegments; x++) {
          let theta = x / radialSegments * thetaLength + thetaStart;
          let cosTheta = Math.cos(theta);
          let sinTheta = Math.sin(theta);
          vertex.x = radius * sinTheta;
          vertex.y = halfHeight * sign;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, sign, 0);
          uv.x = cosTheta * 0.5 + 0.5;
          uv.y = sinTheta * 0.5 * signV + 0.5;
          uvs.push(uv.x, uv.y);
          index++;
        }
        for (x = 0; x < radialSegments; x++) {
          let c = centerIndexStart + x;
          let i = centerIndexEnd + x;
          if (top === true) {
            indices.push(i, i + 1, c);
          } else {
            indices.push(i + 1, i, c);
          }
        }
      }
      (function generateTorso() {
        let x;
        let y;
        let uv = new Vector2();
        let normal = new Vector3();
        let vertex = new Vector3();
        let slope = (radiusBottom - radiusTop) / height;
        for (y = 0; y <= heightSegments; y++) {
          let indexRow = [];
          let v = y / heightSegments;
          let radius = v * (radiusBottom - radiusTop) + radiusTop;
          for (x = 0; x <= radialSegments; x++) {
            let u = x / radialSegments;
            let theta = u * thetaLength + thetaStart;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            vertex.x = radius * sinTheta;
            vertex.y = -v * height + halfHeight;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            normal.set(sinTheta, slope, cosTheta).normalize();
            normals.push(normal.x, normal.y, normal.z);
            if (planarMapping) {
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 + 0.5;
              uvs.push(uv.x, uv.y);
            } else {
              uvs.push(u, 1 - v);
            }
            indexRow.push(index++);
          }
          indexArray.push(indexRow);
        }
        for (x = 0; x < radialSegments; x++) {
          for (y = 0; y < heightSegments; y++) {
            let a = indexArray[y][x];
            let b = indexArray[y + 1][x];
            let c = indexArray[y + 1][x + 1];
            let d = indexArray[y][x + 1];
            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
      })();
      if (openEnded === false) {
        if (radiusTop > 0) {
          generateCap(true);
        }
        if (radiusBottom > 0) {
          generateCap(false);
        }
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class ConeGeometry extends CylinderGeometry {
    constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    }
  }
  class PlaneGeometry extends Geometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      let ix;
      let iy;
      let width_half = width / 2;
      let height_half = height / 2;
      let gridX = Math.floor(widthSegments) || 1;
      let gridY = Math.floor(heightSegments) || 1;
      let gridX1 = gridX + 1;
      let gridY1 = gridY + 1;
      let segment_width = width / gridX;
      let segment_height = height / gridY;
      let indices = [];
      let vertices = [];
      let normals = [];
      let uvs = [];
      for (iy = 0; iy < gridY1; iy++) {
        let y = iy * segment_height - height_half;
        for (ix = 0; ix < gridX1; ix++) {
          let x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
          let a = ix + gridX1 * iy;
          let b = ix + gridX1 * (iy + 1);
          let c = ix + 1 + gridX1 * (iy + 1);
          let d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class PolyhedronGeometry extends Geometry {
    constructor(vertices, indices = [], radius = 1, detail = 0) {
      super();
      let vertexBuffer = [];
      let uvBuffer = [];
      function subdivideFace(a, b, c, detail) {
        var i;
        var j;
        var cols = Math.pow(2, detail);
        var v = [];
        for (i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = a.clone().lerp(c, i / cols);
          var bj = b.clone().lerp(c, i / cols);
          var rows = cols - i;
          for (j = 0; j <= rows; j++) {
            v[i][j] = j === 0 && i === cols ? aj : aj.clone().lerp(bj, j / rows);
          }
        }
        for (i = 0; i < cols; i++) {
          for (j = 0; j < (cols - i) * 2 - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 == 0) {
              pushVertex(v[i][k + 1]);
              pushVertex(v[i + 1][k]);
              pushVertex(v[i][k]);
            } else {
              pushVertex(v[i][k + 1]);
              pushVertex(v[i + 1][k + 1]);
              pushVertex(v[i + 1][k]);
            }
          }
        }
      }
      function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
      }
      function getVertexByIndex(index, vertex) {
        let stride = index * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
      }
      function correctUV(uv, stride, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1) {
          uvBuffer[stride] = uv.x - 1;
        }
        if (vector.x === 0 && vector.z === 0) {
          uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      (function subdivide(detail) {
        let a = new Vector3();
        let b = new Vector3();
        let c = new Vector3();
        for (let i = 0; i < indices.length; i += 3) {
          getVertexByIndex(indices[i + 0], a);
          getVertexByIndex(indices[i + 1], b);
          getVertexByIndex(indices[i + 2], c);
          subdivideFace(a, b, c, detail);
        }
      })(detail);
      (function appplyRadius(radius) {
        var vertex = new Vector3();
        for (var i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          vertex.normalize().multiplyScalar(radius);
          vertexBuffer[i + 0] = vertex.x;
          vertexBuffer[i + 1] = vertex.y;
          vertexBuffer[i + 2] = vertex.z;
        }
      })(radius);
      (function generateUVs() {
        let vertex = new Vector3();
        for (let i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          let u = azimuth(vertex) / 2 / Math.PI + 0.5;
          vector = vertex;
          let v = Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z)) / Math.PI + 0.5;
          uvBuffer.push(u, 1 - v);
        }
        var vector;
        (function correctUVs() {
          let a = new Vector3();
          let b = new Vector3();
          let c = new Vector3();
          let centroid = new Vector3();
          let uvA = new Vector2();
          let uvB = new Vector2();
          let uvC = new Vector2();
          for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
            a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
            b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
            c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            centroid.copy(a).add(b).add(c).divideScalar(3);
            let azi = azimuth(centroid);
            correctUV(uvA, j + 0, a, azi);
            correctUV(uvB, j + 2, b, azi);
            correctUV(uvC, j + 4, c, azi);
          }
        })();
        (function correctSeam() {
          for (let i = 0; i < uvBuffer.length; i += 6) {
            let x0 = uvBuffer[i + 0];
            let x1 = uvBuffer[i + 2];
            let x2 = uvBuffer[i + 4];
            let max = Math.max(x0, x1, x2);
            let min = Math.min(x0, x1, x2);
            if (max > 0.9 && min < 0.1) {
              if (x0 < 0.2) {
                uvBuffer[i + 0] += 1;
              }
              if (x1 < 0.2) {
                uvBuffer[i + 2] += 1;
              }
              if (x2 < 0.2) {
                uvBuffer[i + 4] += 1;
              }
            }
          }
        })();
      })();
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertexBuffer), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(vertexBuffer.slice()), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvBuffer), 2));
      if (detail === 0) {
        this.computeVertexNormals();
      } else {
        this.normalizeNormals();
      }
    }
  }
  class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius, detail) {
      let t = (1 + Math.sqrt(5)) / 2;
      super([-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], radius, detail);
    }
  }
  class OctahedronGeometry extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0) {
      super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], radius, detail);
      this.type = "OctahedronGeometry";
      this.parameters = {
        radius: radius,
        detail: detail
      };
    }
  }
  OctahedronGeometry.fromJSON = function (data) {
    return new OctahedronGeometry(data.radius, data.detail);
  };
  class RingGeometry extends Geometry {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      var segment;
      var j;
      var i;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var radius = innerRadius;
      var radiusStep = (outerRadius - innerRadius) / phiSegments;
      var vertex = new Vector3();
      var uv = new Vector2();
      for (j = 0; j <= phiSegments; j++) {
        for (i = 0; i <= thetaSegments; i++) {
          segment = thetaStart + i / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, 0, 1);
          uv.x = (vertex.x / outerRadius + 1) / 2;
          uv.y = (vertex.y / outerRadius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        radius += radiusStep;
      }
      for (j = 0; j < phiSegments; j++) {
        var thetaSegmentLevel = j * (thetaSegments + 1);
        for (i = 0; i < thetaSegments; i++) {
          var a = segment = i + thetaSegmentLevel;
          var b = segment + thetaSegments + 1;
          var c = segment + thetaSegments + 2;
          var d = segment + 1;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class SphereGeometry extends Geometry {
    constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
      super();
      widthSegments = Math.max(3, Math.floor(widthSegments));
      heightSegments = Math.max(2, Math.floor(heightSegments));
      let ix;
      let iy;
      let thetaEnd = thetaStart + thetaLength;
      let index = 0;
      let grid = [];
      let vertex = new Vector3();
      let normal = new Vector3();
      let indices = [];
      let vertices = [];
      let normals = [];
      let uvs = [];
      for (iy = 0; iy <= heightSegments; iy++) {
        let verticesRow = [];
        let v = iy / heightSegments;
        for (ix = 0; ix <= widthSegments; ix++) {
          let u = ix / widthSegments;
          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(vertex.x, vertex.y, vertex.z).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          verticesRow.push(index++);
        }
        grid.push(verticesRow);
      }
      for (iy = 0; iy < heightSegments; iy++) {
        for (ix = 0; ix < widthSegments; ix++) {
          let a = grid[iy][ix + 1];
          let b = grid[iy][ix];
          let c = grid[iy + 1][ix];
          let d = grid[iy + 1][ix + 1];
          if (iy !== 0 || thetaStart > 0) {
            indices.push(a, b, d);
          }
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {
            indices.push(b, c, d);
          }
        }
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  class TorusKnotGeometry extends Geometry {
    constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
      super();
      let i;
      let j;
      let indices = [];
      let vertices = [];
      let normals = [];
      let uvs = [];
      let vertex = new Vector3();
      let normal = new Vector3();
      let P1 = new Vector3();
      let P2 = new Vector3();
      let B = new Vector3();
      let T = new Vector3();
      let N = new Vector3();
      for (i = 0; i <= tubularSegments; ++i) {
        let u = i / tubularSegments * p * Math.PI * 2;
        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        B.normalize();
        N.normalize();
        j = 0;
        for (; j <= radialSegments; ++j) {
          let v = j / radialSegments * Math.PI * 2;
          let cx = -tube * Math.cos(v);
          let cy = tube * Math.sin(v);
          vertex.x = P1.x + (cx * N.x + cy * B.x);
          vertex.y = P1.y + (cx * N.y + cy * B.y);
          vertex.z = P1.z + (cx * N.z + cy * B.z);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.subVectors(vertex, P1).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(i / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }
      for (j = 1; j <= tubularSegments; j++) {
        for (i = 1; i <= radialSegments; i++) {
          let a = (radialSegments + 1) * (j - 1) + (i - 1);
          let b = (radialSegments + 1) * j + (i - 1);
          let c = (radialSegments + 1) * j + i;
          let d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      function calculatePositionOnCurve(u, p, q, radius, position) {
        let cu = Math.cos(u);
        let su = Math.sin(u);
        let quOverP = q / p * u;
        let cs = Math.cos(quOverP);
        position.x = radius * (2 + cs) * 0.5 * cu;
        position.y = radius * (2 + cs) * su * 0.5;
        position.z = radius * Math.sin(quOverP) * 0.5;
      }
      this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
      this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices), 3));
      this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals), 3));
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
    }
  }
  Class(function Interaction3D(_camera) {
    Inherit(this, Component);
    const _this = this;
    let _hover;
    let _click;
    var _lastOnUpdate;
    var _maximumVRHitDistance;
    var _v3 = new Vector3();
    var _plane = new Plane();
    var _input = {};
    var _cacheHits = [];
    var _enabled = true;
    _this.ID = Utils.timestamp();
    _camera = _camera || World.CAMERA;
    var _ray = _this.initClass(Raycaster, _camera);
    var _meshes = [];
    var _test = [];
    var _event = {};
    const PROHIBITED_ELEMENTS = ["hit", "prevent_interaction3d"];
    function checkIfProhibited(element) {
      let el = element;
      while (el) {
        if (el.classList) {
          for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++) {
            if (el.classList.contains(PROHIBITED_ELEMENTS[i])) {
              return true;
            }
          }
        }
        el = el.parentNode;
      }
      return false;
    }
    function parseMeshes(meshes) {
      if (!Array.isArray(meshes)) {
        meshes = [meshes];
      }
      let output = [];
      meshes.forEach(function checkMesh(obj) {
        if (obj.isOcclusionMesh) {
          return;
        }
        if (obj.hitArea || obj.hitMesh) {
          obj = function initHitMesh(obj) {
            obj.hitMesh ||= new Mesh(obj.hitArea);
            obj.add(obj.hitMesh);
            (obj = obj.hitMesh).isHitMesh = true;
            obj.shader.neverRender = true;
            return obj;
          }(obj);
        }
        if (typeof obj.isHitMesh == "boolean") {
          obj.mouseEnabled = function (visible) {
            if (visible) {
              if (!~_meshes.indexOf(obj)) {
                _meshes.push(obj);
              }
            } else {
              _meshes.remove(obj);
            }
          };
          output.push(obj);
        } else {
          output.push(obj);
        }
        if (obj.children.length) {
          obj.children.forEach(checkMesh);
        }
      });
      return output;
    }
    function testObjects() {
      _test.length = 0;
      for (let i = _meshes.length - 1; i > -1; i--) {
        let obj = _meshes[i];
        if (obj.determineVisible()) {
          _test.push(obj);
        }
      }
      return _test;
    }
    function start(e) {
      if (_input.type == "2d") {
        let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
        if (element && checkIfProhibited(element) || GLUI.HIT) {
          return;
        }
      }
      if (!_enabled) {
        return;
      }
      let hit = move(e);
      if (_input.type == "3d") {
        _this.events.fire(Interaction3D.EXTERNAL_PRESS);
      }
      if (hit) {
        _click = hit.object;
        _click.time = Render.TIME;
      } else {
        _click = null;
      }
    }
    function moveHand(e) {
      if (!_enabled) {
        return;
      }
      _cacheHits.length = 0;
      for (let i = 0; i < _input.obj.length; i++) {
        let obj = _input.obj[i];
        _v3.set(0, 0, -1).applyQuaternion(obj.quaternion);
        let hit = _ray.checkFromValues(testObjects(), obj.position, _v3)[0];
        if (hit) {
          _cacheHits.push(hit);
        }
      }
      _cacheHits.sort((a, b) => a.distance - b.distance);
      let hit = _cacheHits[0];
      if (!hit || hit.object != _lastOnUpdate) {
        if (_lastOnUpdate && _lastOnUpdate.onMissUpdate) {
          _lastOnUpdate.onMissUpdate();
        }
        _lastOnUpdate = null;
      }
      if (hit) {
        let mesh = hit.object;
        if (mesh.onHitUpdate) {
          hit.usingFinger = true;
          _lastOnUpdate = mesh;
          mesh.onHitUpdate(hit);
          return false;
        }
        if (!mesh._debounceFingerClick || Render.TIME - mesh._debounceFingerClick > 1000) {
          if (hit.distance < 0.01) {
            _click = mesh;
            triggerClick(mesh, hit);
            mesh._debounceFingerClick = Render.TIME;
          } else if (!_hover) {
            _hover = mesh;
            triggerHover("over", mesh, hit);
          }
        } else if (_hover) {
          triggerHover("out", _hover);
          _hover = null;
        }
      } else if (_hover) {
        triggerHover("out", _hover);
        _hover = null;
      }
    }
    function move(e) {
      if (_input.type == "2d") {
        let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
        if (element && checkIfProhibited(element)) {
          return;
        }
      }
      if (!_enabled) {
        Interaction3D.requestCursor("auto", _this);
        return;
      }
      let hit;
      if (_input.type == "2d") {
        hit = _ray.checkHit(testObjects(), _input.position, _input.rect || Stage)[0];
      } else {
        _input.obj.hideBeam();
        _v3.set(0, 0, -1).applyQuaternion(_input.obj.group.getWorldQuaternion());
        hit = _ray.checkFromValues(testObjects(), _input.obj.group.getWorldPosition(), _v3)[0];
      }
      if (!hit || hit.object != _lastOnUpdate) {
        if (_lastOnUpdate && _lastOnUpdate.onMissUpdate) {
          _lastOnUpdate.onMissUpdate();
        }
        _lastOnUpdate = null;
      }
      if (hit) {
        _this.intersecting = true;
        let mesh = hit.object;
        if (_input.type == "3d") {
          let max = _maximumVRHitDistance || Interaction3D.maximumVRHitDistance;
          if (typeof mesh.maximumVRHitDistance == "number" && mesh.maximumVRHitDistance > 0) {
            max = mesh.maximumVRHitDistance;
          }
          if (mesh.onHitUpdate && hit.distance > max) {
            return false;
          }
          _input.obj.showBeam();
          if (_input.obj.setHitPosition) {
            _input.obj.setHitPosition(hit);
          }
        }
        if (mesh.onHitUpdate) {
          mesh.onHitUpdate(hit);
          _lastOnUpdate = mesh;
          return false;
        } else {
          if (_hover !== mesh) {
            if (_hover) {
              triggerHover("out", _hover, hit);
            }
            _hover = mesh;
            triggerHover("over", _hover, hit);
            if (_hover.__clickCallback) {
              Interaction3D.requestCursor("pointer", _this);
            } else {
              Interaction3D.requestCursor("auto", _this);
            }
          } else {
            (function triggerMove(mesh, hit) {
              _event.action = "move";
              _event.mesh = mesh;
              _event.hit = hit;
              _this.events.fire(Interaction3D.MOVE, _event, true);
              if (mesh["__moveCallback" + _this.ID]) {
                mesh["__moveCallback" + _this.ID](_event);
              }
            })(_hover, hit);
          }
          return hit;
        }
      }
      _this.intersecting = false;
      end();
      if (_input.obj && _input.obj.setHitPosition) {
        _input.obj.setHitPosition(false);
      }
      return false;
    }
    function end() {
      if (_hover) {
        triggerHover("out", _hover, null);
        _hover = null;
        Interaction3D.requestCursor(_this.cursor, _this);
      }
    }
    function click(e) {
      if (_input.type == "3d") {
        _this.events.fire(Interaction3D.EXTERNAL_RELEASE);
      }
      if (!_this.enabled) {
        return;
      }
      if (!_click) {
        return;
      }
      let hit;
      let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
      if (!element || !checkIfProhibited(element)) {
        if (_input.type == "2d") {
          if (GLUI.HIT) {
            return;
          }
          hit = _ray.checkHit(testObjects(), _input.position, _input.rect)[0];
        } else {
          _v3.set(0, 0, -1).applyQuaternion(_input.obj.group.getWorldQuaternion());
          hit = _ray.checkFromValues(testObjects(), _input.obj.group.getWorldPosition(), _v3)[0];
        }
        if (hit && hit.object === _click) {
          triggerClick(_click, hit);
        }
        _click = null;
      }
    }
    function triggerHover(action, mesh, hit) {
      _event.action = action;
      _event.mesh = mesh;
      _event.hit = hit;
      _this.events.fire(Interaction3D.HOVER, _event, true);
      if (_hover.__hoverCallback) {
        _hover.__hoverCallback(_event);
      }
    }
    function triggerClick(mesh, hit) {
      _event.action = "click";
      _event.mesh = mesh;
      _event.hit = hit;
      _this.events.fire(Interaction3D.CLICK, _event, true);
      if (_click.__clickCallback) {
        _click.__clickCallback(_event);
      }
    }
    function vrInputButton(e) {
      if (e.label == "trigger") {
        if (e.pressed) {
          start(e);
        } else {
          click(e);
        }
      }
    }
    this.cursor = "auto";
    _ray.testVisibility = true;
    this.set("camera", c => {
      _ray.camera = c;
    });
    this.add = function (meshes, hover, click, move, seo) {
      let seoRoot;
      if (!Array.isArray(meshes)) {
        meshes = parseMeshes(meshes);
      }
      if (move && typeof move != "function") {
        seo = move;
        move = null;
      }
      if (seo && seo.root) {
        seoRoot = seo.root;
        seo = seo.seo;
      }
      meshes.forEach((mesh, i) => {
        if (seo) {
          try {
            mesh._divFocus = _ => hover({
              action: "over",
              seo: true,
              mesh: mesh
            });
            mesh._divBlur = _ => hover({
              action: "out",
              seo: true,
              mesh: mesh
            });
            mesh._divSelect = _ => click({
              action: "click",
              seo: true,
              mesh: mesh
            });
            let {
              url: url,
              label: label,
              ...options
            } = Array.isArray(seo) ? seo[i] : seo;
            GLSEO.objectNode(mesh, seoRoot);
            mesh.seo.aLink(url, label, options);
          } catch (e) {
            if (Hydra.LOCAL) {
              console.warn("Could not add SEO to Interaction3D meshes", e);
            }
          }
        }
        mesh.hitDestroy = _ => _meshes.remove(mesh);
        if (hover) {
          mesh.__hoverCallback = hover;
        }
        if (click) {
          mesh.__clickCallback = click;
        }
        if (move) {
          mesh["__moveCallback" + _this.ID] = move;
        }
        _meshes.push(mesh);
      });
    };
    this.remove = function (meshes) {
      if (!Array.isArray(meshes)) {
        meshes = parseMeshes(meshes);
      }
      meshes.forEach(mesh => {
        if (mesh === _hover) {
          _hover = null;
          Interaction3D.requestCursor(_this.cursor, _this);
        }
        if (mesh.seo) {
          mesh.seo.unlink();
        }
        for (let i = _meshes.length - 1; i >= 0; i--) {
          if (mesh === _meshes[i]) {
            _meshes.splice(i, 1);
          }
        }
      });
    };
    this.set("testVisibility", v => _ray.testVisibility = v);
    this.set("input", obj => {
      if (_input && _input.obj) {
        if (_input.obj.isVrController) {
          _this.events.unsub(_input.obj, VRInput.BUTTON, vrInputButton);
        }
        if (_input.obj.setHitPosition) {
          _input.obj.setHitPosition(false);
        }
        if (_input.obj.hideBeam) {
          _input.obj.hideBeam();
        }
      }
      (_input = {}).obj = obj;
      _input.position = obj.group ? obj.group.position : obj;
      _input.quaternion = obj.group ? obj.group.quaternion : null;
      _input.type = typeof _input.position.z == "number" || Array.isArray(obj) ? "3d" : "2d";
      _input.rect = obj.rect;
      if (_input.type == "3d") {
        new Vector3();
        new Vector3();
      } else {
        new Vector2();
        new Vector2();
      }
      if (obj == Mouse) {
        (function addHandlers() {
          _this.events.sub(Mouse.input, Interaction.START, start);
          if (Device.mobile) {
            _this.events.sub(Mouse.input, Interaction.END, end);
          }
          _this.events.sub(Mouse.input, Interaction.MOVE, move);
          _this.events.sub(Mouse.input, Interaction.CLICK, click);
        })();
      } else {
        (function removeHandlers() {
          _this.events.unsub(Mouse.input, Interaction.START, start);
          if (Device.mobile) {
            _this.events.unsub(Mouse.input, Interaction.END, end);
          }
          _this.events.unsub(Mouse.input, Interaction.MOVE, move);
          _this.events.unsub(Mouse.input, Interaction.CLICK, click);
        })();
        if (Array.isArray(obj)) {
          _this.startRender(moveHand);
          _this.stopRender(move);
        } else {
          _this.events.sub(obj, VRInput.BUTTON, vrInputButton);
          _this.startRender(move);
          _this.stopRender(moveHand);
        }
      }
    });
    this.get("input", _ => _input);
    this.get("enabled", _ => _enabled);
    this.set("enabled", v => {
      if (!(_enabled = v)) {
        if (_hover) {
          triggerHover("out", _hover, null);
        }
        _hover = null;
        if (_input && _input.obj) {
          if (_input.obj.setHitPosition) {
            _input.obj.setHitPosition(false);
          }
          if (_input.obj.hideBeam) {
            _input.obj.hideBeam();
          }
        }
      }
    });
    this.checkObjectHit = function (object, mouse, rect = Stage) {
      return _ray.checkHit(object, mouse, rect)[0];
    };
    this.checkObjectFromValues = function (object, origin, direction) {
      return _ray.checkFromValues(object, origin, direction)[0];
    };
    this.getObjectHitLocalCoords = function (v, object, mouse, rect = Stage) {
      let hit = _this.checkObjectHit(object, mouse, rect);
      if (hit) {
        v.copy(hit.point);
        return hit.object.worldToLocal(v);
      } else {
        _plane.normal.set(0, 0, 1).applyQuaternion(object.getWorldQuaternion());
        _plane.constant = -object.getWorldPosition().dot(_plane.normal);
        _ray.ray.intersectPlane(_plane, v);
        return object.worldToLocal(v);
      }
    };
    this.get("maximumVRHitDistance", () => _maximumVRHitDistance);
    this.set("maximumVRHitDistance", value => {
      if (value) {
        if (typeof value == "number" && value > 0) {
          _maximumVRHitDistance = value;
        }
      } else {
        _maximumVRHitDistance = undefined;
      }
    });
  }, () => {
    Interaction3D.HOVER = "interaction3d_hover";
    Interaction3D.CLICK = "interaction3d_click";
    Interaction3D.MOVE = "interaction3d_move";
    Interaction3D.EXTERNAL_PRESS = "interaction3d_ext_press";
    Interaction3D.EXTERNAL_RELEASE = "interaction3d_ext_release";
    var _cursorObj;
    var _map = new Map();
    var _input = Mouse;
    var _maximumVRHitDistance = 5;
    Interaction3D.find = function (camera) {
      camera = camera.camera || camera;
      if (!_map.has(camera)) {
        let interaction = new Interaction3D(camera);
        interaction.input = _input;
        _map.set(camera, interaction);
      }
      return _map.get(camera);
    };
    Interaction3D.useInput = function (obj) {
      if (_input != obj) {
        for (let [camera, interaction] of _map) {
          interaction.input = obj;
        }
        _input = obj;
      }
    };
    Interaction3D.requestCursor = function (cursor, obj) {
      if (obj.forceCursor) {
        cursor = obj.forceCursor;
      }
      if (cursor == "pointer") {
        _cursorObj = obj;
        Stage.cursor(cursor);
      }
      if (cursor == "auto" && _cursorObj == obj) {
        Stage.cursor(cursor);
        _cursorObj = null;
      }
    };
    Object.defineProperty(Interaction3D, "maximumVRHitDistance", {
      get: () => _maximumVRHitDistance,
      set(value) {
        if (value) {
          if (typeof value == "number" && value > 0) {
            _maximumVRHitDistance = value;
          }
        } else {
          _maximumVRHitDistance = 5;
        }
      }
    });
  });
  Class(function Lighting() {
    Inherit(this, Component);
    const _this = this;
    var _activeScene;
    var _scenes = {};
    function loop() {
      decomposeLights(_activeScene.lights);
      if (_this.UBO) {
        let shader = _activeScene.shaders.start();
        if (shader) {
          updateArrays(shader);
          if (_activeScene.ubo.created) {
            _activeScene.ubo.update();
          } else {
            createUBO(shader.uniforms);
          }
        }
      } else {
        let shader = _activeScene.shaders.start();
        while (shader) {
          updateArrays(shader);
          shader = _activeScene.shaders.next();
        }
      }
    }
    function createUBO(uniforms) {
      if (uniforms.lightPos) {
        _activeScene.ubo.created = true;
        _activeScene.ubo.push(uniforms.lightPos);
        _activeScene.ubo.push(uniforms.lightColor);
        _activeScene.ubo.push(uniforms.lightData);
        _activeScene.ubo.push(uniforms.lightData2);
        _activeScene.ubo.push(uniforms.lightData3);
        _activeScene.ubo.push(uniforms.lightProperties);
        _activeScene.ubo.upload();
      }
    }
    function decomposeLights(lights) {
      for (let i = lights.length - 1; i > -1; i--) {
        let light = lights[i];
        if (!light._decomposedTime || !(Render.TIME - light._decomposedTime < 8)) {
          light._decomposedTime = Render.TIME;
          if (!light._parent) {
            light.updateMatrixWorld();
          }
          light._world ||= new Vector3();
          if (light.lockToLocal) {
            light._world.copy(light.position);
          } else {
            light.getWorldPosition(light._world);
          }
        }
      }
    }
    function updateArrays(shader) {
      let lighting = shader.__lighting;
      lighting.position.length = 0;
      lighting.color.length = 0;
      lighting.data.length = 0;
      lighting.data2.length = 0;
      lighting.data3.length = 0;
      lighting.properties.length = 0;
      for (let i = 0; i < _activeScene.lights.length; i++) {
        let light = _activeScene.lights[i];
        if (!light._world) {
          decomposeLights(_activeScene.lights);
        }
        lighting.position.push(light._world.x, light._world.y, light._world.z, 0);
        lighting.color.push(light.color.r, light.color.g, light.color.b, 0);
        lighting.data.push(light.data.x, light.data.y, light.data.z, light.data.w);
        lighting.data2.push(light.data2.x, light.data2.y, light.data2.z, light.data2.w);
        lighting.data3.push(light.data3.x, light.data3.y, light.data3.z, light.data3.w);
        lighting.properties.push(light.properties.x, light.properties.y, light.properties.z, light.properties.w);
      }
    }
    function findParentScene(obj3d) {
      if (!obj3d) {
        return _activeScene;
      }
      if (obj3d._lightingData) {
        return obj3d._lightingData;
      }
      let scene;
      let p = obj3d._parent;
      while (p) {
        if (p instanceof Scene && p._lightingData) {
          scene = p._lightingData;
        }
        p = p._parent;
      }
      scene ||= _activeScene;
      return scene;
    }
    this.fallbackAreaToPoint = false;
    this.scenes = _scenes;
    (async function () {
      await Hydra.ready();
      _this.createScene("default");
      _this.useScene("default");
    })();
    this.createScene = function (name, scene) {
      if (_scenes[name]) {
        return this;
      }
      let obj = {
        lights: [],
        renderShadows: [],
        ubo: new (window.Metal ? MetalUBO : UBO)(2),
        shaders: new LinkedList(),
        name: name
      };
      if (scene) {
        scene._lightingData = obj;
      }
      _scenes[name] = obj;
      return this;
    };
    this.useScene = function (name) {
      if (!(_activeScene = _scenes[name])) {
        throw `Scene ${name} not found`;
      }
      loop();
      return this;
    };
    this.destroyScene = function (name) {
      delete _scenes[name];
    };
    this.push = this.add = function (light) {
      _this.UBO = Renderer.UBO && !window.AURA && RenderManager.type != RenderManager.WEBVR;
      if (window.Metal) {
        _this.UBO = true;
      }
      let scene = findParentScene(light);
      scene.lights.push(light);
      if (light.isAreaLight) {
        scene.hasAreaLight = true;
      }
      if (!_this.startedLoop) {
        _this.startedLoop = true;
        if (RenderManager.type == RenderManager.WEBVR) {
          _this.startRender(loop, World.NUKE);
        } else {
          Render.onDrawFrame(loop);
        }
      }
    };
    this.remove = function (light) {
      _activeScene.lights.remove(light);
    };
    this.getLighting = function (shader, force) {
      if (shader.__lighting && !force) {
        return shader.__lighting;
      }
      let scene = findParentScene(shader.mesh);
      scene.shaders.push(shader);
      if (window.AreaLightUtil && scene.hasAreaLight) {
        AreaLightUtil.append(shader);
      }
      let lighting = shader.__lighting = {
        position: [],
        color: [],
        data: [],
        data2: [],
        data3: [],
        properties: []
      };
      if (!scene.lights.length) {
        return shader.__lighting;
      }
      let lightUBO = _this.UBO;
      shader.uniforms.lightPos = {
        type: "v4v",
        value: lighting.position,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      shader.uniforms.lightColor = {
        type: "v4v",
        value: lighting.color,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      shader.uniforms.lightData = {
        type: "v4v",
        value: lighting.data,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      shader.uniforms.lightData2 = {
        type: "v4v",
        value: lighting.data2,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      shader.uniforms.lightData3 = {
        type: "v4v",
        value: lighting.data3,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      shader.uniforms.lightProperties = {
        type: "v4v",
        value: lighting.properties,
        ignoreUIL: true,
        lightUBO: lightUBO,
        components: 4,
        metalIgnore: true
      };
      updateArrays(shader);
      if (_this.UBO && !_activeScene.ubo.created) {
        createUBO(shader.uniforms);
      }
      return shader.__lighting;
    };
    this.destroyShader = function (shader) {
      findParentScene(shader.mesh);
      _activeScene.shaders.remove(shader);
    };
    this.sort = function (callback) {
      _activeScene.lights.sort(callback);
    };
    this.addToShadowGroup = function (light) {
      findParentScene(light).renderShadows.push(light);
    };
    this.removeFromShadowGroup = function (light) {
      findParentScene(light);
      _activeScene.renderShadows.remove(light);
    };
    this.getShadowLights = function () {
      return _activeScene.renderShadows;
    };
    this.getShadowCount = function () {
      return _activeScene.renderShadows.length;
    };
    this.initShadowShader = function (object, mesh) {
      let scene;
      let shader = object.shader || object;
      if (shader.mesh) {
        let p = shader.mesh._parent;
        while (p) {
          if (p instanceof Scene && p._lightingData) {
            scene = p._lightingData;
          }
          p = p._parent;
        }
      }
      scene ||= _activeScene;
      if (!World.RENDERER.shadows || scene.renderShadows.length == 0) {
        return "";
      }
      if (!shader._gl) {
        shader.upload();
      }
      let vsName = shader.vsName;
      let fsName = "ShadowDepth";
      if (shader.customShadowShader) {
        fsName = shader.customShadowShader;
      }
      shader.shadow = new Shader(vsName, fsName, {
        receiveLight: shader.receiveLight,
        UILPrefix: shader.UILPrefix,
        precision: "high"
      });
      if (shader.vertexShader) {
        shader.shadow.vertexShader = shader.vertexShader;
      }
      if (shader.restoreVS) {
        shader.shadow.vertexShader = shader.restoreVS;
      }
      if (shader.customCompile) {
        shader.shadow.customCompile = shader.customCompile + "_shadow";
      }
      if (shader.defines) {
        shader.shadow.defines = shader.defines;
        shader.shadow.resetProgram();
      }
      shader.shadow.lights = shader.lights;
      shader.shadow.isShadow = true;
      shader.copyUniformsTo(shader.shadow, true);
      shader.shadow.upload();
    };
    this.getShadowUniforms = function (shader) {
      let scene;
      if (shader.mesh) {
        let p = shader.mesh._parent;
        while (p) {
          if (p instanceof Scene && p._lightingData) {
            scene = p._lightingData;
          }
          p = p._parent;
        }
      }
      scene ||= _activeScene;
      if (World.RENDERER.shadows && scene.renderShadows.length != 0) {
        return [`\n#define SHADOW_MAPS ${scene.renderShadows.length}`, World.RENDERER.shadows == Renderer.SHADOWS_LOW ? "#define SHADOWS_LOW" : "", World.RENDERER.shadows == Renderer.SHADOWS_MED ? "#define SHADOWS_MED" : "", World.RENDERER.shadows == Renderer.SHADOWS_HIGH ? "#define SHADOWS_HIGH" : "", `uniform sampler2D shadowMap[${scene.renderShadows.length}];`, `uniform mat4 shadowMatrix[${scene.renderShadows.length}];`, `uniform vec3 shadowLightPos[${scene.renderShadows.length}];`, `uniform float shadowSize[${scene.renderShadows.length}];`].join("\n");
      } else {
        return "";
      }
    };
    this.bindUBO = function (shader) {
      if (_activeScene.ubo.created) {
        _activeScene.ubo.bind(shader, "lights");
      }
    };
    this.fallbackAreaToPointTest = function () {
      return _this.fallbackAreaToPoint;
    };
    this.get("activeScene", _ => _activeScene);
    this.renderShadowsAllowLight = function (object, light) {
      if (!object._renderShadowsAllowLights) {
        let allowed = new WeakMap();
        object._renderShadowsAllowLights = allowed;
        let prevOnBeforeRenderShadow = object.onBeforeRenderShadow;
        object.onBeforeRenderShadow = function (renderLight) {
          let result = prevOnBeforeRenderShadow && prevOnBeforeRenderShadow.apply(this, arguments);
          return !allowed.has(renderLight) || result;
        };
      }
      object._renderShadowsAllowLights.set(light.light || light, true);
    };
  }, "static");
  class Shadow {
    constructor(light) {
      this.light = light;
      this.camera = new PerspectiveCamera(60, 1, 0.1, 50);
      this.target = new Vector3();
      this.rt = new RenderTarget(1024, 1024);
      this.rt.createDepthTexture();
      this.enabled = true;
      this._size = 1024;
      this._fov = 60;
      this._far = 50;
      this._near = 0.1;
      light.add(this.camera);
    }
    destroy() {
      this.rt.destroy();
    }
    set fov(value) {
      this._fov = value;
      this.camera.fov = value;
      this.camera.updateProjectionMatrix();
      if (value == -1) {
        this.camera = new OrthographicCamera(-5, 5, 5, -5, 0.1, 50);
      }
    }
    get fov() {
      return this._fov;
    }
    set area(value) {
      this._area = value;
      this.camera.left = -value;
      this.camera.right = value;
      this.camera.top = value;
      this.camera.bottom = -value;
      this.camera.updateProjectionMatrix();
    }
    get area() {
      return this._area;
    }
    set far(value) {
      this._far = value;
      this.camera.far = value;
      this.camera.updateProjectionMatrix();
    }
    get far() {
      return this._far;
    }
    set near(value) {
      this._near = value;
      this.camera.near = value;
      this.camera.updateProjectionMatrix();
    }
    get near() {
      return this._near;
    }
    set size(value) {
      this._size = value;
      this.rt.setSize(value, value);
    }
    get size() {
      return this._size;
    }
  }
  class Box2 {
    constructor(min, max) {
      this.min = min !== undefined ? min : new Vector2(Infinity, Infinity);
      this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      let v1 = this.V1 || new Vector2();
      this.V1 = v1;
      let halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    clone() {
      return new Box2().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
      if (this.isEmpty()) {
        return target.set(0, 0);
      } else {
        return target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
    }
    getSize(target) {
      if (this.isEmpty()) {
        return target.set(0, 0);
      } else {
        return target.subVectors(this.max, this.min);
      }
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    containsPoint(point) {
      return !(point.x < this.min.x) && !(point.x > this.max.x) && !(point.y < this.min.y) && !(point.y > this.max.y);
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
      return !(box.max.x < this.min.x) && !(box.min.x > this.max.x) && !(box.max.y < this.min.y) && !(box.min.y > this.max.y);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      let v1 = this.V1 || new Vector2();
      this.V1 = v1;
      return v1.copy(point).clamp(this.min, this.max).sub(point).length();
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }
  class Box3 {
    constructor(min, max) {
      this.min = min !== undefined ? min : new Vector3(Infinity, Infinity, Infinity);
      this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = array.length; i < l; i += 3) {
        let x = array[i];
        let y = array[i + 1];
        let z = array[i + 2];
        if (x < minX) {
          minX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (z < minZ) {
          minZ = z;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y > maxY) {
          maxY = y;
        }
        if (z > maxZ) {
          maxZ = z;
        }
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        let x = attribute.array[i * 3 + 0];
        let y = attribute.array[i * 3 + 1];
        let z = attribute.array[i * 3 + 2];
        if (x < minX) {
          minX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (z < minZ) {
          minZ = z;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y > maxY) {
          maxY = y;
        }
        if (z > maxZ) {
          maxZ = z;
        }
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    }
    clone() {
      return new Box3().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      if (this.isEmpty()) {
        return target.set(0, 0, 0);
      } else {
        return target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
    }
    getSize(target) {
      if (this.isEmpty()) {
        return target.set(0, 0, 0);
      } else {
        return target.subVectors(this.max, this.min);
      }
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, local, onlyvisible) {
      let scope;
      let i;
      let l;
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      scope = this;
      object.updateMatrixWorld(true);
      object.traverse(node => {
        if (onlyvisible && !node.visible) {
          return;
        }
        if (node.isGizmo) {
          return;
        }
        let geometry = node.geometry;
        if (!geometry) {
          return;
        }
        let attribute = geometry.attributes.position;
        if (attribute !== undefined) {
          i = 0;
          l = attribute.count;
          for (; i < l; i++) {
            v1.fromBufferAttribute(attribute, i).applyMatrix4(local ? node.matrix : node.matrixWorld);
            scope.expandByPoint(v1);
          }
        }
      });
      return this;
    }
    containsPoint(point) {
      return !(point.x < this.min.x) && !(point.x > this.max.x) && !(point.y < this.min.y) && !(point.y > this.max.y) && !(point.z < this.min.z) && !(point.z > this.max.z);
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
      return !(box.max.x < this.min.x) && !(box.min.x > this.max.x) && !(box.max.y < this.min.y) && !(box.min.y > this.max.y) && !(box.max.z < this.min.z) && !(box.min.z > this.max.z);
    }
    intersectsSphere(sphere) {
      let closestPoint = this.V1 || new Vector3();
      this.V1 = closestPoint;
      this.clampPoint(sphere.center, closestPoint);
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min;
      let max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= plane.constant && max >= plane.constant;
    }
    intersectsTriangle(triangle) {
      let v0 = this.V0 || new Vector3();
      this.V0 = v0;
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let v2 = this.V2 || new Vector3();
      this.V2 = v2;
      let f0 = this.F0 || new Vector3();
      this.F0 = f0;
      let f1 = this.F1 || new Vector3();
      this.F1 = f1;
      let f2 = this.F2 || new Vector3();
      this.F2 = f2;
      let testAxis = this.V3 || new Vector3();
      this.V3 = testAxis;
      let center = this.V4 || new Vector3();
      this.V4 = center;
      let extents = this.V5 || new Vector3();
      this.V5 = extents;
      let triangleNormal = this.V6 || new Vector3();
      function satForAxes(axes) {
        let i;
        let j;
        i = 0;
        j = axes.length - 3;
        for (; i <= j; i += 3) {
          testAxis.fromArray(axes, i);
          let r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
          let p0 = v0.dot(testAxis);
          let p1 = v1.dot(testAxis);
          let p2 = v2.dot(testAxis);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
            return false;
          }
        }
        return true;
      }
      this.V6 = triangleNormal;
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(center);
      extents.subVectors(this.max, center);
      v0.subVectors(triangle.a, center);
      v1.subVectors(triangle.b, center);
      v2.subVectors(triangle.c, center);
      f0.subVectors(v1, v0);
      f1.subVectors(v2, v1);
      f2.subVectors(v0, v2);
      let axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];
      return !!satForAxes(axes) && (axes = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!satForAxes(axes) && (triangleNormal.crossVectors(f0, f1), axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z], satForAxes(axes)));
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      return v1.copy(point).clamp(this.min, this.max).sub(point).length();
    }
    getBoundingSphere(target = new Sphere()) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      this.getCenter(target.center);
      target.radius = this.getSize(v1).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) {
        this.makeEmpty();
      }
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty()) {
        return this;
      }
      let m = matrix.elements;
      let xax = m[0] * this.min.x;
      let xay = m[1] * this.min.x;
      let xaz = m[2] * this.min.x;
      let xbx = m[0] * this.max.x;
      let xby = m[1] * this.max.x;
      let xbz = m[2] * this.max.x;
      let yax = m[4] * this.min.y;
      let yay = m[5] * this.min.y;
      let yaz = m[6] * this.min.y;
      let ybx = m[4] * this.max.y;
      let yby = m[5] * this.max.y;
      let ybz = m[6] * this.max.y;
      let zax = m[8] * this.min.z;
      let zay = m[9] * this.min.z;
      let zaz = m[10] * this.min.z;
      let zbx = m[8] * this.max.z;
      let zby = m[9] * this.max.z;
      let zbz = m[10] * this.max.z;
      this.min.x = Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12];
      this.min.y = Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13];
      this.min.z = Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14];
      this.max.x = Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12];
      this.max.y = Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13];
      this.max.z = Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14];
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        let x = attribute.array[i * 3 + 0];
        let y = attribute.array[i * 3 + 1];
        let z = attribute.array[i * 3 + 2];
        if (x < minX) {
          minX = x;
        }
        if (y < minY) {
          minY = y;
        }
        if (z < minZ) {
          minZ = z;
        }
        if (x > maxX) {
          maxX = x;
        }
        if (y > maxY) {
          maxY = y;
        }
        if (z > maxZ) {
          maxZ = z;
        }
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
  }
  class Color {
    constructor(r, g, b) {
      if (r == null && g == null && b == null) {
        return this.setRGB(1, 1, 1);
      } else if (g === undefined && b === undefined) {
        return this.set(r);
      } else {
        this.setRGB(r, g, b);
        return;
      }
    }
    set(value) {
      if (value && value instanceof Color) {
        this.copy(value);
      } else if (typeof value == "number") {
        this.setHex(value);
      } else if (typeof value == "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    }
    setStyle(string) {
      return this.setHex(Number(string.replace("#", "0x")));
    }
    setRGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    }
    setHSL(h, s, l) {
      function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        } else if (t < 0.5) {
          return q;
        } else if (t < 2 / 3) {
          return p + (q - p) * 6 * (2 / 3 - t);
        } else {
          return p;
        }
      }
      h = Math.euclideanModulo(h, 1);
      s = Math.clamp(s, 0, 1);
      l = Math.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        let p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        let q = l * 2 - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      return this;
    }
    clone() {
      return new Color(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
      let safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    }
    convertGammaToLinear(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    }
    convertLinearToGamma(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    }
    getHex() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
      return "#" + ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL() {
      let target = this.target || {};
      this.target = target;
      let hue;
      let saturation;
      let r = this.r;
      let g = this.g;
      let b = this.b;
      let max = Math.max(r, g, b);
      let min = Math.min(r, g, b);
      let lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        let delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    tween(color, time, ease, delay) {
      const _this = this;
      _this.tweenObj ||= {
        v: 0
      };
      _this.tweenObj.v = 0;
      let clone = this.clone();
      return TweenManager.tween(_this.tweenObj, {
        v: 1
      }, time, ease, delay).onUpdate(_ => {
        _this.copy(clone).lerp(color, _this.tweenObj.v);
      });
    }
    offsetHSL(h, s, l) {
      let hsl = this.getHSL();
      hsl.h += h;
      hsl.s += s;
      hsl.l += l;
      this.setHSL(hsl.h, hsl.s, hsl.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    invert() {
      this.r = 1 - this.r;
      this.g = 1 - this.g;
      this.b = 1 - this.b;
      return this;
    }
    lerp(color, alpha, hz) {
      this.r = Math.lerp(color.r, this.r, alpha, hz);
      this.g = Math.lerp(color.g, this.g, alpha, hz);
      this.b = Math.lerp(color.b, this.b, alpha, hz);
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    toRGBA(alpha = 1) {
      return `rgba(${Math.floor(this.r * 255)}, ${Math.floor(this.g * 255)}, ${Math.floor(this.b * 255)}, ${alpha})`;
    }
  }
  class Cylindrical {
    constructor(radius = 1, theta = 0, y = 0) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
    }
    set(radius, theta, y) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;
      return this;
    }
    setFromVector3(vec3) {
      this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
      this.theta = Math.atan2(vec3.x, vec3.z);
      this.y = vec3.y;
      return this;
    }
  }
  class Euler {
    constructor(x, y, z, order) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._order = order || "XYZ";
      this.isEuler = true;
    }
    get x() {
      return this._x;
    }
    set x(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Euler::NaN");
      }
      let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
      this._x = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get y() {
      return this._y;
    }
    set y(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Euler::NaN");
      }
      let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
      this._y = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get z() {
      return this._z;
    }
    set z(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Euler::NaN");
      }
      let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
      this._z = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    set order(value) {
      this._order = value;
      this.onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;
      this.onChangeCallback();
      return this;
    }
    clone() {
      return new Euler(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler.x;
      this._y = euler.y;
      this._z = euler.z;
      if (euler._order) {
        this._order = euler._order;
      }
      this.onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order, update) {
      let clamp = Math.clamp;
      let te = m.elements;
      let m11 = te[0];
      let m12 = te[4];
      let m13 = te[8];
      let m21 = te[1];
      let m22 = te[5];
      let m23 = te[9];
      let m31 = te[2];
      let m32 = te[6];
      let m33 = te[10];
      if ((order = order || this._order) === "XYZ") {
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 1 - Base3D.DIRTY_EPSILON) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
      } else if (order === "YXZ") {
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 1 - Base3D.DIRTY_EPSILON) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
      } else if (order === "ZXY") {
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 1 - Base3D.DIRTY_EPSILON) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
      } else if (order === "ZYX") {
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 1 - Base3D.DIRTY_EPSILON) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
      } else if (order === "YZX") {
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 1 - Base3D.DIRTY_EPSILON) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
      } else if (order === "XZY") {
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 1 - Base3D.DIRTY_EPSILON) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
      }
      this._order = order;
      if (update !== false) {
        this.onChangeCallback();
      }
      return this;
    }
    setFromQuaternion(q, order, update) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix, order, update);
    }
    setFromVector3(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
      let q = this.Q1 || new Quaternion();
      this.Q1 = q;
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    }
    lerp(euler, alpha) {
      this._x += (euler._x - this._x) * alpha;
      this._y += (euler._y - this._y) * alpha;
      this._z += (euler._z - this._z) * alpha;
      this.onChangeCallback();
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined) {
        this._order = array[3];
      }
      this.onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    }
    onChange(callback) {
      this.onChangeCallback = callback;
    }
    onChangeCallback() {}
  }
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class Frustum {
    constructor(p0, p1, p2, p3, p4, p5) {
      this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
    }
    set(p0, p1, p2, p3, p4, p5) {
      let planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    clone() {
      return new Frustum().copy(this);
    }
    copy(frustum) {
      let planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromMatrix(m) {
      let planes = this.planes;
      let me = m.elements;
      let me0 = me[0];
      let me1 = me[1];
      let me2 = me[2];
      let me3 = me[3];
      let me4 = me[4];
      let me5 = me[5];
      let me6 = me[6];
      let me7 = me[7];
      let me8 = me[8];
      let me9 = me[9];
      let me10 = me[10];
      let me11 = me[11];
      let me12 = me[12];
      let me13 = me[13];
      let me14 = me[14];
      let me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    setFromCamera(camera) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      return this.setFromMatrix(matrix);
    }
    intersectsObject(object) {
      let sphere = this.S1 || new Sphere();
      this.S1 = sphere;
      let geometry = object.geometry;
      return !!geometry && (geometry.boundingSphere === null && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld), this.intersectsSphere(sphere));
    }
    intersectsSphere(sphere) {
      let planes = this.planes;
      let center = sphere.center;
      let negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(center) < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      let p1 = this.V1 || new Vector3();
      let p2 = this.V2 || new Vector3();
      this.V1 = p1;
      this.V2 = p2;
      let planes = this.planes;
      for (let i = 0; i < 6; i++) {
        let plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        let d1 = plane.distanceToPoint(p1);
        let d2 = plane.distanceToPoint(p2);
        if (d1 < 0 && d2 < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      let planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  }
  class Line3 {
    constructor(start = new Vector3(), end = new Vector3()) {
      this.start = start;
      this.end = end;
    }
    set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
    getCenter(target = new Vector3()) {
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target = new Vector3()) {
      return target.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t, target = new Vector3()) {
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
      let startP = this.V1 || new Vector3();
      let startEnd = this.V2 || new Vector3();
      this.V1 = startP;
      this.V2 = startEnd;
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      let startEnd2 = startEnd.dot(startEnd);
      let t = startEnd.dot(startP) / startEnd2;
      if (clampToLine) {
        t = Math.clamp(t, 0, 1);
      }
      return t;
    }
    closestPointToPoint(point, clampToLine, target = new Vector3()) {
      let t = this.closestPointToPointParameter(point, clampToLine);
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
    equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  }
  class Matrix3 {
    constructor() {
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      let te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix3().fromArray(this.elements);
    }
    copy(m) {
      let te = this.elements;
      let me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    setFromMatrix4(m) {
      let me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      let ae = a.elements;
      let be = b.elements;
      let te = this.elements;
      let a11 = ae[0];
      let a12 = ae[3];
      let a13 = ae[6];
      let a21 = ae[1];
      let a22 = ae[4];
      let a23 = ae[7];
      let a31 = ae[2];
      let a32 = ae[5];
      let a33 = ae[8];
      let b11 = be[0];
      let b12 = be[3];
      let b13 = be[6];
      let b21 = be[1];
      let b22 = be[4];
      let b23 = be[7];
      let b31 = be[2];
      let b32 = be[5];
      let b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      let te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      let te = this.elements;
      let a = te[0];
      let b = te[1];
      let c = te[2];
      let d = te[3];
      let e = te[4];
      let f = te[5];
      let g = te[6];
      let h = te[7];
      let i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    getInverse(matrix, throwOnDegenerate) {
      let me = matrix.elements;
      let te = this.elements;
      let n11 = me[0];
      let n21 = me[1];
      let n31 = me[2];
      let n12 = me[3];
      let n22 = me[4];
      let n32 = me[5];
      let n13 = me[6];
      let n23 = me[7];
      let n33 = me[8];
      let t11 = n33 * n22 - n32 * n23;
      let t12 = n32 * n13 - n33 * n12;
      let t13 = n23 * n12 - n22 * n13;
      let det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) {
        let msg = ".getInverse() can't invert matrix, determinant is 0";
        if (throwOnDegenerate === true) {
          throw new Error(msg);
        }
        return this.identity();
      }
      let detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp;
      let m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      let c = Math.cos(rotation);
      let s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    }
    scale(sx, sy) {
      let te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
    rotate(theta) {
      let c = Math.cos(theta);
      let s = Math.sin(theta);
      let te = this.elements;
      let a11 = te[0];
      let a12 = te[3];
      let a13 = te[6];
      let a21 = te[1];
      let a22 = te[4];
      let a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
    translate(tx, ty) {
      let te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
    equals(matrix) {
      let te = this.elements;
      let me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i]) {
          return false;
        }
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      let te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    applyToBufferAttribute(attribute) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      for (let i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.array[i * 3 + 0];
        v1.y = attribute.array[i * 3 + 1];
        v1.z = attribute.array[i * 3 + 2];
        v1.applyMatrix3(this);
        attribute.array[i * 3 + 0] = v1.x;
        attribute.array[i * 3 + 1] = v1.y;
        attribute.array[i * 3 + 2] = v1.z;
      }
      return attribute;
    }
  }
  class Matrix4 {
    constructor() {
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      let te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      let te = this.elements;
      let me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      let te = this.elements;
      let me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
    extractRotation(m) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let te = this.elements;
      let me = m.elements;
      let scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      let scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      let scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      return this;
    }
    makeRotationFromEuler(euler) {
      let te = this.elements;
      let x = euler.x;
      let y = euler.y;
      let z = euler.z;
      let a = Math.cos(x);
      let b = Math.sin(x);
      let c = Math.cos(y);
      let d = Math.sin(y);
      let e = Math.cos(z);
      let f = Math.sin(z);
      if (euler.order === "XYZ") {
        let ae = a * e;
        let af = a * f;
        let be = b * e;
        let bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        let ce = c * e;
        let cf = c * f;
        let de = d * e;
        let df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        let ce = c * e;
        let cf = c * f;
        let de = d * e;
        let df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        let ae = a * e;
        let af = a * f;
        let be = b * e;
        let bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        let ac = a * c;
        let ad = a * d;
        let bc = b * c;
        let bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        let ac = a * c;
        let ad = a * d;
        let bc = b * c;
        let bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      let te = this.elements;
      let x = q._x;
      let y = q._y;
      let z = q._z;
      let w = q._w;
      let x2 = x + x;
      let y2 = y + y;
      let z2 = z + z;
      let xx = x * x2;
      let xy = x * y2;
      let xz = x * z2;
      let yy = y * y2;
      let yz = y * z2;
      let zz = z * z2;
      let wx = w * x2;
      let wy = w * y2;
      let wz = w * z2;
      te[0] = 1 - (yy + zz);
      te[4] = xy - wz;
      te[8] = xz + wy;
      te[1] = xy + wz;
      te[5] = 1 - (xx + zz);
      te[9] = yz - wx;
      te[2] = xz - wy;
      te[6] = yz + wx;
      te[10] = 1 - (xx + yy);
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    lookAt(eye, target, up) {
      let x = this.V1 || new Vector3();
      let y = this.V2 || new Vector3();
      let z = this.V3 || new Vector3();
      this.V1 = x;
      this.V2 = y;
      this.V3 = z;
      let te = this.elements;
      z.subVectors(eye, target);
      if (z.lengthSq() === 0) {
        z.z = 1;
      }
      z.normalize();
      x.crossVectors(up, z);
      if (x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          z.x += 0.0001;
        } else {
          z.z += 0.0001;
        }
        z.normalize();
        x.crossVectors(up, z);
      }
      x.normalize();
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(ae, be) {
      let a = ae.elements;
      let b = be.elements;
      let out = this.elements;
      let a00 = a[0];
      let a01 = a[1];
      let a02 = a[2];
      let a03 = a[3];
      let a10 = a[4];
      let a11 = a[5];
      let a12 = a[6];
      let a13 = a[7];
      let a20 = a[8];
      let a21 = a[9];
      let a22 = a[10];
      let a23 = a[11];
      let a30 = a[12];
      let a31 = a[13];
      let a32 = a[14];
      let a33 = a[15];
      let b0 = b[0];
      let b1 = b[1];
      let b2 = b[2];
      let b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return this;
    }
    multiplyScalar(s) {
      let te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      let te = this.elements;
      let n11 = te[0];
      let n12 = te[4];
      let n13 = te[8];
      let n14 = te[12];
      let n21 = te[1];
      let n22 = te[5];
      let n23 = te[9];
      let n24 = te[13];
      let n31 = te[2];
      let n32 = te[6];
      let n33 = te[10];
      let n34 = te[14];
      return te[3] * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + te[7] * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + te[11] * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + te[15] * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      let tmp;
      let te = this.elements;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
    setPosition(v) {
      let te = this.elements;
      te[12] = v.x;
      te[13] = v.y;
      te[14] = v.z;
      return this;
    }
    getInverse(m, throwOnDegenerate) {
      let te = this.elements;
      let me = m.elements;
      let n11 = me[0];
      let n21 = me[1];
      let n31 = me[2];
      let n41 = me[3];
      let n12 = me[4];
      let n22 = me[5];
      let n32 = me[6];
      let n42 = me[7];
      let n13 = me[8];
      let n23 = me[9];
      let n33 = me[10];
      let n43 = me[11];
      let n14 = me[12];
      let n24 = me[13];
      let n34 = me[14];
      let n44 = me[15];
      let t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
      let t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
      let t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
      let t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      let det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) {
        let msg = ".getInverse() can't invert matrix, determinant is 0";
        if (throwOnDegenerate === true) {
          throw new Error(msg);
        }
        return this.identity();
      }
      let detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    invert() {
      const te = this.elements;
      const n11 = te[0];
      const n21 = te[1];
      const n31 = te[2];
      const n41 = te[3];
      const n12 = te[4];
      const n22 = te[5];
      const n32 = te[6];
      const n42 = te[7];
      const n13 = te[8];
      const n23 = te[9];
      const n33 = te[10];
      const n43 = te[11];
      const n14 = te[12];
      const n24 = te[13];
      const n34 = te[14];
      const n44 = te[15];
      const t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
      const t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
      const t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
      const t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) {
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      let te = this.elements;
      let x = v.x;
      let y = v.y;
      let z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      let te = this.elements;
      let scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      let scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      let scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    }
    makeRotationX(theta) {
      let c = Math.cos(theta);
      let s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationY(theta) {
      let c = Math.cos(theta);
      let s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationZ(theta) {
      let c = Math.cos(theta);
      let s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationAxis(axis, angle) {
      let c = Math.cos(angle);
      let s = Math.sin(angle);
      let t = 1 - c;
      let x = axis.x;
      let y = axis.y;
      let z = axis.z;
      let tx = t * x;
      let ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
    makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
    makeShear(x, y, z) {
      this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      return this;
    }
    compose(position, quaternion, scale) {
      this.makeRotationFromQuaternion(quaternion);
      this.scale(scale);
      this.setPosition(position);
      return this;
    }
    decompose(position, quaternion, scale) {
      let vector = this.V1 || new Vector3();
      this.V1 = vector;
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      let te = this.elements;
      let sx = vector.set(te[0], te[1], te[2]).length();
      let sy = vector.set(te[4], te[5], te[6]).length();
      let sz = vector.set(te[8], te[9], te[10]).length();
      if (this.determinant() < 0) {
        sx = -sx;
      }
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix.copy(this);
      let invSX = 1 / sx;
      let invSY = 1 / sy;
      let invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      let te = this.elements;
      let x = near * 2 / (right - left);
      let y = near * 2 / (top - bottom);
      let a = (right + left) / (right - left);
      let b = (top + bottom) / (top - bottom);
      let c = -(far + near) / (far - near);
      let d = far * -2 * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      let te = this.elements;
      let w = 1 / (right - left);
      let h = 1 / (top - bottom);
      let p = 1 / (far - near);
      let x = (right + left) * w;
      let y = (top + bottom) * h;
      let z = (far + near) * p;
      te[0] = w * 2;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = h * 2;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = p * -2;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      let te = this.elements;
      let me = matrix.elements;
      return te[0] == me[0] && te[1] == me[1] && te[2] == me[2] && te[3] == me[3] && te[4] == me[4] && te[5] == me[5] && te[6] == me[6] && te[7] == me[7] && te[8] == me[8] && te[9] == me[9] && te[10] == me[10] && te[11] == me[11] && te[12] == me[12] && te[13] == me[13] && te[14] == me[14] && te[15] == me[15];
    }
    fromArray(array, offset = 0) {
      let te = this.elements;
      te[0] = array[0 + offset];
      te[1] = array[1 + offset];
      te[2] = array[2 + offset];
      te[3] = array[3 + offset];
      te[4] = array[4 + offset];
      te[5] = array[5 + offset];
      te[6] = array[6 + offset];
      te[7] = array[7 + offset];
      te[8] = array[8 + offset];
      te[9] = array[9 + offset];
      te[10] = array[10 + offset];
      te[11] = array[11 + offset];
      te[12] = array[12 + offset];
      te[13] = array[13 + offset];
      te[14] = array[14 + offset];
      te[15] = array[15 + offset];
      return this;
    }
    toArray(array = [], offset = 0) {
      let te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
    applyToBufferAttribute(attribute) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      for (let i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.array[i * 3 + 0];
        v1.y = attribute.array[i * 3 + 1];
        v1.z = attribute.array[i * 3 + 2];
        v1.applyMatrix4(this);
        attribute.array[i * 3 + 0] = v1.x;
        attribute.array[i * 3 + 1] = v1.y;
        attribute.array[i * 3 + 2] = v1.z;
      }
      return attribute;
    }
    isIdentity() {
      let te = this.elements;
      return te[0] == 1 && te[1] == 0 && te[2] == 0 && te[3] == 0 && te[4] == 0 && te[5] == 1 && te[6] == 0 && te[7] == 0 && te[8] == 0 && te[9] == 0 && te[10] == 1 && te[11] == 0 && te[12] == 0 && te[13] == 0 && te[14] == 0 && te[15] == 1;
    }
  }
  Matrix4.__IDENTITY__ = new Matrix4();
  class Plane {
    constructor(normal, constant) {
      this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
      this.constant = constant !== undefined ? constant : 0;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b, c) {
      let v1 = this.V1 || new Vector3();
      let v2 = this.V2 || new Vector3();
      this.V1 = v1;
      this.V2 = v2;
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    clone() {
      return new Plane().copy(this);
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      var inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      var direction = line.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        } else {
          return undefined;
        }
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return undefined;
      } else {
        return target.copy(direction).multiplyScalar(t).add(line.start);
      }
    }
    intersectsLine(line) {
      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let m1 = this.M1 || new Matrix3();
      this.M1 = m1;
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  }
  class Quaternion {
    constructor(x, y, z, w) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._w = w !== undefined ? w : 1;
      this.isQuaternion = true;
    }
    get x() {
      return this._x;
    }
    set x(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Quaternion::NaN");
      }
      let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
      this._x = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get y() {
      return this._y;
    }
    set y(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Quaternion::NaN");
      }
      let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
      this._y = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get z() {
      return this._z;
    }
    set z(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Quaternion::NaN");
      }
      let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
      this._z = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get w() {
      return this._w;
    }
    set w(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Quaternion::NaN");
      }
      let dirty = Math.abs(this._w - v) > Base3D.DIRTY_EPSILON;
      this._w = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    clone() {
      return new Quaternion(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      const abs = Math.abs;
      let dirty = abs(this._x - quaternion.x) > Base3D.DIRTY_EPSILON || abs(this._y - quaternion.y) > Base3D.DIRTY_EPSILON || abs(this._z - quaternion.z) > Base3D.DIRTY_EPSILON || abs(this._w - quaternion.w) > Base3D.DIRTY_EPSILON;
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    set(x, y, z, w) {
      const abs = Math.abs;
      let dirty = abs(this._x - x) > Base3D.DIRTY_EPSILON || abs(this._y - y) > Base3D.DIRTY_EPSILON || abs(this._z - z) > Base3D.DIRTY_EPSILON || abs(this._w - w) > Base3D.DIRTY_EPSILON;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    setFromEuler(euler, update) {
      let x = euler._x;
      let y = euler._y;
      let z = euler._z;
      let order = euler.order;
      let cos = Math.cos;
      let sin = Math.sin;
      let c1 = cos(x / 2);
      let c2 = cos(y / 2);
      let c3 = cos(z / 2);
      let s1 = sin(x / 2);
      let s2 = sin(y / 2);
      let s3 = sin(z / 2);
      if (order === "XYZ") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "YXZ") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === "ZXY") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "ZYX") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === "YZX") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "XZY") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      }
      if (update !== false) {
        this.onChangeCallback();
      }
      return this;
    }
    setFromAxisAngle(axis, angle) {
      let halfAngle = angle / 2;
      let s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this.onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      let s;
      let te = m.elements;
      let m11 = te[0];
      let m12 = te[4];
      let m13 = te[8];
      let m21 = te[1];
      let m22 = te[5];
      let m23 = te[9];
      let m31 = te[2];
      let m32 = te[6];
      let m33 = te[10];
      let trace = m11 + m22 + m33;
      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = Math.sqrt(1 + m11 - m22 - m33) * 2;
        this._w = (m32 - m23) / s;
        this._x = s * 0.25;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = Math.sqrt(1 + m22 - m11 - m33) * 2;
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = s * 0.25;
        this._z = (m23 + m32) / s;
      } else {
        s = Math.sqrt(1 + m33 - m11 - m22) * 2;
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = s * 0.25;
      }
      this.onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let r = vFrom.dot(vTo) + 1;
      if (r < 0.000001) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }
      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      return this.normalize();
    }
    inverse() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this.onChangeCallback();
      return this;
    }
    dot(v) {
      const w = v._w === undefined ? 1 : v._w;
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this.onChangeCallback();
      return this;
    }
    multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      let qax = a._x;
      let qay = a._y;
      let qaz = a._z;
      let qaw = a._w;
      let qbx = b._x;
      let qby = b._y;
      let qbz = b._z;
      let qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this.onChangeCallback();
      return this;
    }
    slerp(qb, t, hz = true) {
      if ((t = hz ? Math.framerateNormalizeLerpAlpha(t) : Math.clamp(t)) === 0) {
        return this;
      }
      if (t === 1) {
        return this.copy(qb);
      }
      let x = this._x;
      let y = this._y;
      let z = this._z;
      let w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
      if (Math.abs(sinHalfTheta) < 0.001) {
        this._w = (w + this._w) * 0.5;
        this._x = (x + this._x) * 0.5;
        this._y = (y + this._y) * 0.5;
        this._z = (z + this._z) * 0.5;
        return this;
      }
      let halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      let ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
      let ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this.onChangeCallback();
      return this;
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this.onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    onChange(callback) {
      this.onChangeCallback = callback;
    }
    onChangeCallback() {}
  }
  class RayManager {
    constructor(origin, direction, near = 0, far = Infinity) {
      this.ray = new Ray(origin, direction);
      this.near = near;
      this.far = far;
      this.params = {
        Mesh: {},
        Points: {
          threshold: 1
        }
      };
    }
    set(origin, direction) {
      this.ray.set(origin, direction);
      return this;
    }
    setFromCamera(coords, camera) {
      if (camera.isPerspective) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      } else {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      }
    }
    _ascSort(a, b) {
      return a.distance - b.distance;
    }
    _intersectObject(object, raycaster, intersects, recursive, forceAllVisible) {
      if ((object.visible !== false || forceAllVisible) && (object.raycast && object.raycast(raycaster, intersects), recursive === true)) {
        let children = object.children;
        for (let i = 0, l = children.length; i < l; i++) {
          this._intersectObject(children[i], raycaster, intersects, true);
        }
      }
    }
    intersectObject(object, recursive, optionalTarget, forceAllVisible) {
      let intersects = optionalTarget || [];
      this._intersectObject(object, this, intersects, recursive, forceAllVisible);
      intersects.sort(this._ascSort);
      return intersects;
    }
    intersectObjects(objects, recursive, optionalTarget) {
      let intersects = optionalTarget || [];
      for (let i = 0, l = objects.length; i < l; i++) {
        this._intersectObject(objects[i], this, intersects, recursive);
      }
      intersects.sort(this._ascSort);
      return intersects;
    }
  }
  class Ray {
    constructor(origin = new Vector3(), direction = new Vector3()) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    clone() {
      return new Ray().copy(this);
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target = new Vector3()) {
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      this.origin.copy(this.at(t, v1));
    }
    closestPointToPoint(point, target = new Vector3()) {
      target.subVectors(point, this.origin);
      let directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      } else {
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      }
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      let directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      } else {
        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return v1.distanceToSquared(point);
      }
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      let segCenter = this.V1 || new Vector3();
      let segDir = this.V2 || new Vector3();
      let diff = this.V3 || new Vector3();
      this.V1 = segCenter;
      this.V2 = segDir;
      this.V3 = diff;
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      let s0;
      let s1;
      let sqrDist;
      let extDet;
      let segExtent = v0.distanceTo(v1) * 0.5;
      let a01 = -this.direction.dot(segDir);
      let b0 = diff.dot(this.direction);
      let b1 = -diff.dot(segDir);
      let c = diff.lengthSq();
      let det = Math.abs(1 - a01 * a01);
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              let invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + b0 * 2) + s1 * (a01 * s0 + s1 + b1 * 2) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + b1 * 2) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + b1 * 2) + c;
          }
        } else if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + b1 * 2) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + b1 * 2) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + b1 * 2) + c;
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + b1 * 2) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      v1.subVectors(sphere.center, this.origin);
      let tca = v1.dot(this.direction);
      let d2 = v1.dot(v1) - tca * tca;
      let radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) {
        return null;
      }
      let thc = Math.sqrt(radius2 - d2);
      let t0 = tca - thc;
      let t1 = tca + thc;
      if (t0 < 0 && t1 < 0) {
        return null;
      } else if (t0 < 0) {
        return this.at(t1, target);
      } else {
        return this.at(t0, target);
      }
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      let denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        } else {
          return null;
        }
      }
      let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      if (t >= 0) {
        return t;
      } else {
        return null;
      }
    }
    intersectPlane(plane, target) {
      let t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      } else {
        return this.at(t, target);
      }
    }
    intersectsPlane(plane) {
      let distToPoint = plane.distanceToPoint(this.origin);
      return distToPoint === 0 || plane.normal.dot(this.direction) * distToPoint < 0;
    }
    intersectBox(box, target) {
      let tmin;
      let tmax;
      let tymin;
      let tymax;
      let tzmin;
      let tzmax;
      let invdirx = 1 / this.direction.x;
      let invdiry = 1 / this.direction.y;
      let invdirz = 1 / this.direction.z;
      let origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax) {
        return null;
      } else {
        if (tymin > tmin || tmin != tmin) {
          tmin = tymin;
        }
        if (tymax < tmax || tmax != tmax) {
          tmax = tymax;
        }
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) {
          return null;
        } else {
          if (tzmin > tmin || tmin != tmin) {
            tmin = tzmin;
          }
          if (tzmax < tmax || tmax != tmax) {
            tmax = tzmax;
          }
          if (tmax < 0) {
            return null;
          } else {
            return this.at(tmin >= 0 ? tmin : tmax, target);
          }
        }
      }
    }
    intersectsBox(box) {
      let v = this.V1 || new Vector3();
      this.V1 = v;
      return this.intersectBox(box, v) !== null;
    }
    intersectsTriangle(a, b, c, backfaceCulling, target) {
      let diff = this.V1 || new Vector3();
      let edge1 = this.V2 || new Vector3();
      let edge2 = this.V3 || new Vector3();
      let normal = this.V4 || new Vector3();
      this.V1 = diff;
      this.V2 = edge1;
      this.V3 = edge2;
      this.V4 = normal;
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      let sign;
      let DdN = this.direction.dot(normal);
      if (DdN > 0) {
        if (backfaceCulling) {
          return null;
        }
        sign = 1;
      } else {
        if (!(DdN < 0)) {
          return null;
        }
        sign = -1;
        DdN = -DdN;
      }
      diff.subVectors(this.origin, a);
      let DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      let DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      let QdN = -sign * diff.dot(normal);
      if (QdN < 0) {
        return null;
      } else {
        return this.at(QdN / DdN, target);
      }
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  }
  class Sphere {
    constructor(center = new Vector3(), radius = 0) {
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      let box = this.V1 || new Box3();
      this.V1 = box;
      let center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    empty() {
      return this.radius <= 0;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      let radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target = new Vector3()) {
      let deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target = new Box3()) {
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  }
  class Spherical {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    clone() {
      return new Spherical().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    makeSafe() {
      this.phi = Math.max(0.000001, Math.min(Math.PI - 0.000001, this.phi));
      return this;
    }
    setFromVector3(vec3) {
      this.radius = vec3.length();
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(vec3.x, vec3.z);
        this.phi = Math.acos(Math.clamp(vec3.y / this.radius, -1, 1));
      }
      return this;
    }
  }
  class Triangle {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    clone() {
      return new Triangle().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      let v0 = this.V0 || new Vector3();
      let v1 = this.V1 || new Vector3();
      this.V0 = v0;
      this.V1 = v1;
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    }
    getMidpoint(target = new Vector3()) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target = new Vector3()) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  }
  class Vector2 {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    get width() {
      return this.x;
    }
    get height() {
      return this.y;
    }
    setScalar(s) {
      this.x = this.y = s;
      return this;
    }
    clone() {
      return new Vector2(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      let x = this.x;
      let y = this.y;
      let e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      let min = new Vector2();
      let max = new Vector2();
      min.set(minVal, minVal);
      max.set(maxVal, maxVal);
      return this.clamp(min, max);
    }
    clampLength(min, max) {
      let length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      let angle = Math.atan2(this.y, this.x);
      if (angle < 0) {
        angle += Math.PI * 2;
      }
      return angle;
    }
    angleTo(a, b) {
      b ||= this;
      return Math.atan2(a.y - b.y, a.x - b.x);
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      let dx = this.x - v.x;
      let dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha, hz) {
      this.x = Math.lerp(v.x, this.x, alpha, hz);
      this.y = Math.lerp(v.y, this.y, alpha, hz);
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    setAngleRadius(a, r) {
      this.x = Math.cos(a) * r;
      this.y = Math.sin(a) * r;
      return this;
    }
    addAngleRadius(a, r) {
      this.x += Math.cos(a) * r;
      this.y += Math.sin(a) * r;
      return this;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    rotateAround(center, angle) {
      let c = Math.cos(angle);
      let s = Math.sin(angle);
      let x = this.x - center.x;
      let y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.array[index * 2 + 0];
      this.y = attribute.array[index * 2 + 1];
    }
  }
  class Vector3 {
    constructor(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    set(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    clone() {
      return new Vector3(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      let quaternion = this.Q1 || new Quaternion();
      this.Q1 = quaternion;
      return this.applyQuaternion(quaternion.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      let quaternion = this.Q1 || new Quaternion();
      this.Q1 = quaternion;
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      let x = this.x;
      let y = this.y;
      let z = this.z;
      let e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyMatrix4(m) {
      let x = this.x;
      let y = this.y;
      let z = this.z;
      let e = m.elements;
      let w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      let x = this.x;
      let y = this.y;
      let z = this.z;
      let qx = q.x;
      let qy = q.y;
      let qz = q.z;
      let qw = q.w;
      if (qx == 0 && qy == 0 && qz == 0 && qw == 1) {
        return this;
      }
      let ix = qw * x + qy * z - qz * y;
      let iy = qw * y + qz * x - qx * z;
      let iz = qw * z + qx * y - qy * x;
      let iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
      return this.applyMatrix4(matrix);
    }
    unproject(camera) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
      return this.applyMatrix4(matrix);
    }
    transformDirection(m) {
      let x = this.x;
      let y = this.y;
      let z = this.z;
      let e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      let min = new Vector3();
      let max = new Vector3();
      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    }
    clampLength(min, max) {
      let length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha, hz) {
      this.x = Math.lerp(v.x, this.x, alpha, hz);
      this.y = Math.lerp(v.y, this.y, alpha, hz);
      this.z = Math.lerp(v.z, this.z, alpha, hz);
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    }
    cross(v) {
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      let ax = a.x;
      let ay = a.y;
      let az = a.z;
      let bx = b.x;
      let by = b.y;
      let bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(vector) {
      let scalar = vector.dot(this) / vector.lengthSq();
      return this.copy(vector).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    }
    reflect(normal) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      return this.sub(v1.copy(normal).multiplyScalar(this.dot(normal) * 2));
    }
    angleTo(v) {
      let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
      return Math.acos(Math.clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      let dx = this.x - v.x;
      let dy = this.y - v.y;
      let dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromCylindrical(c) {
      this.x = c.radius * Math.sin(c.theta);
      this.y = c.y;
      this.z = c.radius * Math.cos(c.theta);
      return this;
    }
    setFromMatrixPosition(m) {
      let e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      let sx = this.setFromMatrixColumn(m, 0).length();
      let sy = this.setFromMatrixColumn(m, 1).length();
      let sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setAngleRadius(a, r, dir = "xy") {
      this[dir[0]] = Math.cos(a) * r;
      this[dir[1]] = Math.sin(a) * r;
      return this;
    }
    addAngleRadius(a, r, dir = "xy") {
      this[dir[0]] += Math.cos(a) * r;
      this[dir[1]] += Math.sin(a) * r;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    setFromSpherical(s) {
      this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      let sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.x = attribute.array[index * 3 + 0];
      this.y = attribute.array[index * 3 + 1];
      this.z = attribute.array[index * 3 + 2];
      return this;
    }
  }
  class Vector3D {
    constructor(x, y, z) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
    }
    get x() {
      return this._x;
    }
    set x(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Vector3D::NaN");
      }
      let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
      this._x = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get y() {
      return this._y;
    }
    set y(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Vector3D::NaN");
      }
      let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
      this._y = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    get z() {
      return this._z;
    }
    set z(v) {
      if (zUtils3D.LOCAL && isNaN(v)) {
        return console.trace("Vector3D::NaN");
      }
      let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
      this._z = v;
      if (dirty) {
        this.onChangeCallback();
      }
    }
    onChangeCallback() {}
    set(x = 0, y = 0, z = 0) {
      const abs = Math.abs;
      let dirty = abs(this._x - x) > Base3D.DIRTY_EPSILON || abs(this._y - y) > Base3D.DIRTY_EPSILON || abs(this._z - z) > Base3D.DIRTY_EPSILON;
      this._x = x;
      this._y = y;
      this._z = z;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    setScalar(scalar) {
      const abs = Math.abs;
      let dirty = abs(this._x - scalar) > Base3D.DIRTY_EPSILON || abs(this._y - scalar) > Base3D.DIRTY_EPSILON || abs(this._z - scalar) > Base3D.DIRTY_EPSILON;
      this._x = scalar;
      this._y = scalar;
      this._z = scalar;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    clone() {
      return new Vector3(this._x, this._y, this._z);
    }
    copy(v) {
      const abs = Math.abs;
      let dirty = abs(this._x - v.x) > Base3D.DIRTY_EPSILON || abs(this._y - v.y) > Base3D.DIRTY_EPSILON || abs(this._z - v.z) > Base3D.DIRTY_EPSILON;
      this._x = v.x;
      this._y = v.y;
      this._z = v.z;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    add(v) {
      let nx = this._x + v.x;
      let ny = this._y + v.y;
      let nz = this._z + v.z;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    addScalar(s) {
      let nx = this._x + s;
      let ny = this._y + s;
      let nz = this._z + s;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    addVectors(a, b) {
      this._x = a.x + b.x;
      this._y = a.y + b.y;
      this._z = a.z + b.z;
      this.onChangeCallback();
      return this;
    }
    addScaledVector(v) {
      this._x += v.x * s;
      this._y += v.y * s;
      this._z += v.z * s;
      this.onChangeCallback();
      return this;
    }
    sub(v) {
      let nx = this._x - v.x;
      let ny = this._y - v.y;
      let nz = this._z - v.z;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    subScalar(s) {
      let nx = this._x - s;
      let ny = this._y - s;
      let nz = this._z - s;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    subVectors(a, b) {
      this._x = a.x - b.x;
      this._y = a.y - b.y;
      this._z = a.z - b.z;
      this.onChangeCallback();
      return this;
    }
    multiply(v) {
      let nx = this._x * v.x;
      let ny = this._y * v.y;
      let nz = this._z * v.z;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    multiplyScalar(scalar) {
      let nx = this._x * scalar;
      let ny = this._y * scalar;
      let nz = this._z * scalar;
      const abs = Math.abs;
      let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;
      this._x = nx;
      this._y = ny;
      this._z = nz;
      if (dirty) {
        this.onChangeCallback();
      }
      return this;
    }
    multiplyVectors(a, b) {
      this._x = a.x * b.x;
      this._y = a.y * b.y;
      this._z = a.z * b.z;
      this.onChangeCallback();
      return this;
    }
    applyEuler(euler) {
      let quaternion = this.Q1 || new Quaternion();
      this.Q1 = quaternion;
      return this.applyQuaternion(quaternion.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      let quaternion = this.Q1 || new Quaternion();
      this.Q1 = quaternion;
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      let x = this._x;
      let y = this._y;
      let z = this._z;
      let e = m.elements;
      this._x = e[0] * x + e[3] * y + e[6] * z;
      this._y = e[1] * x + e[4] * y + e[7] * z;
      this._z = e[2] * x + e[5] * y + e[8] * z;
      this.onChangeCallback();
      return this;
    }
    applyMatrix4(m) {
      let x = this._x;
      let y = this._y;
      let z = this._z;
      let e = m.elements;
      let w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this._x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this._y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this._z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      this.onChangeCallback();
      return this;
    }
    applyQuaternion(q) {
      let x = this._x;
      let y = this._y;
      let z = this._z;
      let qx = q.x;
      let qy = q.y;
      let qz = q.z;
      let qw = q.w;
      let ix = qw * x + qy * z - qz * y;
      let iy = qw * y + qz * x - qx * z;
      let iz = qw * z + qx * y - qy * x;
      let iw = -qx * x - qy * y - qz * z;
      this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      this.onChangeCallback();
      return this;
    }
    project(camera) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
      return this.applyMatrix4(matrix);
    }
    unproject(camera) {
      let matrix = this.M1 || new Matrix4();
      this.M1 = matrix;
      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
      return this.applyMatrix4(matrix);
    }
    transformDirection(m) {
      let x = this._x;
      let y = this._y;
      let z = this._z;
      let e = m.elements;
      this._x = e[0] * x + e[4] * y + e[8] * z;
      this._y = e[1] * x + e[5] * y + e[9] * z;
      this._z = e[2] * x + e[6] * y + e[10] * z;
      this.onChangeCallback();
      return this.normalize();
    }
    divide(v) {
      this._x /= v.x;
      this._y /= v.y;
      this._z /= v.z;
      this.onChangeCallback();
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this._x = Math.min(this._x, v.x);
      this._y = Math.min(this._y, v.y);
      this._z = Math.min(this._z, v.z);
      this.onChangeCallback();
      return this;
    }
    max(v) {
      this._x = Math.max(this._x, v.x);
      this._y = Math.max(this._y, v.y);
      this._z = Math.max(this._z, v.z);
      return this;
    }
    clamp(min, max) {
      this._x = Math.max(min.x, Math.min(max.x, this._x));
      this._y = Math.max(min.y, Math.min(max.y, this._y));
      this._z = Math.max(min.z, Math.min(max.z, this._z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      let min = new Vector3();
      let max = new Vector3();
      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);
      return this.clamp(min, max);
    }
    clampLength(min, max) {
      let length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this._x = Math.floor(this._x);
      this._y = Math.floor(this._y);
      this._z = Math.floor(this._z);
      this.onChangeCallback();
      return this;
    }
    ceil() {
      this._x = Math.ceil(this._x);
      this._y = Math.ceil(this._y);
      this._z = Math.ceil(this._z);
      this.onChangeCallback();
      return this;
    }
    round() {
      this._x = Math.round(this._x);
      this._y = Math.round(this._y);
      this._z = Math.round(this._z);
      this.onChangeCallback();
      return this;
    }
    roundToZero() {
      this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x);
      this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y);
      this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z);
      this.onChangeCallback();
      return this;
    }
    negate() {
      this._x = -this._x;
      this._y = -this._y;
      this._z = -this._z;
      this.onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v.x + this._y * v.y + this._z * v.z;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
    }
    manhattanLength() {
      return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
    }
    normalize() {
      this.onChangeCallback();
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      this.onChangeCallback();
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha, hz) {
      this._x = Math.lerp(v.x, this._x, alpha, hz);
      this._y = Math.lerp(v.y, this._y, alpha, hz);
      this._z = Math.lerp(v.z, this._z, alpha, hz);
      this.onChangeCallback();
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.onChangeCallback();
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    }
    cross(v) {
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      let ax = a.x;
      let ay = a.y;
      let az = a.z;
      let bx = b.x;
      let by = b.y;
      let bz = b.z;
      this._x = ay * bz - az * by;
      this._y = az * bx - ax * bz;
      this._z = ax * by - ay * bx;
      this.onChangeCallback();
      return this;
    }
    projectOnVector(vector) {
      let scalar = vector.dot(this) / vector.lengthSq();
      return this.copy(vector).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      this.onChangeCallback();
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    }
    reflect(normal) {
      let v1 = this.V1 || new Vector3();
      this.V1 = v1;
      this.onChangeCallback();
      return this.sub(v1.copy(normal).multiplyScalar(this.dot(normal) * 2));
    }
    angleTo(v) {
      let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
      return Math.acos(Math.clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      let dx = this._x - v.x;
      let dy = this._y - v.y;
      let dz = this._z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this._x - v.x) + Math.abs(this._y - v.y) + Math.abs(this._z - v.z);
    }
    setFromSpherical(s) {
      let sinPhiRadius = Math.sin(s.phi) * s.radius;
      this._x = sinPhiRadius * Math.sin(s.theta);
      this._y = Math.cos(s.phi) * s.radius;
      this._z = sinPhiRadius * Math.cos(s.theta);
      this.onChangeCallback();
      return this;
    }
    setFromCylindrical(c) {
      this._x = c.radius * Math.sin(c.theta);
      this._y = c.y;
      this._z = c.radius * Math.cos(c.theta);
      this.onChangeCallback();
      return this;
    }
    setFromMatrixPosition(m) {
      let e = m.elements;
      this._x = e[12];
      this._y = e[13];
      this._z = e[14];
      this.onChangeCallback();
      return this;
    }
    setFromMatrixScale(m) {
      let sx = this.setFromMatrixColumn(m, 0).length();
      let sy = this.setFromMatrixColumn(m, 1).length();
      let sz = this.setFromMatrixColumn(m, 2).length();
      this.onChangeCallback();
      this._x = sx;
      this._y = sy;
      this._z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      this.onChangeCallback();
      return this.fromArray(m.elements, index * 4);
    }
    equals(v) {
      return v.x === this._x && v.y === this._y && v.z === this._z;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this.onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.array[index * 3 + 0];
      this._y = attribute.array[index * 3 + 1];
      this._z = attribute.array[index * 3 + 2];
      this.onChangeCallback();
    }
    onChange(callback) {
      this.onChangeCallback = callback;
    }
    onChangeCallback() {}
  }
  class Vector4 {
    constructor(x = 0, y = 0, z = 0, w = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    multiplyScalar(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      this.w *= s;
      return this;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    lerp(v, alpha, hz) {
      this.x = Math.lerp(v.x, this.x, alpha, hz);
      this.y = Math.lerp(v.y, this.y, alpha, hz);
      this.z = Math.lerp(v.z, this.z, alpha, hz);
      this.w = Math.lerp(v.w, this.w, alpha, hz);
      return this;
    }
    applyMatrix4(m) {
      let x = this.x;
      let y = this.y;
      let z = this.z;
      let w = this.w;
      let e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    set width(v) {
      this.z = v;
    }
    set height(v) {
      this.w = v;
    }
    get width() {
      return this.z;
    }
    get height() {
      return this.w;
    }
    clone() {
      return new Vector4(this.x, this.y, this.z, this.w);
    }
  }
  class Face3 {
    constructor(a, b, c, normal = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal;
    }
  }
  function NoGLPolyfill() {
    this.activeTexture = this.attachShader = this.bindAttribLocation = this.bindBuffer = this.bindFramebuffer = this.bindRenderbuffer = this.bindTexture = this.blendColor = this.blendEquation = this.blendEquationSeparate = this.blendFunc = this.blendFuncSeparate = this.bufferData = this.bufferSubData = this.checkFramebufferStatus = this.clear = this.clearColor = this.clearDepthf = this.clearStencil = this.colorMask = this.compileShader = this.compressedTexImage2D = this.compressedTexSubImage2D = this.copyTexImage2D = this.copyTexSubImage2D = this.createProgram = this.createShader = this.cullFace = this.deleteBuffers = this.deleteFramebuffers = this.deleteProgram = this.deleteRenderbuffers = this.deleteShader = this.deleteTextures = this.depthFunc = this.depthMask = this.depthRangef = this.detachShader = this.disable = this.disableVertexAttribArray = this.drawArrays = this.drawElements = this.enable = this.enableVertexAttribArray = this.finish = this.flush = this.framebufferRenderbuffer = this.framebufferTexture2D = this.frontFace = this.generateMipmap = this.getActiveAttrib = this.getActiveUniform = this.getAttachedShaders = this.getAttribLocation = this.getBooleanv = this.getBufferParameteriv = this.getError = this.getFloatv = this.getFramebufferAttachmentParameteriv = this.getIntegerv = this.getProgramiv = this.getProgramInfoLog = this.getRenderbufferParameteriv = this.getShaderiv = this.getShaderInfoLog = this.getShaderPrecisionFormat = this.getShaderSource = this.getString = this.getTexParameterfv = this.getTexParameteriv = this.getUniformfv = this.getUniformiv = this.getUniformLocation = this.getVertexAttribfv = this.getVertexAttribiv = this.getVertexAttribPointerv = this.isBuffer = this.isEnabled = this.isFramebuffer = this.isProgram = this.isRenderbuffer = this.isShader = this.isTexture = this.lineWidth = this.linkProgram = this.pixelStorei = this.polygonOffset = this.readPixels = this.releaseShaderCompiler = this.renderbufferStorage = this.sampleCoverage = this.scissor = this.shaderBinary = this.shaderSource = this.stencilFunc = this.stencilFuncSeparate = this.stencilMask = this.stencilMaskSeparate = this.stencilOp = this.stencilOpSeparate = this.texParameterf = this.texParameterfv = this.texParameteri = this.texParameteriv = this.texSubImage2D = this.uniform1f = this.uniform1fv = this.uniform1i = this.uniform1iv = this.uniform2f = this.uniform2fv = this.uniform2i = this.uniform2iv = this.uniform3f = this.uniform3fv = this.uniform3i = this.uniform3iv = this.uniform4f = this.uniform4fv = this.uniform4i = this.uniform4iv = this.uniformMatrix2fv = this.uniformMatrix3fv = this.uniformMatrix4fv = this.useProgram = this.validateProgram = this.vertexAttrib1f = this.vertexAttrib1fv = this.vertexAttrib2f = this.vertexAttrib2fv = this.vertexAttrib3f = this.vertexAttrib3fv = this.vertexAttrib4f = this.vertexAttrib4fv = this.vertexAttribPointer = this.viewport = this.getParameter = this.getExtension = this.drawElementsInstanced = this.drawArraysInstanced = this.vertexAttribDivisor = this.getUniformBlockIndex = this.uniformBlockBinding = this.bindBufferBase = this.createVertexArray = this.bindVertexArray = this.deleteVertexArray = this.drawBuffers = this.blitFramebuffer = this.texImage2D = this.getContextAttributes = this.isContextLost = this.clearDepth = this.depthRange = this.createTexture = this.createBuffer = this.createFramebuffer = this.createRenderbuffer = this.deleteTexture = this.deleteBuffer = this.deleteFramebuffer = this.getBufferParameter = this.getRenderbufferParameter = this.getProgramParameter = this.getVertexAttribOffset = this.getFramebufferAttachmentParemeter = this.getUniform = this.getTexParameter = this.getShaderParameter = this.getSupportedExtensions = this.activeTexture = this.attachShader = _ => {};
    this.getShaderParameter = this.getProgramParameter = function () {
      return true;
    };
  }
  Class(function zUtils3D() {
    var diff;
    var edge1;
    var edge2;
    var normal;
    var v1;
    var v0;
    Math.euclideanModulo = function (n, m) {
      return (n % m + m) % m;
    };
    Math.isPowerOf2 = function (w, h) {
      let test = value => (value & value - 1) == 0;
      return test(w) && test(h);
    };
    Math.floorPowerOf2 = function (value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    };
    Math.ceilPowerOf2 = function (value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    };
    this.LOCAL = window.Hydra && Hydra.LOCAL;
    Geometry.createAttributes = function (geom) {
      let attributes = {};
      let handler = {
        set(target, property, value) {
          target[property] = value;
          geom._attributeKeys.length = 0;
          geom._attributeValues.length = 0;
          for (let key in attributes) {
            geom._attributeKeys.push(key);
            geom._attributeValues.push(attributes[key]);
          }
          return true;
        }
      };
      geom._attributeKeys = [];
      geom._attributeValues = [];
      return new Proxy(attributes, handler);
    };
    Geometry.TYPED_ARRAYS = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
    };
    Geometry.arrayNeedsUint32 = function (array) {
      for (let i = array.length - 1; i >= 0; --i) {
        if (array[i] > 65535) {
          return true;
        }
      }
      return false;
    };
    Geometry.TYPES = {
      SphereGeometry: SphereGeometry,
      IcosahedronGeometry: IcosahedronGeometry,
      BoxGeometry: BoxGeometry,
      PlaneGeometry: PlaneGeometry,
      CylinderGeometry: CylinderGeometry
    };
    Matrix4.prototype.isMatrix4 = true;
    Matrix3.prototype.isMatrix3 = true;
    Vector3.prototype.isVector3 = true;
    Vector3D.prototype.isVector3 = true;
    Vector2.prototype.isVector2 = true;
    CameraBase3D.prototype.isCamera = true;
    PerspectiveCamera.prototype.isPerspective = true;
    Scene.FRONT_TO_BACK = "sort_front_to_back";
    Scene.FRONT_TO_BACK_BOUNDING = "sort_front_to_back_bounding";
    if (window.THREAD) {
      Shader = {
        FRONT_SIDE: "shader_front_side",
        BACK_SIDE: "shader_back_side",
        DOUBLE_SIDE: "shader_double_side"
      };
    }
    Ray.prototype.intersectTriangle = (diff = new Vector3(), edge1 = new Vector3(), edge2 = new Vector3(), normal = new Vector3(), function intersectTriangle(a, b, c, backfaceCulling, target) {
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      var sign;
      var DdN = this.direction.dot(normal);
      if (DdN > 0) {
        if (backfaceCulling) {
          return null;
        }
        sign = 1;
      } else {
        if (!(DdN < 0)) {
          return null;
        }
        sign = -1;
        DdN = -DdN;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign * diff.dot(normal);
      if (QdN < 0) {
        return null;
      } else {
        return this.at(QdN / DdN, target);
      }
    });
    Mesh.prototype.raycast = function () {
      let inverseMatrix = new Matrix4();
      let ray = new Ray();
      let sphere = new Sphere();
      let vA = new Vector3();
      let vB = new Vector3();
      let vC = new Vector3();
      new Vector3();
      new Vector3();
      new Vector3();
      new Vector3();
      let uvA = new Vector2();
      let uvB = new Vector2();
      let uvC = new Vector2();
      let barycoord = new Vector3();
      let intersectionPoint = new Vector3();
      let intersectionPointWorld = new Vector3();
      function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
        vA.fromBufferAttribute(position, a);
        vB.fromBufferAttribute(position, b);
        vC.fromBufferAttribute(position, c);
        if (object.raycastLimit) {
          let {
            radiusSq: radiusSq,
            position: position
          } = object.raycastLimit;
          if (vA.distanceToSquared(position) > radiusSq) {
            return;
          }
        }
        let intersection = function checkIntersection(object, shader, raycaster, ray, pA, pB, pC, point) {
          let intersect;
          intersect = shader.side === Shader.BACK_SIDE ? ray.intersectTriangle(pC, pB, pA, true, point) : ray.intersectTriangle(pA, pB, pC, shader.side !== Shader.DOUBLE_SIDE, point);
          if (intersect === null) {
            return null;
          }
          intersectionPointWorld.copy(point);
          intersectionPointWorld.applyMatrix4(object.matrixWorld);
          let distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
          if (distance < raycaster.near || distance > raycaster.far) {
            return null;
          } else {
            return {
              distance: distance,
              point: intersectionPointWorld.clone(),
              object: object
            };
          }
        }(object, object.shader, raycaster, ray, vA, vB, vC, intersectionPoint);
        if (intersection) {
          if (uv) {
            uvA.fromBufferAttribute(uv, a);
            uvB.fromBufferAttribute(uv, b);
            uvC.fromBufferAttribute(uv, c);
            intersection.uv = function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
              Triangle.getBarycoord(point, p1, p2, p3, barycoord);
              uv1.multiplyScalar(barycoord.x);
              uv2.multiplyScalar(barycoord.y);
              uv3.multiplyScalar(barycoord.z);
              uv1.add(uv2).add(uv3);
              return uv1.clone();
            }(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
          }
          let face = new Face3(a, b, c);
          Triangle.getNormal(vA, vB, vC, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      return function raycast(raycaster, intersects) {
        let intersection;
        let a;
        let b;
        let c;
        let geometry = this.geometry;
        let shader = this.shader;
        let matrixWorld = this.matrixWorld;
        if (shader === undefined) {
          return;
        }
        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }
        if (this.scale.x == 0) {
          return;
        }
        if (this.staticRaycast) {
          if (!this.raySphere) {
            this.raySphere = new Sphere();
            this.raySphere.copy(geometry.boundingSphere);
            this.raySphere.applyMatrix4(matrixWorld);
          }
          if (this.raycastNeedsUpdate) {
            this.raySphere.copy(geometry.boundingSphere);
            this.raySphere.applyMatrix4(matrixWorld);
            this.raycastNeedsUpdate = false;
          }
          if (raycaster.ray.intersectsSphere(this.raySphere) === false) {
            return;
          }
        } else {
          sphere.copy(geometry.boundingSphere);
          sphere.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(sphere) === false) {
            return;
          }
        }
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null && ray.intersectsBox(geometry.boundingBox) === false) {
          return;
        }
        let i;
        let l;
        let index = geometry.index;
        let position = geometry.attributes.position;
        let uv = geometry.attributes.uv;
        if (index !== null) {
          i = 0;
          l = index.length;
          for (; i < l; i += 3) {
            a = index[i];
            b = index[i + 1];
            c = index[i + 2];
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        } else if (position !== undefined) {
          i = 0;
          l = position.count;
          for (; i < l; i += 3) {
            a = i;
            b = i + 1;
            c = i + 2;
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      };
    }();
    Triangle.prototype.closestPointToPoint = function () {
      let plane = new Plane();
      let edgeList = [new Line3(), new Line3(), new Line3()];
      let projectedPoint = new Vector3();
      let closestPoint = new Vector3();
      return function closestPointToPoint(point, target = new Vector3()) {
        let minDistance = Infinity;
        plane.setFromCoplanarPoints(this.a, this.b, this.c);
        plane.projectPoint(point, projectedPoint);
        if (this.containsPoint(projectedPoint) === true) {
          target.copy(projectedPoint);
        } else {
          edgeList[0].set(this.a, this.b);
          edgeList[1].set(this.b, this.c);
          edgeList[2].set(this.c, this.a);
          for (let i = 0; i < edgeList.length; i++) {
            edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
            let distance = projectedPoint.distanceToSquared(closestPoint);
            if (distance < minDistance) {
              minDistance = distance;
              target.copy(closestPoint);
            }
          }
        }
        return target;
      };
    }();
    Points.prototype.raycast = function () {
      let inverseMatrix = new Matrix4();
      let ray = new Ray();
      let sphere = new Sphere();
      return function raycast(raycaster, intersects) {
        let object = this;
        let geometry = this.geometry;
        let matrixWorld = this.matrixWorld;
        let threshold = raycaster.params.Points.threshold;
        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(sphere) === false) {
          return;
        }
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        let localThresholdSq = localThreshold * localThreshold;
        let position = new Vector3();
        let intersectPoint = new Vector3();
        function testPoint(point, index) {
          let rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            ray.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            let distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) {
              return;
            }
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object
            });
          }
        }
        let index = geometry.index;
        let positions = geometry.attributes.position.array;
        if (index !== null) {
          let indices = index.array;
          for (let i = 0, il = indices.length; i < il; i++) {
            let a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (let i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      };
    }();
    Object.assign(Triangle, {
      getNormal: (v0 = new Vector3(), function getNormal(a, b, c, target = new Vector3()) {
        target.subVectors(c, b);
        v0.subVectors(a, b);
        target.cross(v0);
        var targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        } else {
          return target.set(0, 0, 0);
        }
      }),
      getBarycoord: function () {
        var v0 = new Vector3();
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function getBarycoord(point, a, b, c, target = new Vector3()) {
          v0.subVectors(c, a);
          v1.subVectors(b, a);
          v2.subVectors(point, a);
          var dot00 = v0.dot(v0);
          var dot01 = v0.dot(v1);
          var dot02 = v0.dot(v2);
          var dot11 = v1.dot(v1);
          var dot12 = v1.dot(v2);
          var denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          var invDenom = 1 / denom;
          var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        };
      }(),
      getUV: function () {
        let _v3 = new Vector3();
        return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3.x);
          target.addScaledVector(uv2, _v3.y);
          target.addScaledVector(uv3, _v3.z);
          return target;
        };
      }(),
      containsPoint: (v1 = new Vector3(), function containsPoint(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, v1);
        return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
      })
    });
  }, "static");
  Class(function FXLayer(_parentNuke, _type, _preventDrawBuffers = false) {
    Inherit(this, Component);
    var _nuke;
    var _rt;
    var _this = this;
    var _scene = new Scene();
    var _objects = [];
    var _textureIndex = -1;
    var _visible = true;
    var _id = Utils.timestamp();
    var _name = Utils.getConstructorName(_this);
    var _useDrawBuffers = !_preventDrawBuffers;
    this.resolution = 1;
    this.enabled = true;
    this.renderShadows = true;
    const CLEAR_COLOR = [0, 0, 0, 1];
    function resizeHandler() {
      if (_rt.setSize) {
        _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr);
      }
    }
    FXLayer.exists = true;
    this.set("visible", v => _this.scene.visible = _visible = v);
    this.get("visible", _ => _visible);
    this.onInvisible = function () {
      _this.scene.visible = false;
    };
    this.onVisible = function () {
      _this.scene.visible = true;
    };
    this.create = function (nuke = World.NUKE, type, rt) {
      if (!nuke) {
        return;
      }
      let format;
      let manualRender;
      let mipmaps;
      _useDrawBuffers = nuke.useDrawBuffers;
      if (type && typeof type == "object") {
        if (typeof type.useDrawBuffers == "boolean") {
          _useDrawBuffers = type.useDrawBuffers;
        }
        format = type.format;
        manualRender = type.manualRender;
        mipmaps = type.mipmaps;
        rt ||= type.rt;
        type = type.type;
      }
      _this.rtType = type || Texture.UNSIGNED_BYTE;
      _this.rtFormat = format || Texture.RGBFormat;
      _this.rtMipmaps = mipmaps;
      (_this = this).scene = _scene;
      (_nuke = _this.initClass(Nuke, nuke.stage, {
        renderer: nuke.renderer,
        camera: nuke.camera,
        scene: _scene,
        dpr: nuke.dpr,
        useDrawBuffers: false
      })).parentNuke = nuke;
      _parentNuke = nuke;
      _this.nuke = _nuke;
      (function initRT(rt) {
        if (_useDrawBuffers) {
          let texture = new Texture();
          texture.minFilter = Texture.LINEAR;
          texture.magFilter = Texture.LINEAR;
          texture.format = Texture.RGBAFormat;
          if (_this.rtType) {
            texture.type = _this.rtType;
          }
          if (_this.rtFormat) {
            texture.format = _this.rtFormat;
          }
          if (_this.rtMipmaps) {
            texture.generateMipmaps = true;
            texture.minFilter = texture.magFilter = Texture.LINEAR_MIPMAP;
          } else {
            texture.generateMipmaps = false;
          }
          if (texture.type == Texture.FLOAT) {
            texture.format = Texture.RGBAFormat;
          }
          texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE;
          texture.fxLayer = _this;
          _this.textureIndex = _textureIndex = _parentNuke.attachDrawBuffer(texture);
          _rt = {
            texture: texture
          };
        } else {
          if (_this.rtType && _this.rtType == Texture.FLOAT && Device.system.os == "ios") {
            _this.rtType = Texture.HALF_FLOAT;
          }
          _rt = rt || Utils3D.createRT(Math.round(_nuke.stage.width * _this.resolution * _nuke.dpr), Math.round(_nuke.stage.height * _this.resolution * _nuke.dpr), _this.rtType, _this.rtFormat);
          if (_this.rtMipmaps) {
            _rt.texture.minFilter = _rt.texture.magFilter = Texture.LINEAR_MIPMAP;
            _rt.texture.generateMipmaps = true;
          } else {
            _rt.texture.generateMipmaps = false;
          }
        }
        _this.rt = _rt;
        _this.nuke.setSize(_rt.width, _rt.height);
      })(rt);
      (function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
      })();
      if (!manualRender && !FXScene.manualRender) {
        _this.startRender(_ => _this.draw(), nuke);
      }
    };
    this.addObject = this.add = function (object) {
      if (_nuke) {
        if (!_useDrawBuffers) {
          let clone = object.clone();
          object["clone_" + _id] = clone;
          _scene.add(clone);
          _objects.push(object);
          if (object.shader) {
            (function editShader(mesh) {
              let modifyShader = (shader, name) => {
                let fs = shader._fragmentShader;
                if (!fs) {
                  return;
                }
                let marker = "#drawbuffer " + name;
                if (fs.includes(marker)) {
                  let split = fs.split(marker + " ");
                  fs = split.join("");
                }
                while (fs.includes("#drawbuffer")) {
                  fs = fs.split("\n");
                  for (let i = 0; i < fs.length; i++) {
                    if (fs[i].includes("#drawbuffer")) {
                      fs[i] = "";
                    }
                  }
                  fs = fs.join("\n");
                }
                shader.fragmentShader = fs;
              };
              let applyShadow = (shader, bool) => {
                let fs = shader.fragmentShader;
                if (fs) {
                  while (fs.includes("#applyShadow")) {
                    fs = fs.split("\n");
                    for (let i = 0; i < fs.length; i++) {
                      if (bool) {
                        if (fs[i].includes("#applyShadow")) {
                          fs[i] = fs[i].replace("#applyShadow", "");
                        }
                      } else if (fs[i].includes("#applyShadow")) {
                        fs[i] = "";
                      }
                    }
                    fs = fs.join("\n");
                  }
                  shader.fragmentShader = fs;
                }
              };
              mesh.shader._fragmentShader ||= mesh.shader.fragmentShader;
              modifyShader(mesh.shader, "Color");
              let shader = mesh.shader.clone(!_this.renderShadows, `-${_this.name || _name}`);
              modifyShader(shader, _this.name || _name);
              applyShadow(shader, _this.renderShadows);
              applyShadow(mesh.shader, true);
              mesh.shader.copyUniformsTo(shader, true);
              mesh.shader = shader;
            })(clone);
          }
          while (clone.children.length) {
            clone.remove(clone.children[0]);
          }
          return clone;
        }
        if (object.shader && object.shader.fragmentShader) {
          (function editDBShader(mesh) {
            const WEBGL2 = Renderer.type == Renderer.WEBGL2;
            let modifyMarker = (fs, name, index) => {
              if (WEBGL2) {
                if (fs.includes("layout(location=0) out vec4 reflectionsData")) {
                  return fs;
                }
                if (!fs.includes(`layout(location=${index})`)) {
                  let mainAt = (fs = fs.replace("out vec4 FragColor;", "")).indexOf("void main()");
                  let before = fs.slice(0, mainAt);
                  let after = fs.slice(mainAt);
                  fs = `${before}layout(location=${index}) out vec4 ${name};\n${after}`;
                }
              }
              let marker = "#drawbuffer " + name;
              if (fs.includes(marker)) {
                let split = fs.split(marker + " ");
                let finalOut = WEBGL2 ? name : `gl_FragData[${index}]`;
                for (let i = 1; i < split.length; ++i) {
                  split[i] = split[i].replace("gl_FragColor", finalOut);
                }
                fs = split.join("");
              }
              while (fs.includes("#applyShadow")) {
                fs = fs.split("\n");
                for (let i = 0; i < fs.length; i++) {
                  if (fs[i].includes("#applyShadow")) {
                    fs[i] = fs[i].replace("#applyShadow", "");
                  }
                }
                fs = fs.join("\n");
              }
              return fs;
            };
            let shader = mesh.shader;
            let fs = shader.fragmentShader;
            let name = _this.name || _name;
            if (!WEBGL2 || !fs.includes("location=0")) {
              fs = modifyMarker(fs, "Color", 0);
            }
            fs = modifyMarker(fs, name, _textureIndex);
            shader.fragmentShader = fs;
          })(object);
          object.shader._attachmentData = {
            format: _this.rtFormat,
            type: _this.rtType,
            attachments: _parentNuke.attachments
          };
        }
      }
    };
    this.removeObject = function (object) {
      if (_nuke) {
        _scene.remove(object["clone_" + _id]);
        _objects.remove(object);
        delete object["clone_" + _id];
      }
    };
    this.render = this.draw = function (stage, camera) {
      if (!_nuke || !_this.enabled || _useDrawBuffers) {
        return;
      }
      if (!_parentNuke.enabled || !_objects.length) {
        return;
      }
      const oldClear = Renderer.CLEAR;
      Renderer.CLEAR = CLEAR_COLOR;
      if (stage) {
        _nuke.stage = stage;
        _this.setSize(stage.width, stage.height);
      }
      _nuke.camera = camera || _nuke.parentNuke.camera;
      if (!_this.renderShadows) {
        _nuke.renderer.overridePreventShadows = true;
      }
      for (let i = _objects.length - 1; i > -1; i--) {
        let obj = _objects[i];
        let clone = obj["clone_" + _id];
        if (_this.forceVisible) {
          clone.visible = true;
        } else {
          clone.visible = obj.determineVisible();
        }
        if (clone.visible) {
          obj.updateMatrixWorld();
          if (!obj.ignoreMatrix) {
            Utils3D.decompose(obj, clone);
          }
        }
      }
      _nuke.rtt = _rt;
      _nuke.render();
      RenderStats.update("FXLayer");
      _nuke.renderer.overridePreventShadows = false;
      Renderer.CLEAR = oldClear;
    };
    this.addPass = function (pass) {
      if (_nuke) {
        _nuke.add(pass);
      }
    };
    this.removePass = function (pass) {
      if (_nuke) {
        _nuke.remove(pass);
      }
    };
    this.setSize = function (width, height) {
      if (_nuke) {
        if (_rt.width != width || _rt.height != height) {
          _this.events.unsub(Events.RESIZE, resizeHandler);
          if (_rt) {
            _rt.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr);
          }
          _nuke.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr);
        }
      }
    };
    this.setDPR = function (dpr) {
      if (_nuke) {
        _nuke.dpr = dpr;
        resizeHandler();
      }
    };
    this.setResolution = function (res) {
      _this.resolution = res;
      resizeHandler();
    };
    this.getObjects = function () {
      return _objects;
    };
    this.useRT = function (rt) {
      _rt = _this.rt = rt;
    };
    this.getName = function () {
      return _this.name || _name;
    };
    if (_parentNuke instanceof Nuke) {
      this.create(_parentNuke, _type);
    }
  });
  Namespace("FX");
  Class(function FXScene(_parentNuke, _type, ...rest) {
    Inherit(this, Component);
    var _nuke;
    var _rt;
    var _rtPool;
    var _showManualRenderWarning;
    var _this = this;
    var _scene = new Scene();
    var _id = Utils.timestamp();
    var _objects = [];
    var _renderTime = Render.TIME;
    var _visible = true;
    function resizeHandler() {
      if (_rt.setSize) {
        _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr);
      }
      _this.nuke.setSize(_rt.width, _rt.height);
      _this.width = _rt.width;
      _this.height = _rt.height;
    }
    this.resolution = 1;
    this.autoVisible = true;
    this.enabled = true;
    this.scene = _scene;
    this.renderShadows = true;
    this.set("visible", v => {
      if (_this.scene) {
        _this.scene.visible = _visible = v;
        _this.onFXSceneVisibility?.(v);
      }
    });
    this.get("visible", _ => _visible);
    this.onInvisible = this.fxInvisible = function () {
      if (this.scene.visible) {
        this.scene.visible = false;
        _this.flag("needsOnVisible", true);
      }
      if (_rtPool) {
        _rtPool.putRT(_this.rt);
      }
    };
    this._bindOnDestroy(function () {
      if (_rtPool) {
        _rtPool.putRT(_this.rt);
      }
    });
    this.onVisible = this.fxVisible = function () {
      if (_this.flag("needsOnVisible")) {
        this.scene.visible = true;
        _this.flag("needsOnVisible", false);
      }
      if (_rtPool) {
        _this.useRT(_rtPool.getRT());
        resizeHandler();
      }
    };
    this.create = function (nuke = World.NUKE, rt, options) {
      if (!_this.nuke) {
        if (rt instanceof RTPool) {
          rt = (_rtPool = rt).nullRT;
        }
        if (nuke instanceof RTPool) {
          options = rt;
          rt = (_rtPool = nuke).nullRT;
          nuke = World.NUKE;
        } else if (rt && typeof rt == "object") {
          if (!rt.isRT) {
            options = rt;
            rt = undefined;
          }
        } else if (!!nuke && !(nuke instanceof Nuke)) {
          options = nuke;
          nuke = World.NUKE;
        }
        options ||= {};
        _this.rtFormat = options.format || Texture.RGBFormat;
        _this.rtType = options.type || Texture.UNSIGNED_BYTE;
        if (options.vr) {
          _this.vrRT = RenderManager.type == RenderManager.VR;
        }
        if (options.parentNuke) {
          nuke = options.parentNuke;
        }
        (_this = this).scene = _scene;
        _this.nuke = _nuke = _this.initClass(Nuke, nuke.stage, {
          renderer: nuke.renderer,
          camera: nuke.camera,
          scene: _scene,
          dpr: nuke.dpr,
          format: options.format,
          vrRT: _this.vrRT,
          multisample: options.multisample,
          samplesAmount: options.samplesAmount
        });
        _scene.nuke = _nuke;
        (function initRT(rt, options = {}) {
          if (options.type == Texture.FLOAT) {
            options.format = Texture.RGBAFormat;
            if (Device.system.os == "ios") {
              options.type = Texture.HALF_FLOAT;
              options.minFilter = Texture.NEAREST;
              options.magFilter = Texture.NEAREST;
            }
          }
          const RT = _this.nuke.useDrawBuffers && options.multiRenderTarget ? MultiRenderTarget : RenderTarget;
          _this.width = _nuke.stage.width * _this.resolution * _nuke.dpr;
          _this.height = _nuke.stage.height * _this.resolution * _nuke.dpr;
          let filter = options.mipmaps ? Texture.LINEAR_MIPMAP : Texture.LINEAR;
          _rt = rt || new RT(_this.width, _this.height, Object.assign({
            minFilter: filter,
            magFilter: filter,
            generateMipmaps: options.mipmaps || false
          }, options));
          _nuke.rtt = _this.rt = _rt;
          _rt.fxscene = _this;
          if (_this.vrRT) {
            _rt.vrRT = true;
          }
        })(rt, options);
        if (rt) {
          _this.flag("recycle_rt", true);
        } else {
          (function addListeners() {
            _this.events.sub(Events.RESIZE, resizeHandler);
          })();
        }
        if (FXScene.onCreate) {
          FXScene.onCreate(_this);
        }
        if (!options.manualRender && !_this.manualRender && !FXScene.manualRender) {
          if (Hydra.LOCAL) {
            _showManualRenderWarning = true;
          }
          if (_this.vrRT) {
            _this.startRender(({
              view: view
            }) => {
              if (view === 0) {
                _this.draw();
              }
            }, RenderManager.EYE_RENDER);
          } else {
            _this.startRender(_ => {
              _this.draw();
            }, nuke);
          }
        }
      }
    };
    this.onDestroy = this.fxDestroy = function () {
      _this.scene.deleted = true;
      if (_this.flag("recycle_rt")) {
        if (_rtPool && _rt) {
          _rtPool.putRT(_rt);
        }
      } else if (_rt && _rt.destroy) {
        _rt.destroy();
      }
    };
    this.setSize = function (width, height, exact) {
      if (_nuke) {
        if (!exact) {
          width = width * _this.resolution * _nuke.dpr;
          height = height * _this.resolution * _nuke.dpr;
        }
        if (_rt.width != width || _rt.height != height) {
          _this.events.unsub(Events.RESIZE, resizeHandler);
          _this.width = width;
          _this.height = height;
          if (_rt) {
            _rt.setSize(_this.width, _this.height);
          }
          _nuke.setSize(_this.width, _this.height);
        }
      }
    };
    this.add = this.addObject = function (object) {
      if (!object) {
        return console.error("FXScene addObject undefined!");
      }
      let clone = object.clone();
      object["clone_" + _id] = clone;
      _scene.add(clone);
      _objects.push(object);
      object.shader._attachmentData = {
        format: _this.rtFormat,
        type: _this.rtType,
        attachments: 1
      };
      while (clone.children.length) {
        clone.remove(clone.children[0]);
      }
      return clone;
    };
    this.removeObject = function (object) {
      _scene.remove(object["clone_" + _id]);
      _objects.remove(object);
      delete object["clone_" + _id];
    };
    this.setScissor = function (x, y, w, h) {
      this.scissor ||= new Vector4();
      this.scissor.x = x * _this.width;
      this.scissor.y = _this.height - h * _this.height - y * _this.height;
      this.scissor.width = w * _this.width;
      this.scissor.height = h * _this.height;
      this.rt.scissor = this.scissor;
    };
    this.render = this.draw = function (stage, camera) {
      if (_this.preventRender) {
        return;
      }
      if (_this.isVrWorldMode) {
        if (_this.onBeforeRender) {
          _this.onBeforeRender();
        }
        return;
      }
      if (_showManualRenderWarning && Render.TIME - _renderTime < 1000 / Render.REFRESH_RATE / 2) {
        console.warn(`FXScene ${Utils.getConstructorName(_this)} rendering early (${Math.round(Render.TIME - _renderTime, 3)}ms elapsed, expected ~${Math.round(1000 / Render.REFRESH_RATE, 3)}ms. Set manualRender option if using own render loop.`);
        _showManualRenderWarning = false;
      }
      _renderTime = Render.TIME;
      if (_this.isVrSceneMode) {
        let rt = World.NUKE.enabled && World.NUKE.passes.length ? World.NUKE.rttBuffer : undefined;
        let autoClear = _nuke.renderer.autoClear;
        _nuke.renderer.autoClear = false;
        _nuke.renderer.clearDepth(rt);
        if (_this.onBeforeRender) {
          _this.onBeforeRender();
        }
        _nuke.renderer.render(_scene, _nuke.camera, rt);
        _nuke.renderer.autoClear = autoClear;
        return;
      }
      if (stage) {
        _this.events.unsub(Events.RESIZE, resizeHandler);
        _this.nuke.stage = stage;
        _this.setSize(stage.width, stage.height);
      }
      if (camera) {
        _this.nuke.camera = camera;
      }
      let clearColor = null;
      let alpha = 1;
      if (_this.clearColor) {
        clearColor = _nuke.renderer.getClearColor().getHex();
        _nuke.renderer.setClearColor(_this.clearColor);
      }
      if (_this.clearAlpha > -1) {
        alpha = _nuke.renderer.getClearAlpha();
        _nuke.renderer.setClearAlpha(_this.clearAlpha);
      }
      if (!_this.renderShadows) {
        _nuke.renderer.overridePreventShadows = true;
      }
      for (let i = _objects.length - 1; i > -1; i--) {
        let obj = _objects[i];
        let clone = obj["clone_" + _id];
        if (_this.forceVisible || obj.cloneVisible) {
          clone.visible = typeof clone.isVisible != "boolean" || clone.isVisible;
        } else {
          clone.visible = obj.determineVisible();
        }
        if (clone.visible) {
          obj.updateMatrixWorld(obj.visible === false || undefined);
          if (!obj.ignoreMatrix) {
            Utils3D.decompose(obj, clone);
            if (clone.overrideScale) {
              clone.scale.setScalar(clone.overrideScale);
            }
          }
        }
      }
      if (!_this.preventRTDraw) {
        RenderStats.update("FXScene", 1, _this);
        if (_this.onBeforeRender) {
          _this.onBeforeRender();
        }
        _nuke.rtt = _rt;
        _nuke.render();
      }
      _nuke.renderer.overridePreventShadows = false;
      if (_this.clearColor) {
        _nuke.renderer.setClearColor(clearColor);
      }
      if (_this.clearAlpha > -1) {
        _nuke.renderer.setClearAlpha(_this.clearAlpha);
      }
      RenderManager.fire(_this);
    };
    this.setDPR = function (dpr) {
      if (_nuke) {
        _nuke.dpr = dpr;
        resizeHandler();
        return _this;
      } else {
        return _this;
      }
    };
    this.addPass = function (pass) {
      if (_nuke) {
        _nuke.add(pass);
      }
    };
    this.removePass = function (pass) {
      if (_nuke) {
        _nuke.remove(pass);
      }
    };
    this.setResolution = function (res) {
      _this.resolution = res;
      resizeHandler();
      return this;
    };
    this.useRT = function (rt) {
      _rt = _this.rt = rt;
      if (_this.vrRT) {
        rt.vrRT = true;
      }
    };
    this.upload = function () {
      if (_rt) {
        _rt.upload();
      }
    };
    this.useCamera = function (camera) {
      _this.nuke.camera = camera.camera || camera;
    };
    this.useScene = function (scene) {
      _this.nuke.scene = scene;
    };
    this.vrWorldMode = function () {
      _this.isVrWorldMode = true;
      _this.group = new Group();
      for (let i = 0; i < this.scene.children.length; i++) {
        this.group.add(this.scene.children[i]);
      }
      _scene = _this.scene = _this.group;
      World.SCENE.add(_this.group);
    };
    this.vrSceneMode = function () {
      _this.isVrSceneMode = true;
      World.NUKE.autoClear = false;
      RenderManager.renderer.autoClear = false;
    };
    this.createDepthTexture = function (useRTTBuffer) {
      if (!_this.depthTexture) {
        if (_this.nuke.passes.length || useRTTBuffer) {
          _this.nuke.rttBuffer.createDepthTexture();
          _this.depthTexture = _this.nuke.rttBuffer.depth;
        } else {
          _this.rt.createDepthTexture();
          _this.depthTexture = _this.rt.depth;
        }
      }
      return _this.depthTexture;
    };
    if (_parentNuke instanceof Nuke) {
      this.create(_parentNuke, _type, ...rest);
    }
  });
  Class(function FXSceneCompositor(_shader, _options = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var _basicShader;
    function decorateShader(shader) {
      shader.addUniforms({
        tFrom: {
          value: null
        },
        tTo: {
          value: null
        },
        uTransition: {
          value: 0
        }
      });
    }
    function loop() {
      _this.mesh.shader = _shader.uniforms.uTransition.value > 0 ? _shader : _basicShader;
      if (_shader.uniforms.uTransition.value >= 1) {
        _this.mesh.shader = _basicShader;
        _basicShader.set("tMap", _shader.get("tTo"));
        _shader.set("uTransition", 0);
      }
    }
    (function initOptions() {
      if (_options === null || _options instanceof Texture || _options.texture || _options.rt && _options.rt.texture) {
        _options = {
          startTexture: _options
        };
      }
    })();
    decorateShader(_shader);
    (function initMesh() {
      let uniforms = {
        tMap: {
          value: _options.startTexture || null
        }
      };
      if (_options.basicShader) {
        (_basicShader = _options.basicShader).addUniforms(uniforms);
      } else {
        _basicShader = _this.initClass(Shader, "ScreenQuad", uniforms);
      }
      _this.mesh = new Mesh(World.QUAD, _basicShader);
      _this.mesh.frustumCulled = false;
      _this.add(_this.mesh);
    })();
    _this.startRender(loop);
    this.useShader = function (shader) {
      _shader = shader;
      decorateShader(shader);
    };
    this.useBasicShader = function (shader) {
      _basicShader.copyUniformsTo(shader, true);
      _basicShader = shader;
    };
    this.swap = function (showTransition) {
      if (showTransition) {
        _this.mesh.shader = _shader;
      } else {
        _basicShader.set("tMap", _shader.get("tTo"));
        _this.mesh.shader = _basicShader;
        _shader.set("tFrom", _basicShader.get("tMap"));
      }
    };
    this.set("manual", v => {
      if (v) {
        _this.stopRender(loop);
      } else {
        _this.startRender(loop);
      }
    });
    this.transition = async function (texture, time, ease, delay) {
      let from = _shader.get("tFrom");
      _shader.set("tTo", texture);
      texture.visible = true;
      if (from) {
        await _shader.tween("uTransition", 1, time, ease, delay).promise();
      } else {
        _shader.set("uTransition", 1);
      }
      if (from) {
        from.visible = false;
      }
      _shader.set("tFrom", texture);
    };
  });
  Class(function BlitPass(_forceNuke) {
    Inherit(this, NukePass);
    this.uniforms = {};
    this.init("BlitPass");
    if (!_forceNuke) {
      this.blitFramebuffer = true;
    }
  });
  Class(function Nuke(_stage, _params) {
    Inherit(this, Component);
    var _width;
    var _height;
    var _nukeMesh;
    var _this = this;
    if (!_params.renderer) {
      console.error("Nuke :: Must define renderer");
    }
    _this.stage = _stage;
    _this.renderer = _params.renderer;
    _this.camera = _params.camera;
    _this.scene = _params.scene;
    _this.rtt = _params.rtt;
    _this.enabled = _params.enabled != 0;
    _this.passes = _params.passes || [];
    _this.format = _params.format || Texture.RGBFormat;
    _this.useDrawBuffers = !Utils.query("noDrawBuffers") && !Nuke.NO_DRAWBUFFERS && (_params.useDrawBuffers !== undefined ? _params.useDrawBuffers : Renderer.type == Renderer.WEBGL2 || !!window.Metal);
    var _rttPing;
    var _rttPong;
    var _rttBuffer;
    var _dpr = _params.dpr || 1;
    var _drawBuffers = [];
    var _enabledPasses = [];
    var _multisample = _params.multisample || false;
    var _samplesAmount = _params.samplesAmount || 4;
    function resizeHandler() {
      var width = _this.stage.width * _dpr;
      var height = _this.stage.height * _dpr;
      _rttPing.setSize(width, height);
      _rttPong.setSize(width, height);
      _rttBuffer.setSize(width, height);
      Nuke.renameRT(_width, _height, width, height, false, 1, _this.format, false, _samplesAmount);
      Nuke.renameRT(_width, _height, width, height, false, 2, _this.format, false, _samplesAmount);
      Nuke.renameRT(_width, _height, width, height, _this.useDrawBuffers, -1, _this.format, _multisample, _samplesAmount);
      _width = width;
      _height = height;
    }
    _this.scene.nuke = _this;
    (function initDefaultPass() {
      if (Nuke.defaultPass) {
        return;
      }
      let upload = (Nuke.defaultPass = new BlitPass()).upload;
      Nuke.defaultPass.upload = function () {
        upload.apply(this, arguments);
        Nuke.defaultPass.uploaded = true;
      };
    })();
    (function initNuke() {
      let width = _this.stage.width * _dpr;
      let height = _this.stage.height * _dpr;
      _rttPing = Nuke.getRT(width, height, false, 1, _this.format, false, _samplesAmount);
      _rttPong = Nuke.getRT(width, height, false, 2, _this.format, false, _samplesAmount);
      _rttBuffer = Nuke.getRT(width, height, _this.useDrawBuffers, -1, _this.format, _multisample, _samplesAmount);
      (_nukeMesh = new Mesh(World.QUAD, null)).frustumCulled = false;
      _nukeMesh.noMatrices = true;
      _nukeMesh.transient = true;
      _width = width;
      _height = height;
      if (_params.vrRT) {
        _this.vrRT = true;
        _rttBuffer.vrRT = true;
      }
    })();
    (function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
    })();
    _this.onBeforeShaderCompile = function (obj) {
      if (!obj) {
        return;
      }
      let shader = obj.shader;
      if (!shader || !shader.fragmentShader || !_this.useDrawBuffers || !_drawBuffers.length) {
        return;
      }
      const WEBGL2 = Renderer.type == Renderer.WEBGL2;
      let matched = false;
      _drawBuffers.forEach((t, i) => {
        let name = t.fxLayer.getName();
        if (!(WEBGL2 ? new RegExp(`\\b${name}\\s*=`) : new RegExp(`\\bgl_FragData\\[${i + 1}\\]\\s*=`)).test(shader.fragmentShader) && _this.useDrawBuffers) {
          let fs = shader.fragmentShader;
          if (!fs.includes(`#drawbuffer ${name} gl_FragColor`)) {
            let idx = fs.lastIndexOf("}");
            fs = `${fs.slice(0, idx)}#drawbuffer ${name} gl_FragColor = vec4(0.0);\n${fs.slice(idx)}`;
            shader.fragmentShader = fs;
          }
          t.fxLayer.add(obj);
          matched = true;
        }
      });
      if (!(WEBGL2 ? /\bColor\s*=/ : /\bgl_FragData\[0\]\s*=/).test(shader.fragmentShader)) {
        let fs = shader.fragmentShader;
        if (!fs.includes("layout(location=0) out vec4 reflectionsData")) {
          if (!WEBGL2) {
            fs = "#extension GL_EXT_draw_buffers : require\n" + fs;
          }
          fs = fs.split("void main() {");
          fs = fs[0] + "void main() {\nvec4 tmpFragColor;\n" + fs[1];
          fs = fs.replace(/gl_FragColor/g, "tmpFragColor");
          let idx = fs.lastIndexOf("}");
          fs = matched ? WEBGL2 ? fs.slice(0, idx) + "Color = tmpFragColor;\n" + fs.slice(idx) : fs.slice(0, idx) + "gl_FragData[0] = tmpFragColor;\n" + fs.slice(idx) : fs.slice(0, idx) + "#drawbuffer Color gl_FragColor = tmpFragColor;\n" + fs.slice(idx);
        }
        shader.fragmentShader = fs;
      }
      shader.onBeforePrecompilePromise.resolve();
    };
    _this.add = function (pass, index) {
      if (typeof index != "number") {
        _this.passes.push(pass);
      } else {
        _this.passes.splice(index, 0, pass);
      }
    };
    _this.remove = function (pass) {
      if (typeof pass == "number") {
        _this.passes.splice(pass);
      } else {
        _this.passes.remove(pass);
      }
    };
    _this.render = function (directCallback) {
      RenderStats.update("Nuke");
      RenderManager.fire(_this);
      _this.events.fire(Nuke.RENDER, _this, true);
      if (_this.onBeforeRender) {
        _this.onBeforeRender();
      }
      let count = _this.passes.length;
      _enabledPasses.length = 0;
      for (let i = 0; i < count; i++) {
        let pass = _this.passes[i];
        if (!pass.disabled) {
          _enabledPasses.push(pass);
        }
      }
      if (_this.enabled && _enabledPasses.length === 0 && !_this.rtt && (_dpr !== Device.pixelRatio || _multisample) && Nuke.defaultPass) {
        _enabledPasses.push(Nuke.defaultPass);
      }
      if (!_this.enabled || !_enabledPasses.length) {
        let autoClear = _this.renderer.autoClear;
        if (_this.autoClear == 0) {
          _this.renderer.autoClear = false;
        }
        _this.renderer.render(_this.scene, _this.camera, _this.rtt, null, directCallback);
        if (_this.onBeforeProcess) {
          _this.onBeforeProcess();
        }
        _this.events.fire(Nuke.BEFORE_PASSES, _this, true);
        _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, true);
        if (_this.postRender) {
          _this.postRender();
        }
        _this.events.fire(Nuke.POST_RENDER, _this, true);
        if (_this.autoClear == 0) {
          _this.renderer.autoClear = autoClear;
          _this.renderer.clearColor();
        }
        return;
      }
      RenderStats.update("NukePass", _enabledPasses.length);
      _this.hasRendered = true;
      if (_this.onBeforeProcess) {
        _this.onBeforeProcess();
      }
      let autoClear = _this.renderer.autoClear;
      if (_this.autoClear == 0) {
        _this.renderer.autoClear = false;
      }
      if (!_this.preventNewRender) {
        _this.renderer.render(_this.scene, _this.camera, _rttBuffer);
      }
      if (_this.autoClear == 0) {
        _this.renderer.autoClear = autoClear;
      }
      let pingPong = true;
      let skipMultisample = _this.rtt && _this.rtt.multisample;
      if (skipMultisample) {
        _this.rtt.multisample = false;
      }
      count = _enabledPasses.length;
      _this.events.fire(Nuke.BEFORE_PASSES, _this, true);
      for (var i = 0; i < count; i++) {
        let shader = _enabledPasses[i].pass;
        let inTexture = i === 0 ? _rttBuffer.texture : pingPong ? _rttPing.texture : _rttPong.texture;
        let outTexture = pingPong ? _rttPong : _rttPing;
        if (i === count - 1) {
          outTexture = _this.rtt;
        }
        _nukeMesh.shader = shader;
        _nukeMesh.shader.depthTest = false;
        _nukeMesh.shader.depthWrite = false;
        _nukeMesh.shader.uniforms.tDiffuse.value = inTexture;
        _this.renderer.renderSingle(_nukeMesh, _this.camera || World.CAMERA, outTexture, i === count - 1 ? directCallback : null);
        _enabledPasses[i]?.onRenderCallBack?.();
        pingPong = !pingPong;
      }
      if (skipMultisample) {
        _this.rtt.multisample = true;
      }
      _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, true);
      if (_this.postRender) {
        _this.postRender();
      }
      _this.events.fire(Nuke.POST_RENDER, _this, true);
      if (_this.autoClear == 0) {
        _this.renderer.clearColor(_rttBuffer);
      }
    };
    _this.setSize = function (width, height) {
      if (width != _width || height != _height) {
        _width = width;
        _height = height;
        resizeHandler();
        _this.events.unsub(Events.RESIZE, resizeHandler);
      }
    };
    _this.attachDrawBuffer = function (texture) {
      if (_this.hasRendered) {
        console.warn("Attempt to attach draw buffer after first render! Create FXLayer instance before first render.");
      }
      _drawBuffers.push(texture);
      if (_rttBuffer && _rttBuffer.attachments) {
        _rttBuffer.attachments = [_this.rtt && _this.rtt.attachments ? _this.rtt.attachments[0] : _rttBuffer.attachments[0]];
        for (let i = 0; i < _drawBuffers.length; i++) {
          _rttBuffer.attachments.push(_drawBuffers[i]);
          if (_this.rtt && _this.rtt.attachments) {
            _this.rtt.attachments.push(_drawBuffers[i]);
          }
        }
      }
      return _drawBuffers.length;
    };
    _this.upload = function () {
      if (_this.passes.length && _this.enabled) {
        _rttPing.upload();
        _rttPong.upload();
        _rttBuffer.upload();
      }
      if (_rttBuffer.depth) {
        _rttBuffer.depth.upload();
      }
      if (_this.rtt) {
        _this.rtt.upload();
      }
    };
    _this.set("dpr", function (v) {
      _dpr = v;
      resizeHandler();
    });
    _this.get("dpr", function () {
      return _dpr;
    });
    _this.get("output", function () {
      if (_nukeMesh.shader && _nukeMesh.shader.uniforms) {
        return _nukeMesh.shader.uniforms.tDiffuse.value;
      } else {
        return null;
      }
    });
    _this.get("rttBuffer", function () {
      return _rttBuffer;
    });
    this.set("rttBuffer", function (v) {
      _rttBuffer = v;
    });
    _this.get("prevFrameRT", function () {
      if (_rttBuffer && _rttBuffer.texture) {
        return _rttBuffer.texture;
      } else {
        return null;
      }
    });
    _this.get("nukeScene", function () {
      return _nukeScene;
    });
    _this.get("ping", function () {
      return _rttPing;
    });
    _this.get("pong", function () {
      return _rttPong;
    });
    _this.get("attachments", function () {
      if (_rttBuffer.attachments) {
        return _rttBuffer.attachments.length;
      } else {
        return 0;
      }
    });
    this.onDestroy = function () {
      _rttBuffer.destroy();
    };
    this.clearMemory = function () {
      _rttBuffer.destroy();
      _rttPing.destroy();
      _rttPong.destroy();
    };
  }, function () {
    Nuke.RENDER = "nuke_render";
    Nuke.BEFORE_PASSES = "nuke_before_passes";
    Nuke.BEFORE_POST_RENDER = "nuke_before_post_render";
    Nuke.POST_RENDER = "nuke_post_render";
    var _rts = {};
    Nuke.getRT = function (width, height, multi, index, format, multisample, samplesAmount) {
      let rt;
      let exists = _rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`];
      return exists || (rt = multi ? Utils3D.createMultiRT(width, height, undefined, format, multisample, samplesAmount) : Utils3D.createRT(width, height, undefined, format, multisample, samplesAmount), Nuke.recyclePingPong && (_rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`] = rt), rt);
    };
    Nuke.renameRT = function (prevWidth, prevHeight, width, height, multi, index, format, multisample, samplesAmount) {
      _rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`] = _rts[`${prevWidth}_${prevHeight}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`];
    };
  });
  Class(function NukePass(_fs, _uniforms, _pass) {
    Inherit(this, Component);
    var _this = this;
    if (typeof _fs == "object") {
      let shader = _fs.shader;
      _uniforms = _fs.uniforms;
      _fs = shader;
    }
    this.UILPrefix = typeof _fs == "string" ? _fs : Utils.getConstructorName(_fs);
    this.init = function (fs, vs) {
      if (_this.pass) {
        return;
      }
      _this = this;
      if (!fs) {
        this.constructor.toString().match(/function ([^\(]+)/)[1];
      }
      if (Array.isArray(fs)) {
        fs.join("");
      }
      _this.uniforms = _uniforms || _this.uniforms || {};
      _this.uniforms.tDiffuse = {
        type: "t",
        value: null,
        ignoreUIL: true
      };
      if (_this.uniforms.unique) {
        _this.UILPrefix += "_" + _this.uniforms.unique + "_";
      }
      if (window.UILStorage) {
        for (let key in _this.uniforms) {
          if (key !== "unique") {
            _this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _this.uniforms[key].value) || _this.uniforms[key];
          }
        }
      }
      _this.pass = _this.initClass(Shader, vs || "NukePass", fs, Utils.mergeObject(_this.uniforms, {
        precision: "high"
      }), (code, type) => type == "fs" ? function prefix(code) {
        if (!code) {
          throw `No shader ${_fs} found`;
        }
        let pre = "";
        if (!code.includes("uniform sampler2D tDiffuse")) {
          pre += "uniform sampler2D tDiffuse;\n";
          pre += "varying vec2 vUv;\n";
        }
        return pre + code;
      }(code) : code);
      _this.uniforms = _this.pass.uniforms;
    };
    this.set = function (key, value) {
      TweenManager.clearTween(_this.uniforms[key]);
      _this.uniforms[key].value = value;
    };
    this.get = function (key) {
      if (_this.uniforms[key] === undefined) {
        return null;
      } else {
        return _this.uniforms[key].value;
      }
    };
    this.tween = function (key, value, time, ease, delay, callback, update) {
      return tween(_this.uniforms[key], {
        value: value
      }, time, ease, delay, callback, update);
    };
    this.clone = function () {
      if (!_this.pass) {
        _this.init(_fs);
      }
      return new NukePass(null, null, _this.pass.clone());
    };
    this.upload = function () {
      _this.pass.upload();
    };
    this.addUniforms = function (obj) {
      for (let key in obj) {
        _this.uniforms[key] = obj[key];
      }
    };
    if (typeof _fs == "string") {
      _this.init(_fs);
    } else if (_pass) {
      _this.pass = _pass;
      _this.uniforms = _pass.uniforms;
    }
  });
  Class(function Raycaster(_camera) {
    Inherit(this, Component);
    const _this = this;
    let _mouse = new Vector3();
    let _raycaster = new RayManager();
    function ascSort(a, b) {
      return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
      let obj = object;
      while (obj && _this.testVisibility) {
        if (obj.visible === false && !obj.forceRayVisible && obj.testVisibility !== false) {
          return;
        }
        obj = obj.parent;
      }
      if (object.raycast && (object.raycast(raycaster, intersects), recursive === true)) {
        let children = object.children;
        for (let i = 0, l = children.length; i < l; i++) {
          intersectObject(children[i], raycaster, intersects, true);
        }
      }
    }
    function intersect(objects) {
      if (!Array.isArray(objects)) {
        objects = [objects];
      }
      let intersects = [];
      objects.forEach(object => {
        intersectObject(object, _raycaster, intersects, false);
      });
      intersects.sort(ascSort);
      return intersects;
    }
    this.testVisibility = true;
    this.set("camera", function (camera) {
      _camera = camera;
    });
    this.set("pointsThreshold", function (value) {
      _raycaster.params.Points.threshold = value;
    });
    this.get("ray", () => _raycaster.ray);
    this.checkHit = function (objects, mouse, rect = Stage) {
      mouse = mouse || Mouse;
      _mouse.x = mouse.x / rect.width * 2 - 1;
      _mouse.y = -mouse.y / rect.height * 2 + 1;
      _raycaster.setFromCamera(_mouse, _camera);
      return intersect(objects);
    };
    this.checkFromValues = function (objects, origin, direction) {
      _raycaster.set(origin, direction, 0, Number.POSITIVE_INFINITY);
      return intersect(objects);
    };
  }, _ => {
    var _ray;
    var _map = new WeakMap();
    Raycaster.checkHit = function (objects, mouse) {
      _ray ||= new Raycaster(World.CAMERA);
      return _ray.checkHit(objects, mouse);
    };
    Raycaster.checkFromValues = function (objects, origin, direction) {
      _ray ||= new Raycaster(World.CAMERA);
      return _ray.checkFromValues(objects, origin, direction);
    };
    Raycaster.find = function (camera) {
      if (!_map.has(camera)) {
        let ray = new Raycaster(camera);
        _map.set(camera, ray);
      }
      return _map.get(camera);
    };
  });
  Class(function ScreenProjection(_camera) {
    Inherit(this, Component);
    var _v3 = new Vector3();
    var _v32 = new Vector3();
    var _value = new Vector3();
    _camera = _camera.camera || _camera;
    this.set("camera", function (v) {
      _camera = v.camera || v;
    });
    this.get("camera", _ => _camera);
    this.unproject = function (mouse, rect = Stage, distance = 1) {
      if (typeof rect == "number") {
        distance = rect;
        rect = Stage;
      }
      _v3.set(mouse.x / rect.width * 2 - 1, -mouse.y / rect.height * 2 + 1, 0.5);
      _v3.unproject(_camera);
      let pos = _camera.getWorldPosition();
      _v3.sub(pos).normalize().multiplyScalar(distance);
      _value.copy(pos).add(_v3);
      return _value;
    };
    this.project = function (pos, screen) {
      screen = screen || Stage;
      if (pos instanceof Base3D) {
        pos.updateMatrixWorld();
        _v32.set(0, 0, 0).setFromMatrixPosition(pos.matrixWorld);
      } else {
        _v32.copy(pos);
      }
      _v32.project(_camera);
      _v32.x = (_v32.x + 1) / 2 * screen.width;
      _v32.y = -(_v32.y - 1) / 2 * screen.height;
      return _v32;
    };
  }, _ => {
    var _screen;
    var _map = new WeakMap();
    ScreenProjection.unproject = function (mouse, distance) {
      _screen ||= new ScreenProjection(World.CAMERA);
      return _screen.unproject(mouse, distance);
    };
    ScreenProjection.project = function (pos, screen) {
      _screen ||= new ScreenProjection(World.CAMERA);
      return _screen.project(pos, screen);
    };
    ScreenProjection.find = function (camera) {
      if (!_map.has(camera)) {
        let projection = new ScreenProjection(camera);
        _map.set(camera, projection);
      }
      return _map.get(camera);
    };
  });
  Class(function Object3D() {
    Inherit(this, Component);
    var _this = this;
    var _visible = true;
    this.__element = true;
    this.group = new Group();
    this.group.classRef = this;
    this.add = function (child) {
      this.group.add(child.group || child);
    };
    this.remove = function (child) {
      if (child) {
        this.group.remove(child.group || child);
      }
    };
    this.onDestroy = function () {
      this.group.deleted = true;
      this.group.classRef = null;
      if (this.group && this.group._parent) {
        this.group._parent.remove(this.group);
      }
    };
    this.set("visible", v => _this.group.visible = _visible = v);
    this.get("visible", _ => _visible);
  });
  Class(function Utils3D() {
    const _this = this;
    var _emptyTexture;
    var _q;
    var _v3;
    var _v3b;
    var _v3c;
    var _m4;
    var _v4;
    var _supportsKtx1;
    var _textures = {};
    var _restorable = {};
    function getTexture(key, params, loadTexture) {
      if (!Device.graphics.webgl && !window.AURA) {
        let texture = new Texture();
        texture.promise = Promise.resolve();
        texture.dimensions = {
          width: 0,
          height: 0
        };
        return texture;
      }
      let restorable = _restorable[key];
      if (restorable) {
        restorable = restorable.deref();
        delete _restorable[key];
      }
      if (restorable) {
        restorable.restore();
      } else if (_textures[key]) {
        _textures[key].exists++;
      } else {
        let texture = new Texture();
        texture.exists = 1;
        texture.loaded = false;
        texture.promise = Promise.create();
        texture._destroy = texture.destroy;
        texture.destroy = function (force) {
          if (!!force || !texture.forcePersist && !(--texture.exists > 0)) {
            if (texture.exists || texture._image || texture._gl || _textures[key]) {
              delete _textures[key];
              RenderCount.remove(`tex_${texture?.dimensions?.width}_${texture?.dimensions?.height}`);
              RenderCount.remove("tex_" + (texture.compressed ? "compressed" : "uncompressed"));
              _restorable[key] = new WeakRef(this);
              this._destroy();
            }
          }
        };
        _textures[key] = texture;
        if (params.premultiplyAlpha === false) {
          texture.premultiplyAlpha = false;
        }
        if (_this.onTextureCreated) {
          _this.onTextureCreated(texture);
        }
        let doLoadTexture = async () => {
          try {
            await loadTexture(texture);
            texture.loaded = true;
            texture.needsReupload = true;
            RenderCount.add(`tex_${texture.dimensions.width}_${texture.dimensions.height}`);
            RenderCount.add("tex_" + (texture.compressed ? "compressed" : "uncompressed"));
            if (texture.onload) {
              texture.onload();
              texture.onload = null;
            }
            texture.promise.resolve();
          } catch (e) {
            texture.promise.reject(e);
          }
        };
        doLoadTexture(texture);
        texture.restore = function () {
          delete _restorable[key];
          texture.exists++;
          if (!_textures[key]) {
            texture.promise = Promise.create();
            texture.loaded = texture.needsReupload = false;
            _textures[key] = texture;
            doLoadTexture(texture);
          }
        };
      }
      return _textures[key];
    }
    function loadTextureSource(texture, path, params) {
      let promise = Promise.create();
      ImageDecoder.decode(path, params).then(imgBmp => {
        imgBmp.crossOrigin = "anonymous";
        texture.dimensions = {
          width: imgBmp.width,
          height: imgBmp.height
        };
        texture.loaded = true;
        texture.needsReupload = true;
        if (texture.compressed && !imgBmp.compressedData) {
          texture.compressed = false;
        }
        if (World.RENDERER.type !== Renderer.WEBGL2 && !Math.isPowerOf2(imgBmp.width, imgBmp.height)) {
          texture.minFilter = Texture.LINEAR;
          texture.generateMipmaps = false;
        }
        promise.resolve(imgBmp);
      }).catch(e => {
        promise.reject(e);
      });
      return promise;
    }
    function parseTexturePath(path) {
      if (path.includes("://")) {
        let guard = path.split("://");
        guard[1] = guard[1].replace(/\/\//g, "/");
        path = guard.join("://");
      } else {
        path = path.replace(/\/\//g, "/");
      }
      let compressed;
      let compressedIdentifier;
      let cacheBust;
      ({
        compressed: compressed,
        compressedIdentifier: compressedIdentifier,
        path: path
      } = parseCompressed(path));
      if (window.URLSearchParams) {
        if (path.includes("?")) {
          let [withoutQuery, query] = path.split("?");
          let params = new URLSearchParams(query);
          for (const [key, value] of params.entries()) {
            let check = key;
            if (key.includes("-compressedKtx")) {
              check = key.substring(0, key.indexOf("-compressedKtx"));
            }
            if (Number.isInteger(Number(check)) && Number(check) > 0 && value === "") {
              params.delete(key);
              if (check !== key && compressed) {
                withoutQuery += compressedIdentifier;
              }
              cacheBust = true;
            }
          }
          if (cacheBust) {
            path = withoutQuery;
            query = params.toString();
            if (query) {
              path += "?" + query;
            }
          }
        }
      } else if (path.includes("?")) {
        cacheBust = true;
        path = path.split("?")[0];
      }
      if (!Hydra.LOCAL) {
        cacheBust = false;
      }
      let imgPath = path;
      if (cacheBust) {
        imgPath += (imgPath.includes("?") ? "&" : "?") + Date.now();
      }
      if (compressed && !imgPath.includes("compressed")) {
        imgPath += compressedIdentifier;
      }
      return {
        plainPath: path,
        imgPath: imgPath,
        compressed: compressed
      };
    }
    function parseCompressed(path) {
      let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0];
      let compressed = false;
      if (compressedIdentifier) {
        if (!Utils.query("noKtx")) {
          if (compressedIdentifier.endsWith("2")) {
            if (typeof Ktx2Transcoder != "undefined") {
              compressed = "ktx2";
            }
          } else {
            compressed = "ktx1";
          }
        }
        path = path.replace(compressedIdentifier, "");
      }
      let requiresKtx = false;
      if (/\.ktx2(?:\?|#|$)/.test(path)) {
        compressed = "ktx2";
        compressedIdentifier = "";
        requiresKtx = true;
      }
      return {
        compressed: compressed,
        compressedIdentifier: compressedIdentifier,
        path: path,
        requiresKtx: requiresKtx
      };
    }
    function splitCubemapPath(url) {
      let path = url.replace(/-compressedKtx2?/, "").split(/[#?]/)[0];
      let match = /(\d+)(?!.*\d+)/.exec(path);
      if (!match) {
        throw new Error("Cubemap texture path must include a numeric pattern");
      }
      let prefix = url.substring(0, match.index);
      let pattern = match[1];
      return {
        prefix: prefix,
        pattern: pattern,
        suffix: url.substring(match.index + pattern.length),
        start: +pattern
      };
    }
    function getCubemapFacePaths(pathinfo) {
      let padChar;
      let {
        prefix: prefix,
        pattern: pattern,
        suffix: suffix,
        start: start
      } = pathinfo;
      if (pattern.length > String(start).length) {
        padChar = pattern.charAt(0);
      }
      return Array.from(Array(6).keys(), i => {
        let n = String(start + i);
        if (padChar) {
          n = n.padStart(pattern.length, padChar);
        }
        return `${prefix}${n}${suffix}`;
      });
    }
    window.Vec2 = window.Vector2;
    window.Vec3 = window.Vector3;
    this.localDebug = window.Hydra && Hydra.LOCAL;
    (async function () {
      await Hydra.ready();
      let threads = Thread.shared(true);
      for (let i = 0; i < threads.array.length; i++) {
        _this.loadEngineOnThread(threads.array[i]);
      }
    })();
    this.decompose = function (local, world) {
      local.decomposeCache ||= {
        position: new Vector3(),
        quaternion: new Quaternion(),
        scale: new Vector3()
      };
      if (local.decomposeDirty) {
        local.matrixWorld.decompose(local.decomposeCache.position, local.decomposeCache.quaternion, local.decomposeCache.scale);
        local.decomposeDirty = false;
      }
      world.position.copy(local.decomposeCache.position);
      world.quaternion.copy(local.decomposeCache.quaternion);
      world.scale.copy(local.decomposeCache.scale);
    };
    this.createDebug = function (size = 1, color) {
      return new Mesh(new IcosahedronGeometry(size, 1), _this.getTestShader(color));
    };
    this.getTestShader = function (color) {
      if (color) {
        return new Shader("ColorMaterial", {
          color: {
            value: color instanceof Color ? color : new Color(color)
          },
          alpha: {
            value: 1
          }
        });
      } else {
        return new Shader("TestMaterial");
      }
    };
    this.createMultiRT = function (width, height, type, format, multisample = false, samplesAmount = 4) {
      let rt = new MultiRenderTarget(width, height, {
        minFilter: Texture.LINEAR,
        magFilter: Texture.LINEAR,
        format: format || Texture.RGBFormat,
        type: type,
        multisample: multisample,
        samplesAmount: samplesAmount
      });
      rt.texture.generateMipmaps = false;
      return rt;
    };
    this.createRT = function (width, height, type, format, multisample = false, samplesAmount = 4) {
      let rt = new RenderTarget(width, height, {
        minFilter: Texture.LINEAR,
        magFilter: Texture.LINEAR,
        format: format || Texture.RGBFormat,
        type: type,
        multisample: multisample,
        samplesAmount: samplesAmount
      });
      rt.texture.generateMipmaps = false;
      return rt;
    };
    this.getFloatType = function () {
      if (Device.system.os == "android") {
        return Texture.FLOAT;
      } else {
        return Texture.HALF_FLOAT;
      }
    };
    this.getTexture = function (path, params = {}) {
      let {
        imgPath: imgPath,
        plainPath: plainPath,
        compressed: compressed
      } = parseTexturePath(path);
      return getTexture(plainPath, params, async texture => {
        texture.compressed = compressed;
        texture.format = plainPath.match(/\.jpe?g/) ? Texture.RGBFormat : Texture.RGBAFormat;
        texture.src = plainPath;
        let imgBmp = await loadTextureSource(texture, imgPath, params);
        texture.image = imgBmp;
        if (imgBmp.sizes && imgBmp.sizes.length === 1) {
          texture.minFilter = Texture.LINEAR;
        }
        if (params.findDominantColors) {
          texture.dominantColors = _this.findDominantColors(path);
        }
        texture.onUpdate = function () {
          if (!params.preserveData && imgBmp.close) {
            imgBmp.close();
          }
          texture.onUpdate = null;
        };
      });
    };
    this.getCubeTexture = function (paths, params = {}) {
      let parsed = (paths = function getCubePaths(url) {
        if (Array.isArray(url)) {
          return url;
        }
        let {
          compressed: compressed,
          compressedIdentifier: compressedIdentifier,
          path: path,
          requiresKtx: requiresKtx
        } = parseCompressed(url);
        if (requiresKtx) {
          return [path];
        }
        if (compressed === "ktx1") {
          if (_supportsKtx1 === undefined) {
            _supportsKtx1 = !!Renderer.extensions.s3tc || !!Renderer.extensions.etc1 || !!Renderer.extensions.pvrtc || !!Renderer.extensions.astc;
          }
          if (!_supportsKtx1) {
            compressed = false;
          }
        }
        if (!compressed && compressedIdentifier) {
          url = url.replace(compressedIdentifier, "");
        }
        let info = splitCubemapPath(url);
        if (compressed) {
          return [`${info.prefix}${info.suffix}`];
        }
        return getCubemapFacePaths(info);
      }(paths)).map(parseTexturePath);
      return getTexture(`cube:${parsed.map(({
        plainPath: plainPath
      }) => plainPath).join("|")}`, params, async texture => {
        texture.cube = await Promise.all(parsed.map(({
          imgPath: imgPath,
          compressed: compressed
        }) => {
          texture.compressed = compressed;
          texture.format = imgPath.match(/\.jpe?g/) ? Texture.RGBFormat : Texture.RGBAFormat;
          return loadTextureSource(texture, imgPath, params);
        }));
        if (!texture.compressed && texture.cube.length === 1) {
          texture.cube = [...Array(6).keys()].map(_ => texture.cube[0]);
        }
        if (texture.compressed && texture.cube[0].sizes.length === 1) {
          texture.minFilter = Texture.LINEAR;
        }
        texture.onUpdate = function () {
          if (!params.preserveData) {
            texture.cube.forEach(imgBmp => {
              if (imgBmp.close) {
                imgBmp.close();
              }
            });
          }
          texture.onUpdate = null;
        };
      });
    };
    this.splitCubemapPath = splitCubemapPath;
    this.getCubemapFacePaths = getCubemapFacePaths;
    this.getLookupTexture = function (path) {
      let texture = _this.getTexture(path);
      texture.minFilter = texture.magFilter = Texture.NEAREST;
      texture.generateMipmaps = false;
      return texture;
    };
    this.clearTextureCache = function () {
      for (let key in _textures) {
        _textures[key].destroy();
      }
      _textures = {};
    };
    this.makeDataTexturePowerOf2 = function (texture, itemSize) {
      let [maxDimension, minDimension] = [texture.width, texture.height].sort();
      maxDimension = Math.ceilPowerOf2(maxDimension);
      const totalLength = maxDimension * maxDimension * itemSize;
      const remainder = [];
      let j;
      for (let i = 0; i < totalLength - texture.data.length; i++) {
        j = i % texture.data.length;
        remainder.push(texture.data[j]);
      }
      const totalData = new Float32Array(totalLength);
      totalData.set(texture.data);
      totalData.set(remainder, texture.data.length);
      texture.data = totalData;
      texture.width = texture.height = maxDimension;
      texture.powerOfTwoScale = minDimension / maxDimension;
    };
    this.loadCurve = function (obj) {
      if (typeof obj == "string") {
        (obj = Assets.JSON[obj]).curves = obj.curves[0];
      }
      let data = obj.curves;
      let points = [];
      for (let j = 0; j < data.length; j += 3) {
        points.push(new Vector3(data[j + 0], data[j + 1], data[j + 2]));
      }
      if (typeof CatmullRomCurve == "undefined") {
        throw "loadCurve requires curve3d module";
      }
      return new CatmullRomCurve(points);
    };
    this.getEmptyTexture = function () {
      _emptyTexture ||= new Texture();
      return _emptyTexture;
    };
    this.getRepeatTexture = function (src, scale) {
      let texture = _this.getTexture(src, scale);
      texture.promise.then(_ => {
        if (!Math.isPowerOf2(texture.dimensions.width, texture.dimensions.height)) {
          console.warn(`getRepeatTexture :: ${src} not power of two!`);
        }
      });
      texture.wrapS = texture.wrapT = Texture.REPEAT;
      return texture;
    };
    this.findTexturesByPath = function (path) {
      let array = [];
      for (let key in _textures) {
        if (key.includes(path)) {
          array.push(_textures[key]);
        }
      }
      return array;
    };
    this.getHeightFromCamera = function (camera, dist) {
      camera = camera.camera || camera;
      dist ||= camera.position.length();
      let fov = camera.fov;
      return dist * 2 * Math.tan(Math.radians(fov) * 0.5);
    };
    this.getWidthFromCamera = function (camera, dist) {
      camera = camera.camera || camera;
      return _this.getHeightFromCamera(camera, dist) * camera.aspect;
    };
    this.getPositionFromCameraSize = function (camera, size) {
      camera = camera.camera || camera;
      let fov = Math.radians(camera.fov);
      return Math.abs(size / Math.sin(fov / 2));
    };
    this.loadEngineOnThread = function (thread) {
      ["Base3D", "CameraBase3D", "Mesh", "OrthographicCamera", "PerspectiveCamera", "Geometry", "GeometryAttribute", "Points", "Scene", "BoxGeometry", "CylinderGeometry", "PlaneGeometry", "PolyhedronGeometry", "IcosahedronGeometry", "SphereGeometry", "Box2", "Box3", "Face3", "Color", "Cylindrical", "Euler", "Frustum", "Line3", "Matrix3", "Matrix4", "Plane", "Quaternion", "Ray", "Sphere", "Spherical", "Triangle", "Vector2", "Vector3", "Vector4", "RayManager", "Vector3D", "Group"].forEach(name => {
        thread.importES6Class(name);
      });
      thread.importCode(`Class(${zUtils3D.constructor.toString()}, 'static')`);
    };
    this.billboard = function (mesh, camera = World.CAMERA) {
      _q ||= new Quaternion();
      _q.copy(camera.quaternion);
      if (mesh.customRotation) {
        mesh.quaternion.multiply(mesh.customRotation);
      }
      if (mesh._parent) {
        _q.premultiply(mesh._parent.getWorldQuaternion().inverse());
      }
      mesh.quaternion.copy(_q);
    };
    this.billboardYAxis = function (mesh, camera = World.CAMERA) {
      _q ||= new Quaternion();
      _q.copy(camera.quaternion);
      let angle = Math.atan2(_q.y, _q.w) + Math.PI;
      angle = -angle;
      _q.set(0, Math.sin(angle), 0, Math.cos(angle));
      if (mesh.customRotation) {
        mesh.quaternion.multiply(mesh.customRotation);
      }
      if (mesh._parent) {
        _q.premultiply(mesh._parent.getWorldQuaternion().inverse());
      }
      mesh.quaternion.copy(_q);
    };
    this.positionInFrontOfCamera = function (object, distance, alpha = 1, camera = World.CAMERA) {
      _v3 ||= new Vector3();
      _v3b ||= new Vector3();
      _m4 ||= new Matrix4();
      _q ||= new Quaternion();
      let cameraPosition = _v3b;
      let cameraQuaternion = _q;
      camera.updateMatrixWorld();
      camera.matrixWorld.decompose(cameraPosition, cameraQuaternion, _v3);
      _v3.set(0, 0, -distance).applyQuaternion(cameraQuaternion).add(cameraPosition);
      _m4.lookAt(cameraPosition, _v3, object.up);
      _q.setFromRotationMatrix(_m4);
      object.position.lerp(_v3, alpha);
      object.quaternion.slerp(_q, alpha);
    };
    this.getSignedQuaternionAngleToPlane = function (quaternion, direction, planeNormal, axis) {
      _v3c ||= new Vector3();
      let vector = _v3c.copy(direction).applyQuaternion(quaternion);
      return _this.getSignedAngleToPlane(vector, planeNormal, axis);
    };
    this.getSignedAngleToPlane = function (vector, planeNormal, axis) {
      _v3 ||= new Vector3();
      _v3b ||= new Vector3();
      let projected = _v3.copy(vector).projectOnPlane(planeNormal).normalize();
      if (projected.length() === 0) {
        return Math.PI / 2;
      }
      if (axis) {
        vector = _v3b.copy(vector).projectOnPlane(axis).normalize();
      } else {
        axis = _v3b.crossVectors(projected, planeNormal);
      }
      let dot = vector.dot(projected);
      let det = axis.dot(projected.cross(vector));
      return Math.atan2(det, dot);
    };
    this.getQuad = function () {
      let geom = new Geometry();
      let position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
      let uv = new Float32Array([0, 0, 2, 0, 0, 2]);
      geom.addAttribute("position", new GeometryAttribute(position, 3));
      geom.addAttribute("uv", new GeometryAttribute(uv, 2));
      return geom;
    };
    this.findParentCamera = function (group) {
      let parent = group.parent;
      while (parent) {
        if (parent.nuke) {
          return parent.nuke.camera;
        }
        parent = parent.parent;
      }
      return World.CAMERA;
    };
    this.cameraIntrinsicsToObject = function (camera, object) {
      object.fov = camera.fov;
      object.aspect = camera.aspect;
      object.near = camera.near;
      object.far = camera.far;
      if (!object.p) {
        object.p = [];
        object.q = [];
        object.projectionMatrix = [];
      }
      camera.getWorldPosition().toArray(object.p);
      camera.getWorldQuaternion().toArray(object.q);
      camera.projectionMatrix.toArray(object.projectionMatrix);
      object.width = Stage.width;
      object.height = Stage.height;
    };
    this.createFXLayer = function (name, nuke = World.NUKE, options) {
      let layer = new FXLayer(nuke, options);
      layer.name = name;
      return layer;
    };
    this.ensureAttributes = function (mesh) {
      const vs = Shaders.getShader(mesh.shader.vsName + ".vs");
      const attrib_regex = /attribute (\w+) (\w+);/g;
      const attribs = mesh.geometry.attributes;
      const firstCount = attribs[Object.keys(attribs)[0]].count;
      let attrib;
      while ((attrib = attrib_regex.exec(vs)) !== null) {
        const name = attrib[2];
        if (name && !attribs[name]) {
          const size = parseInt(attrib[1][attrib[1].length - 1]) || 1;
          mesh.geometry.addAttribute(name, new GeometryAttribute(new Float32Array(size * firstCount), size));
          mesh.geometry.needsUpdate = true;
        }
      }
    };
    this.findDominantColors = async function (path) {
      let colors = [new Color(), new Color(), new Color(), new Color()];
      let ready = Promise.create();
      fetch(Assets.getPath(path), {
        mode: "cors"
      }).then(async data => {
        let blob = await data.blob();
        let bitmap = await createImageBitmap(blob);
        let canvas = document.createElement("canvas");
        canvas.context = canvas.getContext("2d");
        canvas.width = Math.round(bitmap.width);
        canvas.height = Math.round(bitmap.height);
        ww = canvas.width;
        hh = canvas.height;
        canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        let imageData = canvas.context.getImageData(0, 0, canvas.width, canvas.height);
        imageData = imageData.data;
        let result = await ImageDecoder.parseColors(imageData);
        colors = result.colors.map(e => new Color(e.r, e.g, e.b));
        ready.resolve();
      }).catch(er => {
        ready.resolve();
      });
      await ready;
      return colors;
    };
    this.renderToTexture3D = function (texture, shader) {
      if (texture._renderTargets === undefined) {
        let depth = texture.depth / 4;
        texture._renderTargets = [];
        let offset = 0;
        for (let i = 0; i < depth; i++) {
          offset = i * 4;
          let renderTarget = new RenderTarget(texture.width, texture.height);
          renderTarget.texture = texture;
          renderTarget.indices = [offset, offset + 1, offset + 2, offset + 3];
          texture._renderTargets.push(renderTarget);
        }
        let mesh = new Mesh(World.QUAD, shader);
        texture._meshFor3D = mesh;
      }
      try {
        _v4 ||= new Vector4();
        texture._renderTargets.forEach(rt => {
          shader.set("indices", _v4.set(...rt.indices));
          World.RENDERER.renderSingle(texture._meshFor3D, World.CAMERA, rt);
        });
      } catch (e) {
        console.warn("the 3d texture can not be updated correctly, the shader requires the indices uniform to be declared");
      }
    };
  }, "static");
  if (window.WebGLRenderingContext) {
    (function () {
      "use strict";
  
      var e = {};
      function r(r, t) {
        var i;
        e[r] = true;
        if (t !== undefined) {
          i = t;
          if (window.console && window.console.error) {
            window.console.error(i);
          }
        }
      }
      var t = function e(r) {
        var t = r.gl;
        this.ext = r;
        this.isAlive = true;
        this.hasBeenBound = false;
        this.elementArrayBuffer = null;
        this.attribs = new Array(r.maxVertexAttribs);
        for (var i = 0; i < this.attribs.length; i++) {
          var a = new e.VertexAttrib(t);
          this.attribs[i] = a;
        }
        this.maxAttrib = 0;
      };
      (t.VertexAttrib = function (e) {
        this.enabled = false;
        this.buffer = null;
        this.size = 4;
        this.type = e.FLOAT;
        this.normalized = false;
        this.stride = 16;
        this.offset = 0;
        this.cached = "";
        this.recache();
      }).prototype.recache = function () {
        this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
      };
      function i(r) {
        var t;
        var i;
        var a = this;
        this.gl = r;
        i = (t = r).getError;
        t.getError = function () {
          do {
            if ((r = i.apply(t)) != t.NO_ERROR) {
              e[r] = true;
            }
          } while (r != t.NO_ERROR);
          for (var r in e) {
            if (e[r]) {
              delete e[r];
              return parseInt(r);
            }
          }
          return t.NO_ERROR;
        };
        var n = this.original = {
          getParameter: r.getParameter,
          enableVertexAttribArray: r.enableVertexAttribArray,
          disableVertexAttribArray: r.disableVertexAttribArray,
          bindBuffer: r.bindBuffer,
          getVertexAttrib: r.getVertexAttrib,
          vertexAttribPointer: r.vertexAttribPointer
        };
        r.getParameter = function (e) {
          if (e == a.VERTEX_ARRAY_BINDING_OES) {
            if (a.currentVertexArrayObject == a.defaultVertexArrayObject) {
              return null;
            } else {
              return a.currentVertexArrayObject;
            }
          } else {
            return n.getParameter.apply(this, arguments);
          }
        };
        r.enableVertexAttribArray = function (e) {
          var r = a.currentVertexArrayObject;
          r.maxAttrib = Math.max(r.maxAttrib, e);
          r.attribs[e].enabled = true;
          return n.enableVertexAttribArray.apply(this, arguments);
        };
        r.disableVertexAttribArray = function (e) {
          var r = a.currentVertexArrayObject;
          r.maxAttrib = Math.max(r.maxAttrib, e);
          r.attribs[e].enabled = false;
          return n.disableVertexAttribArray.apply(this, arguments);
        };
        r.bindBuffer = function (e, t) {
          switch (e) {
            case r.ARRAY_BUFFER:
              a.currentArrayBuffer = t;
              break;
            case r.ELEMENT_ARRAY_BUFFER:
              a.currentVertexArrayObject.elementArrayBuffer = t;
          }
          return n.bindBuffer.apply(this, arguments);
        };
        r.getVertexAttrib = function (e, t) {
          var i = a.currentVertexArrayObject.attribs[e];
          switch (t) {
            case r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
              return i.buffer;
            case r.VERTEX_ATTRIB_ARRAY_ENABLED:
              return i.enabled;
            case r.VERTEX_ATTRIB_ARRAY_SIZE:
              return i.size;
            case r.VERTEX_ATTRIB_ARRAY_STRIDE:
              return i.stride;
            case r.VERTEX_ATTRIB_ARRAY_TYPE:
              return i.type;
            case r.VERTEX_ATTRIB_ARRAY_NORMALIZED:
              return i.normalized;
            default:
              return n.getVertexAttrib.apply(this, arguments);
          }
        };
        r.vertexAttribPointer = function (e, r, t, i, s, A) {
          var o = a.currentVertexArrayObject;
          o.maxAttrib = Math.max(o.maxAttrib, e);
          var c = o.attribs[e];
          c.buffer = a.currentArrayBuffer;
          c.size = r;
          c.type = t;
          c.normalized = i;
          c.stride = s;
          c.offset = A;
          c.recache();
          return n.vertexAttribPointer.apply(this, arguments);
        };
        if (r.instrumentExtension) {
          r.instrumentExtension(this, "OES_vertex_array_object");
        }
        r.canvas.addEventListener("webglcontextrestored", function () {
          if (window.console && window.console.log) {
            window.console.log("OESVertexArrayObject emulation library context restored");
          }
          a.reset_();
        }, true);
        this.reset_();
      }
      i.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
      i.prototype.reset_ = function () {
        if (this.vertexArrayObjects !== undefined) {
          for (var e = 0; e < this.vertexArrayObjects.length; ++e) {
            this.vertexArrayObjects.isAlive = false;
          }
        }
        var r = this.gl;
        this.maxVertexAttribs = r.getParameter(r.MAX_VERTEX_ATTRIBS);
        this.defaultVertexArrayObject = new t(this);
        this.currentVertexArrayObject = null;
        this.currentArrayBuffer = null;
        this.vertexArrayObjects = [this.defaultVertexArrayObject];
        this.bindVertexArrayOES(null);
      };
      i.prototype.createVertexArrayOES = function () {
        var e = new t(this);
        this.vertexArrayObjects.push(e);
        return e;
      };
      i.prototype.deleteVertexArrayOES = function (e) {
        e.isAlive = false;
        this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1);
        if (this.currentVertexArrayObject == e) {
          this.bindVertexArrayOES(null);
        }
      };
      i.prototype.isVertexArrayOES = function (e) {
        return !!e && !!(e instanceof t) && !!e.hasBeenBound && e.ext == this;
      };
      i.prototype.bindVertexArrayOES = function (e) {
        var t = this.gl;
        if (!e || e.isAlive) {
          var i = this.original;
          var a = this.currentVertexArrayObject;
          this.currentVertexArrayObject = e || this.defaultVertexArrayObject;
          this.currentVertexArrayObject.hasBeenBound = true;
          var n = this.currentVertexArrayObject;
          if (a != n) {
            if (!a || n.elementArrayBuffer != a.elementArrayBuffer) {
              i.bindBuffer.call(t, t.ELEMENT_ARRAY_BUFFER, n.elementArrayBuffer);
            }
            var s = this.currentArrayBuffer;
            for (var A = Math.max(a ? a.maxAttrib : 0, n.maxAttrib), o = 0; o <= A; o++) {
              var c = n.attribs[o];
              var b = a ? a.attribs[o] : null;
              if (!a || c.enabled != b.enabled) {
                if (c.enabled) {
                  i.enableVertexAttribArray.call(t, o);
                } else {
                  i.disableVertexAttribArray.call(t, o);
                }
              }
              if (c.enabled) {
                var u = false;
                if (!a || c.buffer != b.buffer) {
                  if (s != c.buffer) {
                    i.bindBuffer.call(t, t.ARRAY_BUFFER, c.buffer);
                    s = c.buffer;
                  }
                  u = true;
                }
                if (u || c.cached != b.cached) {
                  i.vertexAttribPointer.call(t, o, c.size, c.type, c.normalized, c.stride, c.offset);
                }
              }
            }
            if (this.currentArrayBuffer != s) {
              i.bindBuffer.call(t, t.ARRAY_BUFFER, this.currentArrayBuffer);
            }
          }
        } else {
          r(t.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
        }
      };
      (function () {
        var e = WebGLRenderingContext.prototype.getSupportedExtensions;
        WebGLRenderingContext.prototype.getSupportedExtensions = function () {
          var r = e.call(this) || [];
          if (r.indexOf("OES_vertex_array_object") < 0) {
            r.push("OES_vertex_array_object");
          }
          return r;
        };
        var r = WebGLRenderingContext.prototype.getExtension;
        WebGLRenderingContext.prototype.getExtension = function (e) {
          return r.call(this, e) || (e !== "OES_vertex_array_object" ? null : (this.__OESVertexArrayObject || (console.log("Setup OES_vertex_array_object polyfill"), this.__OESVertexArrayObject = new i(this)), this.__OESVertexArrayObject));
        };
      })();
    })();
  }
  Class(function DracoThread() {
    let decoderConfig;
    let decoderPending;
    function onError(opts) {
      if (opts.message.preloading) {
        console.warn(opts.er);
      }
      let plane = new PlaneGeometry(1, 1).toNonIndexed();
      let buff = [];
      let data = {};
      for (let key in plane.attributes) {
        data[key] = plane.attributes[key].array;
        buff.push(data[key].buffer);
      }
      computeBounding(data);
      opts?.resolve(data, opts.id, buff);
    }
    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
      const attributeIDs = taskConfig.attributeIDs;
      const attributeTypes = taskConfig.attributeTypes;
      let dracoGeometry;
      let decodingStatus;
      const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
      if (geometryType === draco.TRIANGULAR_MESH) {
        dracoGeometry = new draco.Mesh();
        decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
      } else {
        if (geometryType !== draco.POINT_CLOUD) {
          throw new Error("DRACOLoader: Unexpected geometry type.");
        }
        dracoGeometry = new draco.PointCloud();
        decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
      }
      if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
        throw new Error("DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
      }
      const geometry = {
        index: null,
        attributes: []
      };
      for (const attributeName in attributeIDs) {
        const attributeType = attributeTypes[attributeName];
        let attribute;
        let attributeID;
        if (taskConfig.useUniqueIDs) {
          attributeID = attributeIDs[attributeName];
          attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
        } else {
          attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
          if (attributeID === -1) {
            continue;
          }
          attribute = decoder.GetAttribute(dracoGeometry, attributeID);
        }
        geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
      }
      if (geometryType === draco.TRIANGULAR_MESH) {
        geometry.index = decodeIndex(draco, decoder, dracoGeometry);
      }
      draco.destroy(dracoGeometry);
      return geometry;
    }
    function decodeIndex(draco, decoder, dracoGeometry) {
      const numIndices = dracoGeometry.num_faces() * 3;
      const byteLength = numIndices * 4;
      const ptr = draco._malloc(byteLength);
      decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
      draco._free(ptr);
      return {
        array: index,
        itemSize: 1
      };
    }
    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
      const numComponents = attribute.num_components();
      const numValues = dracoGeometry.num_points() * numComponents;
      const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(draco, attributeType);
      const ptr = draco._malloc(byteLength);
      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
      const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
      draco._free(ptr);
      return {
        name: attributeName,
        array: array,
        itemSize: numComponents
      };
    }
    function getDracoDataType(draco, attributeType) {
      switch (attributeType) {
        case Float32Array:
          return draco.DT_FLOAT32;
        case Int8Array:
          return draco.DT_INT8;
        case Int16Array:
          return draco.DT_INT16;
        case Int32Array:
          return draco.DT_INT32;
        case Uint8Array:
          return draco.DT_UINT8;
        case Uint16Array:
          return draco.DT_UINT16;
        case Uint32Array:
          return draco.DT_UINT32;
      }
    }
    this.loadDraco = function (e, id) {
      const message = e;
      switch (message.type) {
        case "init":
          decoderConfig = message.decoderConfig;
          decoderPending = new Promise(function (pendingResolve) {
            decoderConfig.onModuleLoaded = function (draco) {
              pendingResolve({
                draco: draco
              });
              resolve({}, id);
            };
            DracoDecoderModule(decoderConfig);
          });
          break;
        case "decode_buffer_gltf":
          ((dracoBuffer, dataAttrib) => {
            const buffer = dracoBuffer;
            const attributeIDs = {};
            const attributeTypes = {};
            const TYPE_ARRAY = {
              5121: Uint8Array,
              5122: Int16Array,
              5123: Uint16Array,
              5125: Uint32Array,
              5126: Float32Array,
              "image/jpeg": Uint8Array,
              "image/png": Uint8Array
            };
            dataAttrib.forEach(att => {
              const name = att.name;
              attributeIDs[name] = att.id;
              attributeTypes[name] = TYPE_ARRAY[att.type];
            });
            const taskConfig = {
              attributeIDs: attributeIDs,
              attributeTypes: attributeTypes,
              useUniqueIDs: true
            };
            decoderPending.then(module => {
              const draco = module.draco;
              const decoder = new draco.Decoder();
              const decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
              try {
                const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                const buffers = geometry.attributes.map(attr => attr.array.buffer);
                if (geometry.index) {
                  buffers.push(geometry.index.array.buffer);
                }
                const response = {};
                if (geometry.index) {
                  response.index = geometry.index.array;
                }
                geometry.attributes.forEach(att => {
                  response[att.name] = att.array;
                  response[`${att.name}ItemSize`] = att.itemSize;
                });
                if (response.position) {
                  computeBounding(response);
                }
                resolve(response, id, buffers);
              } catch (error) {
                onError({
                  message: message,
                  er: `Parsing error on Draco file ${message.path}.`,
                  resolve: resolve,
                  id: id
                });
              } finally {
                draco.destroy(decoderBuffer);
                draco.destroy(decoder);
              }
            });
          })(message.buffer, message.dataAttrib);
          break;
        case "decode":
          fetch(message.path).then(res => {
            if (!res.ok) {
              throw new Error();
            }
            return res.arrayBuffer();
          }).then(dracoBuffer => {
            const decoder = new TextDecoder();
            const jsonSize = parseInt(decoder.decode(dracoBuffer.slice(0, 10)));
            const jsonData = JSON.parse(decoder.decode(dracoBuffer.slice(10, 10 + jsonSize)));
            const buffer = dracoBuffer.slice(10 + jsonSize);
            const TYPED_ARRAYS = Object.values(Geometry.TYPED_ARRAYS);
            const attributeIDs = {};
            const attributeTypes = {};
            jsonData.attributes.forEach((att, i) => {
              const name = att[0];
              attributeIDs[name] = i;
              attributeTypes[name] = TYPED_ARRAYS[att[1]];
            });
            const taskConfig = {
              attributeIDs: attributeIDs,
              attributeTypes: attributeTypes,
              useUniqueIDs: true
            };
            const isMesh = jsonData.type === 0;
            decoderPending.then(module => {
              const draco = module.draco;
              const decoder = new draco.Decoder();
              const decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
              try {
                const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                const buffers = geometry.attributes.map(attr => attr.array.buffer);
                if (isMesh && geometry.index) {
                  buffers.push(geometry.index.array.buffer);
                }
                const response = {
                  _type: "BufferGeometry",
                  userData: jsonData.userData || {}
                };
                response.userData.dracoType = jsonData.type;
                if (isMesh && geometry.index) {
                  response.index = geometry.index.array;
                }
                geometry.attributes.forEach(att => {
                  response[att.name] = att.array;
                  response[`${att.name}ItemSize`] = att.itemSize;
                });
                if (isMesh && response.position) {
                  computeBounding(response);
                }
                resolve(response, id, buffers);
              } catch (error) {
                onError({
                  message: message,
                  er: `Parsing error on Draco file ${message.path}.`,
                  resolve: resolve,
                  id: id
                });
              } finally {
                draco.destroy(decoderBuffer);
                draco.destroy(decoder);
              }
            });
          }).catch(() => {
            onError({
              message: message,
              er: `Network error: Draco file (${message.path}) could not be loaded.`,
              resolve: resolve,
              id: id
            });
          });
      }
    };
    this.decodeGeometry = decodeGeometry;
    this.decodeIndex = decodeIndex;
    this.decodeAttribute = decodeAttribute;
    this.getDracoDataType = getDracoDataType;
    this.onError = onError;
  }, "static");
  Class(function GeomThread() {
    Inherit(this, Component);
    const _this = this;
    var _cache = {};
    var _cacheWait = {};
    var _receive = {};
    var _dracoLoaded = null;
    function computeBounding(data) {
      let geom = new Geometry();
      geom.addAttribute("position", new GeometryAttribute(data.position, 3));
      if (data.index) {
        geom.setIndex(data.index);
      }
      geom.computeBoundingBox();
      geom.computeBoundingSphere();
      data.boundingBox = geom.boundingBox;
      data.boundingSphere = geom.boundingSphere;
    }
    function loadGeometry(e, id) {
      get(e.path).then(data => {
        let buffers = [];
        if (data.data && data.metadata?.type) {
          let bufferList = {
            _type: data.metadata.type
          };
          let jsonData = data.data;
          if (jsonData.index) {
            bufferList.index = new Geometry.TYPED_ARRAYS[jsonData.index.type](jsonData.index.array);
            buffers.push(bufferList.index.buffer);
          }
          for (let key in jsonData.attributes) {
            let attrib = jsonData.attributes[key];
            bufferList[key] = new Geometry.TYPED_ARRAYS[attrib.type](attrib.array);
            bufferList[`${key}ItemSize`] = attrib.itemSize;
            buffers.push(bufferList[key].buffer);
          }
          if (bufferList.position) {
            computeBounding(bufferList);
          }
          if (data.userData) {
            bufferList.userData = data.userData;
          }
          resolve(bufferList, id, buffers);
        } else {
          for (let key in data) {
            if (key != "bones") {
              if (Array.isArray(data[key])) {
                const ArrayType = key == "index" ? Geometry.arrayNeedsUint32(data[key]) ? Uint32Array : Uint16Array : Float32Array;
                data[key] = new ArrayType(data[key]);
                buffers.push(data[key].buffer);
              } else if (data[key].length > 0) {
                buffers.push(data[key].buffer);
              }
            }
          }
          computeBounding(data);
          if (e.custom) {
            self[e.custom](data);
          }
          resolve(data, id, buffers);
        }
      }).catch(er => {
        if (!e.preloading) {
          console.error(er);
        }
        let plane = new PlaneGeometry(1, 1).toNonIndexed();
        let buffers = [];
        let data = {};
        for (let key in plane.attributes) {
          data[key] = plane.attributes[key].array;
          buffers.push(data[key].buffer);
        }
        computeBounding(data);
        resolve(data, id, buffers);
      });
    }
    function geom_useFn(e) {
      Global.FNS ||= [];
      Global.FNS.push(e.name);
    }
    function loadDracoLib() {
      _dracoLoaded = Promise.create();
      const useJS = typeof WebAssembly != "object";
      const libFolder = "~assets/js/lib/_draco/";
      const libs = useJS ? [`${libFolder}draco_decoder.js`] : [`${libFolder}draco_wasm_wrapper.js`, `${libFolder}draco_decoder.wasm`];
      Promise.all(libs.map((url, i) => fetch(Assets.getPath(url)).then(res => {
        if (!res.ok) {
          throw new Error();
        }
        if (i === 0) {
          return res.text();
        } else {
          return res.arrayBuffer();
        }
      }))).then(async loadedLibs => {
        Thread.upload(["function loadDraco() {", "/* draco decoder */", loadedLibs[0], "", "/* worker */", "", "let decoderConfig, decoderPending;", "", DracoThread.onError.toString(), DracoThread.decodeGeometry.toString(), DracoThread.decodeIndex.toString(), DracoThread.decodeAttribute.toString(), DracoThread.getDracoDataType.toString(), "", "return " + DracoThread.loadDraco.toString(), "};"].join("\n"));
        const pool = Thread.shared(true).array;
        const decoderConfig = useJS ? {} : {
          wasmBinary: loadedLibs[1]
        };
        pool.forEach(t => t.importCode("self.loadDraco = loadDraco();"));
        await Promise.all(pool.map(t => t.loadDraco({
          type: "init",
          decoderConfig: decoderConfig
        })));
        _dracoLoaded.resolve();
      }).catch(() => {
        console.warn("Draco libs could not be loaded. Fallback to .json");
        _dracoLoaded.reject();
      });
    }
    function parseGeometry(data, path, custom) {
      let geometry;
      if (custom && _receive[custom]) {
        geometry = _receive[custom](data);
      } else {
        let geom = new Geometry();
        if (data._type) {
          for (key in data) {
            if (key !== "_type" && !key.endsWith("ItemSize")) {
              switch (key) {
                case "userData":
                  geom.userData = data.userData;
                  break;
                case "boundingBox":
                  geom.boundingBox = new Box3(new Vector3().set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z), new Vector3().set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z));
                  break;
                case "boundingSphere":
                  geom.boundingSphere = new Sphere(new Vector3().set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z), data.boundingSphere.radius);
                  break;
                case "index":
                  geom.setIndex(data.index);
                  break;
                default:
                  if (data[`${key}ItemSize`]) {
                    geom.addAttribute(key, new GeometryAttribute(data[key], data[`${key}ItemSize`]));
                  }
              }
            }
          }
        } else {
          geom.addAttribute("position", new GeometryAttribute(data.position, 3));
          geom.addAttribute("normal", new GeometryAttribute(data.normal || data.position.length, 3));
          geom.addAttribute("uv", new GeometryAttribute(data.uv || data.position.length / 3 * 2, 2));
          if (data.uv2) {
            geom.addAttribute("uv2", new GeometryAttribute(data.uv2, 2));
          }
          if (data.vdata) {
            geom.addAttribute("vdata", new GeometryAttribute(data.vdata, 3));
          }
          if (data.index) {
            geom.setIndex(data.index);
          }
          if (data.skinIndex) {
            geom.addAttribute("skinIndex", new GeometryAttribute(data.skinIndex, 4));
          }
          if (data.skinWeight) {
            geom.addAttribute("skinWeight", new GeometryAttribute(data.skinWeight, 4));
          }
          if (data.rig || data.bones) {
            geom.bones = (data.rig ? data.rig.bones : data.bones).slice(0);
          }
          geom.boundingBox = new Box3(new Vector3().set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z), new Vector3().set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z));
          geom.boundingSphere = new Sphere(new Vector3().set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z), data.boundingSphere.radius);
        }
        geometry = geom;
        geom._src = path;
      }
      if (!geometry.attributes.position) {
        throw `GeomThread :: Malformed geometry is missing position data. ${path}`;
      }
      if (_this.caching) {
        _cache[path] = geometry;
      }
      _cacheWait[path]?.resolve(geometry);
    }
    this.caching = true;
    (async function () {
      await Hydra.ready();
      Thread.upload(loadGeometry, geom_useFn, computeBounding);
    })();
    this.loadGeometry = function (path, custom, preloading) {
      if (!Device.graphics.gpu) {
        return Promise.resolve(new PlaneGeometry(1, 1));
      }
      if (_cache[path]) {
        return Promise.resolve(_cache[path]);
      }
      let cacheBust = false;
      if (path.includes("?")) {
        path = path.split("?")[0];
        cacheBust = "?" + Utils.timestamp();
      }
      let isBinary = path.endsWith(".bin");
      if (!path.includes("http")) {
        if (!Hydra.LOCAL) {
          cacheBust = false;
        }
        if (!path.includes("assets/geometry/")) {
          path = "assets/geometry/" + path;
        }
        if (!path.includes(".")) {
          path += ".json";
        }
        if (cacheBust) {
          path += cacheBust;
        }
      }
      path = Thread.absolutePath(Assets.getPath(path));
      if (_this.caching) {
        if (_cacheWait[path]) {
          return _cacheWait[path];
        }
        _cacheWait[path] = Promise.create();
      }
      if (isBinary) {
        if (!_dracoLoaded) {
          loadDracoLib();
        }
        _dracoLoaded.then(() => {
          Thread.shared().loadDraco({
            type: "decode",
            path: path,
            custom: custom,
            preloading: preloading
          }).then(data => parseGeometry(data, path, custom));
        }).catch(() => {
          path = path.replace(".bin", ".json");
          Thread.shared().loadGeometry({
            path: path,
            custom: custom,
            preloading: preloading
          }).then(data => parseGeometry(data, path, custom));
        });
      } else {
        Thread.shared().loadGeometry({
          path: path,
          custom: custom,
          preloading: preloading
        }).then(data => parseGeometry(data, path, custom));
      }
      return _cacheWait[path];
    };
    this.removeFromCache = function (path) {
      if (!path.includes("assets/geometry/")) {
        path = "assets/geometry/" + path;
      }
      if (!path.includes(".")) {
        path += ".json";
      }
      path = Thread.absolutePath(Assets.getPath(path));
      delete _cache[path];
      delete _cacheWait[path];
    };
    this.loadDracoLib = function () {
      if (!_dracoLoaded) {
        loadDracoLib();
      }
      return _dracoLoaded;
    };
    this.loadSkinnedGeometry = function (path, custom, preloading) {
      return this.loadGeometry(path, custom, preloading);
    };
    this.customFunction = function (fn, receive) {
      let name = Thread.upload(fn);
      name = name[0];
      t.geom_useFn({
        name: name
      });
      _receive[name] = receive;
    };
  }, "static");
  Class(function InstanceMesh(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _config;
    var _shaderKey;
    function initHotReload() {
      _mesh.cacheGeom = _mesh.geometry.clone();
      _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({
        file: file
      }) => {
        if (_mesh.geometry?._src?.includes(file)) {
          GeomThread.loadGeometry(file).then(_ => {
            createInstanceMesh(_config.getFilePath("json"));
          });
        }
        if (file.includes(_config.getFilePath("json"))) {
          createInstanceMesh(_config.getFilePath("json"));
        }
      });
      _this.events.sub(ShaderUIL.SHADER_UPDATE, ({
        shader: shader
      }) => {
        if (shader.includes(_shader.vsName)) {
          let newShader = new Shader(_shader.vsName, _shader.fsName);
          delete MeshBatch.shaders[`${_shader.vsName}|${_shader.fsName}`];
          updateShader(newShader);
          Shader.renderer.hotReloadClearProgram(_shader.vsName);
          newShader.upload(_mesh, _mesh.cacheGeom);
          _shader._gl &&= newShader._gl;
          _shader._gpu &&= newShader._gpu;
          _shader._metal &&= newShader._metal;
        }
      });
    }
    function updateShader(shader) {
      let prefetchCode = Shaders.getShader(shader.vsName + ".vs");
      shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`;
      shader.resetProgram();
      let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
      if (cached) {
        shader.fragmentShader = cached.fragment;
        shader.vertexShader = cached.vertex;
        return;
      }
      let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
      let fsSplit = shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
      if (!vsSplit[1].includes("vec3 pos = position;") && !vsSplit[1].includes("pos = pos;") && !shader.vertexShader.includes("vec3 transformPosition")) {
        throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
      }
      vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, "vec3 pos = transformPosition(position, offset, scale, orientation);");
      vsSplit[1] = vsSplit[1].replace(/pos = pos;/g, "pos = transformPosition(pos, offset, scale, orientation);");
      vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, "vNormal = normalMatrix * transformNormal(normal, orientation);");
      vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, "vec3 transformedNormal = transformNormal(normal, orientation);");
      vsSplit[0] += "\n";
      vsSplit[0] += "#define INSTANCED 1\n";
      if (!prefetchCode || !prefetchCode.includes("attribute vec3 offset")) {
        vsSplit[0] += "\n";
        vsSplit[0] += "attribute vec3 offset;\n";
        vsSplit[0] += "attribute vec3 scale;\n";
        vsSplit[0] += "attribute vec4 orientation;\n";
      }
      if (!shader.vertexShader.includes("vec3 transformPosition")) {
        vsSplit[0] += Shaders.getShader("instance.vs") + "\n";
      }
      vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__");
      fsSplit = fsSplit.join("__ACTIVE_THEORY_LIGHTS__");
      shader.vertexShader = vsSplit;
      shader.fragmentShader = fsSplit;
      _shaderKey = `${shader.vsName}|${shader.fsName}`;
      MeshBatch.shaders[_shaderKey] = {
        fragment: shader.fragmentShader,
        vertex: shader.vertexShader
      };
    }
    async function createInstanceMesh(json) {
      if (!json) {
        return;
      }
      if (!json.includes("assets/geometry")) {
        json = `assets/geometry/${json}`;
      }
      if (!json.includes(".json")) {
        json += ".json";
      }
      if (_mesh.cacheGeom) {
        json += "?" + Utils.timestamp();
      }
      if (_mesh.instanceMesh) {
        _mesh.instanceMesh.visible = false;
      }
      let geom = new Geometry().instanceFrom(_mesh.cacheGeom || _mesh.geometry);
      let buffers = await Thread.shared().parseInstanceMesh({
        url: Thread.absolutePath(Assets.getPath(json))
      });
      for (let key in buffers) {
        let b = buffers[key];
        geom.addAttribute(key, new GeometryAttribute(b.buffer, b.components, 1));
      }
      let test = _config.get("test");
      if (test) {
        _this.instanceMultiplier = eval(test);
      }
      if (_this.maxInstancedCount === undefined) {
        _this.maxInstancedCount = geom.maxInstancedCount;
      }
      let shader = _mesh.shader;
      updateShader(shader);
      let mesh = new Mesh(geom, shader);
      mesh.renderOrder = _mesh.renderOrder;
      mesh.castShadow = _mesh.castShadow;
      mesh.frustumCulled = false;
      mesh.renderOrder = _mesh.renderOrder;
      mesh.castShadow = _mesh.castShadow;
      mesh.receiveLight = _mesh.receiveLight;
      _this.frustumCulled = true;
      _mesh._parent.add(mesh);
      _mesh.instanceMesh = mesh;
      _mesh.instanceMeshReady.resolve();
      _this.startRender(_ => {
        mesh.renderOrder = _mesh.renderOrder;
        mesh.castShadow = _mesh.castShadow;
        mesh.depthWrite = _mesh.depthWrite;
        mesh.depthTest = _mesh.depthTest;
        mesh.receiveLight = _mesh.receiveLight;
        mesh.geometry.maxInstancedCount = _this.maxInstancedCount * _this.instanceMultiplier;
      }, 10);
    }
    this.instanceMultiplier = 1;
    (_config = InputUIL.create("im_" + _input.prefix, _group)).addFile("json", {
      relative: "assets/geometry"
    });
    _config.add("test");
    _config.setLabel("Instance");
    if (_input.get("visible") !== false) {
      _mesh._parent.remove(_mesh);
      _mesh.visible = false;
      _mesh.instanceMeshReady = Promise.create();
      _mesh.instanceMeshBeforeReady = Promise.create();
      createInstanceMesh(_config.getFilePath("json"));
      _config.onUpdate = _ => {
        createInstanceMesh(_config.getFilePath("json"));
      };
      if (Hydra.LOCAL) {
        initHotReload();
      }
    }
    this.applyToShader = function (shader) {
      updateShader(shader);
    };
    this.onDestroy = function () {
      if (_mesh.instanceMesh) {
        _mesh.instanceMesh.destroy();
      }
      delete MeshBatch.shaders[_shaderKey];
    };
    this.set("frustumCulled", async _ => {
      await _mesh.instanceMeshReady;
      let buffers = [];
      let obj = {};
      for (let key in _mesh.instanceMesh.geometry.attributes) {
        if (!key.includes(["position", "scale", "offset", "orientation"])) {
          continue;
        }
        let attrib = _mesh.instanceMesh.geometry.attributes[key];
        let array = new Float32Array(attrib.array);
        obj[key] = array;
        buffers.push(array.buffer);
      }
      let bounding = await Thread.shared().generateBoundingInstanceMesh(obj, buffers);
      _mesh.instanceMesh.geometry.boundingBox = bounding.boundingBox;
      _mesh.instanceMesh.geometry.boundingSphere = bounding.boundingSphere;
      _mesh.instanceMesh.frustumCulled = true;
    });
  }, _ => {
    Thread.upload(function parseInstanceMesh({
      url: url
    }, id) {
      get(url).then(data => {
        let buffers = [];
        for (let key in data) {
          data[key].buffer = new Float32Array(data[key].buffer);
          buffers.push(data[key].buffer.buffer);
        }
        resolve(data, id, buffers);
      });
    });
    Thread.upload(function generateBoundingInstanceMesh(e, id) {
      let geom = new Geometry();
      geom.addAttribute("position", new GeometryAttribute(e.position, 3));
      let box = new Box3();
      let mesh = new Mesh(geom);
      let count = e.offset.length / 3;
      for (let i = 0; i < count; i++) {
        mesh.position.fromArray(e.offset, i * 3);
        mesh.quaternion.fromArray(e.orientation, i * 4);
        mesh.scale.fromArray(e.scale, i * 3);
        box.expandByObject(mesh);
      }
      let boundingBox = box;
      let boundingSphere = box.getBoundingSphere();
      resolve({
        boundingBox: boundingBox,
        boundingSphere: boundingSphere
      }, id);
    });
  });
  Class(function MeshBatch(_input, _config) {
    Inherit(this, Object3D);
    const _this = this;
    var _geom;
    var _shader;
    var _mesh;
    var _firstRender;
    var _shaderKey;
    var _availableIndices;
    var _packedData;
    var _packedTexture;
    var _maxIndices;
    var _static = false;
    var _renderOrder = 0;
    var _objects = [];
    var _offset = [];
    var _quaternion = [];
    var _scale = [];
    var _attributes = {};
    var _uniformToAttrib = [];
    var _uniformNoAttrib = [];
    var _frustumCulled = true;
    var _v1 = new Vector3();
    var _v2 = new Vector3();
    var _q = new Quaternion();
    var _list = new LinkedList();
    async function initFromSceneLayout() {
      let wildcard = _input.get("wildcard");
      if (!wildcard || !wildcard.length) {
        return;
      }
      let groupName = wildcard.split("|")[0];
      let group = await _this.parent.getLayer(groupName);
      await _this.wait(group.children, "length");
      let children = [...group.children];
      children.sort((a, b) => a.renderOrder - b.renderOrder);
      children.forEach(mesh => _this.add(mesh));
      if (wildcard.includes("static")) {
        _this.static = true;
      }
      _this.group.renderOrder = children[0].renderOrder;
      group.add(_this.group);
    }
    function updateShader(shader, castShadow) {
      let prefetchCode = Shaders.getShader(shader.vsName + ".vs");
      shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`;
      shader.castShadow = castShadow;
      shader.resetProgram();
      let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
      if (cached) {
        shader.fragmentShader = shader.restoreFS = cached.fragment;
        shader.vertexShader = shader.restoreVS = cached.vertex;
        return;
      }
      let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
      let fsSplit = shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
      if (!vsSplit[1].includes("vec3 pos = position;") && !vsSplit[1].includes("pos = pos;") && !shader.vertexShader.includes("vec3 transformPosition")) {
        throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
      }
      let definitions = [];
      vsSplit[1].split("\n").forEach(line => {
        if (line.includes("uniform")) {
          if (line.includes("sampler2D")) {
            return;
          }
          let data = line.split(" ");
          let uni = data[2].replace(";", "");
          if (function uniformToAttrib(key) {
            key = key.trim();
            for (let i = 0; i < _uniformToAttrib.length; i++) {
              let val = _uniformToAttrib[i];
              if (key.includes(val) || val.includes(key)) {
                return !_uniformNoAttrib.includes(key);
              }
            }
            return false;
          }(uni)) {
            definitions.push(`${uni} = a_${data[2]}`);
            vsSplit[1] = vsSplit[1].replace(line, `attribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}`);
            fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
          }
        }
      });
      vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, "vec3 pos = transformPosition(position, offset, scale, orientation);");
      vsSplit[1] = vsSplit[1].replace(/pos = pos;/g, "pos = transformPosition(pos, offset, scale, orientation);");
      vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, "vNormal = normalMatrix * transformNormal(normal, orientation);");
      vsSplit[1] = vsSplit[1].replace(/vWorldNormal = transpose(inverse(mat3(modelMatrix))) \* normal;/g, "vWorldNormal = transpose(inverse(mat3(modelMatrix))) * transformNormal(normal, orientation);");
      vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, "vec3 transformedNormal = transformNormal(normal, orientation);");
      let main = vsSplit[1].split("main() {");
      main[1] = "\n" + definitions.join("\n") + main[1];
      vsSplit[1] = main.join("main() {");
      vsSplit[0] += "#define INSTANCED 1\n";
      fsSplit[0] += "#define INSTANCED 1\n";
      if (!prefetchCode || !prefetchCode.includes("attribute vec3 offset")) {
        vsSplit[0] += "\n";
        vsSplit[0] += "attribute float instance;\n";
        vsSplit[0] += "attribute vec3 offset;\n";
        vsSplit[0] += "attribute vec3 scale;\n";
        vsSplit[0] += "attribute vec4 orientation;\n";
      }
      if (!shader.vertexShader.includes("vec3 transformPosition")) {
        vsSplit[0] += Shaders.getShader("instance.vs") + "\n";
      }
      if (_packedData) {
        vsSplit[0] += "\n            attribute float batchIndex;\n            uniform vec3 uPackedInfo;\n            uniform sampler2D tPackedTexture;\n            vec2 getPackedUV(float index, float offset) {\n                float pixel = (index*uPackedInfo.x) + offset;\n            \n                float size = uPackedInfo.y;\n                float p0 = pixel / size;\n                float y = floor(p0);\n                float x = p0 - y;\n            \n                vec2 uv = vec2(0.0);\n                uv.x = x;\n                uv.y = y / size;\n                return uv;\n            }\n            \n            vec4 getPackedData(float offset) {\n                return texture2D(tPackedTexture, getPackedUV(batchIndex, offset));\n            }\n            ";
      }
      vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__");
      fsSplit = fsSplit.join("__ACTIVE_THEORY_LIGHTS__");
      shader.vertexShader = shader.restoreVS = vsSplit;
      shader.fragmentShader = shader.restoreFS = fsSplit;
      _shaderKey = `${shader.vsName}|${shader.fsName}`;
      MeshBatch.shaders[_shaderKey] = {
        fragment: shader.fragmentShader,
        vertex: shader.vertexShader
      };
    }
    function modifyGeometry(dir) {
      if (!_geom || !_geom.attributes || !_geom.attributes.offset) {
        return;
      }
      let count = _geom.attributes.offset.count + dir;
      _offset = new Float32Array(count * 3);
      _scale = new Float32Array(count * 3);
      _quaternion = new Float32Array(count * 4);
      _geom.attributes.offset.setArray(new Float32Array(count * 3));
      _geom.attributes.scale.setArray(new Float32Array(count * 3));
      _geom.attributes.orientation.setArray(new Float32Array(count * 4));
      for (let key in _attributes) {
        let components = _geom.attributes[key].itemSize;
        _attributes[key] = new Float32Array(count * components);
        _geom.attributes[key].setArray(new Float32Array(count * components));
      }
      _geom.maxInstancedCount = _objects.length;
      loop();
    }
    function dirty(a, b) {
      for (let i = a.length - 1; i > -1; i--) {
        if (a[i] != b[i]) {
          return true;
        }
      }
      return false;
    }
    function prepareMesh(mesh, i) {
      let pos = _v1;
      let scale = _v2;
      let quaternion = _q;
      if (_config.worldCoords) {
        try {
          if (_config.parent > 0) {
            switch (_config.parent) {
              case 1:
                pos.copy(mesh._parent.position);
                scale.copy(mesh._parent.scale);
                quaternion.copy(mesh._parent.quaternion);
                break;
              case 2:
                pos.copy(mesh._parent._parent.position);
                scale.copy(mesh._parent._parent.scale);
                quaternion.copy(mesh._parent._parent.quaternion);
            }
          } else if (_config.addParentPosition) {
            pos.copy(mesh.position).add(mesh._parent.position);
            if (_config.addParentPosition == 2) {
              pos.add(mesh._parent._parent.position);
            }
            scale.copy(mesh.scale);
            quaternion.copy(mesh.quaternion);
          } else {
            pos.copy(mesh.getWorldPosition());
            scale.copy(mesh.getWorldScale());
            quaternion.copy(mesh.getWorldQuaternion());
          }
          if (!_config.bypassVisibilityCheck && !mesh.determineVisible()) {
            scale.x = scale.y = scale.z = 0;
          }
        } catch (e) {
          pos.copy(mesh.position);
          scale.copy(mesh.scale);
          quaternion.copy(mesh.quaternion);
        }
      } else {
        pos.copy(mesh.position);
        scale.copy(mesh.scale);
        quaternion.copy(mesh.quaternion);
        if (_config.visibilityCheck && !mesh.determineVisible()) {
          scale.setScalar(0);
        }
      }
      if (mesh.batchOffsetPos) {
        pos.add(mesh.batchOffsetPos);
      }
      let i3 = i * 3;
      let i4 = i * 4;
      _offset[i3 + 0] = pos.x;
      _offset[i3 + 1] = pos.y;
      _offset[i3 + 2] = pos.z;
      _scale[i3 + 0] = scale.x;
      _scale[i3 + 1] = scale.y;
      _scale[i3 + 2] = scale.z;
      _quaternion[i4 + 0] = quaternion.x;
      _quaternion[i4 + 1] = quaternion.y;
      _quaternion[i4 + 2] = quaternion.z;
      _quaternion[i4 + 3] = quaternion.w;
      if (mesh.attributes) {
        for (let key in mesh.attributes) {
          let attr = mesh.attributes[key];
          let value = attr.value === undefined ? attr : attr.value;
          if (value instanceof Color) {
            _attributes[key][i * 3 + 0] = value.r;
            _attributes[key][i * 3 + 1] = value.g;
            _attributes[key][i * 3 + 2] = value.b;
          } else if (value instanceof Vector3) {
            _attributes[key][i * 3 + 0] = value.x;
            _attributes[key][i * 3 + 1] = value.y;
            _attributes[key][i * 3 + 2] = value.z;
          } else if (value instanceof Vector4 || value instanceof Quaternion) {
            _attributes[key][i * 4 + 0] = value.x;
            _attributes[key][i * 4 + 1] = value.y;
            _attributes[key][i * 4 + 2] = value.z;
            _attributes[key][i * 4 + 3] = value.w;
          } else if (value instanceof Vector2) {
            _attributes[key][i * 2 + 0] = value.x;
            _attributes[key][i * 2 + 1] = value.y;
          } else {
            _attributes[key][i] = value;
          }
        }
      }
      if (_packedTexture) {
        let batchIndex = mesh.batchIndex;
        let stride = _packedTexture.keys * 4;
        for (let key in _packedData) {
          let offset = _packedData[key] * 4;
          let value = mesh.packedData[key].value;
          let index = batchIndex * stride + offset;
          let r = g = b = a = 1;
          if (value instanceof Color) {
            r = value.r;
            g = value.g;
            b = value.b;
          } else if (value instanceof Vector3) {
            r = value.x;
            g = value.y;
            b = value.z;
          } else if (value instanceof Vector4 || value instanceof Quaternion) {
            r = value.x;
            g = value.y;
            b = value.z;
            a = value.w;
          } else if (value instanceof Vector2) {
            r = value.x;
            g = value.y;
          } else {
            r = value;
          }
          _packedTexture.data[index + 0] = r;
          _packedTexture.data[index + 1] = g;
          _packedTexture.data[index + 2] = b;
          _packedTexture.data[index + 3] = a;
        }
        _packedTexture.needsUpdate = true;
      }
    }
    function updateBuffers() {
      if (_mesh) {
        if (dirty(_quaternion, _geom.attributes.orientation.array)) {
          _geom.attributes.orientation.array.set(_quaternion);
          _geom.attributes.orientation.needsUpdate = true;
        }
        if (dirty(_offset, _geom.attributes.offset.array)) {
          _geom.attributes.offset.array.set(_offset);
          _geom.attributes.offset.needsUpdate = true;
        }
        if (dirty(_scale, _geom.attributes.scale.array)) {
          _geom.attributes.scale.array.set(_scale);
          _geom.attributes.scale.needsUpdate = true;
        }
        for (let key in _attributes) {
          if (dirty(_attributes[key], _geom.attributes[key].array)) {
            _geom.attributes[key].array.set(_attributes[key]);
            _geom.attributes[key].needsUpdate = true;
          }
        }
      } else {
        (function initMesh() {
          _geom.addAttribute("offset", new GeometryAttribute(new Float32Array(_offset), 3, 1, _this.useDynamic));
          _geom.addAttribute("scale", new GeometryAttribute(new Float32Array(_scale), 3, 1, _this.useDynamic));
          _geom.addAttribute("orientation", new GeometryAttribute(new Float32Array(_quaternion), 4, 1, _this.useDynamic));
          if (_frustumCulled) {
            let box = new Box3();
            _objects.forEach(mesh => box.expandByObject(mesh, true));
            _geom.boundingBox = box;
            _geom.boundingSphere = box.getBoundingSphere();
          }
          _mesh = new Mesh(_geom, _shader);
          if (_shader.castShadow) {
            _mesh.castShadow = true;
          }
          _mesh.asyncPromise = _this.group.asyncPromise;
          _this.group.asyncPromise.resolve();
          _this.mesh = _mesh;
          _this.shader = _mesh.shader;
          _this.mesh.isMeshBatch = true;
          _this.group.add(_mesh);
          _mesh.frustumCulled = _frustumCulled;
          if (_renderOrder) {
            _mesh.renderOrder = _renderOrder;
          }
          _offset = new Float32Array(_offset);
          _quaternion = new Float32Array(_quaternion);
          _scale = new Float32Array(_scale);
          for (let key in _attributes) {
            _attributes[key] = new Float32Array(_attributes[key]);
            let components = 1;
            let attr = _objects[0].attributes[key];
            let value = attr.value || attr;
            if (value instanceof Vector3) {
              components = 3;
            } else if (value instanceof Vector4 || value instanceof Quaternion) {
              components = 4;
            } else if (value instanceof Color) {
              components = 3;
            } else if (value instanceof Vector2) {
              components = 2;
            }
            _geom.addAttribute(key, new GeometryAttribute(new Float32Array(_attributes[key]), components, 1, _this.useDynamic));
          }
          if (_this.onMeshCreated) {
            _this.onMeshCreated(_mesh);
          }
        })();
      }
    }
    async function initializeStatic() {
      let wasVisible = _this.group.determineVisible();
      await (_ => {
        let promise = Promise.create();
        let mesh = _list.start();
        let i = 0;
        let worker = new Render.Worker(_ => {
          mesh.updateMatrixWorld(true);
          prepareMesh(mesh, i);
          i++;
          mesh = _list.next();
          if (!mesh) {
            worker.stop();
            promise.resolve();
          }
        }, 1);
        return promise;
      })();
      updateBuffers();
      if (wasVisible) {
        if (_frustumCulled) {
          let box = new Box3();
          _objects.forEach(mesh => box.expandByObject(mesh, true));
          _geom.boundingBox = box;
          _geom.boundingSphere = box.getBoundingSphere();
        }
        _this.flag("isStaticReady", true);
      } else {
        await _this.wait(() => _this.group.determineVisible());
        if (_static) {
          initializeStatic();
        }
      }
    }
    function loop() {
      if (_static) {
        _this.stopRender(loop, RenderManager.AFTER_LOOPS);
      }
      let first = !_firstRender;
      _firstRender = true;
      let i = 0;
      let mesh = _list.start();
      while (mesh) {
        if (mesh.batchNeedsUpdate !== false || first) {
          if (first) {
            mesh.updateMatrixWorld(true);
          }
          prepareMesh(mesh, i);
        }
        mesh = _list.next();
        i++;
      }
      updateBuffers();
    }
    function firstLoop() {
      if (!_static) {
        _this.startRender(loop, RenderManager.AFTER_LOOPS);
      }
      loop();
    }
    _this.useDynamic = false;
    if (!(_input instanceof InputUILConfig)) {
      _config = _input;
      _input = null;
    }
    _config = _config || {};
    if (_input) {
      _this.parent.ready(true).then(initFromSceneLayout);
    }
    _this.group.asyncPromise = Promise.create();
    if (Hydra.LOCAL) {
      (function initHotReload() {
        _this.events.sub(ShaderUIL.SHADER_UPDATE, ({
          shader: shader
        }) => {
          if (_shader && _shader.vsName && shader.includes(_shader.vsName)) {
            let newShader = new Shader(_shader.vsName, _shader.fsName);
            delete MeshBatch.shaders[`${_shader.vsName}|${_shader.fsName}`];
            updateShader(newShader);
            Shader.renderer.hotReloadClearProgram(_shader.vsName);
            newShader.upload(_mesh, _geom);
            _shader._gl &&= newShader._gl;
            _shader._gpu &&= newShader._gpu;
            _shader._metal &&= newShader._metal;
          }
        });
      })();
    }
    this.add = function (mesh) {
      _objects.push(mesh);
      _list.push(mesh);
      mesh.uploadIgnore = true;
      mesh.batch = _this;
      if (_availableIndices && !mesh.batchIndex) {
        mesh.batchIndex = _availableIndices.shift();
        mesh.attributes ||= {};
        mesh.attributes.batchIndex = {
          value: mesh.batchIndex
        };
      }
      let shader = mesh.shader;
      for (let key in shader.uniforms) {
        let uniform = shader.uniforms[key];
        if (uniform.value instanceof Color || uniform.value instanceof Vector2 || uniform.value instanceof Vector3 || uniform.value instanceof Vector4 || uniform.value instanceof Quaternion || typeof uniform.value == "number") {
          if (uniform.batchUnique || _config.batchUnique) {
            _uniformToAttrib.push(key);
            mesh.attributes ||= {};
            mesh.attributes["a_" + key] = uniform;
          } else {
            if (!_uniformNoAttrib.includes(key)) {
              _uniformNoAttrib.push(key);
            }
            if (uniform.packedIndex !== undefined) {
              _packedData ||= {};
              if (!_availableIndices) {
                throw "Can't use packedData without first setting .maxIndices";
              }
              _packedData[key] ||= uniform.packedIndex;
              mesh.packedData ||= {};
              mesh.packedData[key] = uniform;
            }
          }
        }
      }
      if (!_geom) {
        (function initGeometry(mesh) {
          _geom = new Geometry().instanceFrom(mesh.geometry);
          _this.geom = _geom;
          if (!_shader) {
            (_shader = mesh.shader.clone()).debug = true;
            mesh.shader.replicateUniformsTo(_shader);
            if (_packedData) {
              let total = Object.keys(_packedData).length;
              let pixels = Math.sqrt(_maxIndices * total);
              let size = Math.pow(2, Math.ceil(Math.log(pixels) / Math.log(2)));
              (_packedTexture = new DataTexture(new Float32Array(size * size * 4), size, size, Texture.RGBAFormat, Texture.FLOAT)).keys = total;
              _shader.addUniforms({
                tPackedTexture: {
                  value: _packedTexture
                },
                uPackedInfo: {
                  value: new Vector3(total, size, _maxIndices)
                }
              });
            }
            updateShader(_shader, mesh.castShadow);
          }
          if (mesh.attributes) {
            for (let key in mesh.attributes) {
              _attributes[key] = [];
            }
          }
          if (_static) {
            defer(initializeStatic);
          }
        })(mesh);
      }
      if (_mesh) {
        modifyGeometry(1);
        if (_static) {
          console.error("Don't add more meshes to a static MeshBatch");
        }
      }
      mesh.shader.neverRender = true;
      if (!_static) {
        RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS);
      }
    };
    this.remove = function (mesh) {
      if (_objects.includes(mesh)) {
        _objects.remove(mesh);
        _list.remove(mesh);
        if (mesh.batchIndex > -1 && !mesh.persistBatchIndex) {
          _availableIndices.push(mesh.batchIndex);
          _availableIndices.sort((a, b) => a - b);
        }
        modifyGeometry(-1);
      }
    };
    this.onDestroy = function () {
      if (_this.mesh && _this.mesh.destroy) {
        _this.mesh.destroy();
      }
      delete MeshBatch.shaders[_shaderKey];
    };
    this.loadFromFile = async function (shader, geomFile, instanceFile) {
      if (!geomFile.includes("assets/geometry")) {
        geomFile = "assets/geometry/" + geomFile;
      }
      if (!geomFile.includes(".json")) {
        geomFile += ".json";
      }
      if (!instanceFile.includes("assets/geometry")) {
        instanceFile = "assets/geometry/" + instanceFile;
      }
      if (!instanceFile.includes(".json")) {
        instanceFile += ".json";
      }
      let [geom, data] = await Promise.all([GeomThread.loadGeometry(Assets.getPath(geomFile)), get(Assets.getPath(instanceFile))]);
      let array = [];
      let count = data.offset.buffer.length / 3;
      for (let i = 0; i < count; i++) {
        let mesh = new Mesh(geom, shader);
        mesh.position.fromArray(data.offset.buffer, i * 3);
        mesh.scale.fromArray(data.scale.buffer, i * 3);
        mesh.quaternion.fromArray(data.orientation.buffer, i * 4);
        array.push(mesh);
        _this.add(mesh);
      }
      await _this.ready();
      return array;
    };
    this.ready = function () {
      return _this.wait("mesh");
    };
    this.staticReady = function () {
      if (_static) {
        return _this.wait("isStaticReady");
      }
    };
    this.getMeshByIndex = function (index) {
      return _objects[index];
    };
    this.getMeshCount = function () {
      return _objects.length;
    };
    this.get("static", () => _static);
    this.set("static", b => {
      if (!!b !== _static) {
        _static = !!b;
        if (_objects.length) {
          if (_static) {
            console.warn("For better initialization performance, set meshBatch.static before adding any meshes");
          }
          _this.stopRender(loop, RenderManager.AFTER_LOOPS);
          RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS);
        }
      }
    });
    this.set("maxIndices", value => {
      _maxIndices = value;
      if (!(_availableIndices = _config.availableIndices || []).length) {
        for (let i = 0; i < value; i++) {
          _availableIndices[i] = i;
        }
      }
    });
    this.get("attributes", _ => _attributes);
    this.get("maxIndices", _ => _maxIndices);
    this.set("renderOrder", v => {
      _renderOrder = v;
      if (_mesh) {
        _mesh.renderOrder = v;
      }
    });
    this.get("renderOrder", _ => _renderOrder);
    this.set("frustumCulled", b => {
      _frustumCulled = b;
      if (_mesh) {
        _mesh.frustumCulled = b;
      }
    });
    this.applyToShader = function (shader, castShadow = shader.mesh?.castShadow ?? false) {
      updateShader(shader, castShadow);
    };
  }, _ => {
    MeshBatch.shaders = {};
  });
  Class(function MeshMerge(_input, _dynamic) {
    Inherit(this, Object3D);
    const _this = this;
    var _mesh;
    var _geom;
    var _texture;
    var _shaderKey;
    var _meshes = [];
    var _pending = [];
    var _index = 0;
    function initDynamic() {
      let array = new Float32Array(1024);
      (_texture = new DataTexture(array, 16, 16, Texture.RGBAFormat, Texture.FLOAT)).dynamic = true;
      _texture.promise = Promise.resolve();
      (function updateShader(shader) {
        shader.customCompile = `${shader.vsName}|${shader.fsName}|dynamicMerge`;
        shader.addUniforms({
          tDynamicMerge: {
            value: _texture
          }
        });
        let cached = MeshMerge.shaders[`${shader.vsName}|${shader.fsName}`];
        if (cached) {
          shader.fragmentShader = cached.fragment;
          return shader.resetProgram();
        }
        shader.resetProgram();
        let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
        if (!vsSplit[1].includes("vec3 pos = position;")) {
          throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
        }
        vsSplit[0] += "attribute float mIndex;\n";
        vsSplit[0] += "uniform sampler2D tDynamicMerge;\n";
        vsSplit[0] += "vec3 offset;\n";
        vsSplit[0] += "vec3 scale;\n";
        vsSplit[0] += "vec4 orientation;\n";
        if (!shader.vertexShader.includes("vec3 transformPosition")) {
          vsSplit[0] += Shaders.getShader("instance.vs") + "\n";
        }
        vsSplit[0] += "\n        vec2 getDMUV(float index, float offset) {\n            float pixel = (index*3.0) + offset;\n        \n            float size = 16.0;\n            float p0 = pixel / size;\n            float y = floor(p0);\n            float x = p0 - y;\n        \n            vec2 uv = vec2(0.0);\n            uv.x = x;\n            uv.y = y / size;\n            return uv;\n        }\n        \n";
        vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, "vec3 pos = transformPosition(position, offset, scale, orientation);");
        vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, "vNormal = normalMatrix * transformNormal(normal, orientation);");
        vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, "vec3 transformedNormal = transformNormal(normal, orientation);");
        let oso = "\n        offset = texture2D(tDynamicMerge, getDMUV(mIndex, 0.0)).xyz;\n        scale = texture2D(tDynamicMerge, getDMUV(mIndex, 1.0)).xyz;\n        orientation = texture2D(tDynamicMerge, getDMUV(mIndex, 2.0));\n        ";
        let main = vsSplit[1].split("main() {");
        main[1] = "\n" + oso + main[1];
        vsSplit[1] = main.join("main() {");
        vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__");
        shader.vertexShader = vsSplit;
        _shaderKey = `${shader.vsName}|${shader.fsName}`;
        MeshMerge.shaders[_shaderKey] = {
          vertex: shader.vertexShader
        };
      })(_mesh.shader);
      let loop = _ => {
        for (let i = _meshes.length - 1; i > -1; i--) {
          let mesh = _meshes[i];
          let index = mesh.mergeIndex;
          array[index * 12 + 0] = mesh.position.x;
          array[index * 12 + 1] = mesh.position.y;
          array[index * 12 + 2] = mesh.position.z;
          array[index * 12 + 3] = 1;
          array[index * 12 + 4] = mesh.scale.x;
          array[index * 12 + 5] = mesh.scale.y;
          array[index * 12 + 6] = mesh.scale.z;
          array[index * 12 + 7] = 1;
          array[index * 12 + 8] = mesh.quaternion.x;
          array[index * 12 + 9] = mesh.quaternion.y;
          array[index * 12 + 10] = mesh.quaternion.z;
          array[index * 12 + 11] = mesh.quaternion.w;
        }
      };
      defer(loop);
      _this.startRender(loop);
    }
    function completeMerge() {
      _mesh.geometry = _geom;
      _mesh.asyncPromise.resolve();
      if (_this.onMeshCreated) {
        _this.onMeshCreated(_mesh);
      }
      _this.mesh = _mesh;
    }
    async function initFromSceneLayout() {
      let wildcard = _input.get("wildcard");
      if (!wildcard || !wildcard.length) {
        return;
      }
      let [groupName, dynamic] = wildcard.split("|");
      await _this.parent.loadedAllLayers();
      let group = await _this.parent.getLayer(groupName);
      _dynamic = dynamic == "dynamic";
      let children = [...group.children];
      children.sort((a, b) => a.renderOrder - b.renderOrder);
      children.forEach(mesh => _this.add(mesh));
      group.add(_this.group);
      MeshMerge.cache[_input.prefix] ||= Promise.create();
    }
    (function () {
      if (typeof _input == "object") {
        if (_input.get("visible") === false) {
          return;
        }
        _this.parent.ready().then(initFromSceneLayout);
      } else if (typeof _input == "boolean") {
        _dynamic = _input;
      }
    })();
    this.onDestroy = function () {
      _mesh.destroy();
      delete MeshBatch.shaders[_shaderKey];
    };
    this.ready = function () {
      return _this.wait("mesh");
    };
    this.add = function (mesh) {
      mesh.uploadIgnore = true;
      if (!mesh.visible) {
        return;
      }
      mesh.merge = _this;
      mesh.updateMatrixWorld(true);
      if (!_mesh) {
        (async function initMesh(mesh) {
          (_mesh = new Mesh(World.QUAD, mesh.shader)).asyncPromise = Promise.create();
          _this.group.add(_mesh);
          if (_input?.get) {
            _mesh.castShadow = _input.get("castShadow");
            _mesh.shader.receiveShadow = _input.get("receiveShadow");
          }
          if (_dynamic) {
            initDynamic();
          }
          if (_input?.prefix) {
            let cached = MeshMerge.cache[_input.prefix];
            if (cached) {
              _geom = await cached;
              completeMerge();
              return;
            }
          }
          await defer();
          let data = await Promise.all(_pending);
          let buffers = [];
          data.forEach(obj => {
            for (let key in obj) {
              if (obj[key].buffer) {
                buffers.push(obj[key].buffer);
              }
            }
          });
          let merged = await Thread.shared().meshMergeComplete({
            data: data
          }, buffers);
          _geom = new Geometry();
          for (let key in merged) {
            if (key !== "components") {
              _geom.addAttribute(key, new GeometryAttribute(merged[key], merged.components[key]));
            }
          }
          if (merged.indexBuffer) {
            _geom.index = merged.indexBuffer;
          }
          if (_input?.prefix) {
            MeshMerge.cache[_input.prefix].resolve(_geom);
          }
          completeMerge();
        })(mesh);
      }
      if (_input?.prefix) {
        if (MeshMerge.cache[_input.prefix]) {
          mesh.visible = false;
          _meshes.push(mesh);
          mesh.mergeIndex = _index++;
          return;
        }
      }
      let geom = mesh.geometry;
      if (mesh.attributes) {
        for (let key in mesh.attributes) {
          let attr = mesh.attributes[key];
          if (attr instanceof Vector4) {
            attr.isVector4 = true;
          }
          if (attr instanceof Vector3) {
            attr.isVector3 = true;
          }
          if (attr instanceof Vector2) {
            attr.isVector2 = true;
          }
          if (attr instanceof Color) {
            attr.isColor = true;
          }
        }
      }
      let data = {};
      let components = {};
      let buffers = [];
      for (let key in geom.attributes) {
        data[key] = new Float32Array(geom.attributes[key].array);
        buffers.push(data[key].buffer);
        components[key] = geom.attributes[key].itemSize;
      }
      if (geom.index) {
        data.indexBuffer = new Uint32Array(geom.index);
        buffers.push(data.indexBuffer.buffer);
      }
      data.attributes = mesh.attributes;
      data.components = components;
      data.matrix = _input == "world" ? mesh.matrixWorld.elements : mesh.matrix.elements;
      if (_dynamic) {
        data.matrix = null;
      }
      data.dynamic = _dynamic;
      data.index = mesh.mergeIndex = _index++;
      mesh.visible = false;
      _meshes.push(mesh);
      _pending.push(Thread.shared().meshMergeTransform(data, buffers));
    };
    this.onDestroy = function () {
      if (_input?.prefix) {
        delete MeshMerge.cache[_input.prefix];
      }
    };
  }, _ => {
    Thread.upload(function meshMergeTransform(e, id) {
      let geom = new Geometry();
      for (let key in e) {
        if (!key.includes(["components", "matrix"]) && e[key] instanceof Float32Array) {
          geom.addAttribute(key, new GeometryAttribute(e[key], e.components[key]));
        }
      }
      if (e.indexBuffer) {
        geom.index = e.indexBuffer;
      }
      if (e.attributes) {
        for (let key in e.attributes) {
          let components = 1;
          let attr = e.attributes[key];
          if (attr.isVector4) {
            components = 4;
          } else if (attr.isVector3 || attr.isColor) {
            components = 3;
          } else if (attr.isVector2) {
            components = 2;
          }
          let buffer = new Float32Array(geom.attributes.position.count * components);
          let step = buffer.length / components;
          for (let i = 0; i < step; i++) {
            if (components == 4) {
              buffer[i * 4 + 0] = attr.x;
              buffer[i * 4 + 1] = attr.y;
              buffer[i * 4 + 2] = attr.z;
              buffer[i * 4 + 3] = attr.w;
            } else if (components == 3) {
              buffer[i * 3 + 0] = attr.x || attr.r || 0;
              buffer[i * 3 + 1] = attr.y || attr.g || 0;
              buffer[i * 3 + 2] = attr.z || attr.b || 0;
            } else if (components == 2) {
              buffer[i * 2 + 0] = attr.x;
              buffer[i * 2 + 1] = attr.y;
            } else {
              buffer[i] = attr;
            }
          }
          geom.addAttribute(key, new GeometryAttribute(buffer, components));
        }
      }
      if (e.matrix) {
        geom.applyMatrix(new Matrix4().fromArray(e.matrix));
      }
      let indexBuffer = new Float32Array(geom.attributes.position.count);
      for (let i = 0; i < indexBuffer.length; i++) {
        indexBuffer[i] = e.index;
      }
      geom.addAttribute("mIndex", new GeometryAttribute(indexBuffer, 1));
      let data = {};
      let buffers = [];
      let components = {};
      for (let key in geom.attributes) {
        data[key] = geom.attributes[key].array;
        components[key] = geom.attributes[key].itemSize;
        buffers.push(data[key].buffer);
      }
      if (geom.index) {
        data.indexBuffer = geom.index;
        buffers.push(data.indexBuffer.buffer);
      }
      data.components = components;
      resolve(data, id, buffers);
    });
    Thread.upload(function meshMergeComplete({
      data: data
    }, id) {
      let _geom;
      data.forEach(data => {
        let geom = new Geometry();
        for (let key in data) {
          if (key != "components") {
            if (key == "indexBuffer") {
              geom.index = data[key];
            } else {
              geom.addAttribute(key, new GeometryAttribute(data[key], data.components[key]));
            }
          }
        }
        if (_geom) {
          _geom.merge(geom);
        } else {
          _geom = geom;
        }
      });
      let result = {};
      let components = {};
      let buffers = [];
      for (let key in _geom.attributes) {
        result[key] = _geom.attributes[key].array;
        components[key] = _geom.attributes[key].itemSize;
        buffers.push(result[key].buffer);
      }
      if (_geom.index) {
        result.indexBuffer = _geom.index;
        buffers.push(result.indexBuffer.buffer);
      }
      result.components = components;
      resolve(result, id, buffers);
    });
    MeshMerge.shaders = {};
    MeshMerge.cache = {};
  });
  Class(function RTPool(_type, _size = 3, _format, _multisample = false, _samplesAmount = 4) {
    Inherit(this, Component);
    const _this = this;
    var _pool;
    var _indexed = {};
    this.nullRT = Utils3D.createRT(2, 2);
    this.nullRT.setSize = () => {};
    var _array = [];
    var _resizeDisabled = false;
    function createRT() {
      let rt = Utils3D.createRT(Stage.width * World.DPR, Stage.height * World.DPR, _type, _format, _multisample, _samplesAmount);
      rt.index = _pool.length();
      return rt;
    }
    function addListeners() {
      if (!_resizeDisabled) {
        _this.events.sub(Events.RESIZE, resizeHandler);
      }
    }
    function resizeHandler() {
      _array.forEach(rt => {
        rt.setSize(Stage.width * World.DPR, Stage.height * World.DPR);
      });
    }
    (function initPool() {
      _pool = new ObjectPool();
      for (let i = 0; i < _size; i++) {
        let rt = createRT();
        _pool.put(rt);
        _array.push(rt);
      }
    })();
    defer(addListeners);
    this.get("array", _ => _array);
    this.getRT = function (index) {
      if (index) {
        _indexed[index] ||= createRT();
        return _indexed[index];
      } else {
        return _pool.get() || createRT();
      }
    };
    this.putRT = function (rt) {
      if (rt.scissor) {
        delete rt.scissor;
      }
      if (rt !== _this.nullRT) {
        _pool.put(rt);
      }
    };
    this.setSize = function (width, height) {
      _this.disableResize();
      _array.forEach(rt => {
        rt.setSize(width, height);
      });
    };
    this.onDestroy = function () {
      let p = _pool.get();
      while (p) {
        p.dispose();
        p = _pool.get();
      }
    };
    this.clone = function (type = _type, size = _size, format = _format, multisample = _multisample, samplesAmount = _samplesAmount) {
      return new RTPool(type, size, format, multisample, samplesAmount);
    };
    this.disableResize = function () {
      _resizeDisabled = true;
      _this.events.unsub(Events.RESIZE, resizeHandler);
    };
  }, "singleton");
  Class(function RenderCount() {
    const _this = this;
    var $container;
    var LOG;
    var _map = {};
    var _display = {};
    (async function () {
      await Hydra.ready();
      _this.active = Utils.query("renderCount");
      LOG = _this.active && Utils.query("log");
      if (_this.active) {
        (async function initUIL() {
          await Hydra.ready();
          ($container = Stage.create("RenderCount")).css({
            width: 175,
            height: "auto",
            paddingBottom: 5,
            bottom: 0,
            maxHeight: 400,
            overflowY: "scroll"
          }).bg("#111").setZ(9999999);
        })();
      }
    })();
    this.add = function (name, detail, amt = 1) {
      if (_this.active) {
        if (_map[name] === undefined && (_map[name] = 0, $container)) {
          let $wrapper = $container.create("wrapper");
          $wrapper.css({
            position: "relative",
            width: "100%",
            height: 20
          });
          $wrapper.label = $wrapper.create("label");
          $wrapper.label.fontStyle("Arial", 12, "#fff").text(name).css({
            left: 10
          });
          $wrapper.value = $wrapper.create("value");
          $wrapper.value.fontStyle("Arial", 12, "#fff").text(0).css({
            right: 10
          });
          _display[name] = $wrapper;
        }
        if (LOG) {
          console.groupCollapsed(name);
          if (detail) {
            console.log(detail);
          }
          console.trace();
          console.groupEnd();
        }
        _map[name] += amt;
        _display[name]?.value?.text?.(_map[name] || "0");
      }
    };
    this.remove = function (name, amt = 1) {
      if (_this.active && _map[name]) {
        _map[name] -= amt;
        _display[name]?.value?.text?.(_map[name] || "0");
      }
    };
  }, "static");
  Class(function RenderStats() {
    const _this = this;
    var _trace;
    var _filter;
    var $container;
    var _map = {};
    var _display = {};
    function flush() {
      for (let key in _map) {
        _this.stats[key] = _map[key];
        if (_display[key]) {
          _display[key].value.text(_map[key] || "0");
        }
        _map[key] = 0;
      }
      _trace = null;
    }
    _this.stats = {};
    (async function () {
      await Hydra.ready();
      _this.active = Utils.query("renderStats");
      if (Utils.query("renderStats")) {
        (async function initUIL() {
          await Hydra.ready();
          ($container = Stage.create("RenderStats")).css({
            position: "fixed",
            width: 150,
            height: "auto",
            paddingTop: 5
          }).bg("#111").setZ(99999);
          if (Utils.query("uil")) {
            const left = RenderCount.active ? 150 : 0;
            $container.css({
              bottom: 0,
              left: left
            });
          }
        })();
      }
      Render.drawFrame = flush;
      let frames = 0;
      let prevTime = 0;
      let fps = Render.REFRESH_RATE;
      Render.start(_ => {
        frames += 1;
        if (Render.TIME >= prevTime + 1000) {
          fps = frames * 1000 / (Render.TIME - prevTime);
          fps = Math.round(fps, fps >= 1 ? 0 : 2);
          prevTime = Render.TIME;
          frames = 0;
        }
        _this.update("FPS", fps);
      });
    })();
    this.update = function (name, amt = 1, detail, detail2) {
      if (Hydra.LOCAL) {
        if (_trace == name) {
          if (_filter && detail) {
            if (!(typeof detail == "string" ? detail : Utils.getConstructorName(detail)).toLowerCase().includes(_filter.toLowerCase())) {
              return;
            }
          }
          console.groupCollapsed(name);
          if (detail) {
            console.log(typeof detail == "string" ? detail : Utils.getConstructorName(detail));
          }
          if (detail2) {
            console.log(detail2);
          }
          console.trace();
          console.groupEnd();
        }
        if (_map[name] === undefined && (_map[name] = 0, $container)) {
          let $wrapper = $container.create("wrapper");
          $wrapper.css({
            position: "relative",
            width: "100%",
            height: 20
          });
          $wrapper.label = $wrapper.create("label");
          $wrapper.label.fontStyle("Arial", 12, "#fff").text(name).css({
            left: 10
          });
          $wrapper.value = $wrapper.create("value");
          $wrapper.value.fontStyle("Arial", 12, "#fff").text(0).css({
            right: 10
          });
          _display[name] = $wrapper;
        }
        _map[name] += amt;
      }
    };
    this.trace = function (name, filter = null) {
      _trace = name;
      _filter = filter;
    };
    this.log = function () {
      for (let key in _this.stats) {
        console.log(key, _this.stats[key]);
      }
      console.log("----");
    };
  }, "static");
  Class(function Fluid(_simSize = 128, _dyeSize = 512, _rect = Stage) {
    Inherit(this, Component);
    const _this = this;
    var _fbos = {};
    var _scenes = {};
    var _tmpVec = new Vector2();
    var _lastSplat = Render.TIME;
    const DYE_WIDTH = _dyeSize;
    const DYE_HEIGHT = _dyeSize;
    const SIM_WIDTH = _simSize;
    const SIM_HEIGHT = _simSize;
    const config = {
      DENSITY_DISSIPATION: 0.97,
      VELOCITY_DISSIPATION: 0.98,
      PRESSURE_DISSIPATION: 0.8,
      PRESSURE_ITERATIONS: 20,
      CURL: 30,
      DEBUG_MOUSE: true,
      SPLAT_RADIUS: 0.25
    };
    function loop() {
      if (config.DEBUG_MOUSE) {
        (function drawMouse() {
          _this.drawInput(Mouse.x, Mouse.y, Mouse.delta.x * 10, Mouse.delta.y * 10, new Color("#777777"));
        })();
      }
      _scenes.curl.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.curl.render(_fbos.curl.fbo);
      _scenes.vorticity.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.vorticity.uniforms.uCurl.value = _fbos.curl.fbo;
      _scenes.vorticity.uniforms.curl.value = config.CURL;
      _scenes.vorticity.render(_fbos.velocity.write);
      _fbos.velocity.swap();
      _scenes.divergence.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.divergence.render(_fbos.divergence.fbo);
      _scenes.clear.uniforms.uTexture.value = _fbos.pressure.read;
      _scenes.clear.uniforms.value.value = config.PRESSURE_DISSIPATION;
      _scenes.clear.render(_fbos.pressure.write);
      _fbos.pressure.swap();
      _scenes.pressure.uniforms.uDivergence.value = _fbos.divergence.fbo;
      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
        _scenes.pressure.uniforms.uPressure.value = _fbos.pressure.read;
        _scenes.pressure.render(_fbos.pressure.write);
        _fbos.pressure.swap();
      }
      _scenes.gradientSubtract.uniforms.uPressure.value = _fbos.pressure.read;
      _scenes.gradientSubtract.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.gradientSubtract.render(_fbos.velocity.write);
      _fbos.velocity.swap();
      _scenes.advection.uniforms.texelSize.value.set(1 / SIM_WIDTH, 1 / SIM_HEIGHT);
      _scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.advection.uniforms.uSource.value = _fbos.velocity.read;
      _scenes.advection.uniforms.dissipation.value = config.VELOCITY_DISSIPATION;
      _scenes.advection.render(_fbos.velocity.write);
      _fbos.velocity.swap();
      _scenes.advection.uniforms.texelSize.value.set(1 / DYE_WIDTH, 1 / DYE_HEIGHT);
      _scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read;
      _scenes.advection.uniforms.uSource.value = _fbos.density.read;
      _scenes.advection.uniforms.dissipation.value = config.DENSITY_DISSIPATION;
      _scenes.advection.render(_fbos.density.write);
      _fbos.density.swap();
      _scenes.display.uniforms.uTexture.value = _fbos.density.read;
      _scenes.display.uniforms.texelSize.value.set(1 / _rect.width, 1 / _rect.height);
      _scenes.display.render(_this.rt);
    }
    this.rt = Utils3D.createRT(_rect.width, _rect.height);
    this.fbos = _fbos;
    this.additiveBlending = true;
    _this.rt.disableDepth = true;
    (function initFBOs() {
      _fbos.density = _this.initClass(FluidFBO, DYE_WIDTH, DYE_HEIGHT, Texture.LINEAR);
      _fbos.velocity = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.LINEAR);
      _fbos.divergence = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST);
      _fbos.curl = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST);
      _fbos.pressure = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST);
    })();
    (function initScenes() {
      _scenes.curl = _this.initClass(FluidScene, "fluidBase", "curlShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uVelocity: {
          value: null
        },
        depthWrite: false
      });
      _scenes.vorticity = _this.initClass(FluidScene, "fluidBase", "vorticityShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uVelocity: {
          value: null
        },
        uCurl: {
          value: null
        },
        curl: {
          value: config.CURL
        },
        dt: {
          value: Render.REFRESH_RATE / 1000 / 100
        }
      });
      _scenes.divergence = _this.initClass(FluidScene, "fluidBase", "divergenceShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uVelocity: {
          value: null
        }
      });
      _scenes.clear = _this.initClass(FluidScene, "fluidBase", "clearShader", {
        uTexture: {
          value: null
        },
        value: {
          value: config.PRESSURE_DISSIPATION
        }
      });
      _scenes.pressure = _this.initClass(FluidScene, "fluidBase", "pressureShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uPressure: {
          value: null
        },
        uDivergence: {
          value: null
        }
      });
      _scenes.gradientSubtract = _this.initClass(FluidScene, "fluidBase", "gradientSubtractShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uPressure: {
          value: null
        },
        uVelocity: {
          value: null
        }
      });
      _scenes.advection = _this.initClass(FluidScene, "fluidBase", "advectionShader", {
        texelSize: {
          value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT)
        },
        uVelocity: {
          value: null
        },
        uSource: {
          value: null
        },
        dt: {
          value: Render.REFRESH_RATE / 1000 / 100
        },
        dissipation: {
          value: config.VELOCITY_DISSIPATION
        }
      });
      _scenes.display = _this.initClass(FluidScene, "fluidBase", "displayShader", {
        texelSize: {
          value: new Vector2(1 / _rect.width, 1 / _rect.height)
        },
        uTexture: {
          value: null
        }
      });
      _scenes.splat = _this.initClass(FluidScene, "fluidBase", "splatShader", {
        uTarget: {
          value: null
        },
        aspectRatio: {
          value: _rect.width / _rect.height
        },
        point: {
          value: new Vector2()
        },
        prevPoint: {
          value: new Vector2()
        },
        color: {
          value: new Vector3()
        },
        bgColor: {
          value: new Color("#000000")
        },
        radius: {
          value: config.SPLAT_RADIUS / 100
        },
        canRender: {
          value: 0
        },
        uAdd: {
          value: 1
        }
      });
    })();
    _this.startRender(loop);
    this.updateConfig = function (key, value) {
      config[key] = value;
    };
    this.drawInput = function (x, y, dx, dy, color, radius = config.SPLAT_RADIUS) {
      _scenes.splat.uniforms.uTarget.value = _fbos.velocity.read;
      _scenes.splat.uniforms.radius.value = radius / 200;
      _scenes.splat.uniforms.aspectRatio.value = _rect.width / _rect.height;
      _tmpVec.set(x / _rect.width, 1 - y / _rect.height);
      let now = Render.TIME;
      let delta = now - _lastSplat;
      _lastSplat = now;
      if (delta > 50) {
        _scenes.splat.uniforms.prevPoint.value.copy(_tmpVec);
      } else {
        _scenes.splat.uniforms.prevPoint.value.copy(_scenes.splat.uniforms.point.value);
      }
      _scenes.splat.uniforms.point.value.copy(_tmpVec);
      _scenes.splat.uniforms.color.value.set(dx, -dy, 1);
      _scenes.splat.uniforms.uAdd.value = 1;
      _scenes.splat.render(_fbos.velocity.write);
      _fbos.velocity.swap();
      _scenes.splat.uniforms.uTarget.value = _fbos.density.read;
      _scenes.splat.uniforms.color.value.set(color.r, color.g, color.b);
      _scenes.splat.uniforms.uAdd.value = _this.additiveBlending ? 1 : 0;
      _scenes.splat.render(_fbos.density.write, true);
      _fbos.density.swap();
      _scenes.splat.uniforms.canRender.value = 1;
    };
  });
  Class(function FluidFBO(_width, _height, _filter) {
    Inherit(this, Component);
    const _this = this;
    const type = Device.mobile || Renderer.type != Renderer.WEBGL1 ? Texture.HALF_FLOAT : Texture.FLOAT;
    var _fbo1 = new RenderTarget(_width, _height, {
      minFilter: _filter,
      magFilter: _filter,
      format: Texture.RGBAFormat,
      type: type
    });
    var _fbo2 = new RenderTarget(_width, _height, {
      minFilter: _filter,
      magFilter: _filter,
      format: Texture.RGBAFormat,
      type: type
    });
    this.fbo = _fbo1;
    this.uniform = {
      value: _fbo1
    };
    _fbo1.disableDepth = true;
    _fbo2.disableDepth = true;
    _fbo1.generateMipmaps = false;
    _fbo2.generateMipmaps = false;
    this.swap = function () {
      let temp = _fbo1;
      _fbo1 = _fbo2;
      _fbo2 = temp;
      _this.uniform.value = _fbo1;
    };
    this.get("read", _ => _fbo1);
    this.get("write", _ => _fbo2);
  });
  Class(function FluidLayer(_input, _group) {
    Inherit(this, Object3D);
    var _fluid;
    var _config;
    var _this = this;
    (function initConfig() {
      (_config = InputUIL.create(_input.prefix + "fluid", _group)).setLabel("Fluid Config");
      _config.add("dyeSize", 512);
      _config.add("simSize", 128);
      _config.add("velocity", 0.98);
      _config.add("density", 0.97);
      _config.add("pressure", 0.8);
      _config.add("iterations", 5);
      _config.add("curl", 30);
      _config.add("defaultRadius", 25);
      _config.addToggle("debugMouse", false);
    })();
    (function initFluid() {
      let rect = Stage;
      let wildcard = _input.get("wildcard");
      if (wildcard && wildcard.includes("x")) {
        let split = wildcard.split("x");
        rect = {
          width: Number(split[0]),
          height: Number(split[1])
        };
      }
      _fluid = _this.initClass(Fluid, _config.getNumber("simSize"), _config.getNumber("dyeSize"), rect);
      _this.rt = _fluid.rt;
      _this.fbos = _fluid.fbos;
      _config.onUpdate = key => {
        switch (key) {
          case "velocity":
            _fluid.updateConfig("VELOCITY_DISSIPATION", _config.getNumber(key));
            break;
          case "density":
            _fluid.updateConfig("DENSITY_DISSIPATION", _config.getNumber(key));
            break;
          case "pressure":
            _fluid.updateConfig("PRESSURE_DISSIPATION", _config.getNumber(key));
            break;
          case "iterations":
            _fluid.updateConfig("PRESSURE_ITERATIONS", _config.getNumber(key));
            break;
          case "curl":
            _fluid.updateConfig("CURL", _config.getNumber(key));
            break;
          case "defaultRadius":
            _fluid.updateConfig("SPLAT_RADIUS", _config.getNumber(key));
            break;
          case "debugMouse":
            _fluid.updateConfig("DEBUG_MOUSE", _config.get(key));
        }
      };
      ["velocity", "density", "pressure", "iterations", "curl", "defaultRadius", "debugMouse"].forEach(_config.onUpdate);
    })();
    this.initMesh = function initMesh() {
      let shader = _this.initClass(Shader, "ScreenQuad", {
        tMap: {
          value: _fluid.rt
        }
      });
      let mesh = new Mesh(World.QUAD, shader);
      _this.add(mesh);
      _this.mesh = mesh;
    };
    this.drawInput = _fluid.drawInput;
    this.set("additiveBlending", v => _fluid.additiveBlending = v);
    this.applyTo = function (shader) {
      shader.uniforms.tFluid = _this.fbos.velocity.uniform;
      shader.uniforms.tFluidMask = {
        value: _this
      };
    };
  });
  Class(function FluidScene(_vs, _fs, _uniforms) {
    Inherit(this, Component);
    const _this = this;
    var _scene = new Scene();
    (function () {
      _uniforms.depthWrite = false;
      let shader = _this.initClass(Shader, _vs, _fs, _uniforms);
      let mesh = new Mesh(World.QUAD, shader);
      shader.depthWrite = false;
      mesh.noMatrices = true;
      _scene.add(mesh);
      _this.uniforms = shader.uniforms;
    })();
    this.render = function (rt) {
      World.RENDERER.autoClear = false;
      World.RENDERER.renderSingle(_scene.children[0], World.CAMERA, rt);
      World.RENDERER.autoClear = true;
    };
  });
  Class(function Fullscreen() {
    Inherit(this, Events);
    const _this = this;
    function update() {
      const isOpen = !!document.fullscreenElement || !!document.webkitFullscreenElement || !!document.mozFullScreenElement || !!document.msFullscreenElement;
      if (isOpen !== _this.isOpen) {
        _this.isOpen = isOpen;
        _this.events.fire(Events.FULLSCREEN, {
          fullscreen: _this.isOpen
        });
      }
    }
    this.isOpen = false;
    (function addHandlers() {
      ["onfullscreenchange", "onwebkitfullscreenchange", "onmozfullscreenchange", "onmsfullscreenchange", "onfullscreenerror", "onwebkitfullscreenerror", "onmozfullscreenerror", "onmsfullscreenerror"].forEach(evt => {
        if (document[evt] !== undefined) {
          document[evt] = update;
        }
      });
    })();
    this.open = function (element) {
      element = element || document.body;
      ["requestFullscreen", "webkitRequestFullscreen", "mozRequestFullScreen", "msRequestFullscreen"].every(method => {
        if (element[method] === undefined) {
          return true;
        }
        element[method]({
          navigationUI: "hide"
        });
      });
    };
    this.close = function () {
      ["exitFullscreen", "webkitExitFullscreen", "mozCancelFullScreen", "msExitFullscreen"].every(method => {
        if (document[method] === undefined) {
          return true;
        }
        document[method]();
      });
    };
    Object.defineProperty(this, "enabled", {
      get: () => ["fullscreenEnabled", "webkitFullscreenEnabled", "mozFullScreenEnabled", "msFullscreenEnabled"].some(prop => Boolean(document[prop]))
    });
  }, "static");
  Class(function FXAA() {
    Inherit(this, NukePass);
    this.uniforms = {
      tMask: {
        value: null
      }
    };
    this.init("FXAA", "FXAA");
    this.setMask = function (texture) {
      this.uniforms.tMask.value = texture;
    };
  });
  Class(function JoystickInteraction(_config = {}) {
    Inherit(this, Events);
    const _this = this;
    var _joystick;
    var _hitObject;
    function loop(t, delta) {
      if (!_joystick) {
        return;
      }
      let e = {
        target: {}
      };
      if (Math.abs(_joystick.x) < 0.001 && Math.abs(_joystick.y) < 0.001) {
        e.x = _this.move.x;
        e.y = _this.move.y;
        _this.delta.x = 0;
        _this.delta.y = 0;
        _this.move.x = 0;
        _this.move.y = 0;
        if (_this.isTouching) {
          _this.isTouching = false;
          _this.events.fire(Interaction.END, e, true);
        }
      } else if (_this.isTouching) {
        _this.delta.x = _joystick.x * delta;
        _this.delta.y = _joystick.y * delta;
        _this.move.x += _this.delta.x;
        _this.move.y += _this.delta.y;
        e.x = _this.move.x;
        e.y = _this.move.y;
        _this.velocity.x = Math.abs(_this.delta.x) / delta;
        _this.velocity.y = Math.abs(_this.delta.y) / delta;
        _this.events.fire(Interaction.MOVE, e, true);
        _this.events.fire(Interaction.DRAG, e, true);
      } else {
        _this.isTouching = true;
        e.x = _this.move.x = 0;
        e.y = _this.move.y = 0;
        _this.delta.x = 0;
        _this.delta.y = 0;
        _this.events.fire(Interaction.START, e, true);
      }
    }
    this.delta = new Vector2();
    this.move = new Vector2();
    _this.velocity = new Vector2();
    (function () {
      if (Device.system.xr.vr) {
        if (_config && _config.raycast) {
          _hitObject = _config;
          World.CAMERA;
        } else if (_config) {
          _hitObject = _config.hit;
          if (!_config.hitCamera) {
            World.CAMERA;
          }
        }
        if (!_hitObject) {
          throw "JoystickInteraction requires a Mesh for hit testing";
        }
        (async function addHandlers() {
          await VRInput.ready();
          _joystick = {
            x: 0,
            y: 0
          };
          VRInput.controllers.forEach(controller => _this.events.sub(controller, VRInput.JOYSTICK, e => {
            (function handleJoystick(e, controller) {
              if (!function checkHit(controller) {
                return _hitObject.interaction.checkObjectFromValues(_hitObject, controller.group.worldPos, controller.pointer, _config.hitCamera);
              }(controller)) {
                _joystick.x = 0;
                _joystick.y = 0;
              } else {
                _joystick.x = e.x;
                _joystick.y = e.y;
              }
            })(e, controller);
          }));
        })();
        Render.start(loop);
      }
    })();
  });
  Interaction.Class(function Renderer(_object) {
    var _hydraObject = _object instanceof HydraObject;
    this.needsUpdate = !!_hydraObject;
    if (_hydraObject) {
      _object.x = _object.x || 0;
      _object.y = _object.y || 0;
      _object.z = _object.z || 0;
      _object.pos = {
        x: 0,
        y: 0,
        z: 0
      };
    }
    this.update = function () {
      _object.transform();
    };
  });
  Interaction.Class(function Slider(_object, _direction, _config) {
    Inherit(this, Component);
    var _input;
    var _values;
    var _renderer;
    var _side;
    var _addInput;
    var _axis;
    var _views;
    var _dragging;
    var _lockMove;
    var _cacheStart;
    var _hitObject;
    var _this = this;
    var _holdOffset = 0;
    var _lastSign = 1;
    function copyFromTo(o1, o2) {
      if (!_this.interpolate) {
        if (o1.x !== undefined) {
          o2.x = o1.x;
        }
        if (o1.y !== undefined) {
          o2.y = o1.y;
        }
        if (o1.z !== undefined) {
          o2.z = o1.z;
        }
      }
    }
    function loop() {
      if (_this.interpolate) {
        if (_values.x !== undefined) {
          _object.x = Math.lerp(_values.x, _object.x, _this.interpolate);
        }
        if (_values.y !== undefined) {
          _object.y = Math.lerp(_values.y, _object.y, _this.interpolate);
        }
        if (_values.z !== undefined) {
          _object.z = Math.lerp(_values.z, _object.z, _this.interpolate);
        }
      }
      (function getFullElapsed() {
        if (!_this.preventVisible && (_this.elapsed = Math.abs(_object[_axis]) / Math.abs(-_this[_side] * (_this.maxSlides - 1)), _views)) {
          for (var i = 0; i < _views.length; i++) {
            var view = _views[i];
            var pos = _this[_side] * i;
            var offset = (_object[_axis] + pos) / _this[_side];
            view.sliderOffset = offset;
            if (view.updatePosition) {
              view.updatePosition(offset, _dragging);
            }
          }
        }
      })();
    }
    function tweenObj(_to) {
      var css = _this.cssTransitions;
      _this.needsRender = true;
      if (_this.interpolate && _values[_axis] === undefined) {
        _values[_axis] = _object[_axis];
      }
      copyFromTo(_object, _values);
      tween(_values, _to, _this.easeTime, _this.ease).onUpdate(() => {
        copyFromTo(_values, css ? _object.pos : _object);
        if (!css && _this.autoRender && _renderer.needsUpdate) {
          _renderer.update();
        }
        if (_this.onUpdate) {
          _this.onUpdate(_this.elapsed);
        }
      }).onComplete(_ => _this.needsRender = false);
      if (css) {
        var cssTo = {
          [_axis]: _to[_axis]
        };
        _object.tween(cssTo, _this.easeTime, _this.ease);
      }
    }
    function incSlide() {
      _this.currentSlide++;
      if (_this.repeatable && _this.currentSlide > _this.maxSlides - 1) {
        _this.currentSlide = 0;
      }
      if (!_this.infinite && _this.currentSlide > _this.maxSlides - 1) {
        _this.currentSlide = _this.maxSlides - 1;
      }
      onUpdateSlide(_this.currentSlide);
    }
    function decSlide() {
      _this.currentSlide--;
      if (_this.repeatable && _this.currentSlide < 0) {
        _this.currentSlide = _this.maxSlides - 1;
      }
      if (!_this.infinite && _this.currentSlide < 0) {
        _this.currentSlide = 0;
      }
      onUpdateSlide(_this.currentSlide);
    }
    function onUpdateSlide(slide) {
      _this.events.fire(Interaction.Slider.UPDATE, {
        slide: slide
      });
    }
    function inputUpdate(e, delta = _input.move, override) {
      if (!Device.mobile && !_this.desktopDrag || !_dragging && !override || _this.preventMovement || _this.preventVisible) {
        return;
      }
      (_this.interpolate ? _values : _object)[_axis] = -_this[_side] * _this.currentSlide + delta[_axis] * _this.multiplier + _holdOffset;
      if (!_this.infinite && function outOfBounds() {
        return _object[_axis] > 0 || _this.currentSlide == _this.maxSlides - 1 && _object[_axis] < -_this[_side] * _this.currentSlide;
      }()) {
        (function clampWithFriction() {
          let obj = _this.interpolate ? _values : _object;
          var val = obj[_axis];
          var max = -_this[_side] * _this.currentSlide;
          if (val > 0) {
            obj[_axis] = val * _this.friction;
          } else if (val < max) {
            obj[_axis] = max + (val - max) * _this.friction;
          }
        })();
      }
      if (_this.cssTransitions) {
        _object.stopTween();
      }
      e.elapsed = _this.elapsed;
      _this.events.fire(Interaction.MOVE, e, true);
      if (_this.autoRender && _renderer.needsUpdate) {
        if (_this.cssTransitions) {
          _object.pos[_axis] = _object[_axis];
        }
        _renderer.update();
      }
      delta;
    }
    function lockStart(e) {
      _cacheStart = e;
    }
    function lockMove(e) {
      if (Math.abs(_input.move[_axis]) > _lockMove && !_this.flag("overrideLock") && !_this.flag("preventMove")) {
        inputStart(_cacheStart);
        _this.flag("overrideLock", true);
        _this.events.fire(Interaction.Slider.OVERRIDE_LOCK, {
          action: "start"
        });
      }
      if (Math.abs(_input.move[_axis == "x" ? "y" : "x"]) > _lockMove) {
        _this.flag("preventMove", true);
      }
    }
    function lockEnd(e) {
      _cacheStart = null;
      if (_this.flag("overrideLock")) {
        _this.events.fire(Interaction.Slider.OVERRIDE_LOCK, {
          action: "end"
        });
      }
      _this.flag("overrideLock", false);
      _this.flag("preventMove", false);
    }
    function inputStart(e) {
      if ((!!Device.mobile || !!_this.desktopDrag) && (e.target.className != "hit" || _config.allowHit == 1) && !_this.preventMovement && !_this.preventVisible && !!function checkHit(e) {
        return !_hitObject || _hitObject.interaction.checkObjectHit(_hitObject, e, _config.hitCamera);
      }(e)) {
        _dragging = true;
        clearTween(_values);
        _holdOffset = _values[_axis] + _this[_side] * _this.currentSlide || 0;
        Date.now();
        0;
        _this.needsRender = true;
        _this.events.fire(Interaction.Slider.START_INTERACTION, null, true);
      }
    }
    function inputEnd(e, override) {
      if ((Device.mobile || _this.desktopDrag) && (_dragging || override) && !_this.preventMovement && !_this.preventVisible) {
        var velocity;
        var target = {};
        var delta = _input.delta[_axis];
        if (delta !== 0 || _input.velocity[_axis] === 0) {
          _lastSign = Math.sign(delta);
        }
        velocity = _input.velocity[_axis] * _lastSign;
        Date.now();
        if (RenderManager.type != RenderManager.VR && (Math.abs(velocity) > 0.1 || override)) {
          if ((override || velocity) > 0) {
            decSlide();
          } else {
            incSlide();
          }
        } else {
          let currentSlide = Math.clamp(Math.round(-_object[_axis] / _this[_side]), 0, _this.maxSlides - 1);
          if (currentSlide !== _this.currentSlide) {
            _this.currentSlide;
            _this.currentSlide = currentSlide;
            onUpdateSlide(_this.currentSlide);
          }
        }
        target[_axis] = -_this[_side] * _this.currentSlide;
        _dragging = false;
        tweenObj(target);
        _this.events.fire(Interaction.Slider.END_INTERACTION, null, true);
      }
    }
    this.autoRender = true;
    this.currentSlide = 0;
    this.maxSlides = _config.slides;
    this.width = _config.width;
    this.height = _config.height;
    this.snapPoint = 0.3;
    this.ease = "easeOutCubic";
    this.easeTime = 500;
    this.friction = 0.3;
    this.infinite = false;
    this.desktopDrag = typeof _config.desktopDrag != "boolean" || _config.desktopDrag;
    this.preventMovement = false;
    this.cssTransitions = false;
    this.multiplier = 1;
    this.elapsed = 0;
    this.interpolate = false;
    (function initHelpers() {
      if (RenderManager.type == RenderManager.VR) {
        _input = _this.initClass(JoystickInteraction, {
          hit: _config.vrHit || _config.hit || _object,
          hitCamera: _config.hitCamera
        });
      } else {
        let object = _config.hit || _object;
        if (object instanceof GLUIObject) {
          _hitObject = object;
          object = Stage;
        }
        _input = _this.initClass(Interaction, object);
      }
      _this.events.sub(_input, Interaction.MOVE, inputUpdate);
      _this.events.sub(_input, Interaction.START, inputStart);
      _this.events.sub(_input, Interaction.END, inputEnd);
      _this.input = _input;
      _values = {};
      _renderer = _config.renderer || _this.initClass(Interaction.Renderer, _object);
    })();
    (function initDirection() {
      _side = _direction.x ? "width" : "height";
      _axis = _direction.x ? "x" : "y";
    })();
    _this.startRender(loop);
    this.set("views", function (v) {
      _views = v;
    });
    this.set("lockMove", function (v) {
      _lockMove = v;
    });
    this.lockDirection = function (move = 50) {
      _lockMove = move;
      _this.events.unsub(_input, Interaction.START, inputStart);
      _this.events.sub(_input, Interaction.START, lockStart);
      _this.events.sub(_input, Interaction.MOVE, lockMove);
      _this.events.sub(_input, Interaction.END, lockEnd);
    };
    this.moveTo = function (slide) {
      if (!_this.infinite) {
        if (slide < 0) {
          slide = 0;
        }
        if (slide >= _this.maxSlides) {
          slide = _this.maxSlides - 1;
        }
      }
      _this.currentSlide = slide;
      var target = {
        [_axis]: -_this[_side] * _this.currentSlide
      };
      tweenObj(target);
      onUpdateSlide(_this.currentSlide);
    };
    this.jumpTo = function (slide) {
      if (!_this.infinite) {
        if (slide < 0) {
          slide = 0;
        }
        if (slide >= _this.maxSlides) {
          slide = _this.maxSlides - 1;
        }
      }
      _this.currentSlide = slide;
      _values[_axis] = -_this[_side] * _this.currentSlide;
      copyFromTo(_values, _object);
      if (_this.autoRender && _renderer.needsUpdate) {
        _object.pos[_axis] = _object[_axis];
        _renderer.update();
      }
      onUpdateSlide(_this.currentSlide);
    };
    this.next = function () {
      incSlide();
      var target = {
        [_axis]: -_this[_side] * _this.currentSlide
      };
      tweenObj(target);
    };
    this.prev = function () {
      decSlide();
      var target = {
        [_axis]: -_this[_side] * _this.currentSlide
      };
      tweenObj(target);
    };
    this.clearTween = function () {
      clearTween(_values);
    };
    this.onInvisible = function () {
      _this.preventVisible = true;
    };
    this.onVisible = function () {
      _this.preventVisible = false;
    };
    this.addInput = function (x = 0, y = 0) {
      if (!_this.flag("preventInput") && (_addInput || ((_addInput = {}).delta = {}), _addInput.delta.x = x, _addInput.delta.y = y, _addInput.total ||= 0, inputUpdate(_addInput, _addInput.delta, true), Math.abs(_object[_axis]) > Math.abs(_this[_side]) * 0.2)) {
        let val = Math.abs(y) > Math.abs(x) ? y : x;
        _this.moveTo(_this.currentSlide + Math.sign(val));
        _this.flag("preventInput", true, _this.easeTime);
      }
    };
  }, _ => {
    Interaction.Slider.OVERRIDE_LOCK = "slider_override_lock";
    Interaction.Slider.UPDATE = "slider_update";
    Interaction.Slider.START_INTERACTION = "slider_start_interaction";
    Interaction.Slider.END_INTERACTION = "slider_end_interaction";
  });
  Class(function GLA11y() {
    Inherit(this, Element);
    const _this = this;
    var $this;
    var _groups = [];
    var _links = [];
    function isVisible(group) {
      if (group.__glseoParent) {
        const seoHidden = !!group.__glseoParent.seoHidden;
        const hidden = !!group.__glseoParent.hidden;
        return !seoHidden && !hidden;
      }
      return group.seo.enabled && group.determineVisible();
    }
    function isDeleted(group) {
      if (group.__glseoParent) {
        return group.__glseoParent.deleted;
      } else {
        return group.deleted;
      }
    }
    function loop() {
      for (let i = _groups.length - 1; i > -1; i--) {
        let group = _groups[i];
        if (isDeleted(group)) {
          $this.removeChild(group.seo);
          return _groups.splice(i, 1);
        }
        if (isVisible(group)) {
          if (group.seo && group.seo.hidden) {
            group.seo.hidden = false;
            $this.add(group.seo);
          }
          seo = group.seo;
          Array.prototype.slice.call(seo.div.children).forEach(div => {
            let seo = div.hydraObject;
            let group = seo && seo.group;
            if (!seo || !group) {
              return;
            }
            let hidden = !group.determineVisible();
            if (hidden !== seo.hidden) {
              if (hidden) {
                seo.hide();
              } else {
                seo.show();
              }
              seo.hidden = hidden;
            }
          });
        } else if (group.seo && !group.seo.hidden) {
          group.seo.hidden = true;
          $this.removeChild(group.seo, true);
        }
      }
      var seo;
      for (let i = _links.length - 1; i > -1; i--) {
        let group = _links[i];
        if (isDeleted(group)) {
          $this.removeChild(group.seo);
          return _groups.splice(i, 1);
        }
        if (isVisible(group)) {
          if (group.seoHidden) {
            group.seoHidden = false;
            group.seoDOM.forEach(obj => obj.show());
          }
        } else if (!group.seoHidden) {
          group.seoHidden = true;
          group.seoDOM.forEach(obj => obj.hide());
        }
      }
    }
    function aLink($object, url, label, options = {}) {
      let seo = $("link", "a");
      seo.group = $object.group;
      seo.attr("href", url === "#" ? url : Hydra.absolutePath(url));
      seo.text(label);
      seo.accessible();
      seo.div.onfocus = _ => $object._divFocus();
      seo.div.onblur = _ => $object._divBlur();
      seo.div.onclick = e => {
        e.preventDefault();
        $object._divSelect();
      };
      if (options.role) {
        seo.attr("role", options.role);
        seo.div.onkeydown = e => {
          switch (e.key) {
            case " ":
            case "Spacebar":
              e.preventDefault();
              e.stopPropagation();
              $object._divSelect();
          }
        };
      }
      return seo;
    }
    (async function () {
      window.GLSEO = _this;
      await Hydra.ready();
      (function initHTML() {
        ($this = _this.element).setZ(-1);
        Stage.add($this);
      })();
      HydraCSS.style(".GLA11y *", {
        position: "relative"
      });
    })();
    this.registerPage = function (group, name) {
      let topLevel = group;
      if (!(group = group instanceof GLUIObject ? group : group.group || group.scene || group).determineVisible && group.group) {
        group.determineVisible = group.group.determineVisible.bind(group.group);
      }
      if (!Global.PLAYGROUND) {
        World.ELEMENT.mouseEnabled(false);
      }
      topLevel.seo = group.seo = $(name);
      group.seo.hidden = true;
      group.seo.enabled = true;
      let remove = group.seo.remove.bind(group.seo);
      group.seo.remove = _ => {
        _groups.remove(group);
        remove();
      };
      _groups.push(group);
      _this.startRender(loop, 10);
    };
    this.setPageH1 = function (group, title) {
      let $h1 = group.seo.h1;
      if (!$h1) {
        $h1 = group.seo.create("title", "h1");
        defer(() => {
          let el = $h1.div;
          el.parentNode.insertBefore(el, el.parentNode.firstChild);
        });
      }
      $h1.text(title);
    };
    this.registerPersist = function (group, name) {
      let topLevel = group;
      group = group instanceof GLUIObject ? group : group.group || group.scene || group;
      if (!Global.PLAYGROUND) {
        World.ELEMENT.mouseEnabled(false);
      }
      topLevel.seo = group.seo = $this.create(name);
    };
    this.link = function ($dom, group) {
      if ($dom instanceof HydraObject) {
        if (!(group = group.group || group.scene || group).seoDOM) {
          group.seoDOM = [];
        }
        group.seoDOM.push($dom);
        _links.push(group);
      }
      if ($dom instanceof GLUIObject) {
        $dom.seo = group.seo;
      }
    };
    this.textNode = function ($text, text) {
      let parent = ($text._3d ? $text.anchor || $text.group : $text)._parent;
      if ($text.parentSeo) {
        let parentSeo = $text.parentSeo;
        parent = parentSeo.group && parentSeo.group.seo ? parentSeo.group : parentSeo;
      } else if (parent) {
        while (parent && !parent.seo) {
          parent = parent._parent;
        }
      }
      if (parent && parent.seo) {
        if ($text.seo) {
          $text.seo.text(text);
          $text.seo.accessible();
        } else {
          $text.seo = $("text");
          $text.seo.group = $text.group;
          $text.seo.text(text);
          $text.seo.accessible();
          parent.seo.add($text.seo);
          $text.seo.aLink = function (url, options) {
            let index = Array.prototype.slice.call(parent.seo.div.children).indexOf($text.seo.div);
            $text.seo.remove();
            $text.seo = aLink($text, url, text, options);
            parent.seo.div.insertBefore($text.seo.div, parent.seo.div.children[index]);
          };
          $text.seo.unlink = function () {
            parent.seo.div.removeChild($text.seo.div);
            $text.seo.group = null;
            $text.seo = null;
          };
        }
      }
    };
    this.bindToPage = function (parent, child, name) {
      child.__glseoParent = parent;
      _this.registerPage(child, name);
    };
    this.objectNode = function ($object, $parent) {
      let parent = $parent || ($object._3d ? $object.group : $object)._parent;
      if ($object.parentSeo) {
        parent = $object.parentSeo.group || $object.parentSeo;
      } else {
        if (!parent) {
          return;
        }
        while (parent && !parent.seo) {
          parent = parent._parent;
        }
      }
      if (parent && parent.seo) {
        if (!$object.seo) {
          $object.seo = {};
          $object.seo.group = $object.group;
          $object.seo.aLink = function (url, label, options) {
            let index = Array.prototype.slice.call(parent.seo.div.children).indexOf($object.seo.div);
            $object.seo = aLink($object, url, label, options);
            parent.seo.div.insertBefore($object.seo.div, parent.seo.div.children[index]);
            $object.seo.unlink = function () {
              parent.seo.div.removeChild($object.seo.div);
              $object.seo.group = null;
              $object.seo = null;
            };
          };
        }
      }
    };
  }, "static");
  Class(function GlassShader(_mesh, _shader) {
    _shader ||= _mesh;
    _shader.addUniforms({
      tEnv: {
        value: null
      },
      uRefractionRatio: {
        value: 1
      },
      uReflectScale: {
        value: 1
      },
      uEnvBlend: {
        value: 1
      },
      uRatio: {
        value: 0.5
      },
      uAttenuation: {
        value: 0.5
      },
      uAlpha: {
        value: 1
      },
      uShininess: {
        value: 1
      },
      uFresnelPow: {
        value: 1
      },
      uFresnelAlpha: {
        value: 1
      },
      uDistortStrength: {
        value: 1
      },
      uSpecAdd: {
        value: new Vector2(1, 0)
      },
      uPhongColor: {
        value: new Color()
      },
      uFresnelColor: {
        value: new Color()
      },
      uLightDir: {
        value: new Vector3(0, 0, 1)
      },
      uTransparent: {
        value: 1
      }
    });
  });
  Class(function GLScreenProjection(_camera = World.CAMERA, _target = new Vector2()) {
    Inherit(this, Object3D);
    var _this = this;
    var _projection = new ScreenProjection(_camera);
    var _m0 = new Matrix4();
    var _m1 = new Matrix4();
    function loop() {
      _this.pos.set(_target.x, _target.y);
      _this.pos3D.copy(_projection.unproject(_this.pos));
      _this.group.updateMatrixWorld();
      _m0.copy(_camera.projectionMatrix);
      _m1.getInverse(_camera.matrixWorld);
      _this.matrix.multiplyMatrices(_m0, _m1);
      _this.uniforms.normalMatrix.value.copy(_camera.matrixWorld);
      _this.uniforms.modelMatrix.value.copy(_this.group.matrixWorld);
    }
    this.resolution = new Vector2();
    this.pos = new Vector2();
    this.pos3D = new Vector3();
    this.matrix = new Matrix4();
    this.uniforms = {
      projMatrix: {
        type: "m4",
        value: this.matrix
      },
      pos: {
        type: "v2",
        value: this.pos
      },
      pos3D: {
        type: "v3",
        value: this.pos3D
      },
      normalMatrix: {
        type: "m4",
        value: new Matrix4()
      },
      modelMatrix: {
        type: "m4",
        value: new Matrix4()
      }
    };
    this.set("camera", v => {
      _camera = v;
      _projection.camera = _camera;
    });
    this.set("target", v => {
      _target = v;
    });
    this.update = loop;
    this.start = function () {
      _this.startRender(loop);
    };
    this.stop = function () {
      _this.stopRender(loop);
    };
  });
  Class(function GLText({
    font: font,
    italic = false,
    bold = false,
    text: text,
    width = Infinity,
    align = "left",
    size = 1,
    direction = "ltr",
    letterSpacing = 0,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    paragraphSpacing = 1,
    color = new Color("#000000"),
    alpha = 1,
    shader = "DefaultText",
    customCompile = false
  }) {
    const _this = this;
    var _override;
    var _promise = Promise.create();
    const config = GLText.FONT_CONFIG[font];
    function overrideParams() {
      if (GLText.overrideParams) {
        _override = {
          letterSpacing: letterSpacing,
          size: size,
          wordSpacing: wordSpacing,
          lineHeight: lineHeight
        };
        let obj = GLText.overrideParams({
          letterSpacing: letterSpacing,
          size: size,
          wordSpacing: wordSpacing,
          lineHeight: lineHeight
        });
        letterSpacing = obj.letterSpacing;
        size = obj.size;
        wordSpacing = obj.wordSpacing;
        lineHeight = obj.lineHeight;
      }
    }
    function resetOverride() {
      if (_override) {
        letterSpacing = _override.letterSpacing;
        size = _override.size;
        wordSpacing = _override.wordSpacing;
        lineHeight = _override.lineHeight;
      }
    }
    (function init() {
      overrideParams();
      _this.charLength = text.length;
      _this.text = new GLTextGeometry({
        font: font,
        italic: italic,
        bold: bold,
        text: text,
        width: width,
        align: align,
        direction: direction,
        wordSpacing: wordSpacing,
        letterSpacing: letterSpacing,
        paragraphSpacing: paragraphSpacing,
        size: size,
        lineHeight: lineHeight,
        wordBreak: wordBreak,
        langBreak: langBreak,
        config: config
      });
      _this.string = text;
      resetOverride();
      _this.text.loaded.then(({
        buffers: buffers,
        image: image,
        imageBold: imageBold,
        imageItalic: imageItalic,
        height: height,
        numLines: numLines
      }) => {
        _this.texture = GLText.getTexture(image);
        if (bold) {
          _this.textureBold = GLText.getTexture(imageBold);
        }
        if (italic) {
          _this.textureItalic = GLText.getTexture(imageItalic);
        }
        _this.shader = new Shader(shader, {
          tMap: {
            value: _this.texture,
            ignoreUIL: true
          },
          tMapBold: {
            value: _this.textureBold || Utils3D.getEmptyTexture(),
            ignoreUIL: true
          },
          tMapItalic: {
            value: _this.textureItalic || Utils3D.getEmptyTexture(),
            ignoreUIL: true
          },
          uColor: {
            value: color,
            ignoreUIL: true
          },
          uAlpha: {
            value: alpha,
            ignoreUIL: true
          },
          transparent: true,
          customCompile: customCompile
        });
        if (_this.onCreateShader) {
          _this.onCreateShader(_this.shader);
        }
        (function createGeometry(buffers) {
          _this.geometry = new Geometry();
          _this.geometry.addAttribute("position", new GeometryAttribute(buffers.position, 3));
          _this.geometry.addAttribute("uv", new GeometryAttribute(buffers.uv, 2));
          _this.geometry.addAttribute("animation", new GeometryAttribute(buffers.animation, 3));
          _this.geometry.addAttribute("weight", new GeometryAttribute(buffers.weight, 1));
          _this.geometry.setIndex(new GeometryAttribute(buffers.index, 1));
          _this.geometry.boundingBox = buffers.boundingBox;
          _this.geometry.boundingSphere = buffers.boundingSphere;
          _this.geometry.letterCount = buffers.letterCount + 1;
          _this.geometry.wordCount = buffers.wordCount + 1;
          _this.geometry.lineCount = buffers.lineCount + 1;
        })(buffers);
        _this.mesh = new Mesh(_this.geometry, _this.shader);
        _this.height = height;
        _promise.resolve();
      });
    })();
    if (font === undefined) {
      console.log(font, text);
    }
    this.destroy = function () {
      if (_this.mesh && _this.mesh.destroy) {
        _this.mesh.destroy();
      }
    };
    this.ready = this.loaded = function () {
      return _promise;
    };
    this.centerY = function () {
      _this.mesh.position.y = _this.height * 0.5;
      _this.needsCenterY = true;
    };
    this.resize = function (options) {
      return this.setText(text, options);
    };
    this.tweenColor = function (c, time = 300, ease = "easeOutCubic") {
      if (c) {
        color.tween(c, time, ease);
      }
    };
    this.setColor = function (c) {
      if (c) {
        color.set(c);
      }
    };
    this.setText = function (txt, options) {
      if ((text != txt || !function match(options) {
        return !options || options.font == font && options.italic == italic && options.bold == bold && options.width == width && options.align == align && options.direction == direction && (!(options.wordSpacing > 0) || options.wordSpacing == wordSpacing) && options.letterSpacing == letterSpacing && options.paragraphSpacing == paragraphSpacing && options.size == size && options.lineHeight == lineHeight && (options.wordBreak !== true || !!options.wordBreak) && (options.wordBreak != 0 || !options.wordBreak);
      }(options)) && (text = txt)) {
        (function setVars(options) {
          font = options.font || font;
          bold = options.bold || bold;
          italic = options.italic || italic;
          width = options.width || width;
          align = options.align || align;
          wordSpacing = options.wordSpacing || wordSpacing;
          letterSpacing = options.letterSpacing || letterSpacing;
          paragraphSpacing = options.paragraphSpacing || paragraphSpacing;
          size = options.size || size;
          lineHeight = options.lineHeight || lineHeight;
          wordBreak = options.wordBreak || wordBreak;
          langBreak = options.langBreak || langBreak;
          direction = options.direction || direction;
        })(options || {});
        overrideParams();
        _this.string = text;
        _this.charLength = text.length;
        _this.text = new GLTextGeometry({
          font: font,
          italic: italic,
          bold: bold,
          text: text,
          width: width,
          align: align,
          direction: direction,
          wordSpacing: wordSpacing,
          letterSpacing: letterSpacing,
          paragraphSpacing: paragraphSpacing,
          size: size,
          lineHeight: lineHeight,
          wordBreak: wordBreak,
          langBreak: langBreak,
          config: config
        });
        resetOverride();
        _promise = Promise.create();
        _this.text.loaded.then(({
          buffers: buffers,
          image: image,
          imageBold: imageBold,
          imageItalic: imageItalic,
          height: height,
          numLines: numLines
        }) => {
          (function updateGeometry(buffers) {
            _this.geometry.attributes.position.setArray(buffers.position);
            _this.geometry.attributes.uv.setArray(buffers.uv);
            _this.geometry.attributes.animation.setArray(buffers.animation);
            _this.geometry.attributes.weight.setArray(buffers.weight);
            _this.geometry.index = buffers.index;
            _this.geometry.indexNeedsUpdate = true;
            _this.geometry.boundingBox = buffers.boundingBox;
            _this.geometry.boundingSphere = buffers.boundingSphere;
            _this.geometry.letterCount = buffers.letterCount + 1;
            _this.geometry.wordCount = buffers.wordCount + 1;
            _this.geometry.lineCount = buffers.lineCount + 1;
          })(buffers);
          _this.height = height;
          if (_this.needsCenterY) {
            _this.centerY();
          }
          _promise.resolve();
        });
        return _promise;
      }
    };
    this.getData = function () {
      return {
        font: font,
        italic: italic,
        bold: bold,
        text: text,
        width: width,
        align: align,
        direction: direction,
        wordSpacing: wordSpacing,
        letterSpacing: letterSpacing,
        paragraphSpacing: paragraphSpacing,
        size: size,
        lineHeight: lineHeight,
        wordBreak: wordBreak,
        langBreak: langBreak,
        color: color
      };
    };
  }, _ => {
    GLText.FONT_CONFIG = {};
    var _map = new Map();
    GLText.getTexture = function (image) {
      if (!_map.get(image)) {
        let texture = new Texture(image);
        texture.generateMipmaps = false;
        texture.minFilter = Texture.LINEAR;
        _map.set(image, texture);
      }
      return _map.get(image);
    };
  });
  Class(function GLTextGeometry({
    font: font,
    italic: italic,
    bold: bold,
    text: text,
    width = Infinity,
    align = "left",
    size = 1,
    direction = "ltr",
    letterSpacing = 0,
    paragraphSpacing = 1,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    config = {}
  }) {
    let json;
    let image;
    let glyphs;
    let bJson;
    let bImage;
    let bGlyphs;
    let iJson;
    let iImage;
    let iGlyphs;
    let _this = this;
    _this.loaded = Promise.create();
    _this.fontLoaded = Promise.create();
    (async function init() {
      await async function loadFont() {
        [json, image, glyphs] = await GLTextGeometry.loadFont(font);
        if (bold) {
          [bJson, bImage, bGlyphs] = await GLTextGeometry.loadFont(bold);
        }
        if (italic) {
          [iJson, iImage, iGlyphs] = await GLTextGeometry.loadFont(italic);
        }
        _this.fontLoaded.resolve();
      }();
      (async function createGeometry() {
        let buffers = await GLTextThread.generate({
          font: font,
          bold: bold,
          italic: italic,
          text: text,
          width: width,
          align: align,
          size: size,
          direction: direction,
          letterSpacing: letterSpacing,
          paragraphSpacing: paragraphSpacing,
          lineHeight: lineHeight,
          wordSpacing: wordSpacing,
          wordBreak: wordBreak,
          langBreak: langBreak,
          json: json,
          glyphs: glyphs,
          bJson: bJson,
          bGlyphs: bGlyphs,
          iJson: iJson,
          iGlyphs: iGlyphs,
          config: config
        });
        _this.buffers = buffers;
        _this.image = image;
        _this.imageBold = bImage;
        _this.imageItalic = iImage;
        _this.numLines = buffers.lineLength;
        _this.height = _this.numLines * size * lineHeight;
        if (_this.onLayout) {
          _this.onLayout(buffers, image, _this.height, _this.numLines);
        }
        _this.loaded.resolve({
          buffers: buffers,
          image: image,
          imageBold: bImage,
          imageItalic: iImage,
          height: _this.height,
          numLines: _this.numLines
        });
      })();
    })();
  }, _ => {
    async function loadJSON(font) {
      return await get(getPathTo(font, "json"));
    }
    async function loadImage(font) {
      return await new Promise(resolve => {
        let img = new Image();
        img.onload = () => resolve(img);
        img.crossOrigin = "anonymous";
        img.src = getPathTo(font, "png");
      });
    }
    function getPathTo(font, ext) {
      let mapped = false;
      let fontName = function () {
        for (let key in GLTextGeometry.fontMapping) {
          let mapping = GLTextGeometry.fontMapping[key];
          if (key == font) {
            mapped = true;
            return mapping;
          }
        }
        return font;
      }();
      let path = mapped && GLTextGeometry.fontPath ? GLTextGeometry.fontPath : "assets/fonts/";
      return Assets.getPath(`${path + fontName + "." + ext}?${window._CACHE_ || Date.now()}`);
    }
    let _promises = {};
    GLTextGeometry.fontMapping = {};
    GLTextGeometry.chars = {};
    GLTextGeometry.loadFont = function (font) {
      if (!_promises[font]) {
        let promise = Promise.create();
        _promises[font] = promise;
        (async function () {
          let [json, image] = await Promise.all([loadJSON(font), loadImage(font)]);
          glyphs = {};
          json.chars.forEach(d => glyphs[d.char] = d);
          promise.resolve([json, image, glyphs]);
          GLTextGeometry.chars[font] = json.chars;
        })();
      }
      return _promises[font];
    };
  });
  Class(function GLTextThread() {
    function loadTextGeometry({
      font: font,
      bold: bold,
      italic: italic,
      text: text,
      width: width,
      align: align,
      size: size,
      direction: direction,
      letterSpacing: letterSpacing,
      paragraphSpacing: paragraphSpacing,
      lineHeight: lineHeight,
      wordSpacing: wordSpacing,
      wordBreak: wordBreak,
      langBreak: langBreak,
      json: json,
      glyphs: glyphs,
      bJson: bJson,
      bGlyphs: bGlyphs,
      iJson: iJson,
      iGlyphs: iGlyphs,
      config: config
    }, pid) {
      const newline = /\n/;
      const whitespace = /\s/;
      const langbreak = !!langBreak && new RegExp(langBreak);
      const dir = direction === "rtl" ? -1 : 1;
      config ||= {};
      config.boldBaseOffset = config.boldBaseOffset ? config.boldBaseOffset : 0;
      config.italicBaseOffset = config.italicBaseOffset ? config.italicBaseOffset : 0;
      let weights = [];
      let weight = {
        0: glyphs,
        1: bGlyphs,
        2: iGlyphs
      };
      var buffers;
      function getKernPairOffset(id1, id2) {
        for (let i = 0; i < json.kernings.length; i++) {
          let k = json.kernings[i];
          if (!(k.first < id1) && !(k.second < id2)) {
            if (k.first > id1 || k.first === id1 && k.second > id2) {
              return 0;
            } else {
              return k.amount;
            }
          }
        }
        return 0;
      }
      (function setWeights() {
        let i = 0;
        let w = 0;
        while (i < text.length) {
          let code = text.substring(i, i + 3).toLowerCase();
          let endcode = text.substring(i, i + 4).toLowerCase();
          if (code === "<b>" || code === "<i>") {
            w = code === "<b>" ? 1 : 2;
            text = text.substr(0, i) + text.substr(i + 3);
          }
          if (endcode === "</b>" || endcode === "</i>") {
            w = 0;
            text = text.substr(0, i) + text.substr(i + 4);
          }
          weights.push(w);
          i++;
        }
      })();
      (function createGeometry() {
        fontHeight = json.common.lineHeight;
        baseline = json.common.base;
        scale = size / baseline;
        let numChars = text.replace(/[ \n]/g, "").length;
        buffers = {
          position: new Float32Array(numChars * 4 * 3),
          uv: new Float32Array(numChars * 4 * 2),
          animation: new Float32Array(numChars * 3 * 4),
          index: new Uint16Array(numChars * 6),
          weight: new Float32Array(numChars * 4)
        };
        for (let i = 0; i < numChars; i++) {
          buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);
        }
        (function layout() {
          const lines = [];
          let cursor = 0;
          let wordCursor = 0;
          let wordWidth = 0;
          let line = newLine();
          function newLine(br = false) {
            const line = {
              width: 0,
              glyphs: []
            };
            if (lines.last()) {
              lines.last().br = br;
            }
            lines.push(line);
            wordCursor = cursor;
            wordWidth = 0;
            return line;
          }
          while (cursor < text.length) {
            let prev = text[cursor - 1];
            let char = text[cursor];
            text[cursor + 1];
            if (!line.width && whitespace.test(char) && (!prev || !newline.test(char) || !newline.test(prev))) {
              cursor++;
              wordCursor = cursor;
              wordWidth = 0;
              continue;
            }
            if (newline.test(char)) {
              cursor++;
              line = newLine(true);
              continue;
            }
            let style = weight[weights[cursor]] || weight[0];
            let glyph = style[char];
            if (!glyph) {
              console.warn(`font ${font} missing character '${char}'`);
              char = Object.keys(style)[0];
              glyph = style[char];
            }
            glyph.weight = weights[cursor];
            let charScale = glyph.scale ? glyph.scale : 1;
            if (line.glyphs.length) {
              const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
              let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
              line.width += kern;
              wordWidth += kern * dir;
            }
            let gl = Object.assign({}, glyph);
            gl.weight = weights[cursor];
            line.glyphs.push([gl, line.width]);
            let advance = 0;
            if (whitespace.test(char)) {
              gl.whitespace = true;
              wordCursor = cursor;
              wordWidth = 0;
              advance += wordSpacing * size;
            } else {
              advance += letterSpacing * size;
            }
            advance += glyph.xadvance * scale * charScale;
            line.width += advance;
            wordWidth += advance;
            if (line.width > width) {
              if ((wordBreak || char && langBreak && !langbreak.test(char)) && line.glyphs.length > 1) {
                line.width -= advance;
                line.glyphs.pop();
                line = newLine();
                continue;
              }
              if (!wordBreak && wordWidth !== line.width) {
                let numGlyphs = cursor - wordCursor + 1;
                line.glyphs.splice(-numGlyphs, numGlyphs);
                cursor = wordCursor;
                line.width -= wordWidth;
                line = newLine();
                continue;
              }
            }
            cursor++;
          }
          if (!line.width) {
            lines.pop();
          }
          if (align === "justify") {
            let max = -Infinity;
            lines.forEach(l => {
              l.whitespaces = 0;
              if (max < l.width) {
                max = l.width;
              }
              l.glyphs.forEach(g => {
                if (g[0].whitespace) {
                  l.whitespaces++;
                }
              });
            });
            lines.forEach(l => {
              let totalToAdd = max - l.width;
              let addToWhitespace = l.whitespaces === 0 ? 0 : totalToAdd / l.whitespaces;
              l.width = max;
              let additionalOffset = 0;
              l.glyphs.forEach(g => {
                g[1] += additionalOffset;
                if (g[0].whitespace) {
                  additionalOffset += addToWhitespace;
                }
              });
            });
          }
          (function populateBuffers(lines) {
            const texW = json.common.scaleW;
            const texH = json.common.scaleH;
            let geom;
            let y = (config.baseOffset ? config.baseOffset : 0.07) * size;
            let j = 0;
            let glyphIndex = 0;
            let wordIndex = -1;
            let lineId = -1;
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
              let line = lines[lineIndex];
              wordIndex++;
              lineId++;
              for (let i = 0; i < line.glyphs.length; i++) {
                const glyph = line.glyphs[i][0];
                let x = line.glyphs[i][1];
                if (dir === -1) {
                  x = line.width - x;
                }
                if (align === "center" || align === "justify") {
                  x -= line.width * 0.5;
                } else if (align === "right") {
                  x -= line.width * dir;
                }
                if (whitespace.test(glyph.char)) {
                  wordIndex++;
                  continue;
                }
                let charScale = glyph.scale ? glyph.scale : 1;
                if (glyph.weight === 1) {
                  y += config.boldBaseOffset * scale;
                }
                if (glyph.weight === 2) {
                  y += config.italicBaseOffset * scale;
                }
                x += glyph.xoffset * scale * dir * charScale;
                y -= glyph.yoffset * scale * charScale;
                buffers.weight.set([glyph.weight, glyph.weight, glyph.weight, glyph.weight], glyphIndex * 4);
                let w = glyph.width * scale * charScale;
                let h = glyph.height * scale * charScale;
                if (dir === -1) {
                  buffers.position.set([x - w, y - h, 0, x - w, y, 0, x, y - h, 0, x, y, 0], j * 4 * 3);
                } else {
                  buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);
                }
                buffers.animation.set([glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId], glyphIndex * 3 * 4);
                glyphIndex++;
                let u = glyph.x / texW;
                let uw = glyph.width / texW;
                let v = 1 - glyph.y / texH;
                let vh = glyph.height / texH;
                buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);
                if (glyph.weight === 1) {
                  y -= config.boldBaseOffset * scale;
                }
                if (glyph.weight === 2) {
                  y -= config.italicBaseOffset * scale;
                }
                y += glyph.yoffset * scale * charScale;
                j++;
              }
              y -= size * lineHeight * (line.br ? paragraphSpacing : 1);
            }
            if (window.zUtils3D) {
              geom = new Geometry();
              geom.addAttribute("position", new GeometryAttribute(buffers.position, 3));
              geom.computeBoundingBox();
            }
            let backing = [];
            for (let key in buffers) {
              backing.push(buffers[key].buffer);
            }
            buffers.lineLength = lines.length;
            if (geom) {
              buffers.boundingBox = geom.boundingBox;
              buffers.boundingSphere = geom.boundingSphere;
            }
            buffers.letterCount = glyphIndex;
            buffers.lineCount = lineId;
            buffers.wordCount = wordIndex;
            resolve(buffers, pid, backing);
          })(lines);
        })();
      })();
    }
    Thread.upload(loadTextGeometry);
    this.generate = async function (obj) {
      return Thread.shared().loadTextGeometry(obj);
    };
  }, "static");
  Class(function GLUI() {
    Inherit(this, Component);
    const _this = this;
    const hasMetal = !!window.Metal;
    const hasAuraAR = !!window.AURA_AR;
    function loop() {
      if (!hasMetal) {
        if (hasAuraAR && AURA_AR.active) {
          World.NUKE.postRender = null;
          AURA_AR.postRender = loop;
        }
        if (_this.Scene) {
          _this.Scene.render();
        }
        if (_this.Stage) {
          _this.Stage.render();
        }
      }
    }
    window.$gl = function (width, height, map, customCompile) {
      return new GLUIObject(width, height, map, customCompile);
    };
    window.$glText = function (text, fontName, fontSize, options, customCompile) {
      return new GLUIText(text, fontName, fontSize, options, customCompile);
    };
    this.init = async function (is2D, is3D) {
      if (!_this.initialized) {
        if (is2D === undefined) {
          is2D = true;
          is3D = true;
        }
        await AssetLoader.waitForLib("zUtils3D");
        if (is2D) {
          _this.Stage = new GLUIStage();
        }
        if (is3D) {
          _this.Scene = new GLUIStage3D();
          _this.Scene.interaction.input = Mouse;
        }
        _this.wait(World, "NUKE", _ => {
          _this.initialized = true;
          if (_this.Scene) {
            World.NUKE.onBeforeRender = _this.Scene.mark;
          }
          World.NUKE.postRender = loop;
        });
      }
    };
    this.clear = function () {
      _this.Stage.clear();
      _this.Scene.clear();
    };
    this.ready = function () {
      return _this.wait(_this, "initialized");
    };
    this.renderDirect = function (render) {
      if (_this.Scene) {
        _this.Scene.renderDirect(render);
      }
      if (_this.Stage) {
        _this.Stage.renderDirect(render);
      }
    };
  }, "static");
  Class(function GLUIElement() {
    Inherit(this, Component);
    this.element = $gl();
    this.create = function (w, h, t) {
      return this.element.create(w, h, t);
    };
  });
  Class(function GLUIUtils() {
    const _this = this;
    _this.setRetinaMode = function ($obj, retinaMode, parent) {
      if (RenderManager.type === RenderManager.WEBVR) {
        retinaMode = false;
      }
      if (parent ||= $obj.anchor && $obj.anchor._parent || $obj.group._parent) {
        if (retinaMode) {
          let gluiToRTScene;
          let p = parent;
          while (p) {
            if (p.glSceneEnabled) {
              gluiToRTScene = p;
            }
            p = p.parent;
          }
          if (gluiToRTScene) {
            gluiToRTScene.glScene.add($obj);
          } else {
            GLUI.Scene.add($obj);
          }
          parent.add($obj.anchor);
          $obj.anchor.retinaAnchorFor = $obj;
          if ($obj.group.asyncPromise && !$obj.anchor.asyncPromise) {
            $obj.anchor.asyncPromise = $obj.group.asyncPromise;
          }
          if ($obj.scaleX !== 1 || $obj.scaleY !== 1) {
            $obj.isDirty = true;
            if ($obj.mesh && $obj.mesh.onBeforeRender) {
              $obj.mesh.onBeforeRender();
            }
          }
        } else {
          if (_this.isRetinaMode($obj)) {
            parent.remove($obj.anchor);
            GLUI.Scene.remove($obj);
            $obj.anchor._parent = null;
            $obj.group.visible = parent.determineVisible();
            if (typeof $obj.isDirty == "boolean" && $obj.mesh && $obj.mesh.onBeforeRender) {
              $obj.isDirty = true;
              $obj.mesh.onBeforeRender();
            } else {
              $obj.group.position.setScalar(0);
              $obj.group.quaternion.set(0, 0, 0, 1);
              $obj.group.scale.setScalar(1);
            }
            $obj.deferred = false;
            $obj.parent = null;
          }
          parent.add($obj.group);
        }
      }
    };
    _this.isRetinaMode = function ($obj) {
      return RenderManager.type !== RenderManager.WEBVR && $obj.anchor && $obj.anchor._parent && $obj.parent === GLUI.Scene;
    };
  }, "static");
  Class(function GLUIBatch(globalUniforms = {}, _useWorldCoords) {
    Inherit(this, Component);
    const _this = this;
    var _timer;
    var _geometry;
    var _shader;
    var _objects = [];
    function loop() {
      if (_geometry) {
        for (let i = 0; i < _objects.length; i++) {
          let obj = _objects[i];
          if (obj._buffers) {
            obj.mesh.onBeforeRender();
            if (_useWorldCoords) {
              obj.group.updateMatrixWorld();
              obj.mesh.getWorldPosition(obj.worldPosition);
              obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
              obj.mesh.getWorldScale(obj.worldScale);
            }
            obj._buffers.forEach(buffer => {
              let dirty = false;
              dirty = !buffer.value.equals(buffer.lookup);
              buffer.value.copy(buffer.lookup);
              if (dirty) {
                let attribute = _geometry.attributes[buffer.key];
                let array = attribute.array;
                switch (buffer.key) {
                  case "scale":
                    if (_useWorldCoords) {
                      array[i * 2 + 0] = obj.worldScale.x;
                      array[i * 2 + 1] = obj.worldScale.y;
                    } else {
                      array[i * 2 + 0] = obj.group.scale.x * obj.mesh.scale.x;
                      array[i * 2 + 1] = obj.group.scale.y * obj.mesh.scale.y;
                    }
                    break;
                  case "rotation":
                    array[i] = buffer.lookup.z;
                    break;
                  default:
                    if (_useWorldCoords) {
                      array[i * 3 + 0] = obj.worldPosition.x;
                      array[i * 3 + 1] = obj.worldPosition.y;
                    } else {
                      array[i * 3 + 0] = obj.group.position.x;
                      array[i * 3 + 1] = obj.group.position.y;
                    }
                    array[i * 3 + 2] = obj.mesh.renderOrder;
                }
                attribute.needsUpdate = true;
              }
            });
            obj._uniforms.forEach(uniform => {
              let dirty = false;
              if (uniform.type == "f") {
                dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
                uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
              } else {
                dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
                uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
              }
              if (dirty) {
                let attribute = _geometry.attributes["a_" + uniform.key];
                let array = attribute.array;
                if (uniform.type == "f") {
                  array[i] = uniform.value;
                } else {
                  uniform.value.toArray(array, i * uniform.components);
                }
                attribute.needsUpdate = true;
              }
            });
          }
        }
      }
    }
    function getTypeFromSize(size) {
      switch (size) {
        case 1:
          return "float";
        case 2:
          return "vec2";
        case 3:
          return "vec3";
        case 4:
          return "vec4";
      }
    }
    function createMesh() {
      let shader = _objects[0].mesh.shader;
      _geometry = new Geometry().instanceFrom(_objects[0].mesh.geometry.clone());
      let map = {};
      let arrays = {};
      _objects.forEach((obj, i) => {
        obj.mesh.onBeforeRender();
        let buffers = [];
        let uniforms = [];
        for (let key in shader.uniforms) {
          let uniform = shader.uniforms[key];
          if (uniform) {
            if (uniform.value instanceof Color) {
              uniforms.push({
                key: key,
                type: "c",
                components: 3
              });
            }
            if (uniform.value instanceof Vector4) {
              uniforms.push({
                key: key,
                type: "v4",
                components: 4
              });
            }
            if (uniform.value instanceof Vector3) {
              uniforms.push({
                key: key,
                type: "v3",
                components: 3
              });
            }
            if (uniform.value instanceof Vector2) {
              uniforms.push({
                key: key,
                type: "v",
                components: 2
              });
            }
            if (typeof uniform.value == "number") {
              uniforms.push({
                key: key,
                type: "f",
                components: 1
              });
            }
          }
        }
        if (_useWorldCoords) {
          obj.worldScale = new Vector3();
          obj.worldRotation = new Euler();
          obj.worldPosition = new Vector3();
        }
        buffers.push({
          key: "scale",
          lookup: _useWorldCoords ? obj.worldScale : obj.group.scale,
          components: 2
        });
        buffers.push({
          key: "rotation",
          lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation,
          components: 1
        });
        buffers.push({
          key: "offset",
          lookup: _useWorldCoords ? obj.worldPosition : obj.group.position,
          components: 3
        });
        uniforms.forEach(uniform => {
          arrays["a_" + uniform.key] ||= [];
          map["a_" + uniform.key] ||= uniform;
          let value = shader.uniforms[uniform.key].value;
          if (typeof value == "object") {
            uniform.value = value.clone();
            uniform.value.toArray(arrays["a_" + uniform.key], i * uniform.components);
          } else {
            uniform.value = shader.uniforms[uniform.key].value;
            arrays["a_" + uniform.key].push(uniform.value);
          }
        });
        buffers.forEach(buffer => {
          arrays[buffer.key] ||= [];
          map[buffer.key] ||= buffer;
          buffer.value = buffer.lookup.clone();
          switch (buffer.key) {
            case "scale":
              arrays[buffer.key].push(obj.group.scale.x * obj.mesh.scale.x, obj.group.scale.y * obj.mesh.scale.y);
              break;
            case "rotation":
              arrays[buffer.key].push(buffer.lookup.z);
              break;
            default:
              arrays[buffer.key].push(buffer.lookup.x, buffer.lookup.y, obj.mesh.renderOrder);
          }
        });
        obj._buffers = buffers;
        obj._uniforms = uniforms;
        obj.shader.neverRender = true;
      });
      let attributes = [];
      let defines = [];
      for (let key in map) {
        if (key.includes("a_")) {
          attributes.push(`% ${getTypeFromSize(map[key].components)} ${key};`);
          defines.push(`${key.replace("a_", "v_")} = ${key};`);
        }
      }
      attributes = attributes.join("\n");
      defines = defines.join("\n");
      for (let key in arrays) {
        _geometry.addAttribute(key, new GeometryAttribute(new Float32Array(arrays[key]), map[key].components, 1));
      }
      if (GLUIBatch.cache[shader.fsName]) {
        _shader = GLUIBatch.cache[shader.fsName];
      } else {
        let vsSplit = (_shader = _this.initClass(Shader, "GLUIBatch", shader.fsName, Object.assign({}, {
          transparent: true,
          depthWrite: false,
          depthTest: false
        }, globalUniforms))).vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
        let fsSplit = _shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
        let definitions = [];
        fsSplit[1].split("\n").forEach(line => {
          if (line.includes("uniform")) {
            if (line.includes("sampler2D")) {
              return;
            }
            let data = line.split(" ");
            definitions.push(`${data[2].replace(";", "")} = a_${data[2]}`);
            vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}${vsSplit[1]}`;
            vsSplit[1] = vsSplit[1].replace(line, "");
            fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
          }
        });
        vsSplit[1] = vsSplit[1].replace("//vdefines", "\n" + definitions.join("\n"));
        _shader.vertexShader = vsSplit.join("__ACTIVE_THEORY_LIGHTS__");
        _shader.fragmentShader = fsSplit.join("__ACTIVE_THEORY_LIGHTS__");
        GLUIBatch.cache[shader.fsName] = _shader;
      }
      shader.copyUniformsTo(_shader);
      _this.mesh = new Mesh(_geometry, _shader);
      _this.mesh.frustumCulled = false;
      _this.group.add(_this.mesh);
    }
    this.group = new Group();
    if (typeof globalUniforms == "boolean") {
      _useWorldCoords = globalUniforms;
      globalUniforms = {};
    }
    GLUIBatch.cache ||= {};
    _this.startRender(loop);
    this.add = function (obj) {
      clearTimeout(_timer);
      _timer = _this.delayedCall(createMesh, 50);
      if (_useWorldCoords) {
        let getAlpha = obj.getAlpha;
        if (getAlpha) {
          obj.getAlpha = () => (_this.parent ? _this.parent.getAlpha() : 1) * getAlpha.call(obj);
        }
      } else {
        _this.parent.add(obj);
      }
      _objects.push(obj);
    };
    this.setZ = async function (z) {
      await _this.wait("mesh");
      _this.mesh.renderOrder = z;
    };
    this.onDestroy = function () {
      if (_this.mesh) {
        _this.mesh.destroy();
      }
    };
  });
  Class(function GLUIBatchText(globalUniforms = {}, _useWorldCoords) {
    Inherit(this, Component);
    const _this = this;
    var _geometry;
    var _shader;
    var _timer;
    var _forceUpdate;
    var _promises = [];
    var _toSplice = [];
    var _objects = [];
    var _offset = 0;
    function loop() {
      if (!_geometry) {
        return;
      }
      let updated = false;
      for (let key in _geometry.attributes) {
        let attrib = _geometry.attributes[key];
        attrib.updateRange.length &&= 0;
      }
      let len = _objects.length;
      for (let i = 0; i < len; i++) {
        let obj = _objects[i];
        obj.mesh.onBeforeRender();
        if (_useWorldCoords) {
          obj.group.updateMatrixWorld();
          obj.mesh.getWorldPosition(obj.worldPosition);
          obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
          obj.mesh.getWorldScale(obj.worldScale);
        }
        let offset = obj._offset;
        let count = obj._count;
        let end = offset + count;
        obj._buffers.forEach(buffer => {
          let dirty = false;
          dirty = !buffer.value.equals(buffer.lookup);
          buffer.value.copy(buffer.lookup);
          if (dirty) {
            let array = _geometry.attributes[buffer.key].array;
            for (let j = offset; j < end; j++) {
              switch (buffer.components) {
                case 4:
                  array[j * 4 + 0] = buffer.lookup.x;
                  array[j * 4 + 1] = buffer.lookup.y;
                  array[j * 4 + 2] = buffer.lookup.z;
                  array[j * 4 + 3] = buffer.lookup.w;
                  break;
                case 3:
                  array[j * 3 + 0] = buffer.lookup.x;
                  array[j * 3 + 1] = buffer.lookup.y;
                  array[j * 3 + 2] = buffer.lookup.z;
                  break;
                case 2:
                  array[j * 2 + 0] = buffer.lookup.x;
                  array[j * 2 + 1] = buffer.lookup.y;
                  break;
                case 1:
                  array[j] = buffer.lookup.z;
              }
            }
            updated = true;
            buffer.updateRange.offset = offset * buffer.components;
            buffer.updateRange.count = count * buffer.components;
            _geometry.attributes[buffer.key].updateRange.push(buffer.updateRange);
            _geometry.attributes[buffer.key].needsUpdate = true;
          }
        });
        obj._uniforms.forEach(uniform => {
          let dirty = false;
          if (uniform.type == "f") {
            dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
            uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
          } else {
            dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
            uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
          }
          if (dirty || _forceUpdate) {
            let array = _geometry.attributes["a_" + uniform.key].array;
            for (let j = offset; j < end; j++) {
              if (uniform.type == "f") {
                array[j] = obj.mesh.shader.uniforms[uniform.key].value;
              } else {
                obj.mesh.shader.uniforms[uniform.key].value.toArray(array, j * uniform.components);
              }
            }
            updated = true;
            uniform.updateRange.offset = offset * uniform.components;
            uniform.updateRange.count = count * uniform.components;
            _geometry.attributes["a_" + uniform.key].updateRange.push(uniform.updateRange);
            _geometry.attributes["a_" + uniform.key].needsUpdate = true;
          }
        });
      }
      if (updated) {
        for (let key in _geometry.attributes) {
          let bottom;
          let attrib = _geometry.attributes[key];
          if (!attrib.updateRange.length) {
            continue;
          }
          let toSplice = _toSplice;
          toSplice.length = 0;
          for (let i = 0; i < attrib.updateRange.length; i++) {
            let current = attrib.updateRange[i];
            let prev = attrib.updateRange[i - 1];
            if (prev) {
              if (prev.offset + prev.count == current.offset) {
                bottom.count += current.count;
                toSplice.push(i);
              } else {
                bottom = current;
              }
            } else {
              bottom = current;
            }
          }
          for (let i = toSplice.length - 1; i > -1; i--) {
            attrib.updateRange.splice(toSplice[i], 1);
          }
        }
      }
      _forceUpdate = false;
    }
    async function createMesh() {
      if (_this.flag("mesh")) {
        return;
      }
      _this.flag("mesh", true);
      await Promise.all(_promises);
      await _this.wait(100);
      let mesh = new Mesh(_geometry, _shader);
      _this.mesh = mesh;
      mesh.frustumCulled = false;
      _this.group.add(mesh);
    }
    this.group = new Group();
    if (typeof globalUniforms == "boolean") {
      _useWorldCoords = globalUniforms;
      globalUniforms = {};
    }
    _this.flag("canLoad", true);
    _this.startRender(loop);
    _this.add = async function (obj) {
      await _this.flag("canLoad");
      _this.flag("canLoad", false);
      await obj.loaded();
      obj.mesh.shader.neverRender = true;
      _promises.push(obj.loaded());
      (function addAttributes(obj, mesh) {
        let {
          geometry: geometry,
          shader: shader
        } = mesh;
        let count = geometry.attributes.uv.count;
        mesh.onBeforeRender();
        let buffers = [];
        let uniforms = [];
        for (let key in shader.uniforms) {
          let uniform = shader.uniforms[key];
          if (uniform.value instanceof Color) {
            uniforms.push({
              key: key,
              type: "c",
              components: 3
            });
          }
          if (uniform.value instanceof Vector3) {
            uniforms.push({
              key: key,
              type: "v3",
              components: 3
            });
          }
          if (uniform.value instanceof Vector4) {
            uniforms.push({
              key: key,
              type: "v4",
              components: 4
            });
          }
          if (uniform.value instanceof Vector2) {
            uniforms.push({
              key: key,
              type: "v",
              components: 2
            });
          }
          if (typeof uniform.value == "number") {
            uniforms.push({
              key: key,
              type: "f",
              components: 1
            });
          }
        }
        if (_useWorldCoords) {
          obj.worldScale = new Vector3();
          obj.worldRotation = new Euler();
          obj.worldPosition = new Vector3();
        }
        buffers.push({
          key: "offset",
          lookup: _useWorldCoords ? obj.worldPosition : obj.group.position,
          components: 3
        });
        buffers.push({
          key: "scale",
          lookup: _useWorldCoords ? obj.worldScale : obj.group.scale,
          components: 2
        });
        buffers.push({
          key: "rotation",
          lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation,
          components: 1
        });
        uniforms.forEach(uniform => {
          uniform.updateRange = {};
          uniform.value = shader.uniforms[uniform.key].value;
          if (typeof uniform.value == "object") {
            uniform.value = uniform.value.clone();
          }
          uniform.buffer = new Float32Array(count * uniform.components);
        });
        buffers.forEach(buffer => {
          buffer.updateRange = {};
          buffer.value = buffer.lookup.clone();
          buffer.buffer = new Float32Array(count * buffer.components);
        });
        for (let i = 0; i < count; i++) {
          buffers.forEach(buffer => {
            switch (buffer.components) {
              case 4:
                buffer.buffer[i * 4 + 0] = buffer.lookup.x;
                buffer.buffer[i * 4 + 1] = buffer.lookup.y;
                buffer.buffer[i * 4 + 2] = buffer.lookup.z;
                buffer.buffer[i * 4 + 3] = buffer.lookup.w;
                break;
              case 3:
                buffer.buffer[i * 3 + 0] = buffer.lookup.x;
                buffer.buffer[i * 3 + 1] = buffer.lookup.y;
                buffer.buffer[i * 3 + 2] = buffer.lookup.z;
                break;
              case 2:
                buffer.buffer[i * 2 + 0] = buffer.lookup.x;
                buffer.buffer[i * 2 + 1] = buffer.lookup.y;
                break;
              case 1:
                buffer.buffer[i] = buffer.lookup.z;
            }
          });
          uniforms.forEach(uniform => {
            if (uniform.type == "f") {
              uniform.buffer[i] = shader.uniforms[uniform.key].value;
            } else {
              shader.uniforms[uniform.key].value.toArray(uniform.buffer, i * uniform.components);
            }
          });
        }
        buffers.forEach(buffer => {
          geometry.addAttribute(buffer.key, new GeometryAttribute(buffer.buffer, buffer.components));
        });
        uniforms.forEach(uniform => {
          geometry.addAttribute("a_" + uniform.key, new GeometryAttribute(uniform.buffer, uniform.components));
        });
        obj._offset = _offset;
        obj._count = count;
        obj._uniforms = uniforms;
        obj._buffers = buffers;
        _objects.push(obj);
        _offset += count;
      })(obj, obj.mesh);
      if (_useWorldCoords) {
        let getAlpha = obj.getAlpha;
        if (getAlpha) {
          obj.getAlpha = () => (_this.parent ? _this.parent.getAlpha() : 1) * getAlpha.call(obj);
        }
      } else {
        _this.parent.add(obj);
      }
      if (_geometry) {
        _geometry.merge(obj.mesh.geometry);
      } else {
        (function initGeometry(mesh) {
          if (!(_shader = _this.initClass(Shader, "GLUIBatchText", mesh.shader.fsName, Object.assign({}, {
            transparent: true,
            depthWrite: false,
            customCompile: `${mesh.shader.vsName}|${mesh.shader.fsName}|instance`
          }, globalUniforms))).vertexShader) {
            _shader.resetProgram();
          }
          let vsSplit = _shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
          let fsSplit = _shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
          let definitions = [];
          let definitionSplit = [];
          fsSplit[1].split("\n").forEach(line => {
            if (line.includes("uniform")) {
              if (line.includes("sampler2D")) {
                return;
              }
              let data = line.split(" ");
              definitions.push(`${data[2].replace(";", "")} = a_${data[2]}`);
              vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}${vsSplit[1]}`;
              vsSplit[1] = vsSplit[1].replace(line, "");
              fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
            }
          });
          definitions.forEach(def => definitionSplit.push(def.split(" =")[0].trim()));
          let baseVS = Shaders.getShader(mesh.shader.vsName + ".vs");
          if (baseVS.includes("//start batch main")) {
            let main = baseVS.split("//start batch main")[1].split("//end batch main")[0];
            vsSplit[1] = vsSplit[1].replace("//custommain", main);
            let beforeMain = baseVS.split("void main() {")[0];
            beforeMain = beforeMain.replace("uniform sampler2D tMap;", "");
            beforeMain = beforeMain.replace("varying vec2 vUv;", "");
            beforeMain.split("\n").forEach(line => {
              definitionSplit.forEach(def => {
                if (line.includes(def) && line.includes(["uniform", "varying"])) {
                  beforeMain = beforeMain.replace(line, "");
                }
              });
            });
            vsSplit[0] += beforeMain;
          }
          vsSplit[1] = vsSplit[1].replace("//vdefines", "\n" + definitions.join("\n"));
          _shader.vertexShader = vsSplit.join("__ACTIVE_THEORY_LIGHTS__");
          _shader.fragmentShader = fsSplit.join("__ACTIVE_THEORY_LIGHTS__");
          mesh.shader.copyUniformsTo(_shader);
          _geometry = mesh.geometry.clone();
          for (let key in _geometry.attributes) {
            _geometry.attributes[key].updateRange = [];
          }
        })(obj.mesh);
      }
      _this.flag("canLoad", true);
      clearTimeout(_timer);
      _timer = _this.delayedCall(createMesh, 50);
      obj.isDirty = true;
    };
    _this.forceUpdate = function () {
      _forceUpdate = true;
    };
    _this.onDestroy = function () {
      if (_this.mesh) {
        _this.mesh.destroy();
      }
    };
  });
  Class(function GLUIStageInteraction2D(_camera, _scene, _stage, _custom) {
    Inherit(this, Component);
    const _this = this;
    var _ray;
    var _over;
    var _click;
    var _customTest;
    var _disabled;
    var _blocked;
    var _test = [];
    var _objects = this.objects = [];
    var _hold = new Vector2();
    new Vector2();
    var _lastTestedPoint = new Vector2();
    var _plane = new Plane();
    function cacheTopScene(obj) {
      let p = obj;
      while (p) {
        if (p instanceof Scene) {
          obj.interactionScene = p;
        }
        p = p._parent;
      }
    }
    function testObjects() {
      let objects = GLUI.Stage.interaction.objects;
      _test.length = 0;
      for (let i = objects.length - 1; i > -1; i--) {
        let obj = objects[i];
        if (!obj.interactionScene) {
          cacheTopScene(obj);
        }
        if (obj.forceGLUIInteraction || obj.determineVisible() && _scene == obj.interactionScene) {
          _test.push(obj);
        }
      }
      return _test;
    }
    function externalStart() {
      if (!_this._invisible) {
        start(_lastTestedPoint);
      }
    }
    function externalRelease() {
      if (!_this._invisible) {
        end(_lastTestedPoint);
      }
    }
    function move(e) {
      if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked) {
        return;
      }
      if (!_ray) {
        (_ray = new Raycaster(_camera)).testVisibility = false;
      }
      let objects = testObjects();
      if (!objects.length) {
        if (_over) {
          _over._onOver({
            action: "out",
            object: _over
          });
          _over = null;
          Stage.cursor("auto");
        }
        return;
      }
      let hit = _ray.checkHit(objects, e, _stage);
      try {
        if (hit[0]) {
          if (!_customTest) {
            GLUI.HIT = true;
          }
          let obj = hit[0].object.glui;
          if (!_over) {
            (_over = obj)._onOver({
              action: "over",
              object: obj
            });
            Stage.cursor("pointer");
          }
          if (_over != obj) {
            _over._onOver({
              action: "out",
              object: _over
            });
            (_over = obj)._onOver({
              action: "over",
              object: obj
            });
            Stage.cursor("pointer");
          }
        } else {
          if (!_customTest) {
            GLUI.HIT = false;
          }
          if (_over) {
            _over._onOver({
              action: "out",
              object: _over
            });
            _over = null;
            Stage.cursor("auto");
          }
        }
      } catch (e) {
        console.warn(e);
      }
    }
    function start(e) {
      let handlingEvent = !(e instanceof Vector2);
      let checkDefault = GLUI.PREVENT_DEFAULT_INTERACTION && handlingEvent;
      let checkPrevention = GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked;
      if (!checkDefault && !checkPrevention) {
        if ((!_custom || !handlingEvent) && (!!Device.mobile || RenderManager.type == RenderManager.WEBVR)) {
          move(e);
        }
        if (_over && !_click) {
          _click = _over;
          _hold.copy(e);
          _hold.time = Date.now();
        }
      }
    }
    function end(e) {
      if (!GLUI.PREVENT_INTERACTION && !_this._invisible && !_disabled && !_blocked) {
        if (_customTest && Device.mobile && _click && _over == null) {
          _over = _click;
        }
        GLUI.HIT = false;
        if (_click) {
          if (Date.now() - _hold.time > 750) {
            return _click = null;
          }
          if (_click == _over) {
            try {
              _blocked = true;
              _this.delayedCall(_ => {
                _blocked = false;
              }, _this.preventDoubleClickTime);
              _click._onClick({
                action: "click",
                object: _click
              });
              if ((Device.mobile || _custom) && _over) {
                _over._onOver({
                  action: "out",
                  object: _over
                });
                _over = null;
                Stage.cursor("auto");
              }
            } catch (e) {
              console.warn(e);
            }
          }
        }
        _click = null;
      }
    }
    function findCapture(object) {
      let capture = object.__slc;
      if (capture === undefined) {
        return object.__slc = UI3D.findStageLayoutCapture(object) || null;
      } else {
        return capture;
      }
    }
    this.preventDoubleClickTime = 300;
    (function addListeners() {
      if (!_custom) {
        _this.events.sub(Mouse.input, Interaction.MOVE, move);
      }
      _this.events.sub(Mouse.input, Interaction.START, start);
      _this.events.sub(Mouse.input, Interaction.END, end);
      _this.events.sub(Interaction3D.EXTERNAL_PRESS, externalStart);
      _this.events.sub(Interaction3D.EXTERNAL_RELEASE, externalRelease);
    })();
    _this.startRender(_ => {});
    this.add = function (obj) {
      if (obj) {
        _objects.push(obj.mesh || obj);
      }
    };
    this.remove = function (obj) {
      if (obj) {
        _objects.remove(obj.mesh || obj);
      }
    };
    this.testWith = function (point, id) {
      point.customTest = true;
      _lastTestedPoint.copy(point);
      _lastTestedPoint.customTest = true;
      _customTest = true;
      move(point);
      if (Device.mobile && RenderManager.type != RenderManager.WEBVR && _over) {
        start(point);
      }
    };
    this.testWithFinger = function (point, distance, minDistance) {
      if (!_ray) {
        (_ray = new Raycaster(_camera)).testVisibility = false;
      }
      _customTest = true;
      let objects = testObjects();
      if (objects.length) {
        if (distance < 0.02) {
          let hit = _ray.checkHit(objects, point, _stage);
          try {
            if (hit[0]) {
              let obj = hit[0].object.glui;
              if (!obj._preventClickTime || Render.TIME - obj._preventClickTime > _this.preventDoubleClickTime) {
                if (!obj._requiresClear) {
                  _over = obj;
                  obj._onOver({
                    action: "over",
                    object: obj
                  });
                  obj._onClick({
                    action: "click",
                    object: obj
                  });
                  obj._preventClickTime = Render.TIME;
                  obj._requiresClear = true;
                }
              }
            } else if (_over) {
              _over._requiresClear = false;
              _over._onOver({
                action: "out",
                object: _over
              });
              _over = null;
            }
          } catch (e) {
            console.warn(e);
          }
        } else if (_over) {
          _over._requiresClear = false;
          _over._onOver({
            action: "out",
            object: _over
          });
          _over = null;
        }
      }
    };
    this.checkObjectHit = function (object, mouse) {
      let capture = findCapture(object);
      if (capture) {
        return capture.checkObjectHit(object.mesh || object, mouse);
      } else {
        if (!_ray) {
          (_ray = new Raycaster(_camera)).testVisibility = false;
        }
        return _ray.checkHit(object.mesh || object, mouse, _stage)[0];
      }
    };
    this.checkObjectFromValues = function (object, origin, direction) {
      let capture = findCapture(object);
      if (capture) {
        return capture.checkObjectFromValues(object.mesh || object, origin, direction);
      } else {
        if (!_ray) {
          (_ray = new Raycaster(_camera)).testVisibility = false;
        }
        return _ray.checkFromValues(object.mesh || object, origin, direction)[0];
      }
    };
    this.getObjectHitLocalCoords = function (v, object, mouse) {
      let capture = findCapture(object);
      if (capture) {
        return capture.getObjectHitLocalCoords(v, object, mouse);
      }
      let hit = _this.checkObjectHit(object, mouse);
      if (hit) {
        v.copy(hit.point);
        return hit.object.worldToLocal(v);
      }
      {
        let mesh = object.mesh || object;
        _plane.normal.set(0, 0, 1).applyQuaternion(mesh.getWorldQuaternion());
        _plane.constant = -mesh.getWorldPosition().dot(_plane.normal);
        _ray.ray.intersectPlane(_plane, v);
        return mesh.worldToLocal(v);
      }
    };
    this.set("_disabled", v => {
      if (_disabled = v) {
        _click = null;
        if (_over) {
          _over._onOver({
            action: "out",
            object: _over
          });
          _over = null;
          Stage.cursor("auto");
        }
      }
    });
    this.onInvisible = () => {
      _click = null;
      if (_over) {
        _over._onOver({
          action: "out",
          object: _over
        });
        _over = null;
        Stage.cursor("auto");
      }
    };
  });
  Class(function GLUIStageInteraction3D() {
    Inherit(this, Component);
    function onHover(e) {
      e.mesh.glui._onOver({
        action: e.action,
        object: e.mesh.glui
      });
    }
    function onClick(e) {
      e.mesh.glui._onClick({
        action: e.action,
        object: e.mesh.glui
      });
    }
    this.add = function (obj, camera = World.CAMERA) {
      Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick);
    };
    this.remove = function (obj, camera = World.CAMERA) {
      Interaction3D.find(camera).remove(obj.mesh || obj);
    };
    this.checkObjectHit = function (object, mouse, camera = World.CAMERA) {
      return Interaction3D.find(camera).checkObjectHit(object.mesh, mouse);
    };
    this.checkObjectFromValues = function (object, origin, direction, camera = World.CAMERA) {
      return Interaction3D.find(camera).checkObjectFromValues(object.mesh, origin, direction);
    };
    this.getObjectHitLocalCoords = function (v, object, mouse, camera = World.CAMERA) {
      return Interaction3D.find(camera).getObjectHitLocalCoords(v, object.mesh, mouse);
    };
  });
  Class(function GLUICornerPin($obj) {
    Inherit(this, Component);
    const _this = this;
    var _geom;
    var _vertices;
    var _last;
    function loop() {
      _vertices[0] = _this.tl.x;
      _vertices[1] = -_this.tl.y;
      _vertices[3] = _vertices[9] = _this.bl.x;
      _vertices[4] = _vertices[10] = -_this.bl.y;
      _vertices[6] = _vertices[15] = _this.tr.x;
      _vertices[7] = _vertices[16] = -_this.tr.y;
      _vertices[12] = _this.br.x;
      _vertices[13] = -_this.br.y;
      if (function dirty() {
        let a = _vertices;
        let b = _last;
        for (let i = a.length - 1; i > -1; i--) {
          if (a[i] != b[i]) {
            return true;
          }
        }
        return false;
      }()) {
        _geom.attributes.position.needsUpdate = true;
      }
      _last.set(_vertices);
    }
    this.tl = new Vector2(0, 0);
    this.tr = new Vector2($obj.width, 0);
    this.bl = new Vector2(0, $obj.height);
    this.br = new Vector2($obj.width, $obj.height);
    (function initGeometry() {
      _geom = $obj.mesh.geometry.toNonIndexed();
      $obj.useGeometry(_geom);
      $obj.mesh.scale.set(1, 1, 1);
      _vertices = _geom.attributes.position.array;
      _last = new Float32Array(_vertices);
    })();
    _this.startRender(loop);
    this.update = function () {
      this.tl.set(0, 0);
      this.tr.set($obj.width, 0);
      this.bl.set(0, $obj.height);
      this.br.set($obj.width, $obj.height);
    };
    this.tween = function (type, val, time, ease, delay) {
      val = val instanceof Vector2 ? val : new Vector2(val.x, val.y);
      return tween(_this[type], val, time, ease, delay);
    };
  });
  class GLUIObject {
    constructor(width, height, map, customCompile) {
      let shader = this.textureShader = new Shader("GLUIObject", {
        tMap: {
          value: null
        },
        uAlpha: {
          type: "f",
          value: 1
        },
        transparent: true,
        depthTest: false,
        customCompile: customCompile
      });
      shader.persists = true;
      if (!map) {
        shader.visible = false;
      }
      this.usingMap = map != null && map != "empty" && map != "";
      this.tMap = shader.uniforms.tMap;
      this.group = new Group();
      this.alpha = 1;
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._scaleX = 1;
      this._scaleY = 1;
      this._scale = 1;
      this._rotation = 0;
      this.multiTween = true;
      this.children = [];
      this.dimensions = new Vector3(width, height, 1);
      this._shader = shader;
      this.mesh = new Mesh(GLUIObject.getGeometry("2d"), shader);
      this.mesh.glui = this;
      this.group.add(this.mesh);
      shader.mesh = this.mesh;
      if (window.GLSEO) {
        GLSEO.objectNode(this);
      }
      this.bg(typeof map == "string" ? map.includes(["#", "0x"]) ? map : map === "empty" || map === "" ? null : Utils3D.getTexture(map, {
        premultiplyAlpha: false
      }) : map);
      const _this = this;
      this.mesh.onBeforeRender = _ => {
        if (!_this.mesh.determineVisible() && _this.firstRender) {
          return;
        }
        let alpha = _this.getAlpha();
        if (_this.mesh.shader.uniforms.uAlpha) {
          _this.mesh.shader.uniforms.uAlpha.value = alpha;
        }
        if (_this.usingMap) {
          if (alpha < 0.001) {
            _this.mesh.hidden = true;
            _this.mesh.shader.visible = false;
            if (!_this.isDirty && _this.firstRender) {
              return;
            }
          } else {
            _this.mesh.hidden = false;
            _this.mesh.shader.visible = true;
          }
        }
        if (!_this.isDirty && _this.firstRender) {
          return;
        }
        if (RenderStats.active) {
          RenderStats.update("GLUIObject", 1, _this.mesh.shader.vsName + "|" + _this.mesh.shader.fsName, _this.mesh);
        }
        _this.group.position.x = _this._x;
        _this.group.position.y = _this._3d ? _this._y : -_this._y;
        _this.group.position.z = _this._z;
        if (_this.scale != 1) {
          _this.group.position.x += (_this.dimensions.x - _this.dimensions.x * _this.scale) / 2;
          _this.group.position.y -= (_this.dimensions.y - _this.dimensions.y * _this.scale) / 2;
        }
        _this.mesh.shader;
        if (_this.calcMask) {
          let v = _this.isMasked;
          v.copy(v.origin);
          _this.group.localToWorld(v);
          v.z = v.width;
          v.w = v.height;
        }
        if (map) {
          if (!_this.corners) {
            _this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions);
            _this.group.scale.x = _this._scaleX * _this._scale;
            _this.group.scale.y = _this._scaleY * _this._scale;
          }
        } else {
          _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);
        }
        if (_this._3d) {
          if (_this.anchor && _this.anchor._parent) {
            _this.anchor.position.copy(_this.group.position);
            _this.anchor.scale.copy(_this.group.scale);
            _this.anchor.quaternion.setFromEuler(_this._rotation);
            _this.anchor.isDirty = true;
          } else {
            _this.group.quaternion.setFromEuler(_this._rotation);
            _this.group.matrixDirty = true;
          }
        } else {
          _this.group.rotation.z = Math.radians(_this._rotation);
        }
        if (!_this.firstRender) {
          _this.group.updateMatrixWorld(true);
          _this.firstRender = true;
        }
        _this.isDirty = false;
      };
      _this.isDirty = true;
    }
    get width() {
      return this.dimensions.x;
    }
    set width(w) {
      let dirty = Math.abs(this.dimensions.x - w) > 0.0001;
      this.dimensions.x = w;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get height() {
      return this.dimensions.y;
    }
    set height(h) {
      let dirty = Math.abs(this.dimensions.y - h) > 0.0001;
      this.dimensions.y = h;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get x() {
      return this._x;
    }
    set x(v) {
      let dirty = Math.abs(this._x - v) > 0.0001;
      this._x = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get y() {
      return this._y;
    }
    set y(v) {
      let dirty = Math.abs(this._y - v) > 0.0001;
      this._y = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get z() {
      return this._z;
    }
    set z(v) {
      let dirty = Math.abs(this._z - v) > 0.0001;
      this._z = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get scale() {
      return this._scale;
    }
    set scale(v) {
      let dirty = Math.abs(this._scale - v) > 0.0001;
      this._scale = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get scaleX() {
      return this._scaleX;
    }
    set scaleX(v) {
      let dirty = Math.abs(this._scaleX - v) > 0.0001;
      this._scaleX = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get scaleY() {
      return this._scaleY;
    }
    set scaleY(v) {
      let dirty = Math.abs(this._scaleY - v) > 0.0001;
      this._scaleY = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(v) {
      let dirty = Math.abs(this._rotation - v) > 0.0001;
      this._rotation = v;
      if (dirty) {
        this.isDirty = true;
        if (this.__internalDirty) {
          this.__internalDirty();
        }
      }
    }
    style(props) {
      for (let prop in props) {
        if (this[prop] !== undefined) {
          this[prop] = props[prop];
        }
      }
      return this;
    }
    size(w, h) {
      this.width = w;
      this.height = h;
      if (this.corners) {
        this.corners.update();
      }
      return this;
    }
    add($obj) {
      $obj?.parent?.children?.remove($obj);
      $obj.parent = this;
      this.group.add($obj.group);
      this.children.push($obj);
      if (this.isMasked) {
        $obj.mask(this.isMasked, this.maskShader);
      }
      if (this._3d && !$obj._3d) {
        $obj.enable3D();
      }
      if (this.deferred) {
        $obj.deferRender(true);
        if ($obj.anchor && this.anchor) {
          this.anchor.add($obj.anchor);
        }
      }
      return this;
    }
    interact(over, click, camera = World.CAMERA, url, label, options) {
      if (typeof camera == "string") {
        options = label;
        label = url;
        url = camera;
        camera = World.CAMERA;
      }
      const bubble = (e, fn) => {
        e.stopPropagation = function () {
          e._stopProp = true;
        };
        let parent = this._parent;
        while (parent) {
          if (e._stopProp) {
            return;
          }
          parent[fn]?.(e);
          parent = parent.parent;
        }
      };
      this._onOver = e => {
        bubble(e, "_onChildHover");
        over(e);
      };
      this._onClick = e => {
        bubble(e, "_onChildClick");
        click(e);
      };
      this._interactCamera = camera;
      if (over) {
        this.interaction.add(this, camera);
      } else {
        this.interaction.remove(this, camera);
      }
      if (typeof url == "string" && typeof label == "string") {
        const _this = this;
        defer(_ => {
          if (!_this.seo && window.GLSEO) {
            GLSEO.objectNode(_this);
          }
          if (_this.seo && _this.seo.aLink) {
            _this.seo.aLink(url, label, options);
          }
        });
      }
      return this;
    }
    clearInteract() {
      if (this._onOver) {
        this.interaction.remove(this, this._interactCamera);
        this._onClick = GLUIObject.noop;
        this._onOver = GLUIObject.noop;
      }
      if (this.seo) {
        this.seo.unlink();
      }
      return this;
    }
    remove(param) {
      if (param) {
        console.warn("GLUIObject.remove removes ITSELF from its parent. use removeChild instead");
      }
      this.children.slice().forEach(child => {
        if (child.remove) {
          child.remove();
        } else if (child.destroy) {
          child.destroy();
        }
      });
      this.clearInteract();
      if (this.parent) {
        if (this.parent.children) {
          this.parent.children?.remove(this);
        } else {
          GLUI.Stage.remove(this);
        }
      }
      if (this.mesh._parent) {
        this.group._parent?.remove(this.group);
      } else if (this._3d) {
        GLUI.Scene.remove(this);
      } else {
        GLUI.Stage.remove(this);
      }
      let textureShader = this.textureShader;
      for (let key in textureShader.uniforms) {
        let uniform = textureShader.uniforms[key];
        if (uniform && uniform.value && uniform.value.destroy) {
          uniform.value.destroy();
        }
      }
    }
    create(width, height, map, customCompile) {
      let $obj = $gl(width, height, map, customCompile);
      this.add($obj);
      if (this._3d) {
        $obj.enable3D();
      }
      return $obj;
    }
    removeChild(obj) {
      this.group.remove(obj.group);
      return this;
    }
    tween(obj, time, ease, delay) {
      return tween(this, obj, time, ease, delay);
    }
    enable3D(style2d) {
      this._3d = true;
      this.mesh.geometry = GLUIObject.getGeometry(style2d ? "2d" : "3d");
      this.mesh.shader.depthTest = true;
      this._rotation = new Euler();
      this.anchor ||= new Group();
      this.anchor.onMatrixDirty = _ => {
        _this.isDirty = true;
      };
      const _this = this;
      _this._rotation.onChange(_ => {
        _this.isDirty = true;
      });
      return this;
    }
    loaded() {
      return true;
    }
    setZ(z) {
      this.mesh.renderOrder = z;
      return this;
    }
    bg(path) {
      if (path !== undefined) {
        if (typeof path == "string") {
          if (path.includes(["#", "0x"])) {
            this.colorShader ||= new Shader("GLUIColor", {
              transparent: true,
              uAlpha: {
                type: "f",
                value: 1
              },
              uColor: {
                value: new Color(path)
              }
            });
            this.colorShader.set("uColor", new Color(path));
            if (this._shader != this.colorShader) {
              this.useShader(this.colorShader);
            }
          } else {
            this.textureShader.uniforms.tMap.value = Utils3D.getTexture(path, {
              premultiplyAlpha: false
            });
            if (this._shader != this.textureShader) {
              this.useShader(this.textureShader);
            }
          }
        } else {
          this._shader.uniforms.tMap.value = path;
        }
        return this;
      }
    }
    show() {
      this.group.matrixDirty = true;
      this.mesh.matrixDirty = true;
      this.group.visible = true;
      if (this.anchor) {
        this.anchor.visible = true;
      }
      return this;
    }
    hide() {
      this.group.visible = false;
      if (this.anchor) {
        this.anchor.visible = false;
      }
      return this;
    }
    useShader(shader) {
      if (shader) {
        if (shader != this.textureShader && shader != this.colorShader) {
          shader.uniforms.tMap = this.mesh.shader.uniforms.tMap;
          shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha;
        }
        if (!this._3d) {
          shader.depthTest = false;
        }
        shader.transparent = true;
      }
      this._shader = shader;
      this.mesh.shader = shader || this._shader;
      shader.mesh = this.mesh;
      return this;
    }
    depthTest(bool) {
      this.mesh.shader.depthTest = bool;
    }
    childInteract(hover, click) {
      this._onChildHover = hover;
      this._onChildClick = click;
    }
    useGeometry(geom) {
      this.mesh.geometry = geom;
      return this;
    }
    updateMap(src) {
      this._shader.uniforms.tMap.value = typeof src == "string" ? Utils3D.getTexture(src) : src;
    }
    async mask(obj, shader) {
      await defer();
      let dimensions = {};
      let p = this._parent;
      while (p) {
        if (p.stageLayoutCapture) {
          dimensions.width = p.stageLayoutCapture.width;
          dimensions.height = p.stageLayoutCapture.height;
        }
        p = p._parent;
      }
      if (!dimensions.width) {
        dimensions.width = Stage.width;
        dimensions.height = Stage.height;
      }
      obj.group.updateMatrixWorld(true);
      obj.mesh.onBeforeRender();
      let box = new Box3().setFromObject(obj.mesh);
      let minX = box.min.x / dimensions.width;
      let minY = box.max.y / dimensions.height;
      let maxX = box.max.x / dimensions.width;
      let maxY = -box.min.y / dimensions.height;
      if (this.shader) {
        this.useShader(shader);
        this.shader.addUniforms({
          uMaskValues: {
            value: new Vector4(minX, minY, maxX, maxY)
          }
        });
      }
      obj.hide();
      this.group.traverse(o => {
        if (o.glui && o.glui != this) {
          o.glui.mask(obj, shader);
        }
      });
    }
    deferRender(parent) {
      this.deferred = true;
      if (!parent) {
        this.anchor = new Group();
        GLUI.Scene.addDeferred(this);
      }
    }
    clearTween() {
      if (this._mathTweens) {
        this._mathTweens.forEach(t => {
          t.tween.stop();
        });
      }
      return this;
    }
    createCorners() {
      this.corners = new GLUICornerPin(this);
    }
    getAlpha() {
      if (this._gluiParent) {
        let alpha = this._gluiParent.getAlpha();
        this.alpha = alpha;
        return alpha;
      }
      let alpha = this.alpha;
      let $parent = this.parent;
      while ($parent) {
        alpha *= $parent.alpha;
        $parent = $parent.parent;
      }
      return alpha;
    }
    get shader() {
      return this._shader;
    }
    _divFocus() {
      if (this._onOver) {
        this._onOver({
          action: "over",
          object: this
        });
      }
      if (this.onDivFocus) {
        this.onDivFocus();
      }
    }
    _divBlur() {
      if (this._onOver) {
        this._onOver({
          action: "out",
          object: this
        });
      }
      if (this.onDivBlur) {
        this.onDivBlur();
      }
    }
    _divSelect() {
      if (this._onClick) {
        this._onClick({
          action: "click",
          object: this
        });
      }
      if (this.onDivSelect) {
        this.onDivSelect();
      }
    }
    get _parent() {
      return this.parent;
    }
    get interaction() {
      return (this._3d ? GLUI.Scene : GLUI.Stage).interaction;
    }
    forceUpdate() {
      this.firstRender = false;
      this.mesh.onBeforeRender();
    }
  }
  (function () {
    var _geom2d;
    var _geom3d;
    GLUIObject.getGeometry = function (type) {
      if (type == "2d") {
        if (!_geom2d) {
          (_geom2d = new PlaneGeometry(1, 1)).applyMatrix(new Matrix4().makeTranslation(0.5, -0.5, 0));
        }
        return _geom2d;
      } else {
        _geom3d ||= World.PLANE;
        return _geom3d;
      }
    };
    GLUIObject.clear = function () {
      _geom2d = _geom3d = null;
    };
    GLUIObject.noop = _ => {};
  })();
  class GLUIText {
    constructor(text, fontName, fontSize, options = {}, customCompile) {
      options.font = fontName || options.font;
      options.text = text;
      options.width = options.width;
      options.align = options.align || "left";
      options.size = fontSize || options.size;
      options.lineHeight = options.lineHeight;
      options.letterSpacing = options.letterSpacing;
      options.wordSpacing = options.wordSpacing;
      options.wordBreak = options.wordBreak;
      options.langBreak = options.langBreak;
      options.color = new Color(options.color);
      options.customCompile = customCompile;
      this.text = new GLText(options);
      this.group = new Group();
      this.group.asyncPromise = this.text.text.fontLoaded;
      this.alpha = 1;
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._scaleX = 1;
      this._scaleY = 1;
      this._scale = 1;
      this._rotation = 0;
      this.multiTween = true;
      const _this = this;
      if (text) {
        defer(_ => {
          if (!_this.seo) {
            _this.seoText(text);
          }
        });
      }
      this.text.ready().then(_ => {
        let mesh = _this.text.mesh;
        mesh.glui = _this;
        mesh.shader.visible = false;
        _this.mesh = mesh;
        _this.group.add(mesh);
        if (_this._3d && !_this._style2d) {
          _this.text.centerY();
        }
        if (!_this._3d) {
          _this.text.mesh.shader.depthTest = false;
        }
        mesh.shader.mesh = mesh;
        mesh.onBeforeRender = _ => {
          if (!mesh.determineVisible() && _this.firstRender) {
            return;
          }
          let alpha = _this.getAlpha();
          if (mesh.shader.uniforms.uAlpha) {
            mesh.shader.uniforms.uAlpha.value = alpha;
          }
          if (alpha < 0.001) {
            mesh.shader.visible = false;
            mesh.hidden = false;
            if (!_this.isDirty && _this.firstRender) {
              return;
            }
          } else {
            mesh.hidden = false;
            mesh.shader.visible = true;
          }
          if (!!_this.isDirty || !_this.firstRender) {
            if (RenderStats.active) {
              RenderStats.update("GLUIText", 1, mesh.shader.vsName + "|" + mesh.shader.fsName, mesh);
            }
            _this.group.position.x = _this._x;
            _this.group.position.y = _this._3d ? _this._y : -_this._y;
            _this.group.position.z = _this._z;
            _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);
            if (_this._3d) {
              if (_this.anchor && _this.anchor._parent) {
                _this.anchor.position.copy(_this.group.position);
                _this.anchor.scale.copy(_this.group.scale);
                _this.anchor.quaternion.setFromEuler(_this._rotation);
              } else {
                _this.group.quaternion.setFromEuler(_this._rotation);
              }
            } else {
              _this.group.rotation.z = Math.radians(_this._rotation);
            }
            if (!_this.firstRender) {
              _this.group.updateMatrixWorld(true);
              _this.firstRender = true;
              mesh.shader.visible = true;
            }
            if (_this.onInternalUpdate) {
              _this.onInternalUpdate();
            }
            _this.isDirty = false;
          }
        };
      });
    }
    get x() {
      return this._x;
    }
    set x(v) {
      if (Math.abs(this._x - v) > 0.0001) {
        this.isDirty = true;
      }
      this._x = v;
    }
    get y() {
      return this._y;
    }
    set y(v) {
      if (Math.abs(this._y - v) > 0.0001) {
        this.isDirty = true;
      }
      this._y = v;
    }
    get z() {
      return this._z;
    }
    set z(v) {
      if (Math.abs(this._z - v) > 0.0001) {
        this.isDirty = true;
      }
      this._z = v;
    }
    get scale() {
      return this._scale;
    }
    set scale(v) {
      if (Math.abs(this._scale - v) > 0.0001) {
        this.isDirty = true;
      }
      this._scale = v;
    }
    get scaleX() {
      return this._scaleX;
    }
    set scaleX(v) {
      if (Math.abs(this._scaleX - v) > 0.0001) {
        this.isDirty = true;
      }
      this._scaleX = v;
    }
    get scaleY() {
      return this._scaleY;
    }
    set scaleY(v) {
      if (Math.abs(this._scaleY - v) > 0.0001) {
        this.isDirty = true;
      }
      this._scaleY = v;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(v) {
      if (Math.abs(this._rotation - v) > 0.0001) {
        this.isDirty = true;
      }
      this._rotation = v;
    }
    get dimensions() {
      this._dimensions ||= {};
      if (this.text && this.text.geometry && !this._dimensions.max) {
        this._dimensions = this.text.geometry.boundingBox;
        this._dimensions.width = Math.abs(this._dimensions.min.x - this._dimensions.max.x);
        this._dimensions.height = Math.abs(this._dimensions.min.y - this._dimensions.max.y);
      }
      return this._dimensions;
    }
    interact(over, click, camera = World.CAMERA, seoLink, options) {
      if (typeof camera == "string") {
        options = seoLink;
        seoLink = camera;
        camera = World.CAMERA;
      }
      this._onOver = over;
      this._onClick = click;
      this._interactCamera = camera;
      let stage = this._3d ? GLUI.Scene : GLUI.Stage;
      const _this = this;
      _this.text.ready().then(_ => {
        if (over) {
          if (!_this.text.geometry.boundingBox) {
            _this.text.geometry.computeBoundingBox();
          }
          if (!_this.hitArea) {
            let bb = _this.text.geometry.boundingBox;
            let shader = Utils3D.getTestShader();
            shader.visible = false;
            _this.hitArea = new Mesh(World.PLANE, shader);
            _this.hitArea.glui = _this;
            _this.hitArea.scale.set(Math.abs(bb.min.x) + Math.abs(bb.max.x), Math.abs(bb.min.y) + Math.abs(bb.max.y), 1);
            if (!_this._3d || !!_this._style2d) {
              _this.hitArea.position.x = (bb.max.x - bb.min.x) / 2;
            }
            _this.hitArea.position.y = (bb.min.y - bb.max.y) / 2;
            if (_this._3d) {
              switch (_this.text.getData().align) {
                case "center":
                  _this.hitArea.position.x = 0;
                  break;
                case "right":
                  _this.hitArea.position.x = (bb.min.x - bb.max.x) / 2;
              }
            } else {
              switch (_this.text.getData().align) {
                case "center":
                  _this.hitArea.position.x = 0;
                  break;
                case "right":
                  _this.hitArea.position.x = -(bb.max.x - bb.min.x) / 2;
              }
            }
            _this.text.mesh.add(_this.hitArea);
          }
          stage.interaction.add(_this.hitArea, camera);
        } else {
          stage.interaction.remove(_this.hitArea, camera);
        }
      });
      defer(_ => {
        if (seoLink && _this.seo && _this.seo.aLink) {
          _this.seo.aLink(seoLink, options);
        }
      });
      return this;
    }
    clearInteract() {
      if (this._onOver) {
        (this._3d ? GLUI.Scene : GLUI.Stage).interaction.remove(this.hitArea, this._interactCamera);
        this._onClick = GLUIObject.noop;
        this._onOver = GLUIObject.noop;
      }
      return this;
    }
    remove(param) {
      if (param) {
        console.warn("GLUIObject.remove removes ITSELF from its parent. use removeChild instead");
      }
      let stage = this._3d ? GLUI.Scene : GLUI.Stage;
      if (this.mesh && this.mesh.parent) {
        this.group.parent.remove(this.group);
      } else {
        stage.remove(this);
      }
      if (this.hitArea) {
        stage.interaction.remove(this.hitArea, this._interactCamera);
      }
      if (this.text && this.text.destroy) {
        this.text.destroy();
      }
      Utils.nullObject(this.mesh);
      Utils.nullObject(this);
    }
    tween(obj, time, ease, delay) {
      return tween(this, obj, time, ease, delay);
    }
    enable3D(style2d) {
      this._3d = true;
      this._style2d = style2d;
      this._rotation = new Euler();
      const _this = this;
      _this._rotation.onChange(_ => {
        _this.isDirty = true;
      });
      _this.text.ready().then(_ => {
        _this.text.mesh.shader.depthTest = true;
      });
      this.anchor ||= new Group();
      this.anchor.onMatrixDirty = _ => {
        _this.isDirty = true;
      };
      _this.isDirty = true;
      return this;
    }
    depthTest(bool) {
      const _this = this;
      _this.text.ready().then(_ => {
        _this.text.mesh.shader.depthTest = bool;
      });
      return this;
    }
    setZ(z) {
      const _this = this;
      _this.text.ready().then(_ => {
        _this.text.mesh.renderOrder = z;
      });
      return this;
    }
    height() {
      if (this.mesh) {
        return this.text.height;
      } else {
        return 0;
      }
    }
    async setText(text, options) {
      if (text) {
        text = text.toString();
        this.seoText(text);
      }
      await this.text.ready();
      await this.text.setText(text, options);
      this._dimensions = null;
      return this;
    }
    seoText(text) {
      if (window.GLSEO) {
        GLSEO.textNode(this, text);
      }
    }
    getTextString() {
      return this.text.string;
    }
    setColor(color) {
      const _this = this;
      _this.text.ready().then(_ => _this.text.setColor(color));
      return this;
    }
    tweenColor(color, time, ease, delay) {
      const _this = this;
      _this.text.ready().then(_ => _this.text.tweenColor(color, time, ease, delay));
      return this;
    }
    async resize(options) {
      await this.text.ready();
      await this.text.resize(options);
      this._dimensions = null;
    }
    show() {
      this.text.ready().then(_ => {
        this.text.mesh.visible = true;
        this.text.mesh.updateMatrixWorld(true);
      });
      return this;
    }
    async mask(obj, shader) {
      await defer();
      let dimensions = {};
      let p = this._parent;
      while (p) {
        if (p.stageLayoutCapture) {
          dimensions.width = p.stageLayoutCapture.width;
          dimensions.height = p.stageLayoutCapture.height;
        }
        p = p._parent;
      }
      if (!dimensions.width) {
        dimensions.width = Stage.width;
        dimensions.height = Stage.height;
      }
      obj.group.updateMatrixWorld(true);
      obj.mesh.onBeforeRender();
      let box = new Box3().setFromObject(obj.mesh);
      let minX = box.min.x / dimensions.width;
      let minY = box.max.y / dimensions.height;
      let maxX = box.max.x / dimensions.width;
      let maxY = -box.min.y / dimensions.height;
      if (this.shader) {
        this.useShader(shader);
        this.shader.addUniforms({
          uMaskValues: {
            value: new Vector4(minX, minY, maxX, maxY)
          }
        });
      }
      obj.hide();
      this.group.traverse(o => {
        if (o.glui && o.glui != this) {
          o.glui.mask(obj, shader);
        }
      });
    }
    hide() {
      const _this = this;
      _this.text.ready().then(_ => _this.text.mesh.visible = false);
      return this;
    }
    loaded() {
      return this.text.ready();
    }
    length() {
      return this.text.charLength;
    }
    deferRender(parent) {
      this.deferred = true;
      if (!parent) {
        this.anchor ||= new Group();
        GLUI.Scene.addDeferred(this);
      }
    }
    getAlpha() {
      if (this._gluiParent) {
        let alpha = this._gluiParent.getAlpha();
        this.alpha = alpha;
        return alpha;
      }
      let alpha = this.alpha;
      let $parent = this.parent;
      while ($parent) {
        alpha *= $parent.alpha;
        $parent = $parent.parent;
      }
      return alpha;
    }
    size() {}
    upload() {
      const _this = this;
      _this.text.ready().then(_ => _this.text.mesh.upload());
      return this;
    }
    _divFocus() {
      if (this._onOver) {
        this._onOver({
          action: "over",
          object: this
        });
      }
      if (this.onDivFocus) {
        this.onDivFocus();
      }
    }
    _divBlur() {
      if (this._onOver) {
        this._onOver({
          action: "out",
          object: this
        });
      }
      if (this.onDivBlur) {
        this.onDivBlur();
      }
    }
    _divSelect() {
      if (this._onClick) {
        this._onClick({
          action: "click",
          object: this
        });
      }
      if (this.onDivBlurSelect) {
        this.onDivSelect();
      }
    }
    get _parent() {
      return this.parent;
    }
    async useShader(shader) {
      await this.text.ready();
      shader.uniforms.tMap = this.text.shader.uniforms.tMap;
      shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha;
      shader.uniforms.uColor = this.text.shader.uniforms.uColor;
      shader.transparent = true;
      if (!this._3d || this._3d || this.parent) {
        shader.depthTest = false;
      }
      this.text.mesh.shader = shader || this.text.shader;
      this.text.shader = shader;
      this.text.mesh.shader.mesh = this.text.mesh;
    }
  }
  Class(function GLUIStage() {
    Inherit(this, Component);
    const _this = this;
    var _scene = new Scene();
    var _camera = new OrthographicCamera(1, 1, 1, 1, 0.1, 1);
    function resizeHandler() {
      _camera.left = Stage.width / -2;
      _camera.right = Stage.width / 2;
      _camera.top = Stage.height / 2;
      _camera.bottom = Stage.height / -2;
      _camera.near = 0.01;
      _camera.far = 1000;
      _camera.updateProjectionMatrix();
      _camera.position.x = Stage.width / 2;
      _camera.position.y = -Stage.height / 2;
    }
    this.interaction = new GLUIStageInteraction2D(_camera, _scene, Stage);
    this.alpha = 1;
    this.scene = _scene;
    _scene.disableAutoSort = true;
    _camera.position.z = 1;
    (function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
    })();
    resizeHandler();
    this.add = function ($obj) {
      $obj.parent = _this;
      _scene.add($obj.group || $obj.mesh);
    };
    this.remove = function ($obj) {
      $obj.parent = null;
      _scene.remove($obj.group);
    };
    this.clear = function () {
      _scene.traverse(obj => {
        if (obj.geometry && obj.shader) {
          obj.destroy();
        }
      });
      _scene.children.length = _scene.childrenLength = 0;
    };
    this.renderToRT = function (scene, rt) {
      let clearAlpha;
      if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
        clearAlpha = World.RENDERER.getClearAlpha();
        World.RENDERER.setClearAlpha(0);
      }
      let autoClear = World.RENDERER.autoClear;
      World.RENDERER.autoClear = false;
      World.RENDERER.render(scene, _camera, rt);
      World.RENDERER.autoClear = autoClear;
      if (clearAlpha) {
        World.RENDERER.setClearAlpha(clearAlpha);
      }
    };
    this.resize = resizeHandler;
    this.render = function loop() {
      if (!_scene.children.length) {
        return;
      }
      let clear = World.RENDERER.autoClear;
      World.RENDERER.autoClear = false;
      World.RENDERER.render(_scene, _camera, null, true);
      World.RENDERER.autoClear = clear;
    };
    this.renderDirect = callback => {
      if (_scene.children.length) {
        _scene.traverse(obj => {
          if (obj.shader) {
            obj.shader.depthTest = false;
          }
        });
        callback(_scene, _camera);
      }
    };
  });
  Class(function GLUIStage3D() {
    Inherit(this, Object3D);
    const _this = this;
    var _camera;
    var _externalRenders = [];
    var _scene = new Scene();
    var _list = new LinkedList();
    this.alpha = 1;
    this.interaction = new GLUIStageInteraction3D();
    this.add = function (obj, parent) {
      obj.parent = _this;
      obj._gluiParent = parent;
      if (obj.anchor) {
        obj.anchor._gluiParent = parent;
      }
      if (!obj._3d) {
        obj.enable3D();
      }
      obj.deferRender();
    };
    this.clear = function () {
      _scene.traverse(obj => {
        if (obj.geometry && obj.shader) {
          obj.destroy();
        }
      });
      _scene.children.length = _scene.childrenLength = 0;
    };
    this.addDeferred = function (obj) {
      _list.push(obj);
      _scene.add(obj.group || obj.mesh);
    };
    this.remove = function (obj) {
      _scene.remove(obj.group || obj.mesh);
      _list.remove(obj);
    };
    this.disableAutoSort = function () {
      _scene.disableAutoSort = true;
    };
    this.renderToRT = function (scene, camera) {
      camera = camera.camera || camera;
      scene.traverse(mesh => {
        let obj = mesh.glui || mesh;
        if (obj && obj.anchor && obj.anchor.determineVisible()) {
          Utils3D.decompose(obj.anchor, obj.group || obj);
        }
      });
      scene._textRenderCamera = camera;
      _externalRenders.push(scene);
    };
    this.renderToRT2 = function (scene, rt, camera) {
      let clearAlpha;
      if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
        clearAlpha = World.RENDERER.getClearAlpha();
        World.RENDERER.setClearAlpha(0);
      }
      let autoClear = World.RENDERER.autoClear;
      World.RENDERER.autoClear = false;
      World.RENDERER.render(scene, camera, rt);
      World.RENDERER.autoClear = autoClear;
      if (clearAlpha) {
        World.RENDERER.setClearAlpha(clearAlpha);
      }
    };
    this.render = function loop() {
      if (!window.Metal) {
        if (_list.length) {
          let obj = _list.start();
          while (obj) {
            if (obj._marked) {
              obj._marked = false;
              Utils3D.decompose(obj.anchor, obj.group);
            }
            obj = _list.next();
          }
          let clear = World.RENDERER.autoClear;
          Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
          World.RENDERER.autoClear = false;
          World.RENDERER.render(_scene, _camera || World.CAMERA);
          World.RENDERER.autoClear = clear;
        }
        if (_externalRenders.length) {
          while (_externalRenders.length) {
            let scene = _externalRenders.shift();
            let camera = scene._textRenderCamera;
            let clear = World.RENDERER.autoClear;
            Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
            World.RENDERER.autoClear = false;
            World.RENDERER.render(scene, camera);
            World.RENDERER.autoClear = clear;
          }
        }
      }
    };
    this.mark = function mark() {
      let obj = _list.start();
      while (obj) {
        if (obj.anchor._parent) {
          obj.group.visible = obj.anchor.determineVisible();
        }
        if (obj.mesh && obj.mesh.determineVisible() && obj.anchor._parent) {
          obj._marked = true;
        }
        obj = _list.next();
      }
    };
    this.renderDirect = function (callback) {
      if (_list.length) {
        let obj = _list.start();
        while (obj) {
          if (obj._marked) {
            obj._marked = false;
            Utils3D.decompose(obj.anchor, obj.group);
          }
          obj = _list.next();
        }
        _scene.traverse(obj => {
          if (obj.shader) {
            obj.shader.depthTest = false;
          }
        });
        callback(_scene, _camera || World.CAMERA);
      }
    };
    this.set("camera", c => {
      _camera = c.camera || c;
    });
  });
  Class(function GLUIToRT() {
    const _this = this;
    if (!_this.addObject) {
      throw "GLUIToRT must decorate inheritance on an FXScene";
    }
    var _gluiScene = new Scene();
    var _glui3DScene = new Scene();
    var _3dlist = [];
    this.glui = $gl();
    this.glScene = $gl();
    this.glScene.gluiToRT = _this;
    GLUI.Stage.add(_this.glui);
    _this.startRender(_ => {
      for (let i = 0; i < _3dlist.length; i++) {
        let obj = _3dlist[i];
        if (obj.anchor._parent) {
          obj.group.visible = obj.anchor.determineVisible();
        }
        if (obj.mesh && obj.mesh.determineVisible() && obj.anchor._parent) {
          Utils3D.decompose(obj.anchor, obj.group);
        }
      }
    }, World.NUKE);
    _this.startRender(_ => {
      if (!_this.preventRTDraw) {
        if (_this.flag("gluiActive")) {
          GLUI.Stage.renderToRT(_gluiScene, _this.rt);
          if (_this.glSceneEnabled) {
            GLUI.Scene.renderToRT2(_glui3DScene, _this.rt, _this.nuke.camera);
          }
        }
        if (_this.glSceneEnabled) {
          GLUI.Scene.camera = _this.nuke.camera;
        }
      }
    }, _this);
    this.gluiToRT = function () {
      if (!_this.flag("gluiActive")) {
        _this.flag("gluiActive", true);
        GLUI.Stage.remove(_this.glui);
        _gluiScene.add(_this.glui.group);
        if (_this.glSceneEnabled) {
          GLUI.Scene.remove(_this.glScene);
          _glui3DScene.add(_this.glScene.group);
        }
      }
    };
    this.gluiToScreen = function () {
      if (_this.flag("gluiActive")) {
        GLUI.Stage.add(_this.glui);
        _gluiScene.remove(_this.glui.group);
        _this.flag("gluiActive", false);
        if (_this.glSceneEnabled) {
          if (!_this.flag("fxSceneHidden")) {
            GLUI.Scene.add(_this.glScene);
          }
          _glui3DScene.remove(_this.glScene.group);
        }
      }
    };
    this.displayGLUI = async function (retina) {
      await defer();
      _this.gluiToRT();
      if (retina) {
        _this.gluiToScreen();
      }
    };
    this.onFXSceneVisibility = function (v) {
      _this.flag("fxSceneHidden", !v);
      if (_this.glSceneEnabled) {
        if (v) {
          if (!_this.flag("gluiActive")) {
            GLUI.Scene.add(_this.glScene);
          }
        } else {
          GLUI.Scene.remove(_this.glScene);
        }
      }
    };
    this.addGLUI3D = function (obj) {
      _3dlist.push(obj);
      _this.glScene.add(obj);
    };
  });
  Module(function FirefoxGPUFixer() {
    this.exports = function () {
      if (GPU.detect("radeon r9 200") && (Device.system.os == "mac" || Device.pixelRatio > 1)) {
        Device.graphics.webgl.gpu = "radeon pro 455";
      }
    };
  });
  Class(function GPU() {
    Inherit(this, Component);
    var _this = this;
    var _split = {};
    Hydra.ready(async () => {
      _this.detect = function (match) {
        if (Device.graphics.gpu) {
          return Device.graphics.gpu.detect(match);
        }
      };
      _this.detectAll = function () {
        if (Device.graphics.gpu) {
          var match = true;
          for (var i = 0; i < arguments.length; i++) {
            if (!Device.graphics.gpu.detect(arguments[i])) {
              match = false;
            }
          }
          return match;
        }
      };
      _this.matchGPU = function (str, min, max = 99999) {
        let num = function splitGPU(string) {
          if (_split[string]) {
            return _split[string];
          }
          if (!_this.detect(string)) {
            return -1;
          }
          try {
            var num = Number(_this.gpu.split(string)[1].split(" ")[0]);
            _split[string] = num;
            return num;
          } catch (e) {
            return -1;
          }
        }(str);
        return num >= min && num < max;
      };
      _this.gpu = Device.graphics.gpu ? Device.graphics.gpu.identifier : "";
      if (_this.gpu == "apple gpu") {
        if (Device.mobile) {
          await require("iOSGPUTest")();
        } else {
          require("MacOSPerformanceTest")();
        }
      }
      if (Device.system.browser === "firefox") {
        require("FirefoxGPUFixer")();
      }
      _this.BLACKLIST = require("GPUBlacklist").match();
      _this.T0 = !Device.mobile && (!!_this.BLACKLIST || !!_this.detect("radeon(tm) r5") || !!_this.detect("radeon r9 200") || !!_this.detect("hd graphics family") || !!_this.detect("intel(r) uhd graphics direct") || !!_this.matchGPU("hd graphics ", 1000, 5001) || !!_this.matchGPU("hd graphics ", 0, 618) && !!(Device.pixelRatio > 1) || !!_this.detect(["hd graphics", "iris"]) && !!(Math.max(Stage.width, Stage.height) > 1800) || !!_this.detect(["intel iris opengl engine"]) || !!_this.matchGPU("iris(tm) graphics ", 1000));
      _this.T1 = !_this.BLACKLIST && !Device.mobile && !_this.T0 && (!!_this.matchGPU("iris(tm) graphics ", 540, 1000) || !!_this.matchGPU("hd graphics ", 514, 1000) || !!_this.matchGPU("intel(r) uhd graphics ", 600, 1000) || !_this.detect(["nvidia", "amd", "radeon", "geforce"]) || !!_this.detect(["vega 8"]));
      _this.T2 = !_this.BLACKLIST && !Device.mobile && !!_this.detect(["nvidia", "amd", "radeon", "geforce"]) && !_this.T1 && !_this.T0;
      _this.T3 = !_this.BLACKLIST && !Device.mobile && (!!_this.detect(["titan", "amd radeon pro", "quadro"]) || !!_this.matchGPU("gtx ", 940) || !!_this.matchGPU("radeon (tm) rx ", 400) || !!_this.detect("amd radeon(tm) graphics direct3d11 vs_5_0") || !!_this.matchGPU("radeon rx ", 400) || !!_this.matchGPU("radeon pro ", 420));
      _this.T4 = !_this.BLACKLIST && !Device.mobile && (!!_this.detect(["titan", "quadro", "radeon vii", "apple m"]) || !!_this.matchGPU("gtx ", 1060) || !!_this.matchGPU("rtx") || !!_this.matchGPU("radeon rx ", 500) || !!_this.matchGPU("vega ", 50) || !!_this.detect(["radeon pro 5300m", "radeon pro 5500m", "radeon pro 5600m", "amd radeon unknown prototype"]));
      _this.T5 = !_this.BLACKLIST && !Device.mobile && (!!_this.detect(["titan", "radeon vii"]) || !!_this.matchGPU("gtx ", 1080) || !!_this.matchGPU("rtx ", 2060) || !!_this.matchGPU("radeon rx ", 5500) || !!_this.detect("apple m") && !!_this.detect("max"));
      _this.MT0 = !!Device.mobile && (!!_this.BLACKLIST || Device.system.os == "ios" && !!_this.detect("a7") || Device.system.os == "android" && !!_this.detect("sgx") || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 0, 415) : _this.detect("mali") ? _this.matchGPU("mali-t", 0, 628) : Device.system.os == "ios" && !!_this.detect(["a8", "a9"]) || !!_this.detect("mali-g") || !!_this.matchGPU("adreno (tm) ", 420)));
      _this.MT1 = function () {
        if (!Device.mobile) {
          return false;
        }
        if (_this.BLACKLIST) {
          return false;
        }
        if (Device.system.os == "ios" && _this.detect("a10")) {
          return true;
        }
        if (Device.system.os == "android" && !_this.MT0) {
          return true;
        }
        if (_this.detect("nvidia tegra") && Device.detect("pixel c")) {
          return true;
        }
        if (_this.detect("mali-g")) {
          return _this.matchGPU("mali-g", 73);
        }
        if (_this.detect("adreno")) {
          if (_this.matchGPU("adreno (tm) ", 600, 616)) {
            return true;
          }
          if (_this.matchGPU("adreno (tm) ", 530, 600)) {
            return true;
          }
        }
        return false;
      }();
      _this.MT2 = !!Device.mobile && !_this.BLACKLIST && (Device.system.os == "ios" && !!_this.detect(["a11", "a12"]) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 630) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 74) : !!navigator.platform.toLowerCase().includes(["mac", "windows"]) && Device.system.browser == "chrome"));
      _this.MT3 = !!Device.mobile && !_this.BLACKLIST && (Device.system.os == "ios" && !!_this.detect(["a12", "a13", "a14", "a15", "a16", "a17", "a18"]) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 640) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 76) : !!navigator.platform.toLowerCase().includes(["mac", "windows"]) && Device.system.browser == "chrome"));
      _this.MT4 = !!Device.mobile && !_this.BLACKLIST && (Device.system.os == "ios" && !!_this.detect(["a14", "a15", "a16", "a17", "a18", "a19", "a20", "apple m"]) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 650) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 78) : !!navigator.platform.toLowerCase().includes(["mac", "windows"]) && Device.system.browser == "chrome"));
      _this.lt = function (num) {
        return _this.TIER > -1 && _this.TIER <= num;
      };
      _this.gt = function (num) {
        return _this.TIER > -1 && _this.TIER >= num;
      };
      _this.eq = function (num) {
        return _this.TIER > -1 && _this.TIER == num;
      };
      _this.mobileEq = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER == num;
      };
      _this.mobileLT = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER <= num;
      };
      _this.mobileGT = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER >= num;
      };
      for (var key in _this) {
        if (key.charAt(0) == "T" && _this[key] === true) {
          _this.TIER = Number(key.charAt(1));
        }
        if (key.slice(0, 2) == "MT" && _this[key] === true) {
          _this.M_TIER = Number(key.charAt(2));
        }
      }
      if (Utils.query("gpu") !== false) {
        if (Device.mobile || Utils.query("gpu").toString().includes("m")) {
          _this.TIER = -1;
          _this.M_TIER = Number(Utils.query("gpu").slice(1));
        } else {
          _this.TIER = Number(Utils.query("gpu"));
        }
      }
      if (Device.system.os == "ios" && Render.REFRESH_RATE < 40) {
        _this.M_TIER -= 1;
      }
      _this.OVERSIZED = !Device.mobile && _this.TIER <= 0 && Math.max(window.innerWidth, window.innerHeight) > 1400 || !Device.mobile && _this.TIER <= 1 && Math.max(window.innerWidth, window.innerHeight) > 1600;
      if (Device.system.browser == "ie") {
        _this.OVERSIZED = true;
      }
      _this.initialized = true;
    });
    this.ready = function () {
      return this.wait("initialized");
    };
  }, "static");
  Module(function MacOSPerformanceTest() {
    function test() {
      let results = [];
      function getPrime() {
        return function largest_prime_factor(n) {
          return factors(n).filter(primep).pop();
        }(1000000000000);
      }
      function factors(n) {
        var i;
        var out = [];
        var sqrt_n = Math.sqrt(n);
        for (i = 2; i <= sqrt_n; i++) {
          if (n % i == 0) {
            out.push(i);
          }
        }
        return out;
      }
      function primep(n) {
        return factors(n).length === 0;
      }
      for (let i = 0; i < 3; i++) {
        let time = performance.now();
        getPrime();
        results.push((performance.now() - time) * 10);
      }
      results.sort((a, b) => a - b);
      return results[0];
    }
    this.exports = function () {
      let result = test();
      if (screen.width <= 1440 && screen.height <= 900) {
        Device.graphics.webgl.gpu = result > 540 ? "intel iris opengl engine" : "safari tier 1";
      } else {
        Device.graphics.webgl.gpu = result > 475 ? result > 540 ? "intel iris opengl engine" : "safari tier 1" : result < 375 ? "amd radeon pro 455 opengl engine" : "nvidia geforce 750m opengl engine";
      }
    };
  });
  Module(function iOSGPUTest() {
    function getRenderer(complete, takUrl) {
      var nodes = [{
        x: "Unknown",
        m: function (n) {
          return function family() {
            var segments = /iPhone|iPad|Macintosh/.exec(navigator.userAgent);
            if (segments && segments.length > 0) {
              return segments[0];
            }
            return "";
          }();
        },
        n: [4, 2, 1, 3]
      }, {
        x: "Apple A7 GPU|Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
        m: function (n) {
          return height();
        },
        n: [15, 10, 11, 12, 14, 6, 7, 8, 13, 5, 9],
        v: ["iPhone"]
      }, {
        x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU|Apple A14 GPU|Apple A12Z GPU",
        m: function (n) {
          return height();
        },
        n: [21, 20, 18, 19, 17, 16],
        v: ["iPad"]
      }, {
        x: "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12X GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple A13 GPU|Apple A14 GPU|Apple M1 GPU|Apple A12Z GPU|Apple A15 GPU",
        m: function (n) {
          return height();
        },
        n: [20, 18, 27, 10, 11, 12, 14, 19, 23, 26, 24, 17, 25, 13, 9, 22],
        v: ["Macintosh"]
      }, {
        x: "Apple A10 GPU",
        v: ["iPod Touch"]
      }, {
        x: "Apple A7 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A8 GPU|Apple A13 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [29, 28],
        v: [1136]
      }, {
        x: "Apple A8 GPU|Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [30, 31],
        v: [2001]
      }, {
        x: "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [32, 33],
        v: [2208]
      }, {
        x: "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [34, 35],
        v: [1334]
      }, {
        x: "Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [37, 38, 39, 40, 36, 41],
        v: [2436]
      }, {
        x: "Apple A12 GPU|Apple A13 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [42, 36],
        v: [2688]
      }, {
        x: "Apple A12 GPU|Apple A13 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [44, 43],
        v: [1624]
      }, {
        x: "Apple A12 GPU|Apple A13 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [44, 36],
        v: [1792]
      }, {
        x: "Apple A11 GPU|Apple A12 GPU|Apple A14 GPU|Apple A13 GPU|Apple A15 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [47, 45, 36, 46, 41],
        v: [2079]
      }, {
        x: "Apple A14 GPU",
        v: [2532]
      }, {
        x: "Apple A14 GPU",
        v: [2778]
      }, {
        x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [49, 48],
        v: [2048]
      }, {
        x: "Apple A9X GPU|Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [50, 51],
        v: [2732]
      }, {
        x: "Apple A10X GPU|Apple A12 GPU",
        m: function (n) {
          return hash();
        },
        n: [53, 52],
        v: [2224]
      }, {
        x: "Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
        m: function (n) {
          return hash3d();
        },
        n: [55, 54],
        v: [2388]
      }, {
        x: "Apple A10 GPU|Apple A12 GPU",
        m: function (n) {
          return hash();
        },
        n: [56, 57],
        v: [2160]
      }, {
        x: "Apple A14 GPU",
        v: [2360]
      }, {
        x: "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple M1 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [58, 49],
        v: [2048]
      }, {
        x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [59, 33],
        v: [2208]
      }, {
        x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [59, 35],
        v: [1334]
      }, {
        x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [60, 29],
        v: [1136]
      }, {
        x: "Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
        m: function (n) {
          return mediacolorgamut();
        },
        n: [59, 31],
        v: [2001]
      }, {
        x: "Apple A14 GPU",
        v: [2360, 2778]
      }, {
        x: "Apple A7 GPU|Apple A9 GPU|Apple A8 GPU",
        m: function (n) {
          return hash();
        },
        n: [61, 63, 62, 64, 65],
        v: ["srgb"]
      }, {
        x: "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [66, 37, 67],
        v: ["p3"]
      }, {
        x: "Apple A8 GPU|Apple A9 GPU",
        m: function (n) {
          return hash();
        },
        n: [68, 69],
        v: ["srgb"]
      }, {
        x: "Apple A10 GPU|Apple A11 GPU",
        m: function (n) {
          return hash();
        },
        n: [70, 71],
        v: ["p3"]
      }, {
        x: "Apple A8 GPU|Apple A9 GPU",
        m: function (n) {
          return hash();
        },
        n: [72, 73],
        v: ["srgb"]
      }, {
        x: "Apple A10 GPU|Apple A11 GPU",
        m: function (n) {
          return hash();
        },
        n: [70, 74],
        v: ["p3"]
      }, {
        x: "Apple A8 GPU|Apple A9 GPU",
        m: function (n) {
          return hash();
        },
        n: [75, 76],
        v: ["srgb"]
      }, {
        x: "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [66, 37, 67],
        v: ["p3"]
      }, {
        x: "Apple A12 GPU",
        v: [958581112, 2301174800, 4085158452]
      }, {
        x: "Apple A11 GPU",
        v: [367695777, 411650080, 1220644697]
      }, {
        x: "Apple A13 GPU",
        v: [4193218782]
      }, {
        x: "Apple A14 GPU",
        v: [105985484]
      }, {
        x: "Apple A14 GPU",
        v: [3403189785]
      }, {
        x: "Apple A14 GPU|Apple A15 GPU",
        v: [2364051618]
      }, {
        x: "Apple A13 GPU",
        v: [352823931, 4193218782]
      }, {
        x: "Apple A12 GPU",
        v: [958581112, 2301174800, 3403189785, 4085158452]
      }, {
        x: "Apple A13 GPU",
        v: [352823931, 3335845976, 4193218782]
      }, {
        x: "Apple A11 GPU",
        v: [367695777, 411650080]
      }, {
        x: "Apple A14 GPU",
        v: [105985484, 679860869, 3403189785]
      }, {
        x: "Apple A13 GPU",
        v: [352823931]
      }, {
        x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8X GPU",
        m: function (n) {
          return hash();
        },
        n: [80, 77, 81, 82, 83, 85, 78, 79, 84, 61],
        v: ["srgb"]
      }, {
        x: "Apple A10X GPU|Apple A9X GPU|Apple A12X GPU|Apple A12 GPU|Apple M1 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [55, 87, 86, 88, 89],
        v: ["p3"]
      }, {
        x: "Apple A9X GPU",
        v: ["srgb"]
      }, {
        x: "Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
        m: function (n) {
          return hash3d();
        },
        n: [91, 90, 94, 92, 93],
        v: ["p3"]
      }, {
        x: "Apple A10X GPU",
        v: [63583436, 2114570256, 3129316290]
      }, {
        x: "Apple A12 GPU",
        v: [1349146759, 2917249763]
      }, {
        x: "Apple A12X GPU|Apple A12Z GPU",
        v: [4085158452]
      }, {
        x: "Apple M1 GPU",
        v: [105985484, 3403189785]
      }, {
        x: "Apple A10 GPU",
        v: [2114570256]
      }, {
        x: "Apple A12 GPU",
        v: [1349146759, 2206992415]
      }, {
        x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return hash3d();
        },
        n: [101, 96, 98, 97, 95, 99, 100],
        v: ["srgb"]
      }, {
        x: "Apple A9 GPU",
        v: ["srgb"]
      }, {
        x: "Apple A9 GPU|Apple A10 GPU",
        m: function (n) {
          return hash();
        },
        n: [102, 64, 65],
        v: ["srgb"]
      }, {
        x: "Apple A7 GPU",
        v: [857422828, 1915583345]
      }, {
        x: "Apple A9 GPU",
        v: [46663968, 3129316290]
      }, {
        x: "Apple A8 GPU",
        v: [839732043, 3816812018, 4125234388]
      }, {
        x: "Apple A9 GPU",
        v: [2114570256]
      }, {
        x: "Apple A9 GPU",
        v: [63583436]
      }, {
        x: "Apple A10 GPU",
        v: [583354101, 3458129248, 3928876783]
      }, {
        x: "Apple A13 GPU",
        v: [352823931, 3335845976, 3403189785, 4193218782]
      }, {
        x: "Apple A8 GPU",
        v: [1411440593, 1924197914, 4125234388]
      }, {
        x: "Apple A9 GPU",
        v: [2114570256, 3129316290]
      }, {
        x: "Apple A10 GPU",
        v: [63583436, 2114570256, 3129316290]
      }, {
        x: "Apple A11 GPU",
        v: [1349146759, 2917249763]
      }, {
        x: "Apple A8 GPU",
        v: [1411440593, 1913250432, 3074367344, 4125234388]
      }, {
        x: "Apple A9 GPU",
        v: [46663968, 2114570256, 3129316290]
      }, {
        x: "Apple A11 GPU",
        v: [2917249763, 3237505312]
      }, {
        x: "Apple A8 GPU",
        v: [3128296539, 3816812018, 4125234388]
      }, {
        x: "Apple A9 GPU",
        v: [46663968, 63583436, 2114570256, 3129316290]
      }, {
        x: "Apple A8 GPU",
        v: [2656686317, 3710391565]
      }, {
        x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
        v: [3129316290]
      }, {
        x: "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [103, 95, 99],
        v: [2114570256]
      }, {
        x: "Apple A10 GPU",
        v: [46663968]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return benchmarkcpuavg(n);
        },
        n: [105, 104],
        v: [4125234388]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return hash3d();
        },
        n: [106, 107, 108],
        v: [4005673483]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        v: [1350183384, 1361285941, 3816812018]
      }, {
        x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
        m: function (n) {
          return hash3d();
        },
        n: [101, 100],
        v: [63583436]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return hash3d();
        },
        n: [110, 109],
        v: [2870741841]
      }, {
        x: "Apple A10X GPU|Apple A9X GPU",
        v: [3458129248]
      }, {
        x: "Apple A12X GPU|Apple A12 GPU",
        v: [4085158452]
      }, {
        x: "Apple A10X GPU|Apple A9X GPU",
        m: function (n) {
          return benchmarkcpuavg(n);
        },
        n: [111, 112],
        v: [583354101]
      }, {
        x: "Apple A10X GPU|Apple A9X GPU",
        m: function (n) {
          return benchmarkcpuavg(n);
        },
        n: [113, 114],
        v: [3928876783]
      }, {
        x: "Apple A12X GPU",
        v: [4085158452]
      }, {
        x: "Apple A10X GPU",
        v: [583354101, 3458129248, 3928876783]
      }, {
        x: "Apple M1 GPU",
        v: [105985484]
      }, {
        x: "Apple M1 GPU|Apple A10X GPU",
        m: function (n) {
          return hash();
        },
        n: [116, 115],
        v: [3403189785]
      }, {
        x: "Apple A12Z GPU",
        v: [958581112]
      }, {
        x: "Apple A9X GPU|Apple A10 GPU",
        v: [3458129248]
      }, {
        x: "Apple A8X GPU",
        v: [1480368425, 1783160115]
      }, {
        x: "Apple A8X GPU|Apple A10 GPU",
        m: function (n) {
          return hash();
        },
        n: [56, 117],
        v: [3403189785]
      }, {
        x: "Apple A8 GPU",
        v: [3312905059, 3928382683]
      }, {
        x: "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
        m: function (n) {
          return benchmarkcpuavg(n);
        },
        n: [118, 119],
        v: [583354101]
      }, {
        x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
        m: function (n) {
          return benchmarkcpuavg(n);
        },
        n: [120, 122, 121],
        v: [3928876783]
      }, {
        x: "Apple A10 GPU",
        v: [1058363647, 2015944978]
      }, {
        x: "Apple A9 GPU",
        v: [46663968]
      }, {
        x: "Apple A10 GPU",
        v: [3403189785]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return benchmarkcpustd(n);
        },
        n: [123, 124],
        r: [{
          a: 29.78,
          b: 30.87
        }]
      }, {
        x: "Apple A8 GPU",
        r: [{
          a: 31.19,
          b: 31.59
        }]
      }, {
        x: "Apple A8X GPU",
        v: [1783160115]
      }, {
        x: "Apple A8 GPU",
        v: [3928382683]
      }, {
        x: "Apple A8 GPU|Apple A8X GPU",
        m: function (n) {
          return benchmarkcpustd(n);
        },
        n: [125, 126],
        v: [3403189785]
      }, {
        x: "Apple A8 GPU",
        v: [3312905059]
      }, {
        x: "Apple A8X GPU",
        v: [1480368425]
      }, {
        x: "Apple A10X GPU",
        r: [{
          a: 14.16,
          b: 17.21
        }]
      }, {
        x: "Apple A9X GPU",
        r: [{
          a: 18.44,
          b: 35.94
        }]
      }, {
        x: "Apple A10X GPU",
        r: [{
          a: 12.34,
          b: 15.6
        }]
      }, {
        x: "Apple A9X GPU",
        r: [{
          a: 16.8,
          b: 121.37
        }]
      }, {
        x: "Apple M1 GPU",
        v: [1349146759]
      }, {
        x: "Apple A10X GPU",
        v: [2114570256]
      }, {
        x: "Apple A8X GPU",
        v: [4005673483]
      }, {
        x: "Apple A9X GPU|Apple A9 GPU",
        r: [{
          a: 24.38,
          b: 31.67
        }]
      }, {
        x: "Apple A10 GPU|Apple A9X GPU",
        r: [{
          a: 16.82,
          b: 22.52
        }]
      }, {
        x: "Apple A9 GPU|Apple A9X GPU",
        r: [{
          a: 19.79,
          b: 21.64
        }]
      }, {
        x: "Apple A10 GPU|Apple A9X GPU",
        m: function (n) {
          return benchmarkcpustd(n);
        },
        n: [127],
        r: [{
          a: 14.44,
          b: 19.65
        }]
      }, {
        x: "Apple A9 GPU|Apple A9X GPU",
        r: [{
          a: 22.74,
          b: 24.91
        }]
      }, {
        x: "Apple A8X GPU",
        r: [{
          a: 0.26,
          b: 5.62
        }]
      }, {
        x: "Apple A8 GPU",
        r: [{
          a: 6.32,
          b: 161.36
        }]
      }, {
        x: "Apple A8X GPU",
        r: [{
          a: 0.53,
          b: 13.31
        }]
      }, {
        x: "Apple A8 GPU",
        r: [{
          a: 83.08,
          b: 2952.42
        }]
      }, {
        x: "Apple A9X GPU|Apple A10 GPU",
        r: [{
          a: 29.8,
          b: 228.33
        }]
      }];
      function hash3d() {
        var gl;
        var program;
        var canvas;
        var mat4 = {
          create: function () {
            var result = new Array(16);
            for (var i = 0; i < 16; i++) {
              result[i] = i % 5 == 0 ? 1 : 0;
            }
            return result;
          },
          perspective: function (out, fovy, aspect, near, far) {
            var nf;
            var f = 1 / Math.tan(fovy / 2);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[15] = 0;
            if (far != null && far !== Infinity) {
              nf = 1 / (near - far);
              out[10] = (far + near) * nf;
              out[14] = far * 2 * near * nf;
            } else {
              out[10] = -1;
              out[14] = near * -2;
            }
            return out;
          },
          lookAt: function (out, eye, center, up) {
            var x0;
            var x1;
            var x2;
            var y0;
            var y1;
            var y2;
            var z0;
            var z1;
            var z2;
            var len;
            var eyex = eye[0];
            var eyey = eye[1];
            var eyez = eye[2];
            var upx = up[0];
            var upy = up[1];
            var upz = up[2];
            var centerx = center[0];
            var centery = center[1];
            var centerz = center[2];
            if (Math.abs(eyex - centerx) < 0.000001 && Math.abs(eyey - centery) < 0.000001 && Math.abs(eyez - centerz) < 0.000001) {
              return mat4.identity(out);
            } else {
              z0 = eyex - centerx;
              z1 = eyey - centery;
              z2 = eyez - centerz;
              x0 = upy * (z2 *= len = 1 / Math.hypot(z0, z1, z2)) - upz * (z1 *= len);
              x1 = upz * (z0 *= len) - upx * z2;
              x2 = upx * z1 - upy * z0;
              if (len = Math.hypot(x0, x1, x2)) {
                x0 *= len = 1 / len;
                x1 *= len;
                x2 *= len;
              } else {
                x0 = 0;
                x1 = 0;
                x2 = 0;
              }
              y0 = z1 * x2 - z2 * x1;
              y1 = z2 * x0 - z0 * x2;
              y2 = z0 * x1 - z1 * x0;
              if (len = Math.hypot(y0, y1, y2)) {
                y0 *= len = 1 / len;
                y1 *= len;
                y2 *= len;
              } else {
                y0 = 0;
                y1 = 0;
                y2 = 0;
              }
              out[0] = x0;
              out[1] = y0;
              out[2] = z0;
              out[3] = 0;
              out[4] = x1;
              out[5] = y1;
              out[6] = z1;
              out[7] = 0;
              out[8] = x2;
              out[9] = y2;
              out[10] = z2;
              out[11] = 0;
              out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
              out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
              out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
              out[15] = 1;
              return out;
            }
          },
          multiply: function (out, a, b) {
            var a00 = a[0];
            var a01 = a[1];
            var a02 = a[2];
            var a03 = a[3];
            var a10 = a[4];
            var a11 = a[5];
            var a12 = a[6];
            var a13 = a[7];
            var a20 = a[8];
            var a21 = a[9];
            var a22 = a[10];
            var a23 = a[11];
            var a30 = a[12];
            var a31 = a[13];
            var a32 = a[14];
            var a33 = a[15];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[4];
            b1 = b[5];
            b2 = b[6];
            b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[8];
            b1 = b[9];
            b2 = b[10];
            b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[12];
            b1 = b[13];
            b2 = b[14];
            b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
          },
          identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
          }
        };
        var imageHash = 0;
        if ((canvas = document.createElement("canvas")) != null) {
          var imageData = function generate() {
            if (gl = function getRenderingContext() {
              canvas.width = 67;
              canvas.height = 67;
              var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
              if (gl) {
                gl.viewport(0, 0, 67, 67);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              return gl;
            }()) {
              var vertexShader = gl.createShader(gl.VERTEX_SHADER);
              gl.shaderSource(vertexShader, "attribute vec3 c,d; uniform vec4 e; uniform vec3 f,g;uniform mat4 h,i;varying vec3 j;void main(){vec3 a=normalize(d);vec4 b=h*vec4(c,1.);vec3 k=normalize(vec3(e-b));j=g*f*max(dot(k,a),0.),gl_Position=i*vec4(c,1.);}");
              gl.compileShader(vertexShader);
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(fragmentShader, "#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec3 j;void main(){gl_FragColor = vec4(j, 1.0);}");
              gl.compileShader(fragmentShader);
              program = gl.createProgram();
              gl.attachShader(program, vertexShader);
              gl.attachShader(program, fragmentShader);
              gl.linkProgram(program);
              gl.detachShader(program, vertexShader);
              gl.detachShader(program, fragmentShader);
              gl.deleteShader(vertexShader);
              gl.deleteShader(fragmentShader);
              gl.useProgram(program);
              var n = function initVertexBuffers(gl) {
                var latNumber;
                var longNumber;
                var vertexPositionData = [];
                var normalData = [];
                var textureCoordData = [];
                var indexData = [];
                for (latNumber = 0; latNumber <= 50; ++latNumber) {
                  var theta = latNumber * Math.PI / 50;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = Math.cos(theta);
                  for (longNumber = 0; longNumber <= 50; ++longNumber) {
                    var phi = longNumber * 2 * Math.PI / 50;
                    var sinPhi = Math.sin(phi);
                    var x = Math.cos(phi) * sinTheta;
                    var y = cosTheta;
                    var z = sinPhi * sinTheta;
                    var u = 1 - longNumber / 50;
                    var v = 1 - latNumber / 50;
                    vertexPositionData.push(x * 2);
                    vertexPositionData.push(y * 2);
                    vertexPositionData.push(z * 2);
                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                    textureCoordData.push(u);
                    textureCoordData.push(v);
                  }
                }
                for (latNumber = 0; latNumber < 50; ++latNumber) {
                  for (longNumber = 0; longNumber < 50; ++longNumber) {
                    var first = latNumber * 51 + longNumber;
                    var second = first + 50 + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);
                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                  }
                }
                vertexPositionData = new Float32Array(vertexPositionData);
                normalData = new Float32Array(normalData);
                textureCoordData = new Float32Array(textureCoordData);
                indexData = new Uint16Array(indexData);
                var vertexPositionBuffer = gl.createBuffer();
                var vertexNormalBuffer = gl.createBuffer();
                var indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertexPositionData, gl.STATIC_DRAW);
                var VertexPosition = gl.getAttribLocation(program, "c");
                gl.vertexAttribPointer(VertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexPosition);
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
                var VertexNormal = gl.getAttribLocation(program, "d");
                gl.vertexAttribPointer(VertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexNormal);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
                return indexData.length;
              }(gl);
              gl.clearColor(0, 0, 0, 1);
              gl.enable(gl.DEPTH_TEST);
              var projection = mat4.create();
              mat4.perspective(projection, Math.PI / 6, 1, 0.1, 100);
              var modelView = mat4.create();
              mat4.lookAt(modelView, [0, 0, 10], [0, 0, 0], [0, 1, 0]);
              var mvpMatrix = mat4.create();
              mat4.multiply(mvpMatrix, projection, modelView);
              var ModelViewMatrix = gl.getUniformLocation(program, "h");
              gl.uniformMatrix4fv(ModelViewMatrix, false, modelView);
              var MVP = gl.getUniformLocation(program, "i");
              gl.uniformMatrix4fv(MVP, false, mvpMatrix);
              var LightPosition = gl.getUniformLocation(program, "e");
              gl.uniform4fv(LightPosition, [10, 10, 10, 1]);
              var Kd = gl.getUniformLocation(program, "f");
              gl.uniform3fv(Kd, [0.9, 0.5, 0.3]);
              var Ld = gl.getUniformLocation(program, "g");
              gl.uniform3fv(Ld, [1, 1, 1]);
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
              gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
              (function cleanup() {
                gl.useProgram(null);
                if (program) {
                  gl.deleteProgram(program);
                }
              })();
              return canvas.toDataURL();
            }
          }();
          if (imageData) {
            imageHash = fnvHash(imageData);
          }
        }
        return imageHash;
      }
      var benchmarkValues = null;
      function benchmarkcpu() {
        function workerState() {
          this.samples = [];
          this.active = 0;
        }
        function timerComplete(worker) {
          worker.terminate();
          finished(worker.state);
        }
        function workerComplete(source) {
          clearTimeout(source.currentTarget.timeout);
          var state = source.currentTarget.state;
          source.currentTarget.terminate();
          state.samples = state.samples.concat(source.data);
          finished(state);
        }
        function finished(state) {
          state.active--;
          if (state.active === 0) {
            benchmarkValues = state.samples;
            state.resolve(benchmarkValues);
          }
        }
        function workerFetchUrl(resolve, reject, url) {
          fetch(url, {
            mode: "same-origin"
          }).then(function (response) {
            if (response.ok) {
              (function workersStart(resolve, reject, url) {
                var workers = [];
                var state = new workerState();
                state.resolve = resolve;
                state.reject = reject;
                try {
                  for (var i = 0; i < 2; i++) {
                    var worker = new Worker(url);
                    worker.state = state;
                    worker.onmessage = workerComplete;
                    worker.onerror = function (error) {
                      reject(error);
                    };
                    workers.push(worker);
                  }
                  for (i = 0; i < workers.length; i++) {
                    state.active++;
                    workers[i].postMessage(80);
                    workers[i].timeout = setTimeout(timerComplete, 4000, workers[i]);
                  }
                } catch (ex) {
                  reject(new Error(ex));
                }
              })(resolve, reject, response.url);
            } else {
              var error = new Error("Url could not be reached");
              error.response = response;
              reject(error);
            }
          }).catch(function (error) {
            reject(error);
          });
        }
        return new Promise(function (resolve, reject) {
          if (benchmarkValues != null) {
            resolve(benchmarkValues);
          } else {
            setTimeout(function () {
              workerFetchUrl(resolve, reject, takUrl);
            }, 1000);
          }
        });
      }
      function benchmarkcpuavg(node) {
        return benchmarkcpu().then(function (values) {
          var average = 0;
          if (values.length > 0) {
            average = values.reduce(function (previous, current) {
              return current + previous;
            }) / values.length;
          }
          resolveNode(node, average, 0);
        }).catch(function (error) {
          complete(node.x);
        });
      }
      function benchmarkcpustd(node) {
        return benchmarkcpu().then(function (values) {
          var std = 0;
          if (values.length > 0) {
            var sum = values.reduce(function (previous, current) {
              return current + previous;
            });
            var average = values.length > 0 ? sum / values.length : 0;
            std = values.reduce(function (sq, n) {
              return sq + Math.pow(n - average, 2);
            }, 0) / (values.length - 1);
          }
          resolveNode(node, std, 0);
        }).catch(function (error) {
          complete(node.x);
        });
      }
      function fnvHash(str) {
        var h = 2166136261;
        for (var i = 0; i < str.length; ++i) {
          h ^= str.charCodeAt(i);
          h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
        }
        return h >>> 0;
      }
      function hash() {
        var imageHash = 0;
        var canvas = document.createElement("canvas");
        if (canvas != null) {
          var imageData = function drawImage(canvas) {
            canvas.width = 67;
            canvas.height = 67;
            var ctx = canvas.getContext("2d", {
              alpha: true
            });
            if (ctx != null) {
              ctx.imageSmoothingQuality = "low";
              ctx.imageSmoothingEnabled = true;
              ctx.globalCompositeOperation = "source-over";
              ctx.globalAlpha = 1;
              ctx.miterLimit = Infinity;
              ctx.filter = "none";
              ctx.lineCap = "butt";
              ctx.lineDashOffset = 0;
              ctx.lineJoin = "miter";
              ctx.font = "10pt Arial";
              ctx.lineWidth = 2;
              if (ctx.setLineDash !== undefined) {
                ctx.setLineDash([10, 20]);
              }
              ctx.shadowColor = "black";
              ctx.shadowOffsetX = -3;
              ctx.shadowOffsetY = -5;
              ctx.translate(canvas.width / 2, canvas.height / 2);
              ctx.rotate(0.8901179);
              ctx.fillStyle = "green";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("*51Degrees*", 0, 0);
              ctx.beginPath();
              ctx.shadowColor = "yellow";
              ctx.shadowBlur = 1;
              ctx.shadowOffsetX = 1;
              ctx.shadowOffsetY = 1;
              ctx.strokeStyle = "red";
              ctx.fillStyle = "rgba(0, 0, 255, 0.6)";
              if (ctx.ellipse === undefined) {
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
              } else {
                ctx.ellipse(0, 0, 25, 15, Math.PI / 4, 0, Math.PI * 2);
              }
              ctx.fill();
              ctx.stroke();
              return canvas.toDataURL();
            }
          }(canvas);
          if (imageData) {
            imageHash = fnvHash(imageData);
          }
        }
        return imageHash;
      }
      function height() {
        return window.screen.height * window.devicePixelRatio;
      }
      function mediacolorgamut() {
        return function getMediaSingleValue(name, possibleValues) {
          for (var i = 0; i < possibleValues.length; i++) {
            query = "(" + name + ": " + possibleValues[i] + ")";
            if (window.matchMedia(query).matches) {
              return possibleValues[i];
            }
          }
          var query;
          return "n/a";
        }("color-gamut", ["p3", "srgb"]);
      }
      function resolveNode(node, value, iterations) {
        for (var i = 0; i < node.n.length; i++) {
          var child = nodes[node.n[i]];
          if (child.r) {
            for (var c = 0; c < child.r.length; c++) {
              var range = child.r[c];
              if ((range.a === null || value >= range.a) && (range.b === null || value <= range.b)) {
                evaluateNode(child, 0);
                return;
              }
            }
          } else if (child.v && child.v.indexOf(value) != -1) {
            evaluateNode(child, 0);
            return;
          }
        }
        if (node.n.length > 0 && iterations < 10) {
          setTimeout(function () {
            evaluateNode(node, iterations + 1);
          }, 10);
        }
        complete(node.x);
      }
      function evaluateNode(node, iterations) {
        if (node.m) {
          var result = node.m(node);
          if (result || result === "") {
            if (!result.then) {
              resolveNode(node, result, iterations);
            }
          } else if (node.x) {
            complete(node.x);
          }
        } else {
          complete(node.x);
        }
      }
      evaluateNode(nodes[0], 0);
      complete("done");
    }
    function test() {
      let results = [];
      function getPrime() {
        return function largest_prime_factor(n) {
          return factors(n).filter(primep).pop();
        }(100000000000);
      }
      function factors(n) {
        var i;
        var out = [];
        var sqrt_n = Math.sqrt(n);
        for (i = 2; i <= sqrt_n; i++) {
          if (n % i == 0) {
            out.push(i);
          }
        }
        return out;
      }
      function primep(n) {
        return factors(n).length === 0;
      }
      for (let i = 0; i < 3; i++) {
        let time = performance.now();
        getPrime();
        results.push((performance.now() - time) * 10);
      }
      results.sort((a, b) => a - b);
      return results[0];
    }
    function fallbackTest() {
      let res = Math.min(screen.width, screen.height) + "x" + Math.max(screen.width, screen.height);
      let time = test();
      switch (res) {
        case "320x480":
          Device.graphics.webgl.gpu = "legacy";
          break;
        case "320x568":
          Device.graphics.webgl.gpu = time <= 400 ? "apple a8" : time <= 500 ? "apple a7" : "legacy";
          break;
        case "375x812":
        case "414x896":
          Device.graphics.webgl.gpu = time <= 150 ? "apple a13" : time <= 180 ? "apple a12" : "apple a11";
          break;
        case "414x736":
        case "375x667":
          Device.graphics.webgl.gpu = time <= 220 ? "apple a11" : time <= 250 ? "apple a10" : time <= 360 ? "apple a9" : time <= 400 ? "apple a8" : time <= 600 ? "apple a7" : "legacy";
          break;
        default:
        case "768x1024":
          Device.graphics.webgl.gpu = time <= 140 ? "apple a14" : time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : time <= 250 ? "apple a10" : time <= 360 ? "apple a9" : time <= 400 ? "apple a8" : time <= 600 ? "apple a7" : "legacy";
          break;
        case "834x1112":
          Device.graphics.webgl.gpu = time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : "apple a10";
          break;
        case "834x1194":
          if (time <= 140) {
            Device.graphics.webgl.gpu = "apple m1 gpu";
          } else if (time <= 160) {
            Device.graphics.webgl.gpu = "apple a13";
          } else if (time <= 180) {
            Device.graphics.webgl.gpu = "apple a12";
          }
          break;
        case "810x1080":
          if (time <= 160) {
            Device.graphics.webgl.gpu = "apple a13";
          } else if (time <= 220) {
            Device.graphics.webgl.gpu = "apple a11";
          } else if (time <= 250) {
            Device.graphics.webgl.gpu = "apple a10";
          }
          break;
        case "820x1180":
          Device.graphics.webgl.gpu = "apple a14";
          break;
        case "428x926":
        case "390x844":
          Device.graphics.webgl.gpu = "apple a15";
          break;
        case "1024x1366":
          Device.graphics.webgl.gpu = time <= 140 ? "apple m1 gpu" : time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : time <= 250 ? "apple a10" : "apple a9";
      }
    }
    this.exports = function () {
      let _value;
      let promise = Promise.create();
      getRenderer(value => {
        if (value == "done") {
          if (_value.includes("|")) {
            try {
              let split = _value.split("|");
              if (split.length == 1 && split[0].includes("Apple M")) {
                Device.graphics.webgl.gpu = "apple m1 gpu";
              } else {
                let output = split.filter(v => !v.includes("Apple M")).map(v => Number(v.replace("Apple", "").replace("X", "").replace("Z", "").split("A")[1].split(" ")[0]));
                output.sort((a, b) => a - b);
                if (output[output.length - 1] - output[0] > 2) {
                  fallbackTest();
                } else {
                  Device.graphics.webgl.gpu = split[0].toLowerCase();
                }
                if (Device.graphics.webgl.gpu == "apple a14 gpu") {
                  let res = Math.min(screen.width, screen.height) + "x" + Math.max(screen.width, screen.height);
                  if (res == "428x926" || res == "390x844") {
                    Device.graphics.webgl.gpu = "apple a15 gpu";
                  }
                }
              }
            } catch (e) {
              fallbackTest();
            }
          } else {
            Device.graphics.webgl.gpu = _value.toLowerCase();
          }
          promise.resolve();
        } else {
          _value = value;
        }
      });
      return promise;
    };
  });
  Module(function GPUBlacklist() {
    this.exports = {
      match: function () {
        return !Device.graphics.gpu || Device.graphics.gpu.detect(["radeon hd 6970m", "radeon hd 6770m", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 5750", "radeon hd 5670", "radeon hd 4850", "radeon hd 4870", "radeon hd 4670", "geforce 9400m", "geforce 320m", "geforce 330m", "geforce gt 130", "geforce gt 120", "geforce gtx 285", "geforce 8600", "geforce 9600m", "geforce 9400m", "geforce 8800 gs", "geforce 8800 gt", "quadro fx 5", "quadro fx 4", "radeon hd 2600", "radeon hd 2400", "radeon hd 2600", "mali-4", "mali-3", "mali-2", "swiftshader", "basic render driver", "generic renderer", "sgx543", "legacy", "sgx 543"]);
      }
    };
  });
  Class(function HierarchyAnimation(_data, createObjects, _isLayout) {
    Inherit(this, Object3D);
    const _this = this;
    var _objects;
    var _lastElapsed = -1;
    this.elapsed = 0;
    this.weight = 1;
    this.scale = 1;
    this.duration = 0;
    this.loop = false;
    const prevPos = new Vector3();
    const prevRot = new Quaternion();
    const prevScl = new Vector3();
    const nextPos = new Vector3();
    const nextRot = new Quaternion();
    const nextScl = new Vector3();
    const DEFAULT_QUAT = new Quaternion(0, 0, 0, 1);
    const DEFAULT_POS = new Vector3(0, 0, 0);
    const DEFAULT_SCALE = new Vector3(1, 1, 1);
    function loop() {
      _this.update();
    }
    (async function () {
      if (typeof createObjects != "function") {
        throw "HierarchyAnimation :: Second parameter requires callback function to create objects";
      }
      if (typeof _data == "string") {
        _data = await get(Assets.getPath(`assets/geometry/${_data}.json`));
      }
      _objects = await createObjects(_data.hierarchy);
      if (!Array.isArray(_objects)) {
        throw "HierarchyAnimation :: Object creation function requires an array to be returned";
      }
      (function nestObjects() {
        try {
          if (_data.hierarchy.length != _objects.length) {
            throw "HierarchyAnimation :: Number of objects in hierarchy does not match number of objects created.";
          }
          _data.hierarchy.forEach((d, i) => {
            if (d.parent > -1) {
              if (_data.hierarchy[Number(d.parent)].name != "null") {
                _objects[d.parent].add(_objects[i]);
              }
            } else if (d.name != "null") {
              _this.add(_objects[i]);
            }
          });
        } catch (e) {
          console.error("HierarchyAnimation :: Could not successfully nest objects -- check your names!");
          throw e;
        }
      })();
      _this.duration = _data.frames.length;
      _this.fps = _data.fps;
    })();
    this.update = function (totalWeight = 1, isSet) {
      if (!_objects) {
        return;
      }
      const weight = isSet ? 1 : _this.weight / totalWeight;
      const elapsed = Math.clamp(_this.elapsed, 0, 0.99) * _this.duration;
      if (Math.abs(elapsed - _lastElapsed) < 0.001) {
        return;
      }
      _lastElapsed = elapsed;
      const floorFrame = Math.floor(elapsed);
      const blend = elapsed - floorFrame;
      const prevKey = _data.frames[floorFrame];
      const nextKey = _data.frames[_this.loop ? (floorFrame + 1) % _this.duration : floorFrame + 1];
      if (prevKey && nextKey) {
        _objects.forEach((object, i) => {
          prevPos.fromArray(prevKey.position, i * 3).multiplyScalar(_this.scale);
          prevRot.fromArray(prevKey.quaternion, i * 4);
          prevScl.fromArray(prevKey.scale, i * 3);
          nextPos.fromArray(nextKey.position, i * 3).multiplyScalar(_this.scale);
          nextRot.fromArray(nextKey.quaternion, i * 4);
          nextScl.fromArray(nextKey.scale, i * 3);
          prevPos.lerp(nextPos, blend, false);
          prevRot.slerp(nextRot, blend, false);
          prevScl.lerp(nextScl, blend, false);
          if (_isLayout) {
            if (!prevPos.equals(DEFAULT_POS)) {
              object.position.lerp(prevPos, weight, false);
            }
            if (!prevRot.equals(DEFAULT_QUAT)) {
              object.quaternion.slerp(prevRot, weight, false);
            }
            if (!prevScl.equals(DEFAULT_SCALE)) {
              object.scale.lerp(prevScl, weight, false);
            }
          } else {
            object.position.lerp(prevPos, weight, false);
            object.quaternion.slerp(prevRot, weight, false);
            object.scale.lerp(prevScl, weight, false);
          }
        });
      }
    };
    this.start = function () {
      _this.startRender(loop);
    };
    this.stop = function () {
      _this.stopRender(loop);
    };
    this.ready = function () {
      return _this.wait(_this, "duration");
    };
    this.set("data", data => {
      _data = data;
      _this.duration = _data.frames.length;
      _this.fps = _data.fps;
      _this.elapsed = 0;
    });
  });
  Class(function HierarchyLayout(_data, createObjects) {
    Inherit(this, Component);
    const _this = this;
    var _animation;
    (async function () {
      _animation = new HierarchyAnimation(_data, createObjects, true);
      _this.group = _animation.group;
      _animation.loop = true;
      await _animation.ready();
      _animation.update();
    })();
    this.ready = function () {
      return _animation.ready();
    };
    this.set("scale", s => _animation.scale = s);
  });
  Class(function LayerAnimation(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _config;
    var _active;
    var _hierarchy;
    var _map = {};
    (async function () {
      _mesh.animation = _this;
      (function initConfig() {
        (_config = InputUIL.create(_input.prefix + "anim", _group)).setLabel("Animation Files");
        _config.add("path");
        _config.addTextarea("jsonFiles");
      })();
      await async function initFiles() {
        let path = `assets/geometry/${_config.get("path")}/`;
        let files = _config.get("jsonFiles").split("\n");
        let load = files.map(f => path + f + ".json").map(path => get(path));
        let data = await Promise.all(load);
        for (let i = 0; i < files.length; i++) {
          _map[files[i]] = data[i];
        }
        _active = files[0];
      }();
      (async function initHierarchy() {
        _hierarchy = _this.initClass(HierarchyAnimation, _map[_active], data => {
          let array = [];
          for (let i = 0; i < data.length; i++) {
            if (data[i].name == _input.get("name")) {
              array.push(_mesh);
            } else {
              array.push(new Group());
            }
          }
          return array;
        });
        await _hierarchy.ready();
        _hierarchy.update();
        _this.flag("initialized", true);
      })();
    })();
    this.play = async function (name, time, ease, delay) {
      await _this.wait("initialized");
      if (!_map[name]) {
        throw "No animation file found for " + name;
      }
      ease ||= "linear";
      time ||= _map[name].frames.length / _map[name].fps * 1000;
      _hierarchy.data = _map[name];
      _active = name;
      _hierarchy.start();
      await tween(_hierarchy, {
        elapsed: 1
      }, time, ease, delay).promise();
      _hierarchy.stop();
    };
  });
  Class(function Initializer3D() {
    Inherit(this, Component);
    const _this = this;
    let _loader;
    let _working;
    let _promises = [];
    let _queue = [];
    async function resolve() {
      await Promise.all(_promises);
      clearTimeout(_this.fire);
      _this.fire = _this.delayedCall(_ => {
        _this.events.fire(_this.READY);
        _this.resolved = true;
        Utils3D.onTextureCreated = null;
        if (_loader) {
          _loader.trigger(50);
        }
      }, 100);
    }
    async function workQueue() {
      clearTimeout(_this.warningTimer);
      _working = true;
      let promise = _queue.shift();
      if (!promise) {
        return _working = false;
      }
      promise.resolve(workQueue);
      if (Hydra.LOCAL) {
        _this.warningTimer = _this.delayedCall(_ => {
          console.warn("Long running queue has taken more than 5 seconds.");
        }, 5000);
      }
    }
    function incCompleted() {
      if (_loader) {
        _loader.trigger(1);
      }
    }
    this.READY = "initializer_ready";
    this.bundle = function () {
      return new function PromiseBundler() {
        const promises = [];
        const ready = Promise.create();
        let timer;
        function run() {
          clearTimeout(timer);
          timer = _this.delayedCall(_ => {
            Promise.all(promises).then(_ => ready.resolve());
          }, 100);
        }
        this.capture = function (promise) {
          promises.push(promise);
          run();
        };
        this.ready = function () {
          run();
          return ready;
        };
      }();
    };
    this.promise = this.capture = function (promise) {
      if (_loader) {
        _loader.add(1);
      }
      promise.then(incCompleted);
      _promises.push(promise);
      clearTimeout(_this.timer);
      _this.timer = _this.delayedCall(resolve, 100);
      return promise;
    };
    this.ready = this.loaded = function () {
      return _this.wait(_this, "resolved");
    };
    this.createWorld = async function () {
      await Promise.all([AssetLoader.waitForLib("zUtils3D"), Shaders.ready(), GPU.ready(), UILStorage.ready()]);
      World.instance();
    };
    this.linkSceneLayout = function (loader) {
      _this.captureTextures();
      SceneLayout.initializer = _this.capture;
      _loader = loader;
    };
    this.queue = function (immediate) {
      if (immediate) {
        return Promise.resolve(_ => {});
      }
      let promise = Promise.create();
      _queue.push(promise);
      if (!_working) {
        workQueue();
      }
      return promise;
    };
    this.captureTextures = function () {
      Utils3D.onTextureCreated = texture => {
        _this.promise(texture.promise);
      };
    };
    this.uploadAll = async function (group) {
      if (!group) {
        throw "Undefined passed to uploadAll";
      }
      let sceneLayout;
      if (group instanceof SceneLayout || window.StageLayout && group instanceof StageLayout) {
        sceneLayout = group;
        if (sceneLayout.uploaded) {
          return;
        }
        sceneLayout.uploaded = true;
        await sceneLayout.loadedAllLayers();
        group = group.group;
      }
      let promises = [];
      let layouts = [];
      let textures = [];
      if (sceneLayout) {
        sceneLayout.textures = textures;
        for (let key in sceneLayout.layers) {
          let layer = sceneLayout.layers[key];
          if (layer.uploadSync) {
            layer.uploadSync();
          }
        }
      }
      group.traverse(obj => {
        if (obj.sceneLayout && obj != group) {
          layouts.push(obj.sceneLayout);
        }
        if (obj.stageLayout && obj != group) {
          layouts.push(obj.stageLayout);
        }
        if (!obj.uploadIgnore && obj.visible != 0) {
          if (obj.shader) {
            for (let key in obj.shader.uniforms) {
              let uniform = obj.shader.uniforms[key];
              if (uniform && uniform.value && uniform.value.promise) {
                textures.push(uniform.value);
                promises.push(uniform.value.promise.then(uniform.value.upload.bind(uniform.value)).catch(e => {}));
              }
            }
          }
          if (obj.asyncPromise) {
            promises.push(obj.asyncPromise.then(obj.upload.bind(obj)));
          } else if (obj.upload) {
            obj.upload();
          }
        }
      });
      await Promise.catchAll(promises);
      textures.forEach(t => t.upload());
      for (let i = 0; i < layouts.length; i++) {
        await _this.uploadAll(layouts[i]);
      }
      if (sceneLayout && sceneLayout._completeInitialization) {
        sceneLayout._completeInitialization(true);
      }
      if (sceneLayout) {
        delete sceneLayout.textures;
      }
    };
    this.uploadAllDistributed = this.uploadAllAsync = async function (group, releaseQueue) {
      if (!group) {
        throw "Undefined passed to uploadAllDistributed";
      }
      let sceneLayout;
      if (!releaseQueue && typeof releaseQueue != "boolean") {
        releaseQueue = await _this.queue();
      }
      if (group instanceof SceneLayout || window.StageLayout && group instanceof StageLayout) {
        sceneLayout = group;
        if (sceneLayout.uploaded) {
          if (typeof releaseQueue == "function") {
            return releaseQueue();
          } else {
            return undefined;
          }
        }
        sceneLayout.uploaded = true;
        await sceneLayout.loadedAllLayers();
        group = group.group;
      }
      let uploads = [];
      let _async = [];
      let promises = [];
      let layouts = [];
      let textures = [];
      if (sceneLayout) {
        sceneLayout.textures = textures;
        for (let key in sceneLayout.layers) {
          let layer = sceneLayout.layers[key];
          if (layer.upload && !layer.uploadIgnore) {
            layer.upload();
          }
        }
      }
      group.traverse(obj => {
        if (obj.sceneLayout && obj != group) {
          layouts.push(obj.sceneLayout);
        }
        if (obj.stageLayout && obj != group) {
          layouts.push(obj.stageLayout);
        }
        if (!obj.uploadIgnore && obj.visible != 0) {
          if (obj.shader) {
            for (let key in obj.shader.uniforms) {
              let uniform = obj.shader.uniforms[key];
              if (uniform && uniform.value && uniform.value.promise) {
                textures.push(uniform.value);
                promises.push(uniform.value.promise.then(_ => uploads.push(uniform.value.upload.bind(uniform.value))).catch(e => {}));
              }
            }
          }
          if (obj.asyncPromise) {
            promises.push(obj.asyncPromise.then(_ => {
              if (obj.geometry) {
                obj.geometry.distributeBufferData = true;
              }
              uploads.push(obj.upload.bind(obj));
              if (obj.geometry) {
                _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
              }
            }));
          } else if (obj.upload) {
            if (obj.geometry) {
              if (obj.geometry.uploaded) {
                return;
              }
              obj.geometry.distributeBufferData = true;
            }
            uploads.push(obj.upload.bind(obj));
            if (obj.geometry) {
              _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
            }
          }
        }
      });
      let canFinish = false;
      let promise = Promise.create();
      let worker = new Render.Worker(_ => {
        let upload = uploads.shift();
        if (upload) {
          upload();
        } else if (canFinish) {
          (async _ => {
            for (let i = 0; i < _async.length; i++) {
              await _async[i]();
            }
            for (let i = 0; i < layouts.length; i++) {
              await _this.uploadAllAsync(layouts[i], !!releaseQueue);
            }
            if (typeof releaseQueue == "function") {
              releaseQueue();
            }
            promise.resolve();
          })();
          worker.stop();
        } else {
          worker.pause();
        }
      }, 1);
      Promise.catchAll(promises).then(_ => {
        worker.resume();
        canFinish = true;
      });
      if (sceneLayout && sceneLayout._completeInitialization) {
        sceneLayout._completeInitialization(false);
      }
      if (sceneLayout) {
        promise.then(_ => {
          delete sceneLayout.textures;
        });
      }
      return promise;
    };
    this.detectUploadAll = function (group, sync, releaseQueue) {
      if (sync) {
        return _this.uploadAll(group);
      } else {
        return _this.uploadAllDistributed(group, releaseQueue);
      }
    };
    this.detectUploadNuke = function (nuke, sync) {
      if (sync) {
        return _this.uploadNukeAsync(nuke);
      } else {
        return _this.uploadNuke(nuke);
      }
    };
    this.uploadNuke = async function (nuke) {
      for (let i = 0; i < nuke.passes.length; i++) {
        let pass = nuke.passes[i];
        let uniforms = pass.uniforms;
        for (let key in uniforms) {
          if (uniforms[key].value && uniforms[key].value.promise) {
            await uniforms[key].value.promise;
          }
          if (uniforms[key].value && uniforms[key].value.upload) {
            uniforms[key].value.upload();
          }
        }
        pass.upload();
      }
      if (!Nuke.defaultPass.uploaded) {
        Nuke.defaultPass.upload();
      }
    };
    this.uploadNukeAsync = function (nuke) {
      return this.uploadNuke(nuke);
    };
    this.destroyAll = function (scene) {
      scene.traverse(obj => {
        if (obj.geometry && obj.shader) {
          for (let key in obj.shader.uniforms) {
            let uniform = obj.shader.uniforms[key];
            if (uniform && uniform.value instanceof Texture) {
              uniform.value.destroy();
            }
          }
          obj.destroy();
        }
      });
    };
    this.set("loader", loader => {
      _loader = loader;
    });
  }, "static");
  Class(function Webcam(_width, _height, _audio) {
    Inherit(this, Component);
    var _this = this;
    let _stream;
    let _cameras = {};
    let _config = {};
    let _back = false;
    let _attempts = 0;
    function establishWebcam() {
      if (_attempts >= 2 || !navigator.mediaDevices) {
        return error();
      }
      (function lookupDevices() {
        let promise = Promise.create();
        if (Device.mobile) {
          navigator.mediaDevices.enumerateDevices().then(devices => {
            devices.forEach(device => {
              if (device.label.includes("front")) {
                _cameras.front = {
                  deviceId: {
                    exact: device.deviceId
                  }
                };
              }
              if (device.label.includes("back")) {
                _cameras.back = {
                  deviceId: {
                    exact: device.deviceId
                  }
                };
                _back = true;
              }
            });
            _cameras.front ||= {
              facingMode: "user"
            };
            if (!_cameras.back) {
              _cameras.back = {
                facingMode: "environment"
              };
              _back = false;
            }
            promise.resolve();
          });
          return promise;
        } else {
          return Promise.resolve();
        }
      })().then(() => {
        if (_stream && _config.back) {
          _stream.getTracks()[0].stop();
        }
        if (Device.mobile.phone) {
          if (_cameras && _cameras.back) {
            _cameras.back.frameRate = {
              ideal: 60
            };
          }
          if (_cameras && _cameras.front) {
            _cameras.front.frameRate = {
              ideal: 60
            };
          }
        }
        navigator.mediaDevices.getUserMedia({
          video: _config.back ? _cameras.back : _cameras.front || true,
          audio: _audio
        }).then(success).catch(error);
      });
      _attempts += 1;
    }
    function success(stream) {
      _this.denied = false;
      _stream = stream;
      if (_config.back && !_back) {
        establishWebcam();
      } else {
        _this.div.srcObject = stream;
        _this.events.fire(Events.READY, null, true);
      }
    }
    function error() {
      _this.denied = true;
      _this.events.fire(Events.ERROR, null, true);
    }
    _this.facing = "back";
    (function createVideo() {
      _this.div = window.AURA ? document.createElement() : document.createElement("video");
      _this.div.width = _width;
      _this.div.height = _height;
      _this.div.autoplay = true;
      _this.div.controls = true;
      _this.div.playsinline = true;
      _this.div.setAttribute("playsinline", true);
      _this.div.setAttribute("controls", true);
      Stage.add(_this.div);
      _this.element = $(_this.div);
      _this.element.transformPoint(0, 0).transform({
        scaleX: Device.mobile ? 1 : -1,
        scale: 0.25
      }).setZ(-1);
    })();
    (function initNavigator() {
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    })();
    this.createStream = function (config = {}) {
      _attempts = 0;
      _config = config;
      establishWebcam();
    };
    this.flip = function () {
      if (!_back) {
        return;
      }
      let direction;
      if (_this.facing === "front") {
        _this.facing = "back";
        direction = _cameras.back;
      } else {
        _this.facing = "front";
        direction = _cameras.front;
      }
      _stream.getTracks()[0].stop();
      navigator.getUserMedia({
        video: direction || true,
        audio: _audio
      }, success, error);
    };
    this.get("width", function () {
      return _width;
    });
    this.get("height", function () {
      return _height;
    });
    this.size = function (w, h) {
      _this.div.width = _width = w;
      _this.div.height = _height = h;
      _this.element.size(w, h);
    };
    this.getPixels = function (width = _width, height = _height) {
      if (!_this.canvas) {
        _this.canvas = document.createElement("canvas");
        _this.canvas.width = width;
        _this.canvas.height = height;
        _this.canvas.context = _this.canvas.getContext("2d");
      }
      _this.canvas.context.drawImage(_this.div, 0, 0, width, height);
      return _this.canvas.context.getImageData(0, 0, width, height);
    };
    this.getCanvas = function () {
      if (!_this.canvas) {
        _this.canvas = document.createElement("canvas");
        _this.canvas.width = _width;
        _this.canvas.height = _height;
        _this.canvas.context = _this.canvas.getContext("2d");
      }
      _this.canvas.context.drawImage(_this.div, 0, 0, _width, _height);
      return _this.canvas;
    };
    this.ready = function () {
      return _this.div.readyState > 0;
    };
    this.end = function () {
      _this.active = false;
      _this.div.pause();
      if (_stream) {
        _stream.getTracks()[0].enabled = false;
      }
    };
    this.restart = function () {
      _this.div.play();
      if (_stream) {
        _stream.getTracks()[0].enabled = true;
      }
      _this.active = true;
    };
    this.deviceCount = async function (kind) {
      if (!navigator.mediaDevices) {
        return 0;
      }
      let devices = await navigator.mediaDevices.enumerateDevices();
      let count = 0;
      devices.forEach(d => {
        if (d.kind.includes(kind)) {
          count++;
        }
      });
      return count;
    };
  });
  Namespace("FX");
  FX.Class(function Mirror(_mesh, _params = {}) {
    Inherit(this, FXScene);
    const _this = this;
    var _renderer;
    var _frustum = new Frustum();
    function loop({
      stage: stage,
      camera: camera,
      view: view
    }) {
      if (!_this.visible || !_this.enabled || !_mesh) {
        return;
      }
      if (stage) {
        if (view > 0) {
          return;
        }
        _renderer.camera = camera;
        _this.nuke.camera = camera;
        _this.nuke.stage = stage;
      } else {
        if (_params.nuke && _params.nuke.camera != _this.nuke.camera) {
          _this.nuke.camera = _params.nuke.camera;
        }
        if (_this.nuke.camera != _renderer.camera) {
          _renderer.camera = _this.nuke.camera;
        }
      }
      if (_this.frustumCulled && (_frustum.setFromCamera(_this.nuke.camera), !_frustum.intersectsObject(_mesh))) {
        return;
      }
      _this.draw();
      _mesh.matrixWorld.decompose(_renderer.position, _renderer.quaternion, _renderer.scale);
      let clearColor = null;
      if (_this.clearColor) {
        clearColor = World.RENDERER.getClearColor().getHex();
        World.RENDERER.setClearColor(_this.clearColor);
      }
      World.RENDERER.overridePreventShadows = true;
      _renderer.render(_this.scene);
      World.RENDERER.overridePreventShadows = false;
      if (_this.clearColor) {
        World.RENDERER.setClearColor(clearColor);
      }
      if (_this.postRender) {
        _this.postRender();
      }
    }
    function decorateShader() {
      if (_mesh) {
        _params.shader.uniforms.tMirrorReflection = {
          value: _renderer.renderTarget.texture,
          ignoreUIL: true
        };
        _params.shader.uniforms.uMirrorMatrix = {
          value: _renderer.textureMatrix,
          ignoreUIL: true
        };
        _params.shader.uniforms.uIsMirror = FX.Mirror.isMirrorUniform;
      }
    }
    this.visible = true;
    this.enabled = typeof _params.enabled != "boolean" || _params.enabled;
    this.frustumCulled = true;
    this.manualRender = true;
    if (_mesh && _mesh.isGroup) {
      _mesh.traverse(obj => {
        if (obj.shader && obj.shader.fsName !== "TestMaterial") {
          _mesh = obj;
        }
      });
    }
    if (_mesh && !_params.shader) {
      _params.shader = _mesh.shader;
    }
    _params.nuke = _params.nuke || World.NUKE;
    _this.create(_params.nuke);
    _this.preventRTDraw = true;
    (function initMirror() {
      let width = _params.width || 512;
      let height = _params.height || 512;
      if (_params.size) {
        width = height = _params.size;
      }
      _renderer = new MirrorRenderer(_params.nuke.camera, {
        width: width,
        height: height,
        clipBias: _params.clipBias || 0.01,
        format: _params.format,
        mipmaps: _params.mipmaps
      });
      if (_params.normal) {
        _renderer.normalDir = _params.normal;
      }
    })();
    decorateShader();
    this.onDestroy = function () {
      _renderer.destroy();
    };
    this.start = function (nuke = _params.nuke) {
      _this.startRender(loop, RenderManager.type != RenderManager.VR ? nuke : RenderManager.EYE_RENDER);
    };
    this.stop = function () {
      _this.stopRender(loop, RenderManager.type != RenderManager.VR ? nuke : RenderManager.EYE_RENDER);
    };
    this.decorate = function (shader) {
      shader.uniforms.tMirrorReflection = {
        value: _renderer.renderTarget.texture,
        ignoreUIL: true
      };
      shader.uniforms.uMirrorMatrix = {
        value: _renderer.textureMatrix,
        ignoreUIL: true
      };
      shader.uniforms.uIsMirror = FX.Mirror.isMirrorUniform;
    };
    this.useMesh = function (mesh) {
      _mesh = mesh;
      _params.shader ||= _mesh.shader;
      decorateShader();
    };
    this.useCamera = function (camera) {
      camera = camera.camera || camera;
      _renderer.camera = camera;
      _this.nuke.camera = camera;
    };
    this.add = async function (obj) {
      if (_params.nuke.attachments > 1) {
        await obj.shader.onBeforePrecompilePromise;
        _this.addObject(obj);
      } else {
        _this.addObject(obj);
      }
    };
    this.render = loop;
    this.set("clipBias", v => _renderer.clipBias = v);
  }, () => {
    FX.Mirror.isMirrorUniform = {
      value: 1,
      type: "f",
      ignoreUIL: true
    };
  });
  class MirrorRenderer extends Base3D {
    constructor(camera, options = {}) {
      super();
      this._camera = camera;
      this.width = options.width || 512;
      this.height = options.height || 512;
      this.clipBias = options.clipBias || 0;
      this.renderer = World.RENDERER;
      this.mirrorPlane = new Plane();
      this.normalDir = new Vector3(0, 0, 1);
      this.normal = new Vector3(0, 0, 1);
      this.mirrorWorldPosition = new Vector3();
      this.cameraWorldPosition = new Vector3();
      this.rotationMatrix = new Matrix4();
      this.lookAtPosition = new Vector3(0, 0, -1);
      this.clipPlane = new Vector4();
      this.textureMatrix = new Matrix4();
      this.mirrorCamera = this._camera.clone();
      let filter = options.mipmaps ? Texture.LINEAR_MIPMAP : Texture.LINEAR;
      this.renderTarget = new RenderTarget(this.width, this.height, {
        minFilter: filter,
        magFilter: filter,
        format: options.format || Texture.RGBFormat,
        generateMipmaps: options.mipmaps || false
      });
      this.viewVec = new Vector3();
      this.targetVec = new Vector3();
      this.q = new Quaternion();
      this.updateTextureMatrix();
    }
    updateTextureMatrix() {
      this.updateMatrixWorld();
      this._camera.updateMatrixWorld();
      this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld);
      this.cameraWorldPosition.setFromMatrixPosition(this._camera.matrixWorld);
      this.rotationMatrix.extractRotation(this.matrixWorld);
      this.normal.copy(this.normalDir);
      this.normal.applyMatrix4(this.rotationMatrix);
      this.viewVec.copy(this.mirrorWorldPosition).sub(this.cameraWorldPosition);
      this.viewVec.reflect(this.normal).negate();
      this.viewVec.add(this.mirrorWorldPosition);
      this.rotationMatrix.extractRotation(this._camera.matrixWorld);
      this.lookAtPosition.set(0, 0, -1);
      this.lookAtPosition.applyMatrix4(this.rotationMatrix);
      this.lookAtPosition.add(this.cameraWorldPosition);
      this.targetVec.copy(this.mirrorWorldPosition).sub(this.lookAtPosition);
      this.targetVec.reflect(this.normal).negate();
      this.targetVec.add(this.mirrorWorldPosition);
      this.up.set(0, -1, 0);
      this.up.applyMatrix4(this.rotationMatrix);
      this.up.reflect(this.normal).negate();
      this.mirrorCamera.position.copy(this.viewVec);
      this.mirrorCamera.up = this.up;
      this.mirrorCamera.lookAt(this.targetVec);
      this.mirrorCamera.updateMatrixWorld();
      this.mirrorCamera.projectionMatrix.copy(this._camera.projectionMatrix);
      this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);
      this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);
      this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mirrorWorldPosition);
      this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);
      this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
      let projectionMatrix = this.mirrorCamera.projectionMatrix;
      let q = this.q;
      q.x = (Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      let c = this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(q));
      projectionMatrix.elements[2] = c.x;
      projectionMatrix.elements[6] = c.y;
      projectionMatrix.elements[10] = c.z + 1 - this.clipBias;
      projectionMatrix.elements[14] = c.w;
    }
    render(scene) {
      this.updateTextureMatrix();
      FX.Mirror.isMirrorUniform.value = 1;
      let autoClear = this.renderer.autoClear;
      this.renderer.autoClear = true;
      this.renderer.render(scene, this.mirrorCamera, this.renderTarget);
      this.renderer.autoClear = autoClear;
      FX.Mirror.isMirrorUniform.value = 1;
    }
    destroy() {
      this.renderTarget.destroy();
    }
    set camera(c) {
      this._camera = c;
      this.mirrorCamera = c.clone();
    }
    get camera() {
      return this._camera;
    }
  }
  Class(function MouseFluid(_params = {
    active: true
  }) {
    Inherit(this, Object3D);
    const _this = this;
    var _fluid;
    var _custom;
    this.scale = 1;
    var _scale = 1;
    var _last = new Vector2();
    var _mouse = new Vector2();
    var _white = new Color("#ffffff");
    function loop() {
      _scale += (_this.scale - _scale) * 0.05;
      if (!_custom) {
        _mouse.copy(Mouse);
      }
      let len = _mouse.distanceTo(_last);
      let size = _this.scaleBasedOnVelocity ? Math.range(len, 0, 5, 0, 60, true) : 25;
      size *= 0.8;
      let delta = Math.range(len, 0, 15, 0, 10, true);
      if (len > 0.01) {
        _fluid.drawInput(_mouse.x, _mouse.y, (_mouse.x - _last.x) * delta, (_mouse.y - _last.y) * delta, _white, size * _scale);
      }
      _last.copy(_mouse);
    }
    this.scaleBasedOnVelocity = true;
    (async function () {
      let layout = _this.initClass(SceneLayout, "mousefluid");
      _fluid = await layout.getLayer("fluid");
      if (_this.isPlayground()) {
        _fluid.initMesh();
      }
      _this.fluid = _fluid;
      if (_params.active) {
        _this.startRender(loop, RenderManager.AFTER_LOOPS);
      } else {
        _fluid.visible = false;
      }
    })();
    this.applyTo = async function (shader) {
      await _this.wait("fluid");
      shader.uniforms.tFluid = _fluid.fbos.velocity.uniform;
      shader.uniforms.tFluidMask = {
        value: _fluid
      };
    };
    this.useCustomMouse = function () {
      _custom = true;
    };
    this.getFluid = async function () {
      await _this.wait("fluid");
      return _this.fluid;
    };
    this.get("mouse", _ => _mouse);
  }, "singleton");
  Class(function ParticleDistributor() {
    Inherit(this, Component);
    const _this = this;
    function init() {
      if (!_this.flag("initGenerate")) {
        _this.flag("initGenerate", true);
        Thread.upload(distributeParticles);
        Thread.upload(generatePointCloud);
        Thread.upload(generatePointGrid);
      }
    }
    function distributeParticles(e, id) {
      let {
        position: position,
        count: count,
        normal: normal,
        uv: uv,
        skinIndex: skinIndex,
        skinWeight: skinWeight,
        offset: offset,
        scale: scale,
        orientation: orientation
      } = e;
      let vertices = position.length / 3;
      let v3 = new Vector3();
      let v32 = new Vector3();
      let v33 = new Vector3();
      let q = new Quaternion();
      let outputPosition = new Float32Array(count * 3);
      let outputNormal = normal ? new Float32Array(count * 3) : null;
      let outputUV = uv ? new Float32Array(count * 3) : null;
      let outputSkinIndex = skinIndex ? new Float32Array(count * 4) : null;
      let outputSkinWeight = skinWeight ? new Float32Array(count * 4) : null;
      for (let i = 0; i < count; i++) {
        let j = Math.random(0, vertices / 3) * 3;
        v3.set(Math.random(0, 100), Math.random(0, 100), Math.random(0, 100));
        let m = 1 / (v3.x + v3.y + v3.z);
        v3.set(v3.x * m, v3.y * m, v3.z * m);
        outputPosition[i * 3 + 0] = position[j * 3 + 0] * v3.x + position[j * 3 + 3] * v3.y + position[j * 3 + 6] * v3.z;
        outputPosition[i * 3 + 1] = position[j * 3 + 1] * v3.x + position[j * 3 + 4] * v3.y + position[j * 3 + 7] * v3.z;
        outputPosition[i * 3 + 2] = position[j * 3 + 2] * v3.x + position[j * 3 + 5] * v3.y + position[j * 3 + 8] * v3.z;
        if (offset) {
          let randomInstance = Math.random(0, offset.length / 3 - 1);
          v32.fromArray(outputPosition, i * 3);
          v33.fromArray(scale, randomInstance * 3);
          v32.multiplyScalar(v33);
          q.fromArray(orientation, randomInstance * 4);
          v32.applyQuaternion(q);
          v33.fromArray(offset, randomInstance * 3);
          v32.add(v33);
          v32.toArray(outputPosition, i * 3);
        }
        if (outputNormal) {
          outputNormal[i * 3 + 0] = normal[j * 3 + 0] * v3.x + normal[j * 3 + 3] * v3.y + normal[j * 3 + 6] * v3.z;
          outputNormal[i * 3 + 1] = normal[j * 3 + 1] * v3.x + normal[j * 3 + 4] * v3.y + normal[j * 3 + 7] * v3.z;
          outputNormal[i * 3 + 2] = normal[j * 3 + 2] * v3.x + normal[j * 3 + 5] * v3.y + normal[j * 3 + 8] * v3.z;
        }
        if (outputUV) {
          outputUV[i * 3 + 0] = uv[j * 2 + 0] * v3.x + uv[j * 2 + 2] * v3.y + uv[j * 2 + 4] * v3.z;
          outputUV[i * 3 + 1] = uv[j * 2 + 1] * v3.x + uv[j * 2 + 3] * v3.y + uv[j * 2 + 5] * v3.z;
        }
        if (outputSkinIndex) {
          let skinCluster1 = {
            [skinIndex[j * 4 + 0]]: skinWeight[j * 4 + 0],
            [skinIndex[j * 4 + 1]]: skinWeight[j * 4 + 1],
            [skinIndex[j * 4 + 2]]: skinWeight[j * 4 + 2],
            [skinIndex[j * 4 + 3]]: skinWeight[j * 4 + 3]
          };
          let skinCluster2 = {
            [skinIndex[j * 4 + 4]]: skinWeight[j * 4 + 4],
            [skinIndex[j * 4 + 5]]: skinWeight[j * 4 + 5],
            [skinIndex[j * 4 + 6]]: skinWeight[j * 4 + 6],
            [skinIndex[j * 4 + 7]]: skinWeight[j * 4 + 7]
          };
          let skinCluster3 = {
            [skinIndex[j * 4 + 8]]: skinWeight[j * 4 + 8],
            [skinIndex[j * 4 + 9]]: skinWeight[j * 4 + 9],
            [skinIndex[j * 4 + 10]]: skinWeight[j * 4 + 10],
            [skinIndex[j * 4 + 11]]: skinWeight[j * 4 + 11]
          };
          let indices = [];
          for (let k = 0; k < 12; k++) {
            let index = skinIndex[j * 4 + k];
            if (indices.indexOf(index) === -1) {
              indices.push(index);
            }
          }
          let clusters = [];
          for (let k = 0; k < indices.length; k++) {
            let index = indices[k];
            clusters.push([index, (skinCluster1[index] || 0) * v3.x + (skinCluster2[index] || 0) * v3.y + (skinCluster3[index] || 0) * v3.z]);
          }
          clusters.sort(function (a, b) {
            return b[1] - a[1];
          });
          for (let l = clusters.length - 1; l < 4; l++) {
            clusters.push([0, 0]);
          }
          let sum = clusters[0][1] + clusters[1][1] + clusters[2][1] + clusters[3][1];
          outputSkinIndex[i * 4 + 0] = clusters[0][0];
          outputSkinIndex[i * 4 + 1] = clusters[1][0];
          outputSkinIndex[i * 4 + 2] = clusters[2][0];
          outputSkinIndex[i * 4 + 3] = clusters[3][0];
          outputSkinWeight[i * 4 + 0] = clusters[0][1] * (1 / sum);
          outputSkinWeight[i * 4 + 1] = clusters[1][1] * (1 / sum);
          outputSkinWeight[i * 4 + 2] = clusters[2][1] * (1 / sum);
          outputSkinWeight[i * 4 + 3] = clusters[3][1] * (1 / sum);
        }
      }
      let output = {};
      let buffer = [];
      output.position = outputPosition;
      buffer.push(outputPosition.buffer);
      if (outputNormal) {
        output.normal = outputNormal;
        buffer.push(outputNormal.buffer);
      }
      if (outputUV) {
        output.uv = outputUV;
        buffer.push(outputUV.buffer);
      }
      if (outputSkinIndex) {
        output.skinIndex = outputSkinIndex;
        output.skinWeight = outputSkinWeight;
        buffer.push(outputSkinIndex.buffer);
        buffer.push(outputSkinWeight.buffer);
      }
      resolve(output, id, buffer);
    }
    function generatePointCloud({
      path: path,
      textureSize: textureSize
    }, id) {
      (async function () {
        try {
          let data = await get(path);
          let totalParticles = textureSize * textureSize;
          let positions = new Float32Array(totalParticles * 3);
          let colors = new Float32Array(totalParticles * 3);
          for (let i = 0; i < totalParticles; i++) {
            positions[i * 3 + 0] = data.positions[i * 3 + 0];
            positions[i * 3 + 1] = data.positions[i * 3 + 1];
            positions[i * 3 + 2] = data.positions[i * 3 + 2];
            let hex = Math.floor(Number("0x" + data.colors[i]));
            let r = (hex >> 16 & 255) / 255;
            let g = (hex >> 8 & 255) / 255;
            let b = (hex & 255) / 255;
            colors[i * 3 + 0] = r;
            colors[i * 3 + 1] = g;
            colors[i * 3 + 2] = b;
          }
          data.positions = positions;
          data.colors = colors;
          resolve(data, id, [data.positions.buffer, data.colors.buffer]);
        } catch (e) {
          console.log(e);
          throw `Could not load Point Cloud for ${path}`;
        }
      })();
    }
    function generatePointGrid({
      path: path,
      particleCount: particleCount
    }, id) {
      let split = path.split("generateGrid-")[1].split("-");
      let dir = split[0];
      let scale = Number(split[1]);
      Number(split[2]);
      let textureSize = Number(split[split.length - 1].split(".")[0]);
      let totalParticles = particleCount;
      let positions = new Float32Array(totalParticles * 3);
      let colors = new Float32Array(totalParticles * 3);
      for (let i = 0; i < totalParticles; i++) {
        let p0 = i / textureSize;
        let y = Math.floor(p0);
        let x = p0 - y;
        y /= textureSize;
        x = Math.range(x, 0, 1, -scale / 2, scale / 2);
        y = Math.range(y, 0, 1, -scale / 2, scale / 2);
        if (dir == "xz") {
          positions[i * 3 + 0] = x;
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = y;
        } else {
          positions[i * 3 + 0] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = 0;
        }
        colors[i * 3 + 0] = 1;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;
      }
      resolve({
        colors: colors,
        positions: positions
      }, id, [colors.buffer, positions.buffer]);
    }
    this.generate = async function (geom, count) {
      init();
      let position = new Float32Array(geom.attributes.position.array);
      return (await Thread.shared().distributeParticles({
        position: position,
        count: count
      }, [position.buffer])).position;
    };
    this.generateInstanced = async function (geom, count) {
      init();
      let position = new Float32Array(geom.attributes.position.array);
      let offset = new Float32Array(geom.attributes.offset.array);
      let scale = new Float32Array(geom.attributes.scale.array);
      let orientation = new Float32Array(geom.attributes.orientation.array);
      return (await Thread.shared().distributeParticles({
        position: position,
        offset: offset,
        scale: scale,
        orientation: orientation,
        count: count
      }, [position.buffer, offset.buffer, scale.buffer, orientation.buffer])).position;
    };
    this.generateAll = async function (geom, count) {
      init();
      let position = new Float32Array(geom.attributes.position.array);
      let normal = new Float32Array(geom.attributes.normal.array);
      let uv = new Float32Array(geom.attributes.uv.array);
      return await Thread.shared().distributeParticles({
        position: position,
        normal: normal,
        uv: uv,
        count: count
      }, [position.buffer, normal.buffer, uv.buffer]);
    };
    this.generateSkinned = async function (geom, count) {
      init();
      let position = new Float32Array(geom.attributes.position.array);
      let normal = new Float32Array(geom.attributes.normal.array);
      let uv = new Float32Array(geom.attributes.uv.array);
      let skinIndex = new Float32Array(geom.attributes.skinIndex.array);
      let skinWeight = new Float32Array(geom.attributes.skinWeight.array);
      return await Thread.shared().distributeParticles({
        position: position,
        normal: normal,
        uv: uv,
        skinIndex: skinIndex,
        skinWeight: skinWeight,
        count: count
      }, [position.buffer, normal.buffer, uv.buffer, skinIndex.buffer, skinWeight.buffer]);
    };
    this.generatePointCloud = async function (path, textureSize) {
      if (!path.includes("assets/geometry")) {
        path = "assets/geometry/" + path;
      }
      if (!path.includes(".json")) {
        path += ".json";
      }
      init();
      let fn = path.includes("generateGrid") ? Thread.shared().generatePointGrid : Thread.shared().generatePointCloud;
      let data = await fn({
        path: Thread.absolutePath(path),
        textureSize: textureSize
      });
      return {
        positions: new AntimatterAttribute(data.positions, 3),
        colors: new AntimatterAttribute(data.colors, 3)
      };
    };
  }, "static");
  Class(function PBRShader(_vertexShader, _fragmentShader, _params) {
    const _this = this;
    function defineSetter(prop) {
      Object.defineProperty(_this, prop, {
        set: function (v) {
          _this.shader[prop] = v;
        },
        get: function () {
          return _this.shader[prop];
        }
      });
    }
    if (typeof _vertexShader == "object") {
      _params = _vertexShader;
      _vertexShader = _fragmentShader = "PBR";
    }
    if (typeof _fragmentShader == "object") {
      _params = _fragmentShader;
      _fragmentShader = _vertexShader;
    }
    _vertexShader ||= _fragmentShader = "PBR";
    (function initShader() {
      let lookup = Utils3D.getLookupTexture("assets/images/pbr/lut.png");
      lookup.forcePersist = true;
      _this.shader = new Shader(_vertexShader, _fragmentShader, Utils.mergeObject(_params || {}, {
        tBaseColor: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tMRO: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tNormal: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tEnvDiffuse: {
          value: null,
          premultiplyAlpha: false
        },
        tEnvSpecular: {
          value: null,
          premultiplyAlpha: false
        },
        tLightmap: {
          value: null,
          premultiplyAlpha: false
        },
        tLUT: {
          value: lookup,
          ignoreUIL: true
        },
        uTint: {
          value: new Color("#FFFFFF")
        },
        uTiling: {
          value: new Vector2(1, 1)
        },
        uOffset: {
          value: new Vector2(0, 0)
        },
        uMRON: {
          value: new Vector4(1, 1, 1, 1)
        },
        uEnv: {
          value: new Vector2(1, 0)
        },
        uUseLightmap: {
          value: 0
        },
        uHDR: {
          value: 0,
          ignoreUIL: true
        },
        uUseTonemapping: {
          value: 1,
          ignoreUIL: true
        },
        uUseLinearOutput: {
          value: 0
        },
        receiveLight: true
      }));
      _this.shader.parent = _this;
      _this.lights = _this.shader.lights;
      _this.uniforms = _this.shader.uniforms;
      ["side", "blending", "polygonOffset", "polygonOffsetFactor", "polygonOffsetUnits", "receiveShadow", "vertexShader", "fragmentShader", "depthTest", "depthWrite", "wireframe", "transparent", "visible", "persists", "material", "customShadowShader"].forEach(defineSetter);
    })();
  }, _ => {
    const prototype = PBRShader.prototype;
    PBRShader.webgl1 = function () {
      return World.RENDERER.type == Renderer.WEBGL1;
    };
    prototype.set = function (key, value) {
      if (value !== undefined) {
        this.shader.uniforms[key].value = value;
      }
      return this.shader.uniforms[key].value;
    };
    prototype.get = function (key) {
      return this.shader.uniforms[key].value;
    };
    prototype.tween = function (key, value, time, ease, delay, callback, update) {
      return tween(this.shader.uniforms[key], {
        value: value
      }, time, ease, delay, callback, update);
    };
    prototype.setPBR = prototype.setOverride = function (key, value, ref = this) {
      if (ref.parent instanceof PBRShader) {
        ref = ref.parent;
      }
      ref.set(key, value);
      switch (key) {
        case "tEnvDiffuse":
        case "tEnvSpecular":
        case "tLUT":
          value.generateMipmaps = false;
          value.minFilter = Texture.LINEAR;
      }
      let src = value.src;
      if (src && src.toLowerCase().includes("rgbm")) {
        ref.shader.set("uHDR", 1);
        ref.shader.set("uEnv", new Vector2(1, 0));
      }
    };
    prototype.destroy = function () {
      this.shader.destroy();
    };
    prototype.copyUniformsTo = function (shader, linked) {
      for (let key in this.uniforms) {
        shader.uniforms[key] = linked ? this.uniforms[key] : {
          type: this.uniforms[key].type,
          value: this.uniforms[key].value
        };
      }
    };
    prototype.addUniforms = function (uniforms) {
      if (uniforms.UILPrefix) {
        this.UILPrefix = uniforms.UILPrefix;
        delete uniforms.UILPrefix;
      }
      for (let key in uniforms) {
        this.uniforms[key] = uniforms[key];
      }
    };
  });
  Class(function Performance() {
    Inherit(this, Component);
    var _overrides = Storage.get("performance_override") || {};
    function save(key, value) {
      _overrides[key] = value;
      Storage.set("performance_override", _overrides);
    }
    function convert(tier) {
      if (GPU.BLACKLIST) {
        return "F";
      }
      switch (tier) {
        case 5:
          return "A++";
        case 4:
          return "A+";
        case 3:
          return "A";
        case 2:
          return "B";
        case 1:
          return "C";
        case 0:
          return "D";
      }
    }
    (async function () {
      if (Utils.query("performance") && Utils.query("edit") || Utils.query("custom")) {
        await Hydra.ready();
        for (let key in _overrides) {
          Tests[key] = _ => _overrides[key];
        }
      }
    })();
    this.displayResults = async function () {
      let editing = Utils.query("edit");
      await GPU.ready();
      __body.bg("#000");
      let $results = __body.create("PerformanceResults");
      __body.css({
        overflowY: "scroll",
        background: "#000"
      });
      $results.fontStyle("Arial", 16, "#fff").css({
        marginLeft: 50,
        marginRight: 50,
        "user-select": "auto"
      });
      Mobile.allowNativeScroll();
      HydraCSS.style(".PerformanceResults *", {
        position: "relative",
        "user-select": "auto"
      });
      Tests.constructor.toString();
      let tests = "";
      for (let key in Tests) {
        let result = Tests[key]();
        tests += `<p><b>${key}:</b> `;
        if (editing) {
          if (typeof result == "number") {
            tests += `<input class="${key}" value="${result.toString()}" /></p>`;
          }
          if (typeof result == "boolean") {
            tests += `<input class="${key}" type="checkbox" ${result ? "checked" : ""}/></p>`;
          }
        } else {
          tests += result + "</p>";
        }
      }
      let html = `<h1>Performance Results</h1>\n                    <p><b>GPU:</b> ${Device.graphics.webgl ? Device.graphics.webgl.gpu : "WEBGL UNAVAILABLE"}</p>\n                    <p><b>WebGL Version:</b> ${Device.graphics.webgl ? Device.graphics.webgl.version : "WEBGL UNAVAILABLE"}</p>\n                    <p><b>GPU Tier:</b> ${Device.mobile ? convert(GPU.M_TIER) : convert(GPU.TIER)} [${Device.mobile ? GPU.M_TIER : GPU.TIER}]</p>\n                    <p><b>Mobile:</b> ${Device.mobile ? Object.keys(Device.mobile).filter(key => Device.mobile[key]) : "false"} </p>\n                    <p><b>User Agent:</b> ${Device.agent}</p>\n                    <p><b>OS:</b> ${Device.system.os}</p>\n                    <p><b>DPR:</b> ${Device.pixelRatio}</p>\n                    <p><b>Screen Size:</b> ${screen.width} x ${screen.height}</p>\n                    <p><b>Stage Size:</b> ${Stage.width} x ${Stage.height}</p>\n                    \n                    <h2>Project-Specific Tests</h2>\n                    ${editing ? "<button class=\"resetBtn\">Reset All</button>" : ""}\n                    ${tests}\n        `;
      $results.html(html);
      if (editing) {
        await defer();
        document.querySelector(".resetBtn").onclick = _ => {
          Storage.set("performance_override", null);
          location.reload();
        };
        for (let key in Tests) {
          (function (div, key) {
            div.onchange = _ => {
              let value = div.value;
              value = isNaN(value) ? div.checked : Number(value);
              save(key, value);
            };
          })(document.querySelector(`.${key}`), key);
        }
      }
    };
  }, "static");
  Class(function Proton(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config;
    var _size;
    var _antimatter;
    var _behaviorInput;
    const prefix = this.prefix = `P_${_input.prefix}`;
    async function initConfig() {
      (_config = _this.uilConfig = InputUIL.create(prefix + "_config", _group)).setLabel("Config");
      _config.addButton("load-values", {
        label: "Values",
        actions: [{
          title: "Load",
          callback: loadValues
        }, {
          title: "Save",
          callback: saveValues
        }]
      }).addButton("save", {
        label: "Configuration",
        actions: [{
          title: "Load",
          callback: loadConfig
        }, {
          title: "Save",
          callback: saveConfig
        }]
      }).addButton("load-shader", {
        label: "Shader",
        actions: [{
          title: "Load",
          callback: () => loadShader()
        }]
      }).addButton("load-behavior", {
        label: "Behavior",
        actions: [{
          title: "Load",
          callback: () => loadBehavior()
        }]
      });
      _config.addSelect("type", [{
        label: "Permanent",
        value: "permanent"
      }, {
        label: "Lifecycle",
        value: "lifecycle"
      }]);
      if (window.ProtonPhysics) {
        _config.addToggle("enablePhysics", false);
      }
      _config.add("particleCount", 1000);
      if (window.ProtonVolumeShadows) {
        _config.addToggle("volumeShadows", false);
      }
      let output = [{
        label: "Particles",
        value: "particles"
      }, {
        label: "Custom",
        value: "custom"
      }];
      if (window.ProtonTubes) {
        output.push({
          label: "Tubes",
          value: "tubes"
        });
      }
      if (window.ProtonMarchingCubes) {
        output.push({
          label: "IsoSurface",
          value: "isosurface"
        });
      }
      _config.addSelect("output", output);
      _config.add("shader");
      if (_config.get("shader")) {
        _config.addTextarea("uniforms");
      }
      _config.add("class");
      _config.get("type");
      try {
        if (_input.get("visible") === false) {
          throw "Layer set to invisible";
        }
        _this.particleCount = _size = getSize();
        initAntimatter();
      } catch (e) {
        console.warn("Proton skipped", e);
        _this.disabled = true;
      }
    }
    function loadValues() {
      const name = prompt("Name of values to be loaded");
      if (name === null) {
        return;
      }
      let data = UILStorage.get(`proton_values_${name}`);
      if (!data) {
        alert(`No values ${name} found`);
      }
      data = JSON.parse(data);
      let apply = (shader, obj) => {
        for (let key in obj) {
          UILStorage.set(shader.UILPrefix + key, obj[key]);
        }
      };
      apply(_this.behavior, data.behavior);
      apply(_this.shader, data.shader);
      if (_this.customClass && _this.customClass.saveValues) {
        apply(_this.customClass.saveValues(), data.custom);
      }
      alert("Values imported. Save and refresh.");
    }
    function saveValues() {
      const name = prompt("Name of values to be saved");
      if (name === null) {
        return;
      }
      let store = (shader, to) => {
        for (let key in shader.uniforms) {
          if (shader.uniforms[key].ignoreUIL) {
            continue;
          }
          let uilValue = UILStorage.get(shader.UILPrefix + key);
          if (uilValue !== undefined) {
            to[key] = uilValue;
          }
        }
      };
      let output = {
        behavior: {},
        shader: {}
      };
      store(_this.behavior, output.behavior);
      store(_this.shader, output.shader);
      if (_this.customClass && _this.customClass.saveValues) {
        output.custom = {};
        store(_this.customClass.saveValues(), output.custom);
      }
      UILStorage.setWrite(`proton_values_${name}`, JSON.stringify(output));
    }
    function loadConfig() {
      const name = prompt("Name of configuration to be loaded");
      if (name === null) {
        return;
      }
      let toLoad = UILStorage.get(`proton_config_${name}`);
      loadBehavior(toLoad);
      loadShader(toLoad);
      alert("Loaded. Save and refresh");
    }
    function saveConfig() {
      let name = prompt("Name of configuration to be saved");
      if (name !== null) {
        UILStorage.setWrite(`proton_config_${name}`, prefix);
      }
    }
    function loadShader(toLoad) {
      let shouldNotify = !toLoad;
      if (!toLoad) {
        const name = prompt("Name of shader to be loaded");
        if (name === null) {
          return;
        }
        toLoad = UILStorage.get(`proton_config_${name}`);
      }
      let copyConfig = InputUIL.create(toLoad + "_config", null);
      _config.copyFrom(copyConfig, ["shader", "uniforms"]);
      (_config.get("uniforms") || "").split("\n").forEach(line => {
        if (!line.includes(":")) {
          return;
        }
        let name = (line = line.replace(/ /g, "")).split(":")[0];
        let shaderName = copyConfig.get("shader");
        let store = `${shaderName}/${shaderName}/${prefix}/`;
        let lookup = `${shaderName}/${shaderName}/${toLoad}/`;
        let val = UILStorage.get(lookup + name);
        if (val) {
          UILStorage.set(store + name, val);
        } else {
          val = UILStorage.get(lookup + "_tx_" + name);
          if (val) {
            UILStorage.set(store + "_tx_" + name, val);
          }
        }
      });
      if (shouldNotify) {
        alert("Loaded. Save and refresh");
      }
    }
    function loadBehavior(toLoad) {
      let shouldNotify = !toLoad;
      if (!toLoad) {
        const name = prompt("Name of behavior to be loaded");
        if (name === null) {
          return;
        }
        toLoad = UILStorage.get(`proton_config_${name}`);
      }
      let copyConfig = InputUIL.create(toLoad + "_config", null);
      _config.copyFrom(copyConfig, ["type", "particleCount", "output", "class"]);
      let copyBehavior = InputUIL.create(toLoad + "_behavior", null);
      InputUIL.create(prefix + "_behavior", null).copyFrom(copyBehavior, ["uniforms", "data", "codeCount"]);
      let data = copyBehavior.get("data") || [];
      let buniformString = copyBehavior.get("uniforms") + "\n";
      ListUIL.create(prefix + "_code", null).internalAddItems(data.length);
      data.forEach(postfix => {
        let toCode = InputUIL.create(prefix + postfix, null);
        let fromCode = InputUIL.create(toLoad + postfix, null);
        toCode.copyFrom(fromCode, ["name", "code", "uniforms", "preset"]);
        buniformString += fromCode.get("uniforms") + "\n";
      });
      buniformString.split("\n").forEach(line => {
        if (!line.includes(":")) {
          return;
        }
        let name = (line = line.replace(/ /g, "")).split(":")[0];
        let lookup = "am_ProtonAntimatter_" + toLoad;
        let store = "am_ProtonAntimatter_" + prefix;
        let val = UILStorage.get(lookup + name);
        if (val) {
          UILStorage.set(store + name, val);
        }
      });
      let className = copyConfig.get("class");
      if (className) {
        _this.customClass = _this.parent.initClass(window[className], _this, _group, _input);
        if (_this.customClass.loadConfig) {
          _this.customClass.loadConfig(toLoad, prefix);
        }
      }
      if (shouldNotify) {
        alert("Loaded. Save and refresh");
      }
    }
    function getSize() {
      if (_this.parent.data && _this.parent.data.particleCount) {
        if (typeof _this.parent.data.particleCount == "string") {
          return eval(_this.parent.data.particleCount);
        } else {
          return _this.parent.data.particleCount;
        }
      }
      let size = _config.getNumber("particleCount");
      if (isNaN(size)) {
        try {
          size = eval(_config.get("particleCount"));
        } catch (e) {
          throw "Proton particleCount is not a number or valid test function";
        }
      }
      if (isNaN(size)) {
        throw "Proton particleCount is falsy!";
      }
      _this.particleCount = size;
      return size;
    }
    async function initCustomClass() {
      _this.shader.addUniforms({
        DPR: {
          value: World.DPR,
          ignoreUIL: true
        }
      });
      let className = _config.get("class");
      if (className) {
        _this.customClass = _this.parent.initClass(window[className], _this, _group, _input);
      }
    }
    function parseUniforms(text, predefined) {
      if (!text) {
        return {};
      }
      let split = text.split("\n");
      let output = {};
      split.forEach(line => {
        if (!(line = line.replace(/ /g, "")).length || !line.includes(":")) {
          return;
        }
        let split = line.split(":");
        let name = split[0];
        let val = split[1];
        if (val.includes("[")) {
          let array = JSON.parse(val);
          switch (array.length) {
            case 2:
              output[name] = {
                value: new Vector2().fromArray(array)
              };
              break;
            case 3:
              output[name] = {
                value: new Vector3().fromArray(array)
              };
              break;
            case 4:
              output[name] = {
                value: new Vector4().fromArray(array)
              };
              break;
            default:
              throw `Unknown uniform type ${line}`;
          }
        } else if (val.charAt(0) == "C") {
          predefined[name] = val.slice(1);
        } else if (val === "T") {
          output[name] = {
            value: null
          };
        } else if (val === "OEST") {
          output[name] = {
            value: null,
            oes: true
          };
        } else if (val.includes(["0x", "#"])) {
          output[name] = {
            value: new Color(val)
          };
        } else {
          output[name] = {
            value: Number(val)
          };
        }
      });
      return output;
    }
    function getUniformGLSLType(obj) {
      if (typeof obj.value == "number") {
        return "float";
      } else if (obj.oes) {
        return "samplerExternalOES";
      } else if (obj.value === null || obj.value instanceof Texture) {
        return "sampler2D";
      } else if (obj.value instanceof Vector2) {
        return "vec2";
      } else if (obj.value instanceof Vector3 || obj.value instanceof Vector3D) {
        return "vec3";
      } else if (obj.value instanceof Vector4) {
        return "vec4";
      } else if (obj.value instanceof Color) {
        return "vec3";
      } else {
        return undefined;
      }
    }
    async function initBehavior(behavior) {
      let glsl = [];
      let predefinedUniforms = {
        HZ: "float"
      };
      let input;
      if (_behaviorInput) {
        input = _behaviorInput;
      } else {
        input = InputUIL.create(prefix + "_behavior", _group);
        input.setLabel("Behavior Uniforms");
        input.addTextarea("uniforms");
        input.add("data", "hidden");
        input.add("codeCount", "hidden");
        _behaviorInput = input;
      }
      let map = {};
      let list = [];
      let count = input.getNumber("codeCount") || 0;
      let data = input.get("data") || [];
      let panel = ListUIL.create(prefix + "_code", _group);
      panel.setLabel("Behavior Code");
      panel.onAdd((name, input, index) => {
        if (!list[index]) {
          addCode();
        }
        input.group.add(list[index].group);
        list[index].mapId = name;
        map[name] = list[index];
        input.setLabel(map[name].get("name") || "Code");
      });
      panel.onRemove(name => {
        let postfix = map[name].postfix;
        list.remove(map[name]);
        data.remove(postfix);
        input.setValue("data", JSON.stringify(data));
      });
      panel.onSort(array => {
        let arr = [];
        array.forEach(name => {
          arr.push(map[name].postfix);
        });
        data = arr;
        input.setValue("data", JSON.stringify(data));
      });
      let uniforms = parseUniforms(input.get("uniforms"));
      let createCode = postfix => {
        let input = InputUIL.create(prefix + postfix, _group, true);
        input.prefix = prefix + postfix;
        input.postfix = postfix;
        input.setLabel("Editor");
        input.add("name", "hidden");
        if (Proton.ignorePresets && Proton.ignorePresets.includes(input.get("name"))) {
          return;
        }
        ProtonPresets.bind(input);
        if (input.customPresetCallback) {
          input.customPresetCallback(_this);
        }
        let code = input.get("code") || "";
        if (!input.disabled && code.length) {
          for (uniforms = Utils.mergeObject(uniforms, parseUniforms(input.get("uniforms"), predefinedUniforms)); code.includes("#test ");) {
            try {
              let test = code.split("#test ")[1];
              let name = test.split("\n")[0];
              let glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
              if (!eval(name)) {
                code = code.replace(glsl, "");
              }
              code = code.replace("#test " + name + "\n", "");
              code = code.replace("#endtest", "");
            } catch (e) {
              throw "Error parsing test :: " + e;
            }
          }
          glsl.push(code);
        }
        list.push(input);
      };
      data.forEach(createCode);
      let addCode = _ => {
        count++;
        data.push(`code_${count}`);
        input.setValue("data", JSON.stringify(data));
        input.setValue("codeCount", count);
        createCode(`code_${count}`);
      };
      if (behavior instanceof AntimatterPass) {
        behavior.addInput("tOrigin", _antimatter.vertices);
        behavior.addInput("tAttribs", _antimatter.attribs);
        behavior.addUniforms(uniforms);
      }
      let filledRequire = [];
      let insertUniform = (code, line) => code.split("//uniforms").join(line + "\n//uniforms");
      let insertCode = (code, line) => code.split("//code").join(line + "\n//code");
      let insertRequire = (code, line) => {
        let name = line.split("require(")[1].split(")")[0];
        if (filledRequire.includes(name)) {
          return code;
        } else {
          filledRequire.push(name);
          return code.split("//require").join(Shaders.getShader(name) + "\n//require");
        }
      };
      let insertGLSL = (code, line) => {
        if (line.includes("#require")) {
          let split = line.split("\n");
          for (let l of split) {
            code = l.includes("#require") ? insertRequire(code, l) : insertCode(code, l);
          }
          return code;
        }
        return insertCode(code, line);
      };
      behavior.onCreateShader = code => {
        for (let name in uniforms) {
          code = insertUniform(code, `uniform ${getUniformGLSLType(uniforms[name])} ${name};`);
        }
        for (let name in predefinedUniforms) {
          code = insertUniform(code, `uniform ${predefinedUniforms[name]} ${name};`);
        }
        for (let str of glsl) {
          code = insertGLSL(code, str);
        }
        if (_this.tubes) {
          code = _this.tubes.overrideShader(code);
        }
        if (Renderer.type == Renderer.WEBGL2) {
          code = code.replace(/gl_FragColor/g, "FragColor");
        }
        if (code.includes("samplerExternalOES") && window.AURA && Device.system.os == "android") {
          code = "#version 300 es\n#extension GL_OES_EGL_image_external_essl3 : require\n" + code.replace("#version 300 es", "");
        }
        return code;
      };
      behavior.uniforms.uMaxCount = {
        value: _this.particleCount,
        ignoreUIL: true
      };
      ShaderUIL.add(behavior, _group).setLabel("Behavior Shader");
      behavior.uniforms.HZ = {
        value: 1
      };
      _this.startRender(_ => {
        behavior.uniforms.HZ.value = Render.HZ_MULTIPLIER;
      }, 10);
      ProtonPresets.onCodeEdit = rebuildShader;
    }
    async function rebuildShader() {
      let lifecycle = _config.get("type") == "lifecycle";
      let behavior = _this.initClass(AntimatterPass, "ProtonAntimatter" + (lifecycle ? "Lifecycle" : ""), {
        unique: prefix,
        customCompile: prefix + Utils.uuid()
      });
      await initBehavior(behavior);
      behavior.initialize(64);
      behavior.upload();
      _this.behavior.shader._gl &&= behavior.shader._gl;
      _this.behavior.shader._metal &&= behavior.shader._metal;
      _this.behavior.shader._gpu &&= behavior.shader._gpu;
    }
    function completeShader(shader) {
      let transparent = _input.get("transparent");
      let depthWrite = _input.get("depthWrite");
      let depthTest = _input.get("depthTest");
      let blending = _input.get("blending");
      let castShadow = _input.get("castShadow");
      let receiveShadow = _input.get("receiveShadow");
      if (typeof depthWrite == "boolean") {
        shader.depthWrite = depthWrite;
      }
      if (typeof depthTest == "boolean") {
        shader.depthTest = depthTest;
      }
      if (typeof transparent == "boolean") {
        shader.transparent = transparent;
      }
      if (typeof castShadow == "boolean") {
        _this.mesh.castShadow = castShadow;
      }
      if (typeof receiveShadow == "boolean") {
        shader.receiveShadow = receiveShadow;
      }
      if (blending) {
        shader.blending = blending;
      }
      shader.uniforms.tRandom = {
        value: _antimatter.attribs
      };
    }
    function update() {
      if (!_this.preventUpdate) {
        _antimatter.update();
      }
    }
    async function initAntimatter() {
      let lifecycle = _config.get("type") == "lifecycle";
      if (_config.get("enablePhysics")) {
        _config.addVector("width", [0, 128]);
        _config.addVector("height", [0, 128]);
        _config.addVector("depth", [0, 128]);
      } else {
        _config.addVector("width", [-1, 1]);
        _config.addVector("height", [-1, 1]);
        _config.addVector("depth", [-1, 1]);
      }
      let dimensions = {
        w: _config.get("width") || [-1, 1],
        h: _config.get("height") || [-1, 1],
        d: _config.get("depth") || [-1, 1],
        pot: _config.get("output") === "tubes" || _config.get("volumeShadows") === true || _config.get("output") === "isosurface"
      };
      _antimatter = _this.initClass(Antimatter, _size, dimensions);
      if (Proton.forceCloneVertices.includes(_config.get("class"))) {
        _antimatter.cloneVertices = true;
      }
      _this.antimatter = _antimatter;
      await _antimatter.ready();
      let output = _config.get("output");
      if (output == "tubes") {
        _this.tubes = _this.initClass(ProtonTubes, _this);
      }
      if (output == "isosurface") {
        _this.surface = _this.initClass(ProtonMarchingCubes, _this);
      }
      let overrideShader;
      let wildcard = _input.get("wildcard");
      if (wildcard && wildcard.includes(".behavior")) {
        let layer = await _this.parent.getLayer(wildcard.split(".")[0]);
        await _this.wait(layer, "behavior");
        _this.behavior = layer.behavior;
      } else {
        let behavior = _this.initClass(AntimatterPass, "ProtonAntimatter" + (lifecycle ? "Lifecycle" : ""), {
          unique: prefix,
          customCompile: prefix
        });
        _this.behavior = behavior;
        initBehavior(behavior);
      }
      let shaderName = _config.get("shader");
      if (shaderName) {
        if (shaderName.includes(".shader")) {
          let layer = await _this.parent.getLayer(shaderName.split(".")[0]);
          await _this.wait(layer, "shader");
          overrideShader = layer.shader;
        } else {
          let uniforms = parseUniforms(_config.get("uniforms"));
          uniforms.unique = prefix + (_this.onGenerateUniqueShader ? _this.onGenerateUniqueShader() : "");
          _antimatter.useShader(shaderName, uniforms);
        }
      }
      _antimatter.addPass(_this.behavior);
      _this.mesh = _antimatter.getMesh();
      if (_this.onCreateMesh) {
        _this.onCreateMesh(_this.mesh);
      }
      if (!output || output == "particles") {
        _this.delayedCall(_ => {
          _this.add(_antimatter.mesh);
        }, 480);
      }
      if (!Utils.query("uilOnly")) {
        _this.startRender(update, RenderManager.AFTER_LOOPS);
      }
      if (shaderName && !shaderName.includes(".shader")) {
        ShaderUIL.add(_antimatter.shader, _group).setLabel("Shader");
        completeShader(_antimatter.shader);
      }
      if (overrideShader) {
        _antimatter.overrideShader(overrideShader);
      }
      _this.shader = _antimatter.shader;
      _this.initialized = true;
      if (lifecycle) {
        _this.spawn = _this.initClass(AntimatterSpawn, _this, _group, _input);
      }
      initCustomClass();
      if (_config.get("volumeShadows")) {
        _this.initClass(ProtonVolumeShadows, _this, _group, _input);
      }
      if (_config.get("enablePhysics")) {
        _this.initClass(ProtonPhysics, _this, _group, _input);
      }
    }
    this.uilInput = _input;
    this.uilGroup = _group;
    this.prefix = prefix;
    initConfig();
    this.parseUniforms = parseUniforms;
    this.ready = function () {
      return this.wait(this, "initialized");
    };
    this.applyToInstancedGeometry = function (geometry) {
      geometry.addAttribute("lookup", new GeometryAttribute(_antimatter.getLookupArray(), 3, 1));
      geometry.addAttribute("random", new GeometryAttribute(_antimatter.getRandomArray(), 4, 1));
    };
    this.applyToShader = function (shader) {
      shader.addUniforms({
        tPos: _antimatter.getOutput(),
        tPrevPos: _antimatter.getPrevOutput()
      });
    };
    this.upload = async function () {
      if (_this.disabled) {
        return;
      }
      let groupVisible = _this.group.visible;
      _this.group.visible = false;
      await this.ready();
      let output = _config.get("output");
      await _antimatter.upload(!output || output === "particles");
      if (_this.spawn) {
        await _this.spawn.upload();
      }
      if (_this.tubes) {
        await _this.tubes.upload();
      }
      _this.group.visible = groupVisible;
    };
    this.uploadSync = async function () {
      if (_this.disabled) {
        return;
      }
      await this.ready();
      let output = _config.get("output");
      await _antimatter.uploadSync(!output || output === "particles");
      if (_this.spawn) {
        await _this.spawn.upload();
      }
      if (_this.tubes) {
        await _this.tubes.uploadSync();
      }
    };
    this.stopUpdating = function () {
      _this.stopRender(update);
    };
    this.set("renderOrder", async v => {
      await _this.ready();
      await _antimatter.ready();
      _antimatter.mesh.renderOrder = v;
    });
    this.get("renderOrder", v => _antimatter.mesh.renderOrder);
  }, _ => {
    Proton.forceCloneVertices = [];
    Proton.ignore = function (name) {
      Proton.ignorePresets ||= [];
      Proton.ignorePresets.push(name);
    };
  });
  Class(function ProtonPresets() {
    const _this = this;
    const LIST = [{
      label: "Custom Code",
      value: "custom"
    }, {
      label: "Curl Noise",
      value: "curl"
    }, {
      label: "Sine Move",
      value: "sine"
    }, {
      label: "Plane Shape",
      value: "planeshape"
    }, {
      label: "3D Shape",
      value: "3dshape"
    }, {
      label: "Point Cloud",
      value: "pointcloud"
    }, {
      label: "Force",
      value: "force"
    }, {
      label: "Follow",
      value: "follow"
    }, {
      label: "Mouse Fluid",
      value: "fluid"
    }];
    const CALLBACKS = {
      custom: function customCode(input) {
        input.setValue("name", "Custom Code");
        input.setLabel("Custom Code");
      },
      curl: function curlNoise(input) {
        input.setValue("name", "Curl Noise");
        input.setLabel("Curl Noise");
        input.setValue("uniforms", "\n        uCurlNoiseScale: 1\n        uCurlTimeScale: 0\n        uCurlNoiseSpeed: 0\n        ");
        setPresetCodeIfRequired(input, "#require(curl.glsl)\n\nvec3 curl = curlNoise(pos * uCurlNoiseScale*0.1 + (time * uCurlTimeScale * 0.1));\npos += curl * uCurlNoiseSpeed * 0.01 * HZ;", "uCurlNoise");
      },
      sine: function sineMove(input) {
        input.setValue("name", "Sine Move");
        input.setLabel("Sine Move");
        input.setValue("uniforms", "\n        uSinSpeed: 1\n        uSinMovement: 0\n        ");
        setPresetCodeIfRequired(input, "pos = origin;\npos.x += sin(time*uSinSpeed + radians(360.0 * random.x)) * 0.03 * random.z * uSinMovement;\npos.y += sin(time*uSinSpeed + radians(360.0 * random.y)) * 0.03 * random.w * uSinMovement;\npos.z += sin(time*uSinSpeed + radians(360.0 * random.w)) * 0.03 * random.x * uSinMovement;", "uSinSpeed");
      },
      planeshape: function planeShape(input) {
        input.setValue("name", "Plane Shape");
        input.setLabel("Plane Shape");
        input.setValue("uniforms", "\n        uTakePlaneShape: 1\n        uPlaneScale: 1\n        tPlaneTexture: Csampler2D\n        ");
        setPresetCodeIfRequired(input, "vec2 planeLookup = texture2D(tPlaneTexture, uv).xy;\nvec3 plane;\nplane.x = uPlaneScale * 0.5 * range(planeLookup.x, 0.0, 1.0, -1.0, 1.0);\nplane.y = uPlaneScale * 0.5 * -range(planeLookup.y, 0.0, 1.0, -1.0, 1.0);\nif (uTakePlaneShape > 0.5) pos = plane;", "uPlaneScale");
        input.customPresetCallback = proton => {
          proton.behavior.addUniforms({
            tPlaneTexture: {
              value: null
            }
          });
        };
      },
      "3dshape": function shape3D(input) {
        input.setValue("name", "3D Shape");
        input.setLabel("3D Shape");
        input.add("geometry");
        let geometry = input.get("geometry");
        input.setValue("uniforms", "\n        tShape3D: Csampler2D\n        ");
        setPresetCodeIfRequired(input, "vec3 shape3d = texture2D(tShape3D, uv).xyz;", "tShape3D");
        input.customPresetCallback = proton => {
          let create = async g => {
            let geom = await GeomThread.loadGeometry(g);
            let distribution = await ParticleDistributor.generate(geom, proton.antimatter.particleCount);
            let attribute = new AntimatterAttribute(distribution, 3);
            proton.behavior.addInput("tShape3D", attribute);
          };
          if (geometry) {
            create(geometry);
          }
          proton.set3DShape = create;
        };
      },
      pointcloud: function pointCloud(input) {
        input.setValue("name", "Point Cloud");
        input.setLabel("Point Cloud");
        input.add("file");
        let file = input.get("file");
        input.setValue("uniforms", "\n        tPointCloud: Csampler2D\n        ");
        setPresetCodeIfRequired(input, "vec3 pointShape = texture2D(tPointCloud, uv).xyz;", "tPointCloud");
        input.customPresetCallback = proton => {
          let create = async filePath => {
            let data;
            if (typeof filePath == "string") {
              filePath += "-" + proton.antimatter.powerOf2;
              data = await ParticleDistributor.generatePointCloud(filePath, proton.antimatter.textureSize);
            } else {
              data = filePath;
            }
            if (proton.behavior.shader.uniforms.tPointCloud) {
              proton.behavior.shader.uniforms.tPointCloud.value.destroy();
              proton.shader.uniforms.tPointColor.value.destroy();
            }
            proton.behavior.addInput("tPointCloud", data.positions);
            proton.shader.addUniforms({
              tPointColor: {
                value: data.colors
              }
            });
          };
          file ||= proton.parent.data ? proton.parent.data.pointCloudFile : undefined;
          if (file) {
            create(file);
          }
          proton.setPointCloud = create;
        };
      },
      force: function force(input) {
        input.setValue("name", "Force");
        input.setLabel("Force");
        input.setValue("uniforms", "\n        uForceDir: [0, 1, 0]\n        uForceScale: 1\n        ");
        setPresetCodeIfRequired(input, "vec3 force = normalize(uForceDir) * uForceScale * 0.1;\npos += force * HZ;", "uForceDir");
      },
      follow: function follow(input) {
        input.setValue("name", "Follow");
        input.setLabel("Follow");
        input.setValue("uniforms", "\n        uFollowPos: [0, 0, 0]\n        uFollowRadius: 2\n        uFollowLerp: 0.7\n        ");
        setPresetCodeIfRequired(input, "float speed = range(random.x, 0.0, 1.0, 0.5, 1.5);\nvec3 followPos = uFollowPos;\nfollowPos.x += range(random.y, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\nfollowPos.y += range(random.z, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\nfollowPos.z += range(random.w, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\npos += (followPos - pos) * (uFollowLerp*0.1*speed*HZ);", "followPos");
      },
      fluid: function fluid(input) {
        input.setValue("name", "Mouse Fluid");
        input.setLabel("Mouse Fluid");
        input.setValue("uniforms", "\n        uProjMatrix: Cmat4\n        uProjNormalMatrix: Cmat4\n        uModelMatrix: Cmat4\n        tFluidMask: Csampler2D\n        tFluid: Csampler2D\n        uMouseStrength: 1\n        ");
        setPresetCodeIfRequired(input, "#require(glscreenprojection.glsl)\n\nvec3 mpos = vec3(uModelMatrix * vec4(pos, 1.0));\nvec2 screenUV = getProjection(mpos, uProjMatrix);\nvec3 flow = vec3(texture2D(tFluid, screenUV).xy, 0.0);\napplyNormal(flow, uProjNormalMatrix);\npos += flow * 0.0001 * uMouseStrength * texture2D(tFluidMask, screenUV).r;", "glscreenprojection");
        let findCamera = proton => {
          let camera = World.CAMERA;
          let p = proton.group._parent;
          while (p) {
            if (p instanceof Scene && p.nuke) {
              camera = p.nuke.camera;
            }
            p = p._parent;
          }
          return camera;
        };
        input.customPresetCallback = async proton => {
          if (!("MouseFluid" in window)) {
            alert("'mousefluid' module not found. To use Mouse Fluid preset, import module, load the MouseFluid class, and add a layer named 'fluid' with customCLass FluidLayer.");
            return;
          }
          let camera = findCamera(proton);
          let projection = proton.initClass(GLScreenProjection, camera);
          projection.start();
          proton.projection = projection;
          if (Global.PLAYGROUND) {
            Render.start(_ => {
              let newCamera = findCamera(proton);
              if (newCamera != camera) {
                camera = newCamera;
                projection.camera = camera;
              }
            }, 10);
          }
          proton.wait("behavior").then(_ => {
            proton.behavior.addUniforms({
              uProjMatrix: projection.uniforms.projMatrix,
              uModelMatrix: projection.uniforms.modelMatrix,
              uProjNormalMatrix: projection.uniforms.normalMatrix
            });
            MouseFluid.instance().applyTo(proton.behavior);
          });
        };
      }
    };
    function setPresetCodeIfRequired(input, presetCode, keyShaderComponentString) {
      const editorCode = input.get("code");
      if (!editorCode || !editorCode.includes(keyShaderComponentString)) {
        input.setValue("code", presetCode);
      }
    }
    this.register = function (name, callback) {
      let key = name.replace(/ /g, "").toLowerCase();
      LIST.push({
        label: name,
        value: key
      });
      CALLBACKS[key] = callback;
    };
    this.bind = function (input) {
      input.add("code", "hidden");
      input.add("uniforms", "hidden");
      input.addSelect("preset", LIST);
      let callback = CALLBACKS[input.get("preset")];
      if (callback) {
        callback(input);
      }
      input.addButton("btn", {
        actions: [{
          title: "Edit Code",
          callback: _ => {
            let editor = new UILExternalEditor(input.get("name") || "Code", 300);
            editor.setCode(input.get("code"), "c");
            editor.onSave = value => {
              input.setValue("code", value);
              _this.onCodeEdit?.();
            };
            UIL.add(editor);
          }
        }],
        hideLabel: true
      });
    };
  }, "static");
  Class(function RenderManager() {
    Inherit(this, Component);
    const _this = this;
    var _hasGLUI;
    var _hasMetal;
    var _firingEvt;
    var _dpr = null;
    var _schedules = new Map();
    var _needsDeletion = false;
    function fire(evt, data) {
      let array = _schedules.get(evt);
      if (array) {
        _firingEvt = evt;
        let len = array.length;
        for (let i = 0; i < len; i++) {
          let cb = array[i];
          if (!cb.markedForDeletion) {
            if (data) {
              cb(data);
            } else {
              cb(Render.TIME, Render.DELTA);
            }
          }
        }
        _firingEvt = undefined;
        if (_needsDeletion) {
          for (let i = 0; i < array.length; i++) {
            if (array[i].markedForDeletion) {
              delete array[i].markedForDeletion;
              array.splice(i, 1);
              --i;
            }
          }
          _needsDeletion = false;
        }
      }
    }
    function startFrame() {
      fire(_this.FRAME_BEGIN);
    }
    function resizeHandler() {
      if (_this.renderer) {
        _this.renderer.setSize(Stage.width, Stage.height);
      }
    }
    function getDPR() {
      if (window.AURA) {
        return Device.pixelRatio;
      } else if (GPU.OVERSIZED) {
        return 1;
      } else if (GPU.lt(0)) {
        return Math.min(1.3, Device.pixelRatio);
      } else if (GPU.lt(1)) {
        return Math.min(1.8, Device.pixelRatio);
      } else if (GPU.mobileLT(2)) {
        return Math.min(2, Device.pixelRatio);
      } else if (GPU.gt(4)) {
        return Math.max(1.5, Device.pixelRatio);
      } else {
        return Math.max(1.25, Device.pixelRatio);
      }
    }
    function directRenderCallback(render) {
      if (_hasGLUI && _hasMetal) {
        GLUI.renderDirect(render);
      }
    }
    this.NORMAL = "normal";
    this.MAGIC_WINDOW = "magic_window";
    this.VR = this.WEBVR = "webvr";
    this.AR = this.WEBAR = "webar";
    this.RENDER = "RenderManager_render";
    this.BEFORE_RENDER = "RenderManager_before_render";
    this.POST_RENDER = this.FRAME_END = "RenderManager_post_render";
    this.EYE_RENDER = "RenderManager_eye_render";
    this.FRAME_BEGIN = "RenderManager_frame_begin";
    this.AFTER_LOOPS = "RenderManager_after_loops";
    this.NATIVE_FRAMERATE = "RenderManager_native_framerate";
    this.READY = "render_gl_ready";
    this.initialized = Promise.create();
    _this.events.sub(Events.RESIZE, resizeHandler);
    Render.startFrame = startFrame;
    Hydra.ready(_ => {
      _hasGLUI = !!window.GLUI;
      _hasMetal = !!window.Metal;
    });
    this.get("DPR", v => getDPR());
    this.initialize = function (type, params = {}) {
      if (_this.camera) {
        _this.camera.destroy();
      }
      if (_this.renderer) {
        _this.renderer.destroy();
      }
      if (type == _this.WEBVR || type == _this.WEBAR) {
        params.xrCompatible = true;
        params.alpha = false;
      }
      if (!_this.gl) {
        let camera = new PerspectiveCamera(45, Stage.width / Stage.height, 0.01, 200);
        _this.gl = function () {
          if (Device.system.browser == "safari" && Device.system.browserVersion < 13) {
            delete params.powerPreference;
          }
          if (Utils.query("compat")) {
            params.forceWebGL1 = true;
          }
          let renderer = new (window.Metal ? MetalRenderer : Renderer)(params);
          renderer.setSize(Stage.width, Stage.height);
          renderer.setPixelRatio(getDPR());
          return renderer;
        }();
        _this.scene = new Scene();
        _this.nuke = _this.initClass(Nuke, Stage, Object.assign({
          renderer: _this.gl,
          scene: _this.scene,
          camera: camera,
          dpr: World.DPR
        }, params));
      }
      _dpr = _dpr || World.DPR || 1;
      switch (type) {
        case _this.WEBVR:
          _this.renderer = _this.initClass(VRRenderer, _this.gl, _this.nuke);
          _this.camera = _this.initClass(VRCamera);
          break;
        case _this.WEBAR:
          _this.renderer = _this.initClass(window.Metal ? MetalARRenderer : ARRenderer, _this.gl, _this.nuke);
          _this.camera = _this.initClass(ARCamera);
          break;
        case _this.MAGIC_WINDOW:
          _this.renderer = _this.initClass(MagicWindowRenderer, _this.gl, _this.nuke);
          _this.camera = _this.initClass(VRCamera);
          break;
        case _this.NORMAL:
          _this.renderer = _this.initClass(RenderManagerRenderer, _this.gl, _this.nuke);
          _this.camera = _this.initClass(RenderManagerCamera);
      }
      _this.type = type;
      _this.nuke.camera = _this.camera.worldCamera;
      _this.initialized.resolve();
    };
    this.render = function (scene, camera, renderTarget, forceClear) {
      fire(_this.AFTER_LOOPS);
      if (_this.type == _this.VR) {
        fire(World.NUKE);
      }
      fire(_this.BEFORE_RENDER);
      _this.renderer.render(scene || _this.scene, _this.nuke.camera, renderTarget, forceClear, directRenderCallback);
      _this.events.fire(_this.POST_RENDER);
      fire(_this.POST_RENDER);
    };
    this.schedule = function (callback, slot) {
      if (!_schedules.has(slot)) {
        _schedules.set(slot, []);
      }
      let array = _schedules.get(slot);
      let index = array.indexOf(callback);
      if (!(index >= 0) || !!array[index].markedForDeletion) {
        array.push(callback);
      }
    };
    this.scheduleOne = function (callback, slot) {
      let result;
      if (typeof callback != "function") {
        slot = callback;
        result = Promise.create();
        callback = result.resolve;
      }
      let handler = function () {
        _this.unschedule(handler, slot);
        return callback.apply(this, arguments);
      };
      _this.schedule(handler, slot);
      return result;
    };
    this.unschedule = function (callback, slot) {
      if (!_schedules.has(slot)) {
        _schedules.set(slot, []);
      }
      const array = _schedules.get(slot);
      if (!(array.indexOf(callback) < 0)) {
        if (_firingEvt == slot) {
          callback.markedForDeletion = true;
          _needsDeletion = true;
        } else {
          array.remove(callback);
        }
      }
    };
    this.setSize = function (width, height) {
      _this.events.unsub(Events.RESIZE, resizeHandler);
      _this.renderer.setSize(width, height);
    };
    this.fire = fire;
  }, "static");
  Class(function RenderManagerCamera() {
    Inherit(this, Component);
    const _this = this;
    this.worldCamera = window.THREE ? new THREE.PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000) : new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
    _this.events.sub(Events.RESIZE, () => {
      _this.worldCamera.aspect = Stage.width / Stage.height;
      _this.worldCamera.updateProjectionMatrix();
    });
  });
  Class(function RenderManagerRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _evt = {};
    _nuke.onBeforeProcess = _ => {
      _evt.stage = Stage;
      _evt.camera = _nuke.camera;
      _this.events.fire(RenderManager.RENDER, _evt);
    };
    this.render = function (scene, camera, _1, _2, directRender) {
      _nuke.camera = camera;
      if (_nuke) {
        _nuke.render(directRender);
      } else {
        _renderer.render(scene, camera, null, null, directRender);
      }
    };
    this.setSize = function (width, height) {
      _renderer.setSize(width, height);
    };
  });
  Class(function RichText() {
    this.parse = async function (_data) {
      let node = document.createElement("article");
      new Quill(node, {}).setContents(_data.ops);
      await defer();
      let html = node.firstChild.innerHTML;
      html = html.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      return html;
    };
  }, "static");
  (function (t, e) {
    if (typeof exports == "object" && typeof module == "object") {
      module.exports = e();
    } else if (typeof define == "function" && define.amd) {
      define([], e);
    } else if (typeof exports == "object") {
      exports.Quill = e();
    } else {
      t.Quill = e();
    }
  })(typeof self != "undefined" ? self : this, function () {
    return function (t) {
      function e(r) {
        if (n[r]) {
          return n[r].exports;
        }
        var o = n[r] = {
          i: r,
          l: false,
          exports: {}
        };
        t[r].call(o.exports, o, o.exports, e);
        o.l = true;
        return o.exports;
      }
      var n = {};
      e.m = t;
      e.c = n;
      e.d = function (t, n, r) {
        if (!e.o(t, n)) {
          Object.defineProperty(t, n, {
            configurable: false,
            enumerable: true,
            get: r
          });
        }
      };
      e.n = function (t) {
        var n = t && t.__esModule ? function () {
          return t.default;
        } : function () {
          return t;
        };
        e.d(n, "a", n);
        return n;
      };
      e.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      };
      e.p = "";
      return e(e.s = 45);
    }([function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var r = n(17);
      var o = n(18);
      var i = n(19);
      var l = n(48);
      var a = n(49);
      var s = n(50);
      var u = n(51);
      var c = n(52);
      var f = n(11);
      var h = n(29);
      var p = n(30);
      var d = n(28);
      var y = n(1);
      var v = {
        Scope: y.Scope,
        create: y.create,
        find: y.find,
        query: y.query,
        register: y.register,
        Container: r.default,
        Format: o.default,
        Leaf: i.default,
        Embed: u.default,
        Scroll: l.default,
        Block: s.default,
        Inline: a.default,
        Text: c.default,
        Attributor: {
          Attribute: f.default,
          Class: h.default,
          Style: p.default,
          Store: d.default
        }
      };
      e.default = v;
    }, function (t, e, n) {
      "use strict";
  
      function i(t, e) {
        var n;
        if (e === undefined) {
          e = p.ANY;
        }
        if (typeof t == "string") {
          n = h[t] || u[t];
        } else if (t instanceof Text || t.nodeType === Node.TEXT_NODE) {
          n = h.text;
        } else if (typeof t == "number") {
          if (t & p.LEVEL & p.BLOCK) {
            n = h.block;
          } else if (t & p.LEVEL & p.INLINE) {
            n = h.inline;
          }
        } else if (t instanceof HTMLElement) {
          var r = (t.getAttribute("class") || "").split(/\s+/);
          for (var o in r) {
            if (n = c[r[o]]) {
              break;
            }
          }
          n = n || f[t.tagName];
        }
        if (n == null) {
          return null;
        } else if (e & p.LEVEL & n.scope && e & p.TYPE & n.scope) {
          return n;
        } else {
          return null;
        }
      }
      var a = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e(e) {
          var n = this;
          e = "[Parchment] " + e;
          (n = t.call(this, e) || this).message = e;
          n.name = n.constructor.name;
          return n;
        }
        a(e, t);
        return e;
      }(Error);
      e.ParchmentError = s;
      var p;
      var u = {};
      var c = {};
      var f = {};
      var h = {};
      e.DATA_KEY = "__blot";
      (function (t) {
        t[t.TYPE = 3] = "TYPE";
        t[t.LEVEL = 12] = "LEVEL";
        t[t.ATTRIBUTE = 13] = "ATTRIBUTE";
        t[t.BLOT = 14] = "BLOT";
        t[t.INLINE = 7] = "INLINE";
        t[t.BLOCK = 11] = "BLOCK";
        t[t.BLOCK_BLOT = 10] = "BLOCK_BLOT";
        t[t.INLINE_BLOT = 6] = "INLINE_BLOT";
        t[t.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE";
        t[t.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE";
        t[t.ANY = 15] = "ANY";
      })(p = e.Scope ||= {});
      e.create = function r(t, e) {
        var n = i(t);
        if (n == null) {
          throw new s("Unable to create " + t + " blot");
        }
        var r = n;
        return new r(t instanceof Node || t.nodeType === Node.TEXT_NODE ? t : r.create(e), e);
      };
      e.find = function o(t, n = false) {
        if (t == null) {
          return null;
        } else if (t[e.DATA_KEY] != null) {
          return t[e.DATA_KEY].blot;
        } else if (n) {
          return o(t.parentNode, n);
        } else {
          return null;
        }
      };
      e.query = i;
      e.register = function l() {
        var t = [];
        for (var e = 0; e < arguments.length; e++) {
          t[e] = arguments[e];
        }
        if (t.length > 1) {
          return t.map(function (t) {
            return l(t);
          });
        }
        var n = t[0];
        if (typeof n.blotName != "string" && typeof n.attrName != "string") {
          throw new s("Invalid definition");
        }
        if (n.blotName === "abstract") {
          throw new s("Cannot register abstract class");
        }
        h[n.blotName || n.attrName] = n;
        if (typeof n.keyName == "string") {
          u[n.keyName] = n;
        } else {
          if (n.className != null) {
            c[n.className] = n;
          }
          if (n.tagName != null) {
            if (Array.isArray(n.tagName)) {
              n.tagName = n.tagName.map(function (t) {
                return t.toUpperCase();
              });
            } else {
              n.tagName = n.tagName.toUpperCase();
            }
            var r = Array.isArray(n.tagName) ? n.tagName : [n.tagName];
            r.forEach(function (t) {
              if (f[t] == null || n.className == null) {
                f[t] = n;
              }
            });
          }
        }
        return n;
      };
    }, function (t, e) {
      "use strict";
  
      var n = Object.prototype.hasOwnProperty;
      var r = Object.prototype.toString;
      function o(t) {
        if (typeof Array.isArray == "function") {
          return Array.isArray(t);
        } else {
          return r.call(t) === "[object Array]";
        }
      }
      function i(t) {
        if (!t || r.call(t) !== "[object Object]") {
          return false;
        }
        var i;
        var e = n.call(t, "constructor");
        var o = t.constructor && t.constructor.prototype && n.call(t.constructor.prototype, "isPrototypeOf");
        if (t.constructor && !e && !o) {
          return false;
        }
        for (i in t);
        return i === undefined || n.call(t, i);
      }
      t.exports = function t() {
        var e;
        var n;
        var r;
        var l;
        var a;
        var s;
        var u = arguments[0];
        var c = 1;
        var f = arguments.length;
        var h = false;
        if (typeof u == "boolean") {
          h = u;
          u = arguments[1] || {};
          c = 2;
        }
        if (u == null || typeof u != "object" && typeof u != "function") {
          u = {};
        }
        for (; c < f; ++c) {
          if ((e = arguments[c]) != null) {
            for (n in e) {
              r = u[n];
              if (u !== (l = e[n])) {
                if (h && l && (i(l) || (a = o(l)))) {
                  if (a) {
                    a = false;
                    s = r && o(r) ? r : [];
                  } else {
                    s = r && i(r) ? r : {};
                  }
                  u[n] = t(h, s, l);
                } else if (l !== undefined) {
                  u[n] = l;
                }
              }
            }
          }
        }
        return u;
      };
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      function a(t, e = {}) {
        if (t == null) {
          return e;
        } else {
          if (typeof t.formats == "function") {
            e = (0, f.default)(e, t.formats());
          }
          if (t.parent == null || t.parent.blotName == "scroll" || t.parent.statics.scope !== t.statics.scope) {
            return e;
          } else {
            return a(t.parent, e);
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.BlockEmbed = e.bubbleFormats = undefined;
      var s = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var u = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var f = r(n(2));
      var p = r(n(4));
      var y = r(n(0));
      var b = r(n(14));
      var m = r(n(5));
      var O = r(n(8));
      var w = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        l(e, t);
        s(e, [{
          key: "attach",
          value: function () {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "attach", this).call(this);
            this.attributes = new y.default.Attributor.Store(this.domNode);
          }
        }, {
          key: "delta",
          value: function () {
            return new p.default().insert(this.value(), (0, f.default)(this.formats(), this.attributes.values()));
          }
        }, {
          key: "format",
          value: function (t, e) {
            var n = y.default.query(t, y.default.Scope.BLOCK_ATTRIBUTE);
            if (n != null) {
              this.attributes.attribute(n, e);
            }
          }
        }, {
          key: "formatAt",
          value: function (t, e, n, r) {
            this.format(n, r);
          }
        }, {
          key: "insertAt",
          value: function (t, n, r) {
            if (typeof n == "string" && n.endsWith("\n")) {
              var o = y.default.create(x.blotName);
              this.parent.insertBefore(o, t === 0 ? this : this.next);
              o.insertAt(0, n.slice(0, -1));
            } else {
              u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r);
            }
          }
        }]);
        return e;
      }(y.default.Embed);
      w.scope = y.default.Scope.BLOCK_BLOT;
      var x = function (t) {
        function e(t) {
          o(this, e);
          var n = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          n.cache = {};
          return n;
        }
        l(e, t);
        s(e, [{
          key: "delta",
          value: function () {
            if (this.cache.delta == null) {
              this.cache.delta = this.descendants(y.default.Leaf).reduce(function (t, e) {
                if (e.length() === 0) {
                  return t;
                } else {
                  return t.insert(e.value(), a(e));
                }
              }, new p.default()).insert("\n", a(this));
            }
            return this.cache.delta;
          }
        }, {
          key: "deleteAt",
          value: function (t, n) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "deleteAt", this).call(this, t, n);
            this.cache = {};
          }
        }, {
          key: "formatAt",
          value: function (t, n, r, o) {
            if (!(n <= 0)) {
              if (y.default.query(r, y.default.Scope.BLOCK)) {
                if (t + n === this.length()) {
                  this.format(r, o);
                }
              } else {
                u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, Math.min(n, this.length() - t - 1), r, o);
              }
              this.cache = {};
            }
          }
        }, {
          key: "insertAt",
          value: function (t, n, r) {
            if (r != null) {
              return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r);
            }
            if (n.length !== 0) {
              var o = n.split("\n");
              var i = o.shift();
              if (i.length > 0) {
                if (t < this.length() - 1 || this.children.tail == null) {
                  u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, Math.min(t, this.length() - 1), i);
                } else {
                  this.children.tail.insertAt(this.children.tail.length(), i);
                }
                this.cache = {};
              }
              var l = this;
              o.reduce(function (t, e) {
                (l = l.split(t, true)).insertAt(0, e);
                return e.length;
              }, t + i.length);
            }
          }
        }, {
          key: "insertBefore",
          value: function (t, n) {
            var r = this.children.head;
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n);
            if (r instanceof b.default) {
              r.remove();
            }
            this.cache = {};
          }
        }, {
          key: "length",
          value: function () {
            if (this.cache.length == null) {
              this.cache.length = u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "length", this).call(this) + 1;
            }
            return this.cache.length;
          }
        }, {
          key: "moveChildren",
          value: function (t, n) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "moveChildren", this).call(this, t, n);
            this.cache = {};
          }
        }, {
          key: "optimize",
          value: function (t) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t);
            this.cache = {};
          }
        }, {
          key: "path",
          value: function (t) {
            return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "path", this).call(this, t, true);
          }
        }, {
          key: "removeChild",
          value: function (t) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "removeChild", this).call(this, t);
            this.cache = {};
          }
        }, {
          key: "split",
          value: function (t, n = false) {
            if (n && (t === 0 || t >= this.length() - 1)) {
              var r = this.clone();
              if (t === 0) {
                this.parent.insertBefore(r, this);
                return this;
              } else {
                this.parent.insertBefore(r, this.next);
                return r;
              }
            }
            var o = u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "split", this).call(this, t, n);
            this.cache = {};
            return o;
          }
        }]);
        return e;
      }(y.default.Block);
      x.blotName = "block";
      x.tagName = "P";
      x.defaultChild = "break";
      x.allowedChildren = [m.default, y.default.Embed, O.default];
      e.bubbleFormats = a;
      e.BlockEmbed = w;
      e.default = x;
    }, function (t, e, n) {
      var r = n(54);
      var o = n(12);
      var i = n(2);
      var l = n(20);
      var a = String.fromCharCode(0);
      function s(t) {
        if (Array.isArray(t)) {
          this.ops = t;
        } else if (t != null && Array.isArray(t.ops)) {
          this.ops = t.ops;
        } else {
          this.ops = [];
        }
      }
      s.prototype.insert = function (t, e) {
        var n = {};
        if (t.length === 0) {
          return this;
        } else {
          n.insert = t;
          if (e != null && typeof e == "object" && Object.keys(e).length > 0) {
            n.attributes = e;
          }
          return this.push(n);
        }
      };
      s.prototype.delete = function (t) {
        if (t <= 0) {
          return this;
        } else {
          return this.push({
            delete: t
          });
        }
      };
      s.prototype.retain = function (t, e) {
        if (t <= 0) {
          return this;
        }
        var n = {
          retain: t
        };
        if (e != null && typeof e == "object" && Object.keys(e).length > 0) {
          n.attributes = e;
        }
        return this.push(n);
      };
      s.prototype.push = function (t) {
        var e = this.ops.length;
        var n = this.ops[e - 1];
        t = i(true, {}, t);
        if (typeof n == "object") {
          if (typeof t.delete == "number" && typeof n.delete == "number") {
            this.ops[e - 1] = {
              delete: n.delete + t.delete
            };
            return this;
          }
          if (typeof n.delete == "number" && t.insert != null && (e -= 1, typeof (n = this.ops[e - 1]) != "object")) {
            this.ops.unshift(t);
            return this;
          }
          if (o(t.attributes, n.attributes)) {
            if (typeof t.insert == "string" && typeof n.insert == "string") {
              this.ops[e - 1] = {
                insert: n.insert + t.insert
              };
              if (typeof t.attributes == "object") {
                this.ops[e - 1].attributes = t.attributes;
              }
              return this;
            }
            if (typeof t.retain == "number" && typeof n.retain == "number") {
              this.ops[e - 1] = {
                retain: n.retain + t.retain
              };
              if (typeof t.attributes == "object") {
                this.ops[e - 1].attributes = t.attributes;
              }
              return this;
            }
          }
        }
        if (e === this.ops.length) {
          this.ops.push(t);
        } else {
          this.ops.splice(e, 0, t);
        }
        return this;
      };
      s.prototype.chop = function () {
        var t = this.ops[this.ops.length - 1];
        if (t && t.retain && !t.attributes) {
          this.ops.pop();
        }
        return this;
      };
      s.prototype.filter = function (t) {
        return this.ops.filter(t);
      };
      s.prototype.forEach = function (t) {
        this.ops.forEach(t);
      };
      s.prototype.map = function (t) {
        return this.ops.map(t);
      };
      s.prototype.partition = function (t) {
        var e = [];
        var n = [];
        this.forEach(function (r) {
          (t(r) ? e : n).push(r);
        });
        return [e, n];
      };
      s.prototype.reduce = function (t, e) {
        return this.ops.reduce(t, e);
      };
      s.prototype.changeLength = function () {
        return this.reduce(function (t, e) {
          if (e.insert) {
            return t + l.length(e);
          } else if (e.delete) {
            return t - e.delete;
          } else {
            return t;
          }
        }, 0);
      };
      s.prototype.length = function () {
        return this.reduce(function (t, e) {
          return t + l.length(e);
        }, 0);
      };
      s.prototype.slice = function (t, e) {
        t = t || 0;
        if (typeof e != "number") {
          e = Infinity;
        }
        var n = [];
        for (var r = l.iterator(this.ops), o = 0; o < e && r.hasNext();) {
          var i;
          if (o < t) {
            i = r.next(t - o);
          } else {
            i = r.next(e - o);
            n.push(i);
          }
          o += l.length(i);
        }
        return new s(n);
      };
      s.prototype.compose = function (t) {
        for (var e = l.iterator(this.ops), n = l.iterator(t.ops), r = new s(); e.hasNext() || n.hasNext();) {
          if (n.peekType() === "insert") {
            r.push(n.next());
          } else if (e.peekType() === "delete") {
            r.push(e.next());
          } else {
            var o = Math.min(e.peekLength(), n.peekLength());
            var i = e.next(o);
            var a = n.next(o);
            if (typeof a.retain == "number") {
              var u = {};
              if (typeof i.retain == "number") {
                u.retain = o;
              } else {
                u.insert = i.insert;
              }
              var c = l.attributes.compose(i.attributes, a.attributes, typeof i.retain == "number");
              if (c) {
                u.attributes = c;
              }
              r.push(u);
            } else if (typeof a.delete == "number" && typeof i.retain == "number") {
              r.push(a);
            }
          }
        }
        return r.chop();
      };
      s.prototype.concat = function (t) {
        var e = new s(this.ops.slice());
        if (t.ops.length > 0) {
          e.push(t.ops[0]);
          e.ops = e.ops.concat(t.ops.slice(1));
        }
        return e;
      };
      s.prototype.diff = function (t, e) {
        if (this.ops === t.ops) {
          return new s();
        }
        var n = [this, t].map(function (e) {
          return e.map(function (n) {
            if (n.insert != null) {
              if (typeof n.insert == "string") {
                return n.insert;
              } else {
                return a;
              }
            }
            throw new Error("diff() called " + (e === t ? "on" : "with") + " non-document");
          }).join("");
        });
        var i = new s();
        var u = r(n[0], n[1], e);
        var c = l.iterator(this.ops);
        var f = l.iterator(t.ops);
        u.forEach(function (t) {
          for (var e = t[1].length; e > 0;) {
            var n = 0;
            switch (t[0]) {
              case r.INSERT:
                n = Math.min(f.peekLength(), e);
                i.push(f.next(n));
                break;
              case r.DELETE:
                n = Math.min(e, c.peekLength());
                c.next(n);
                i.delete(n);
                break;
              case r.EQUAL:
                n = Math.min(c.peekLength(), f.peekLength(), e);
                var a = c.next(n);
                var s = f.next(n);
                if (o(a.insert, s.insert)) {
                  i.retain(n, l.attributes.diff(a.attributes, s.attributes));
                } else {
                  i.push(s).delete(n);
                }
            }
            e -= n;
          }
        });
        return i.chop();
      };
      s.prototype.eachLine = function (t, e) {
        e = e || "\n";
        for (var n = l.iterator(this.ops), r = new s(), o = 0; n.hasNext();) {
          if (n.peekType() !== "insert") {
            return;
          }
          var i = n.peek();
          var a = l.length(i) - n.peekLength();
          var u = typeof i.insert == "string" ? i.insert.indexOf(e, a) - a : -1;
          if (u < 0) {
            r.push(n.next());
          } else if (u > 0) {
            r.push(n.next(u));
          } else {
            if (t(r, n.next(1).attributes || {}, o) === false) {
              return;
            }
            o += 1;
            r = new s();
          }
        }
        if (r.length() > 0) {
          t(r, {}, o);
        }
      };
      s.prototype.transform = function (t, e) {
        e = !!e;
        if (typeof t == "number") {
          return this.transformPosition(t, e);
        }
        for (var n = l.iterator(this.ops), r = l.iterator(t.ops), o = new s(); n.hasNext() || r.hasNext();) {
          if (n.peekType() !== "insert" || !e && r.peekType() === "insert") {
            if (r.peekType() === "insert") {
              o.push(r.next());
            } else {
              var i = Math.min(n.peekLength(), r.peekLength());
              var a = n.next(i);
              var u = r.next(i);
              if (a.delete) {
                continue;
              }
              if (u.delete) {
                o.push(u);
              } else {
                o.retain(i, l.attributes.transform(a.attributes, u.attributes, e));
              }
            }
          } else {
            o.retain(l.length(n.next()));
          }
        }
        return o.chop();
      };
      s.prototype.transformPosition = function (t, e) {
        e = !!e;
        for (var n = l.iterator(this.ops), r = 0; n.hasNext() && r <= t;) {
          var o = n.peekLength();
          var i = n.peekType();
          n.next();
          if (i !== "delete") {
            if (i === "insert" && (r < t || !e)) {
              t += o;
            }
            r += o;
          } else {
            t -= Math.min(o, t - r);
          }
        }
        return t;
      };
      t.exports = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = r(n(8));
      var h = r(n(0));
      var p = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        a(e, [{
          key: "formatAt",
          value: function (t, n, r, o) {
            if (e.compare(this.statics.blotName, r) < 0 && h.default.query(r, h.default.Scope.BLOT)) {
              var i = this.isolate(t, n);
              if (o) {
                i.wrap(r, o);
              }
            } else {
              s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, n, r, o);
            }
          }
        }, {
          key: "optimize",
          value: function (t) {
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t);
            if (this.parent instanceof e && e.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
              var n = this.parent.isolate(this.offset(), this.length());
              this.moveChildren(n);
              n.wrap(this);
            }
          }
        }], [{
          key: "compare",
          value: function (t, n) {
            var r = e.order.indexOf(t);
            var o = e.order.indexOf(n);
            if (r >= 0 || o >= 0) {
              return r - o;
            } else if (t === n) {
              return 0;
            } else if (t < n) {
              return -1;
            } else {
              return 1;
            }
          }
        }]);
        return e;
      }(h.default.Inline);
      p.allowedChildren = [p, h.default.Embed, c.default];
      p.order = ["cursor", "inline", "underline", "strike", "italic", "bold", "script", "link", "code"];
      e.default = p;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e, n) {
        if (e in t) {
          Object.defineProperty(t, e, {
            value: n,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          t[e] = n;
        }
        return t;
      }
      function i(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function l(t, e) {
        if ((e = (0, N.default)(true, {
          container: t,
          modules: {
            clipboard: true,
            keyboard: true,
            history: true
          }
        }, e)).theme && e.theme !== S.DEFAULTS.theme) {
          e.theme = S.import("themes/" + e.theme);
          if (e.theme == null) {
            throw new Error("Invalid theme " + e.theme + ". Did you register it?");
          }
        } else {
          e.theme = T.default;
        }
        var n = (0, N.default)(true, {}, e.theme.DEFAULTS);
        [n, e].forEach(function (t) {
          t.modules = t.modules || {};
          Object.keys(t.modules).forEach(function (e) {
            if (t.modules[e] === true) {
              t.modules[e] = {};
            }
          });
        });
        var o = Object.keys(n.modules).concat(Object.keys(e.modules)).reduce(function (t, e) {
          var n = S.import("modules/" + e);
          if (n == null) {
            P.error("Cannot load " + e + " module. Are you sure you registered it?");
          } else {
            t[e] = n.DEFAULTS || {};
          }
          return t;
        }, {});
        if (e.modules != null && e.modules.toolbar && e.modules.toolbar.constructor !== Object) {
          e.modules.toolbar = {
            container: e.modules.toolbar
          };
        }
        e = (0, N.default)(true, {}, S.DEFAULTS, {
          modules: o
        }, n, e);
        ["bounds", "container", "scrollingContainer"].forEach(function (t) {
          if (typeof e[t] == "string") {
            e[t] = document.querySelector(e[t]);
          }
        });
        e.modules = Object.keys(e.modules).reduce(function (t, n) {
          if (e.modules[n]) {
            t[n] = e.modules[n];
          }
          return t;
        }, {});
        return e;
      }
      function a(t, e, n, r) {
        if (this.options.strict && !this.isEnabled() && e === g.default.sources.USER) {
          return new d.default();
        }
        var o = n == null ? null : this.getSelection();
        var i = this.editor.delta;
        var l = t();
        if (o != null) {
          if (n === true) {
            n = o.index;
          }
          if (r == null) {
            o = u(o, l, e);
          } else if (r !== 0) {
            o = u(o, n, r, e);
          }
          this.setSelection(o, g.default.sources.SILENT);
        }
        if (l.length() > 0) {
          var a;
          var c;
          var s = [g.default.events.TEXT_CHANGE, l, i, e];
          (a = this.emitter).emit.apply(a, [g.default.events.EDITOR_CHANGE].concat(s));
          if (e !== g.default.sources.SILENT) {
            (c = this.emitter).emit.apply(c, s);
          }
        }
        return l;
      }
      function s(t, e, n, r, o) {
        var i = {};
        if (typeof t.index == "number" && typeof t.length == "number") {
          if (typeof e != "number") {
            o = r;
            r = n;
            n = e;
            e = t.length;
            t = t.index;
          } else {
            e = t.length;
            t = t.index;
          }
        } else if (typeof e != "number") {
          o = r;
          r = n;
          n = e;
          e = 0;
        }
        if ((n === undefined ? "undefined" : c(n)) === "object") {
          i = n;
          o = r;
        } else if (typeof n == "string") {
          if (r != null) {
            i[n] = r;
          } else {
            o = n;
          }
        }
        return [t, e, i, o = o || g.default.sources.API];
      }
      function u(t, e, n, r) {
        if (t == null) {
          return null;
        }
        var o = undefined;
        var i = undefined;
        if (e instanceof d.default) {
          var l = [t.index, t.index + t.length].map(function (t) {
            return e.transformPosition(t, r !== g.default.sources.USER);
          });
          var a = f(l, 2);
          o = a[0];
          i = a[1];
        } else {
          var s = [t.index, t.index + t.length].map(function (t) {
            if (t < e || t === e && r === g.default.sources.USER) {
              return t;
            } else if (n >= 0) {
              return t + n;
            } else {
              return Math.max(e, t + n);
            }
          });
          var u = f(s, 2);
          o = u[0];
          i = u[1];
        }
        return new x.Range(o, i - o);
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.overload = e.expandConfig = undefined;
      var c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        if (t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof t;
        }
      };
      function f(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var h = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      n(53);
      var d = r(n(4));
      var v = r(n(57));
      var g = r(n(9));
      var _ = r(n(7));
      var w = r(n(0));
      var x = n(22);
      var k = r(x);
      var N = r(n(2));
      var A = r(n(10));
      var T = r(n(32));
      var P = (0, A.default)("quill");
      var S = function () {
        function t(e) {
          var n = this;
          var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          i(this, t);
          this.options = l(e, r);
          this.container = this.options.container;
          if (this.container == null) {
            return P.error("Invalid Quill container", e);
          }
          if (this.options.debug) {
            t.debug(this.options.debug);
          }
          var o = this.container.innerHTML.trim();
          this.container.classList.add("ql-container");
          this.container.innerHTML = "";
          this.container.__quill = this;
          this.root = this.addContainer("ql-editor");
          this.root.classList.add("ql-blank");
          this.root.setAttribute("data-gramm", false);
          this.scrollingContainer = this.options.scrollingContainer || this.root;
          this.emitter = new g.default();
          this.scroll = w.default.create(this.root, {
            emitter: this.emitter,
            whitelist: this.options.formats
          });
          this.editor = new v.default(this.scroll);
          this.selection = new k.default(this.scroll, this.emitter);
          this.theme = new this.options.theme(this, this.options);
          this.keyboard = this.theme.addModule("keyboard");
          this.clipboard = this.theme.addModule("clipboard");
          this.history = this.theme.addModule("history");
          this.theme.init();
          this.emitter.on(g.default.events.EDITOR_CHANGE, function (t) {
            if (t === g.default.events.TEXT_CHANGE) {
              n.root.classList.toggle("ql-blank", n.editor.isBlank());
            }
          });
          this.emitter.on(g.default.events.SCROLL_UPDATE, function (t, e) {
            var r = n.selection.lastRange;
            var o = r && r.length === 0 ? r.index : undefined;
            a.call(n, function () {
              return n.editor.update(null, e, o);
            }, t);
          });
          var s = this.clipboard.convert("<div class='ql-editor' style=\"white-space: normal;\">" + o + "<p><br></p></div>");
          this.setContents(s);
          this.history.clear();
          if (this.options.placeholder) {
            this.root.setAttribute("data-placeholder", this.options.placeholder);
          }
          if (this.options.readOnly) {
            this.disable();
          }
        }
        h(t, null, [{
          key: "debug",
          value: function (t) {
            if (t === true) {
              t = "log";
            }
            A.default.level(t);
          }
        }, {
          key: "find",
          value: function (t) {
            return t.__quill || w.default.find(t);
          }
        }, {
          key: "import",
          value: function (t) {
            if (this.imports[t] == null) {
              P.error("Cannot import " + t + ". Are you sure it was registered?");
            }
            return this.imports[t];
          }
        }, {
          key: "register",
          value: function (t, e) {
            var n = this;
            var r = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
            if (typeof t != "string") {
              var o = t.attrName || t.blotName;
              if (typeof o == "string") {
                this.register("formats/" + o, t, e);
              } else {
                Object.keys(t).forEach(function (r) {
                  n.register(r, t[r], e);
                });
              }
            } else {
              if (this.imports[t] != null && !r) {
                P.warn("Overwriting " + t + " with", e);
              }
              this.imports[t] = e;
              if ((t.startsWith("blots/") || t.startsWith("formats/")) && e.blotName !== "abstract") {
                w.default.register(e);
              } else if (t.startsWith("modules") && typeof e.register == "function") {
                e.register();
              }
            }
          }
        }]);
        h(t, [{
          key: "addContainer",
          value: function (t, e = null) {
            if (typeof t == "string") {
              var n = t;
              (t = document.createElement("div")).classList.add(n);
            }
            this.container.insertBefore(t, e);
            return t;
          }
        }, {
          key: "blur",
          value: function () {
            this.selection.setRange(null);
          }
        }, {
          key: "deleteText",
          value: function (t, e, n) {
            var r = this;
            var o = s(t, e, n);
            var i = f(o, 4);
            t = i[0];
            e = i[1];
            n = i[3];
            return a.call(this, function () {
              return r.editor.deleteText(t, e);
            }, n, t, e * -1);
          }
        }, {
          key: "disable",
          value: function () {
            this.enable(false);
          }
        }, {
          key: "enable",
          value: function () {
            var t = !(arguments.length > 0) || arguments[0] === undefined || arguments[0];
            this.scroll.enable(t);
            this.container.classList.toggle("ql-disabled", !t);
          }
        }, {
          key: "focus",
          value: function () {
            var t = this.scrollingContainer.scrollTop;
            this.selection.focus();
            this.scrollingContainer.scrollTop = t;
            this.scrollIntoView();
          }
        }, {
          key: "format",
          value: function (t, e) {
            var n = this;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : g.default.sources.API;
            return a.call(this, function () {
              var r = n.getSelection(true);
              var i = new d.default();
              if (r == null) {
                return i;
              }
              if (w.default.query(t, w.default.Scope.BLOCK)) {
                i = n.editor.formatLine(r.index, r.length, o({}, t, e));
              } else {
                if (r.length === 0) {
                  n.selection.format(t, e);
                  return i;
                }
                i = n.editor.formatText(r.index, r.length, o({}, t, e));
              }
              n.setSelection(r, g.default.sources.SILENT);
              return i;
            }, r);
          }
        }, {
          key: "formatLine",
          value: function (t, e, n, r, o) {
            var l;
            var i = this;
            var u = s(t, e, n, r, o);
            var c = f(u, 4);
            t = c[0];
            e = c[1];
            l = c[2];
            o = c[3];
            return a.call(this, function () {
              return i.editor.formatLine(t, e, l);
            }, o, t, 0);
          }
        }, {
          key: "formatText",
          value: function (t, e, n, r, o) {
            var l;
            var i = this;
            var u = s(t, e, n, r, o);
            var c = f(u, 4);
            t = c[0];
            e = c[1];
            l = c[2];
            o = c[3];
            return a.call(this, function () {
              return i.editor.formatText(t, e, l);
            }, o, t, 0);
          }
        }, {
          key: "getBounds",
          value: function (t, e = 0) {
            var n = undefined;
            n = typeof t == "number" ? this.selection.getBounds(t, e) : this.selection.getBounds(t.index, t.length);
            var r = this.container.getBoundingClientRect();
            return {
              bottom: n.bottom - r.top,
              height: n.height,
              left: n.left - r.left,
              right: n.right - r.left,
              top: n.top - r.top,
              width: n.width
            };
          }
        }, {
          key: "getContents",
          value: function (t = 0, e = this.getLength() - t) {
            var n = s(t, e);
            var r = f(n, 2);
            t = r[0];
            e = r[1];
            return this.editor.getContents(t, e);
          }
        }, {
          key: "getFormat",
          value: function (t = this.getSelection(true), e = 0) {
            if (typeof t == "number") {
              return this.editor.getFormat(t, e);
            } else {
              return this.editor.getFormat(t.index, t.length);
            }
          }
        }, {
          key: "getIndex",
          value: function (t) {
            return t.offset(this.scroll);
          }
        }, {
          key: "getLength",
          value: function () {
            return this.scroll.length();
          }
        }, {
          key: "getLeaf",
          value: function (t) {
            return this.scroll.leaf(t);
          }
        }, {
          key: "getLine",
          value: function (t) {
            return this.scroll.line(t);
          }
        }, {
          key: "getLines",
          value: function (t = 0, e = Number.MAX_VALUE) {
            if (typeof t != "number") {
              return this.scroll.lines(t.index, t.length);
            } else {
              return this.scroll.lines(t, e);
            }
          }
        }, {
          key: "getModule",
          value: function (t) {
            return this.theme.modules[t];
          }
        }, {
          key: "getSelection",
          value: function () {
            if (arguments.length > 0 && arguments[0] !== undefined && arguments[0]) {
              this.focus();
            }
            this.update();
            return this.selection.getRange()[0];
          }
        }, {
          key: "getText",
          value: function (t = 0, e = this.getLength() - t) {
            var n = s(t, e);
            var r = f(n, 2);
            t = r[0];
            e = r[1];
            return this.editor.getText(t, e);
          }
        }, {
          key: "hasFocus",
          value: function () {
            return this.selection.hasFocus();
          }
        }, {
          key: "insertEmbed",
          value: function (e, n, r) {
            var o = this;
            var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.sources.API;
            return a.call(this, function () {
              return o.editor.insertEmbed(e, n, r);
            }, i, e);
          }
        }, {
          key: "insertText",
          value: function (t, e, n, r, o) {
            var l;
            var i = this;
            var u = s(t, 0, n, r, o);
            var c = f(u, 4);
            t = c[0];
            l = c[2];
            o = c[3];
            return a.call(this, function () {
              return i.editor.insertText(t, e, l);
            }, o, t, e.length);
          }
        }, {
          key: "isEnabled",
          value: function () {
            return !this.container.classList.contains("ql-disabled");
          }
        }, {
          key: "off",
          value: function () {
            return this.emitter.off.apply(this.emitter, arguments);
          }
        }, {
          key: "on",
          value: function () {
            return this.emitter.on.apply(this.emitter, arguments);
          }
        }, {
          key: "once",
          value: function () {
            return this.emitter.once.apply(this.emitter, arguments);
          }
        }, {
          key: "pasteHTML",
          value: function (t, e, n) {
            this.clipboard.dangerouslyPasteHTML(t, e, n);
          }
        }, {
          key: "removeFormat",
          value: function (t, e, n) {
            var r = this;
            var o = s(t, e, n);
            var i = f(o, 4);
            t = i[0];
            e = i[1];
            n = i[3];
            return a.call(this, function () {
              return r.editor.removeFormat(t, e);
            }, n, t);
          }
        }, {
          key: "scrollIntoView",
          value: function () {
            this.selection.scrollIntoView(this.scrollingContainer);
          }
        }, {
          key: "setContents",
          value: function (t) {
            var e = this;
            var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : g.default.sources.API;
            return a.call(this, function () {
              t = new d.default(t);
              var n = e.getLength();
              var r = e.editor.deleteText(0, n);
              var o = e.editor.applyDelta(t);
              var i = o.ops[o.ops.length - 1];
              if (i != null && typeof i.insert == "string" && i.insert[i.insert.length - 1] === "\n") {
                e.editor.deleteText(e.getLength() - 1, 1);
                o.delete(1);
              }
              return r.compose(o);
            }, n);
          }
        }, {
          key: "setSelection",
          value: function (e, n, r) {
            if (e == null) {
              this.selection.setRange(null, n || t.sources.API);
            } else {
              var o = s(e, n, r);
              var i = f(o, 4);
              e = i[0];
              n = i[1];
              r = i[3];
              this.selection.setRange(new x.Range(e, n), r);
              if (r !== g.default.sources.SILENT) {
                this.selection.scrollIntoView(this.scrollingContainer);
              }
            }
          }
        }, {
          key: "setText",
          value: function (t, e = g.default.sources.API) {
            var n = new d.default().insert(t);
            return this.setContents(n, e);
          }
        }, {
          key: "update",
          value: function (t = g.default.sources.USER) {
            var e = this.scroll.update(t);
            this.selection.update(t);
            return e;
          }
        }, {
          key: "updateContents",
          value: function (t) {
            var e = this;
            var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : g.default.sources.API;
            return a.call(this, function () {
              t = new d.default(t);
              return e.editor.applyDelta(t, n);
            }, n, true);
          }
        }]);
        return t;
      }();
      S.DEFAULTS = {
        bounds: null,
        formats: null,
        modules: {},
        placeholder: "",
        readOnly: false,
        scrollingContainer: null,
        strict: true,
        theme: "default"
      };
      S.events = g.default.events;
      S.sources = g.default.sources;
      S.version = "1.3.6";
      S.imports = {
        delta: d.default,
        parchment: w.default,
        "core/module": _.default,
        "core/theme": T.default
      };
      e.expandConfig = l;
      e.overload = s;
      e.default = S;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = function t(e, n = {}) {
        r(this, t);
        this.quill = e;
        this.options = n;
      };
      o.DEFAULTS = {};
      e.default = o;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0)).default.Text);
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = r(n(58));
      var p = (0, r(n(10)).default)("quill:events");
      ["selectionchange", "mousedown", "mouseup", "click"].forEach(function (t) {
        document.addEventListener(t, function () {
          for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) {
            e[n] = arguments[n];
          }
          [].slice.call(document.querySelectorAll(".ql-container")).forEach(function (t) {
            var n;
            if (t.__quill && t.__quill.emitter) {
              (n = t.__quill.emitter).handleDOM.apply(n, e);
            }
          });
        });
      });
      var d = function (t) {
        function e() {
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var t = function i(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
          t.listeners = {};
          t.on("error", p.error);
          return t;
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        a(e, [{
          key: "emit",
          value: function () {
            p.log.apply(p, arguments);
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "emit", this).apply(this, arguments);
          }
        }, {
          key: "handleDOM",
          value: function (t) {
            for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) {
              n[r - 1] = arguments[r];
            }
            (this.listeners[t.type] || []).forEach(function (e) {
              var r = e.node;
              var o = e.handler;
              if (t.target === r || r.contains(t.target)) {
                o.apply(undefined, [t].concat(n));
              }
            });
          }
        }, {
          key: "listenDOM",
          value: function (t, e, n) {
            this.listeners[t] ||= [];
            this.listeners[t].push({
              node: e,
              handler: n
            });
          }
        }]);
        return e;
      }(c.default);
      d.events = {
        EDITOR_CHANGE: "editor-change",
        SCROLL_BEFORE_UPDATE: "scroll-before-update",
        SCROLL_OPTIMIZE: "scroll-optimize",
        SCROLL_UPDATE: "scroll-update",
        SELECTION_CHANGE: "selection-change",
        TEXT_CHANGE: "text-change"
      };
      d.sources = {
        API: "api",
        SILENT: "silent",
        USER: "user"
      };
      e.default = d;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (i.indexOf(t) <= i.indexOf(l)) {
          var e;
          for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) {
            r[o - 1] = arguments[o];
          }
          (e = console)[t].apply(e, r);
        }
      }
      function o(t) {
        return i.reduce(function (e, n) {
          e[n] = r.bind(console, n, t);
          return e;
        }, {});
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = ["error", "warn", "log", "info"];
      var l = "warn";
      r.level = o.level = function (t) {
        l = t;
      };
      e.default = o;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var r = n(1);
      var o = function () {
        function t(t, e, n = {}) {
          this.attrName = t;
          this.keyName = e;
          var o = r.Scope.TYPE & r.Scope.ATTRIBUTE;
          if (n.scope != null) {
            this.scope = n.scope & r.Scope.LEVEL | o;
          } else {
            this.scope = r.Scope.ATTRIBUTE;
          }
          if (n.whitelist != null) {
            this.whitelist = n.whitelist;
          }
        }
        t.keys = function (t) {
          return [].map.call(t.attributes, function (t) {
            return t.name;
          });
        };
        t.prototype.add = function (t, e) {
          return !!this.canAdd(t, e) && (t.setAttribute(this.keyName, e), true);
        };
        t.prototype.canAdd = function (t, e) {
          return r.query(t, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) != null && (this.whitelist == null || (typeof e == "string" ? this.whitelist.indexOf(e.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e) > -1));
        };
        t.prototype.remove = function (t) {
          t.removeAttribute(this.keyName);
        };
        t.prototype.value = function (t) {
          var e = t.getAttribute(this.keyName);
          if (this.canAdd(t, e) && e) {
            return e;
          } else {
            return "";
          }
        };
        return t;
      }();
      e.default = o;
    }, function (t, e, n) {
      function r(t) {
        return t == null;
      }
      function o(t) {
        return !!t && typeof t == "object" && typeof t.length == "number" && typeof t.copy == "function" && typeof t.slice == "function" && (!(t.length > 0) || typeof t[0] == "number");
      }
      var l = Array.prototype.slice;
      var a = n(55);
      var s = n(56);
      var u = t.exports = function (t, e, n) {
        n ||= {};
        return t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || typeof t != "object" && typeof e != "object" ? n.strict ? t === e : t == e : function i(t, e, n) {
          var i;
          var c;
          if (r(t) || r(e)) {
            return false;
          }
          if (t.prototype !== e.prototype) {
            return false;
          }
          if (s(t)) {
            return !!s(e) && (t = l.call(t), e = l.call(e), u(t, e, n));
          }
          if (o(t)) {
            if (!o(e)) {
              return false;
            }
            if (t.length !== e.length) {
              return false;
            }
            for (i = 0; i < t.length; i++) {
              if (t[i] !== e[i]) {
                return false;
              }
            }
            return true;
          }
          try {
            var f = a(t);
            var h = a(e);
          } catch (t) {
            return false;
          }
          if (f.length != h.length) {
            return false;
          }
          f.sort();
          h.sort();
          i = f.length - 1;
          for (; i >= 0; i--) {
            if (f[i] != h[i]) {
              return false;
            }
          }
          for (i = f.length - 1; i >= 0; i--) {
            c = f[i];
            if (!u(t[c], e[c], n)) {
              return false;
            }
          }
          return typeof t == typeof e;
        }(t, e, n));
      };
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.Code = undefined;
      function a(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var s = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var u = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var f = r(n(4));
      var p = r(n(0));
      var y = r(n(3));
      var b = r(n(5));
      var m = r(n(8));
      var _ = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        l(e, t);
        return e;
      }(b.default);
      _.blotName = "code";
      _.tagName = "CODE";
      var O = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        l(e, t);
        s(e, [{
          key: "delta",
          value: function () {
            var t = this;
            var e = this.domNode.textContent;
            if (e.endsWith("\n")) {
              e = e.slice(0, -1);
            }
            return e.split("\n").reduce(function (e, n) {
              return e.insert(n).insert("\n", t.formats());
            }, new f.default());
          }
        }, {
          key: "format",
          value: function (t, n) {
            if (t !== this.statics.blotName || !n) {
              var r = this.descendant(m.default, this.length() - 1);
              var i = a(r, 1)[0];
              if (i != null) {
                i.deleteAt(i.length() - 1, 1);
              }
              u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            }
          }
        }, {
          key: "formatAt",
          value: function (t, n, r, o) {
            if (n !== 0 && p.default.query(r, p.default.Scope.BLOCK) != null && (r !== this.statics.blotName || o !== this.statics.formats(this.domNode))) {
              var i = this.newlineIndex(t);
              if (!(i < 0) && !(i >= t + n)) {
                var l = this.newlineIndex(t, true) + 1;
                var a = i - l + 1;
                var s = this.isolate(l, a);
                var u = s.next;
                s.format(r, o);
                if (u instanceof e) {
                  u.formatAt(0, t - l + n - a, r, o);
                }
              }
            }
          }
        }, {
          key: "insertAt",
          value: function (t, e, n) {
            if (n == null) {
              var r = this.descendant(m.default, t);
              var o = a(r, 2);
              var i = o[0];
              var l = o[1];
              i.insertAt(l, e);
            }
          }
        }, {
          key: "length",
          value: function () {
            var t = this.domNode.textContent.length;
            if (this.domNode.textContent.endsWith("\n")) {
              return t;
            } else {
              return t + 1;
            }
          }
        }, {
          key: "newlineIndex",
          value: function (t) {
            if (arguments.length > 1 && arguments[1] !== undefined && arguments[1]) {
              return this.domNode.textContent.slice(0, t).lastIndexOf("\n");
            }
            var e = this.domNode.textContent.slice(t).indexOf("\n");
            if (e > -1) {
              return t + e;
            } else {
              return -1;
            }
          }
        }, {
          key: "optimize",
          value: function (t) {
            if (!this.domNode.textContent.endsWith("\n")) {
              this.appendChild(p.default.create("text", "\n"));
            }
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t);
            var n = this.next;
            if (n != null && n.prev === this && n.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n.statics.formats(n.domNode)) {
              n.optimize(t);
              n.moveChildren(this);
              n.remove();
            }
          }
        }, {
          key: "replace",
          value: function (t) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replace", this).call(this, t);
            [].slice.call(this.domNode.querySelectorAll("*")).forEach(function (t) {
              var e = p.default.find(t);
              if (e == null) {
                t.parentNode.removeChild(t);
              } else if (e instanceof p.default.Embed) {
                e.remove();
              } else {
                e.unwrap();
              }
            });
          }
        }], [{
          key: "create",
          value: function (t) {
            var n = u(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            n.setAttribute("spellcheck", false);
            return n;
          }
        }, {
          key: "formats",
          value: function () {
            return true;
          }
        }]);
        return e;
      }(y.default);
      O.blotName = "code-block";
      O.tagName = "PRE";
      O.TAB = "  ";
      e.Code = _;
      e.default = O;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "insertInto",
          value: function (t, n) {
            if (t.children.length === 0) {
              a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertInto", this).call(this, t, n);
            } else {
              this.remove();
            }
          }
        }, {
          key: "length",
          value: function () {
            return 0;
          }
        }, {
          key: "value",
          value: function () {
            return "";
          }
        }], [{
          key: "value",
          value: function () {}
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0)).default.Embed);
      c.blotName = "break";
      c.tagName = "BR";
      e.default = c;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        var n = document.createElement("a");
        n.href = t;
        var r = n.href.slice(0, n.href.indexOf(":"));
        return e.indexOf(r) > -1;
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.sanitize = e.default = undefined;
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var f = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        a(e, [{
          key: "format",
          value: function (t, n) {
            if (t !== this.statics.blotName || !n) {
              return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            }
            n = this.constructor.sanitize(n);
            this.domNode.setAttribute("href", n);
          }
        }], [{
          key: "create",
          value: function (t) {
            var n = s(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            t = this.sanitize(t);
            n.setAttribute("href", t);
            n.setAttribute("target", "_blank");
            return n;
          }
        }, {
          key: "formats",
          value: function (t) {
            return t.getAttribute("href");
          }
        }, {
          key: "sanitize",
          value: function (t) {
            if (l(t, this.PROTOCOL_WHITELIST)) {
              return t;
            } else {
              return this.SANITIZED_URL;
            }
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(5)).default);
      f.blotName = "link";
      f.tagName = "A";
      f.SANITIZED_URL = "about:blank";
      f.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"];
      e.default = f;
      e.sanitize = l;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function i(t, e) {
        t.setAttribute(e, t.getAttribute(e) !== "true");
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        if (t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof t;
        }
      };
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var u = r(n(25));
      var f = r(n(106));
      var h = 0;
      var p = function () {
        function t(e) {
          var n = this;
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, t);
          this.select = e;
          this.container = document.createElement("span");
          this.buildPicker();
          this.select.style.display = "none";
          this.select.parentNode.insertBefore(this.container, this.select);
          this.label.addEventListener("mousedown", function () {
            n.togglePicker();
          });
          this.label.addEventListener("keydown", function (t) {
            switch (t.keyCode) {
              case u.default.keys.ENTER:
                n.togglePicker();
                break;
              case u.default.keys.ESCAPE:
                n.escape();
                t.preventDefault();
            }
          });
          this.select.addEventListener("change", this.update.bind(this));
        }
        a(t, [{
          key: "togglePicker",
          value: function () {
            this.container.classList.toggle("ql-expanded");
            i(this.label, "aria-expanded");
            i(this.options, "aria-hidden");
          }
        }, {
          key: "buildItem",
          value: function (t) {
            var e = this;
            var n = document.createElement("span");
            n.tabIndex = "0";
            n.setAttribute("role", "button");
            n.classList.add("ql-picker-item");
            if (t.hasAttribute("value")) {
              n.setAttribute("data-value", t.getAttribute("value"));
            }
            if (t.textContent) {
              n.setAttribute("data-label", t.textContent);
            }
            n.addEventListener("click", function () {
              e.selectItem(n, true);
            });
            n.addEventListener("keydown", function (t) {
              switch (t.keyCode) {
                case u.default.keys.ENTER:
                  e.selectItem(n, true);
                  t.preventDefault();
                  break;
                case u.default.keys.ESCAPE:
                  e.escape();
                  t.preventDefault();
              }
            });
            return n;
          }
        }, {
          key: "buildLabel",
          value: function () {
            var t = document.createElement("span");
            t.classList.add("ql-picker-label");
            t.innerHTML = f.default;
            t.tabIndex = "0";
            t.setAttribute("role", "button");
            t.setAttribute("aria-expanded", "false");
            this.container.appendChild(t);
            return t;
          }
        }, {
          key: "buildOptions",
          value: function () {
            var t = this;
            var e = document.createElement("span");
            e.classList.add("ql-picker-options");
            e.setAttribute("aria-hidden", "true");
            e.tabIndex = "-1";
            e.id = "ql-picker-options-" + h;
            h += 1;
            this.label.setAttribute("aria-controls", e.id);
            this.options = e;
            [].slice.call(this.select.options).forEach(function (n) {
              var r = t.buildItem(n);
              e.appendChild(r);
              if (n.selected === true) {
                t.selectItem(r);
              }
            });
            this.container.appendChild(e);
          }
        }, {
          key: "buildPicker",
          value: function () {
            var t = this;
            [].slice.call(this.select.attributes).forEach(function (e) {
              t.container.setAttribute(e.name, e.value);
            });
            this.container.classList.add("ql-picker");
            this.label = this.buildLabel();
            this.buildOptions();
          }
        }, {
          key: "escape",
          value: function () {
            var t = this;
            this.close();
            setTimeout(function () {
              return t.label.focus();
            }, 1);
          }
        }, {
          key: "close",
          value: function () {
            this.container.classList.remove("ql-expanded");
            this.label.setAttribute("aria-expanded", "false");
            this.options.setAttribute("aria-hidden", "true");
          }
        }, {
          key: "selectItem",
          value: function (t, e = false) {
            var n = this.container.querySelector(".ql-selected");
            if (t !== n && (n != null && n.classList.remove("ql-selected"), t != null && (t.classList.add("ql-selected"), this.select.selectedIndex = [].indexOf.call(t.parentNode.children, t), t.hasAttribute("data-value") ? this.label.setAttribute("data-value", t.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t.hasAttribute("data-label") ? this.label.setAttribute("data-label", t.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e))) {
              if (typeof Event == "function") {
                this.select.dispatchEvent(new Event("change"));
              } else if ((typeof Event == "undefined" ? "undefined" : l(Event)) === "object") {
                var r = document.createEvent("Event");
                r.initEvent("change", true, true);
                this.select.dispatchEvent(r);
              }
              this.close();
            }
          }
        }, {
          key: "update",
          value: function () {
            var t = undefined;
            if (this.select.selectedIndex > -1) {
              var e = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
              t = this.select.options[this.select.selectedIndex];
              this.selectItem(e);
            } else {
              this.selectItem(null);
            }
            var n = t != null && t !== this.select.querySelector("option[selected]");
            this.label.classList.toggle("ql-active", n);
          }
        }]);
        return t;
      }();
      e.default = p;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        var e = a.find(t);
        if (e == null) {
          try {
            e = a.create(t);
          } catch (n) {
            e = a.create(a.Scope.INLINE);
            [].slice.call(t.childNodes).forEach(function (t) {
              e.domNode.appendChild(t);
            });
            if (t.parentNode) {
              t.parentNode.replaceChild(e.domNode, t);
            }
            e.attach();
          }
        }
        return e;
      }
      var o = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = n(47);
      var l = n(27);
      var a = n(1);
      var s = function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          n.build();
          return n;
        }
        o(e, t);
        e.prototype.appendChild = function (t) {
          this.insertBefore(t);
        };
        e.prototype.attach = function () {
          t.prototype.attach.call(this);
          this.children.forEach(function (t) {
            t.attach();
          });
        };
        e.prototype.build = function () {
          var t = this;
          this.children = new i.default();
          [].slice.call(this.domNode.childNodes).reverse().forEach(function (e) {
            try {
              var n = r(e);
              t.insertBefore(n, t.children.head || undefined);
            } catch (t) {
              if (t instanceof a.ParchmentError) {
                return;
              }
              throw t;
            }
          });
        };
        e.prototype.deleteAt = function (t, e) {
          if (t === 0 && e === this.length()) {
            return this.remove();
          }
          this.children.forEachAt(t, e, function (t, e, n) {
            t.deleteAt(e, n);
          });
        };
        e.prototype.descendant = function (t, n) {
          var r = this.children.find(n);
          var o = r[0];
          var i = r[1];
          if (t.blotName == null && t(o) || t.blotName != null && o instanceof t) {
            return [o, i];
          } else if (o instanceof e) {
            return o.descendant(t, i);
          } else {
            return [null, -1];
          }
        };
        e.prototype.descendants = function (t, n = 0, r = Number.MAX_VALUE) {
          var o = [];
          var i = r;
          this.children.forEachAt(n, r, function (n, r, l) {
            if (t.blotName == null && t(n) || t.blotName != null && n instanceof t) {
              o.push(n);
            }
            if (n instanceof e) {
              o = o.concat(n.descendants(t, r, i));
            }
            i -= l;
          });
          return o;
        };
        e.prototype.detach = function () {
          this.children.forEach(function (t) {
            t.detach();
          });
          t.prototype.detach.call(this);
        };
        e.prototype.formatAt = function (t, e, n, r) {
          this.children.forEachAt(t, e, function (t, e, o) {
            t.formatAt(e, o, n, r);
          });
        };
        e.prototype.insertAt = function (t, e, n) {
          var r = this.children.find(t);
          var o = r[0];
          var i = r[1];
          if (o) {
            o.insertAt(i, e, n);
          } else {
            var l = n == null ? a.create("text", e) : a.create(e, n);
            this.appendChild(l);
          }
        };
        e.prototype.insertBefore = function (t, e) {
          if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function (e) {
            return t instanceof e;
          })) {
            throw new a.ParchmentError("Cannot insert " + t.statics.blotName + " into " + this.statics.blotName);
          }
          t.insertInto(this, e);
        };
        e.prototype.length = function () {
          return this.children.reduce(function (t, e) {
            return t + e.length();
          }, 0);
        };
        e.prototype.moveChildren = function (t, e) {
          this.children.forEach(function (n) {
            t.insertBefore(n, e);
          });
        };
        e.prototype.optimize = function (e) {
          t.prototype.optimize.call(this, e);
          if (this.children.length === 0) {
            if (this.statics.defaultChild != null) {
              var n = a.create(this.statics.defaultChild);
              this.appendChild(n);
              n.optimize(e);
            } else {
              this.remove();
            }
          }
        };
        e.prototype.path = function (t, n = false) {
          var r = this.children.find(t, n);
          var o = r[0];
          var i = r[1];
          var l = [[this, t]];
          if (o instanceof e) {
            return l.concat(o.path(i, n));
          } else {
            if (o != null) {
              l.push([o, i]);
            }
            return l;
          }
        };
        e.prototype.removeChild = function (t) {
          this.children.remove(t);
        };
        e.prototype.replace = function (n) {
          if (n instanceof e) {
            n.moveChildren(this);
          }
          t.prototype.replace.call(this, n);
        };
        e.prototype.split = function (t, e = false) {
          if (!e) {
            if (t === 0) {
              return this;
            }
            if (t === this.length()) {
              return this.next;
            }
          }
          var n = this.clone();
          this.parent.insertBefore(n, this.next);
          this.children.forEachAt(t, this.length(), function (t, r, o) {
            t = t.split(r, e);
            n.appendChild(t);
          });
          return n;
        };
        e.prototype.unwrap = function () {
          this.moveChildren(this.parent, this.next);
          this.remove();
        };
        e.prototype.update = function (t, e) {
          var n = this;
          var o = [];
          var i = [];
          t.forEach(function (t) {
            if (t.target === n.domNode && t.type === "childList") {
              o.push.apply(o, t.addedNodes);
              i.push.apply(i, t.removedNodes);
            }
          });
          i.forEach(function (t) {
            if (t.parentNode == null || t.tagName === "IFRAME" || !(document.body.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
              var e = a.find(t);
              if (e != null) {
                if (e.domNode.parentNode == null || e.domNode.parentNode === n.domNode) {
                  e.detach();
                }
              }
            }
          });
          o.filter(function (t) {
            return t.parentNode == n.domNode;
          }).sort(function (t, e) {
            if (t === e) {
              return 0;
            } else if (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING) {
              return 1;
            } else {
              return -1;
            }
          }).forEach(function (t) {
            var e = null;
            if (t.nextSibling != null) {
              e = a.find(t.nextSibling);
            }
            var o = r(t);
            if (o.next != e || o.next == null) {
              if (o.parent != null) {
                o.parent.removeChild(n);
              }
              n.insertBefore(o, e || undefined);
            }
          });
        };
        return e;
      }(l.default);
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = n(11);
      var i = n(28);
      var l = n(17);
      var a = n(1);
      var s = function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          n.attributes = new i.default(n.domNode);
          return n;
        }
        r(e, t);
        e.formats = function (t) {
          return typeof this.tagName == "string" || (Array.isArray(this.tagName) ? t.tagName.toLowerCase() : undefined);
        };
        e.prototype.format = function (t, e) {
          var n = a.query(t);
          if (n instanceof o.default) {
            this.attributes.attribute(n, e);
          } else if (e) {
            if (n != null && (t !== this.statics.blotName || this.formats()[t] !== e)) {
              this.replaceWith(t, e);
            }
          }
        };
        e.prototype.formats = function () {
          var t = this.attributes.values();
          var e = this.statics.formats(this.domNode);
          if (e != null) {
            t[this.statics.blotName] = e;
          }
          return t;
        };
        e.prototype.replaceWith = function (e, n) {
          var r = t.prototype.replaceWith.call(this, e, n);
          this.attributes.copy(r);
          return r;
        };
        e.prototype.update = function (e, n) {
          var r = this;
          t.prototype.update.call(this, e, n);
          if (e.some(function (t) {
            return t.target === r.domNode && t.type === "attributes";
          })) {
            this.attributes.build();
          }
        };
        e.prototype.wrap = function (n, r) {
          var o = t.prototype.wrap.call(this, n, r);
          if (o instanceof e && o.statics.scope === this.statics.scope) {
            this.attributes.move(o);
          }
          return o;
        };
        return e;
      }(l.default);
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = n(27);
      var i = n(1);
      var l = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        r(e, t);
        e.value = function (t) {
          return true;
        };
        e.prototype.index = function (t, e) {
          if (this.domNode === t || this.domNode.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return Math.min(e, 1);
          } else {
            return -1;
          }
        };
        e.prototype.position = function (t, e) {
          var n = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
          if (t > 0) {
            n += 1;
          }
          return [this.parent.domNode, n];
        };
        e.prototype.value = function () {
          (t = {})[this.statics.blotName] = this.statics.value(this.domNode) || true;
          return t;
          var t;
        };
        e.scope = i.Scope.INLINE_BLOT;
        return e;
      }(o.default);
      e.default = l;
    }, function (t, e, n) {
      function r(t) {
        this.ops = t;
        this.index = 0;
        this.offset = 0;
      }
      var o = n(12);
      var i = n(2);
      var l = {
        attributes: {
          compose: function (t, e, n) {
            if (typeof t != "object") {
              t = {};
            }
            if (typeof e != "object") {
              e = {};
            }
            var r = i(true, {}, e);
            if (!n) {
              r = Object.keys(r).reduce(function (t, e) {
                if (r[e] != null) {
                  t[e] = r[e];
                }
                return t;
              }, {});
            }
            for (var o in t) {
              if (t[o] !== undefined && e[o] === undefined) {
                r[o] = t[o];
              }
            }
            if (Object.keys(r).length > 0) {
              return r;
            } else {
              return undefined;
            }
          },
          diff: function (t, e) {
            if (typeof t != "object") {
              t = {};
            }
            if (typeof e != "object") {
              e = {};
            }
            var n = Object.keys(t).concat(Object.keys(e)).reduce(function (n, r) {
              if (!o(t[r], e[r])) {
                n[r] = e[r] === undefined ? null : e[r];
              }
              return n;
            }, {});
            if (Object.keys(n).length > 0) {
              return n;
            } else {
              return undefined;
            }
          },
          transform: function (t, e, n) {
            if (typeof t != "object") {
              return e;
            }
            if (typeof e == "object") {
              if (!n) {
                return e;
              }
              var r = Object.keys(e).reduce(function (n, r) {
                if (t[r] === undefined) {
                  n[r] = e[r];
                }
                return n;
              }, {});
              if (Object.keys(r).length > 0) {
                return r;
              } else {
                return undefined;
              }
            }
          }
        },
        iterator: function (t) {
          return new r(t);
        },
        length: function (t) {
          if (typeof t.delete == "number") {
            return t.delete;
          } else if (typeof t.retain == "number") {
            return t.retain;
          } else if (typeof t.insert == "string") {
            return t.insert.length;
          } else {
            return 1;
          }
        }
      };
      r.prototype.hasNext = function () {
        return this.peekLength() < Infinity;
      };
      r.prototype.next = function (t) {
        t ||= Infinity;
        var e = this.ops[this.index];
        if (e) {
          var n = this.offset;
          var r = l.length(e);
          if (t >= r - n) {
            t = r - n;
            this.index += 1;
            this.offset = 0;
          } else {
            this.offset += t;
          }
          if (typeof e.delete == "number") {
            return {
              delete: t
            };
          }
          var o = {};
          if (e.attributes) {
            o.attributes = e.attributes;
          }
          if (typeof e.retain == "number") {
            o.retain = t;
          } else if (typeof e.insert == "string") {
            o.insert = e.insert.substr(n, t);
          } else {
            o.insert = e.insert;
          }
          return o;
        }
        return {
          retain: Infinity
        };
      };
      r.prototype.peek = function () {
        return this.ops[this.index];
      };
      r.prototype.peekLength = function () {
        if (this.ops[this.index]) {
          return l.length(this.ops[this.index]) - this.offset;
        } else {
          return Infinity;
        }
      };
      r.prototype.peekType = function () {
        if (this.ops[this.index]) {
          if (typeof this.ops[this.index].delete == "number") {
            return "delete";
          } else if (typeof this.ops[this.index].retain == "number") {
            return "retain";
          } else {
            return "insert";
          }
        } else {
          return "retain";
        }
      };
      t.exports = l;
    }, function (t, e) {
      var n = function () {
        "use strict";
  
        function t(t, e) {
          return e != null && t instanceof e;
        }
        function e(n, r, o, i, c) {
          if (typeof r == "object") {
            o = r.depth;
            i = r.prototype;
            c = r.includeNonEnumerable;
            r = r.circular;
          }
          var h = [];
          var p = [];
          var d = typeof Buffer != "undefined";
          if (r === undefined) {
            r = true;
          }
          if (o === undefined) {
            o = Infinity;
          }
          return function f(n, o) {
            if (n === null) {
              return null;
            }
            if (o === 0) {
              return n;
            }
            var y;
            var v;
            if (typeof n != "object") {
              return n;
            }
            if (t(n, a)) {
              y = new a();
            } else if (t(n, s)) {
              y = new s();
            } else if (t(n, u)) {
              y = new u(function (t, e) {
                n.then(function (e) {
                  t(f(e, o - 1));
                }, function (t) {
                  e(f(t, o - 1));
                });
              });
            } else if (e.__isArray(n)) {
              y = [];
            } else if (e.__isRegExp(n)) {
              y = new RegExp(n.source, l(n));
              if (n.lastIndex) {
                y.lastIndex = n.lastIndex;
              }
            } else if (e.__isDate(n)) {
              y = new Date(n.getTime());
            } else {
              if (d && Buffer.isBuffer(n)) {
                y = new Buffer(n.length);
                n.copy(y);
                return y;
              }
              if (t(n, Error)) {
                y = Object.create(n);
              } else if (i === undefined) {
                v = Object.getPrototypeOf(n);
                y = Object.create(v);
              } else {
                y = Object.create(i);
                v = i;
              }
            }
            if (r) {
              var b = h.indexOf(n);
              if (b != -1) {
                return p[b];
              }
              h.push(n);
              p.push(y);
            }
            if (t(n, a)) {
              n.forEach(function (t, e) {
                var n = f(e, o - 1);
                var r = f(t, o - 1);
                y.set(n, r);
              });
            }
            if (t(n, s)) {
              n.forEach(function (t) {
                var e = f(t, o - 1);
                y.add(e);
              });
            }
            for (var g in n) {
              var m;
              if (v) {
                m = Object.getOwnPropertyDescriptor(v, g);
              }
              if (!m || m.set != null) {
                y[g] = f(n[g], o - 1);
              }
            }
            if (Object.getOwnPropertySymbols) {
              var _ = Object.getOwnPropertySymbols(n);
              for (g = 0; g < _.length; g++) {
                var O = _[g];
                if (!(w = Object.getOwnPropertyDescriptor(n, O)) || w.enumerable || c) {
                  y[O] = f(n[O], o - 1);
                  if (!w.enumerable) {
                    Object.defineProperty(y, O, {
                      enumerable: false
                    });
                  }
                }
              }
            }
            if (c) {
              var x = Object.getOwnPropertyNames(n);
              for (g = 0; g < x.length; g++) {
                var w;
                var k = x[g];
                if (!(w = Object.getOwnPropertyDescriptor(n, k)) || !w.enumerable) {
                  y[k] = f(n[k], o - 1);
                  Object.defineProperty(y, k, {
                    enumerable: false
                  });
                }
              }
            }
            return y;
          }(n, o);
        }
        function n(t) {
          return Object.prototype.toString.call(t);
        }
        function l(t) {
          var e = "";
          if (t.global) {
            e += "g";
          }
          if (t.ignoreCase) {
            e += "i";
          }
          if (t.multiline) {
            e += "m";
          }
          return e;
        }
        var a;
        var s;
        var u;
        try {
          a = Map;
        } catch (t) {
          a = function () {};
        }
        try {
          s = Set;
        } catch (t) {
          s = function () {};
        }
        try {
          u = Promise;
        } catch (t) {
          u = function () {};
        }
        e.clonePrototype = function (t) {
          if (t === null) {
            return null;
          }
          function e() {}
          e.prototype = t;
          return new e();
        };
        e.__objToStr = n;
        e.__isDate = function r(t) {
          return typeof t == "object" && n(t) === "[object Date]";
        };
        e.__isArray = function o(t) {
          return typeof t == "object" && n(t) === "[object Array]";
        };
        e.__isRegExp = function i(t) {
          return typeof t == "object" && n(t) === "[object RegExp]";
        };
        e.__getRegExpFlags = l;
        return e;
      }();
      if (typeof t == "object" && t.exports) {
        t.exports = n;
      }
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t) {
        if (Array.isArray(t)) {
          for (var e = 0, n = Array(t.length); e < t.length; e++) {
            n[e] = t[e];
          }
          return n;
        }
        return Array.from(t);
      }
      function i(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function l(t, e) {
        try {
          e.parentNode;
        } catch (t) {
          return false;
        }
        if (e instanceof Text) {
          e = e.parentNode;
        }
        return t.contains(e);
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.Range = undefined;
      function a(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var s = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var c = r(n(0));
      var h = r(n(21));
      var d = r(n(12));
      var v = r(n(9));
      var m = (0, r(n(10)).default)("quill:selection");
      var _ = function t(e, n = 0) {
        i(this, t);
        this.index = e;
        this.length = n;
      };
      var O = function () {
        function t(e, n) {
          var r = this;
          i(this, t);
          this.emitter = n;
          this.scroll = e;
          this.composing = false;
          this.mouseDown = false;
          this.root = this.scroll.domNode;
          this.cursor = c.default.create("cursor", this);
          this.lastRange = this.savedRange = new _(0, 0);
          this.handleComposition();
          this.handleDragging();
          this.emitter.listenDOM("selectionchange", document, function () {
            if (!r.mouseDown) {
              setTimeout(r.update.bind(r, v.default.sources.USER), 1);
            }
          });
          this.emitter.on(v.default.events.EDITOR_CHANGE, function (t, e) {
            if (t === v.default.events.TEXT_CHANGE && e.length() > 0) {
              r.update(v.default.sources.SILENT);
            }
          });
          this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE, function () {
            if (r.hasFocus()) {
              var t = r.getNativeRange();
              if (t != null && t.start.node !== r.cursor.textNode) {
                r.emitter.once(v.default.events.SCROLL_UPDATE, function () {
                  try {
                    r.setNativeRange(t.start.node, t.start.offset, t.end.node, t.end.offset);
                  } catch (t) {}
                });
              }
            }
          });
          this.emitter.on(v.default.events.SCROLL_OPTIMIZE, function (t, e) {
            if (e.range) {
              var n = e.range;
              var o = n.startNode;
              var i = n.startOffset;
              var l = n.endNode;
              var a = n.endOffset;
              r.setNativeRange(o, i, l, a);
            }
          });
          this.update(v.default.sources.SILENT);
        }
        s(t, [{
          key: "handleComposition",
          value: function () {
            var t = this;
            this.root.addEventListener("compositionstart", function () {
              t.composing = true;
            });
            this.root.addEventListener("compositionend", function () {
              t.composing = false;
              if (t.cursor.parent) {
                var e = t.cursor.restore();
                if (!e) {
                  return;
                }
                setTimeout(function () {
                  t.setNativeRange(e.startNode, e.startOffset, e.endNode, e.endOffset);
                }, 1);
              }
            });
          }
        }, {
          key: "handleDragging",
          value: function () {
            var t = this;
            this.emitter.listenDOM("mousedown", document.body, function () {
              t.mouseDown = true;
            });
            this.emitter.listenDOM("mouseup", document.body, function () {
              t.mouseDown = false;
              t.update(v.default.sources.USER);
            });
          }
        }, {
          key: "focus",
          value: function () {
            if (!this.hasFocus()) {
              this.root.focus();
              this.setRange(this.savedRange);
            }
          }
        }, {
          key: "format",
          value: function (t, e) {
            if (this.scroll.whitelist == null || this.scroll.whitelist[t]) {
              this.scroll.update();
              var n = this.getNativeRange();
              if (n != null && n.native.collapsed && !c.default.query(t, c.default.Scope.BLOCK)) {
                if (n.start.node !== this.cursor.textNode) {
                  var r = c.default.find(n.start.node, false);
                  if (r == null) {
                    return;
                  }
                  if (r instanceof c.default.Leaf) {
                    var o = r.split(n.start.offset);
                    r.parent.insertBefore(this.cursor, o);
                  } else {
                    r.insertBefore(this.cursor, n.start.node);
                  }
                  this.cursor.attach();
                }
                this.cursor.format(t, e);
                this.scroll.optimize();
                this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
                this.update();
              }
            }
          }
        }, {
          key: "getBounds",
          value: function (t, e = 0) {
            var n = this.scroll.length();
            t = Math.min(t, n - 1);
            e = Math.min(t + e, n - 1) - t;
            var r = undefined;
            var o = this.scroll.leaf(t);
            var i = a(o, 2);
            var l = i[0];
            var s = i[1];
            if (l == null) {
              return null;
            }
            var u = l.position(s, true);
            var c = a(u, 2);
            r = c[0];
            s = c[1];
            var f = document.createRange();
            if (e > 0) {
              f.setStart(r, s);
              var h = this.scroll.leaf(t + e);
              var p = a(h, 2);
              l = p[0];
              s = p[1];
              if (l == null) {
                return null;
              }
              var d = l.position(s, true);
              var y = a(d, 2);
              r = y[0];
              s = y[1];
              f.setEnd(r, s);
              return f.getBoundingClientRect();
            }
            var v = "left";
            var b = undefined;
            if (r instanceof Text) {
              if (s < r.data.length) {
                f.setStart(r, s);
                f.setEnd(r, s + 1);
              } else {
                f.setStart(r, s - 1);
                f.setEnd(r, s);
                v = "right";
              }
              b = f.getBoundingClientRect();
            } else {
              b = l.domNode.getBoundingClientRect();
              if (s > 0) {
                v = "right";
              }
            }
            return {
              bottom: b.top + b.height,
              height: b.height,
              left: b[v],
              right: b[v],
              top: b.top,
              width: 0
            };
          }
        }, {
          key: "getNativeRange",
          value: function () {
            var t = document.getSelection();
            if (t == null || t.rangeCount <= 0) {
              return null;
            }
            var e = t.getRangeAt(0);
            if (e == null) {
              return null;
            }
            var n = this.normalizeNative(e);
            m.info("getNativeRange", n);
            return n;
          }
        }, {
          key: "getRange",
          value: function () {
            var t = this.getNativeRange();
            if (t == null) {
              return [null, null];
            } else {
              return [this.normalizedToRange(t), t];
            }
          }
        }, {
          key: "hasFocus",
          value: function () {
            return document.activeElement === this.root;
          }
        }, {
          key: "normalizedToRange",
          value: function (t) {
            var e = this;
            var n = [[t.start.node, t.start.offset]];
            if (!t.native.collapsed) {
              n.push([t.end.node, t.end.offset]);
            }
            var r = n.map(function (t) {
              var n = a(t, 2);
              var r = n[0];
              var o = n[1];
              var i = c.default.find(r, true);
              var l = i.offset(e.scroll);
              if (o === 0) {
                return l;
              } else if (i instanceof c.default.Container) {
                return l + i.length();
              } else {
                return l + i.index(r, o);
              }
            });
            var i = Math.min(Math.max.apply(Math, o(r)), this.scroll.length() - 1);
            var l = Math.min.apply(Math, [i].concat(o(r)));
            return new _(l, i - l);
          }
        }, {
          key: "normalizeNative",
          value: function (t) {
            if (!l(this.root, t.startContainer) || !t.collapsed && !l(this.root, t.endContainer)) {
              return null;
            }
            var e = {
              start: {
                node: t.startContainer,
                offset: t.startOffset
              },
              end: {
                node: t.endContainer,
                offset: t.endOffset
              },
              native: t
            };
            [e.start, e.end].forEach(function (t) {
              for (var e = t.node, n = t.offset; !(e instanceof Text) && e.childNodes.length > 0;) {
                if (e.childNodes.length > n) {
                  e = e.childNodes[n];
                  n = 0;
                } else {
                  if (e.childNodes.length !== n) {
                    break;
                  }
                  n = (e = e.lastChild) instanceof Text ? e.data.length : e.childNodes.length + 1;
                }
              }
              t.node = e;
              t.offset = n;
            });
            return e;
          }
        }, {
          key: "rangeToNative",
          value: function (t) {
            var e = this;
            var n = t.collapsed ? [t.index] : [t.index, t.index + t.length];
            var r = [];
            var o = this.scroll.length();
            n.forEach(function (t, n) {
              t = Math.min(o - 1, t);
              var i;
              var l = e.scroll.leaf(t);
              var s = a(l, 2);
              var u = s[0];
              var c = s[1];
              var f = u.position(c, n !== 0);
              var h = a(f, 2);
              i = h[0];
              c = h[1];
              r.push(i, c);
            });
            if (r.length < 2) {
              r = r.concat(r);
            }
            return r;
          }
        }, {
          key: "scrollIntoView",
          value: function (t) {
            var e = this.lastRange;
            if (e != null) {
              var n = this.getBounds(e.index, e.length);
              if (n != null) {
                var r = this.scroll.length() - 1;
                var o = this.scroll.line(Math.min(e.index, r));
                var l = a(o, 1)[0];
                var s = l;
                if (e.length > 0) {
                  var u = this.scroll.line(Math.min(e.index + e.length, r));
                  s = a(u, 1)[0];
                }
                if (l != null && s != null) {
                  var c = t.getBoundingClientRect();
                  if (n.top < c.top) {
                    t.scrollTop -= c.top - n.top;
                  } else if (n.bottom > c.bottom) {
                    t.scrollTop += n.bottom - c.bottom;
                  }
                }
              }
            }
          }
        }, {
          key: "setNativeRange",
          value: function (t, e, n = t, r = e, o = false) {
            m.info("setNativeRange", t, e, n, r);
            if (t == null || this.root.parentNode != null && t.parentNode != null && n.parentNode != null) {
              var i = document.getSelection();
              if (i != null) {
                if (t != null) {
                  if (!this.hasFocus()) {
                    this.root.focus();
                  }
                  var l = (this.getNativeRange() || {}).native;
                  if (l == null || o || t !== l.startContainer || e !== l.startOffset || n !== l.endContainer || r !== l.endOffset) {
                    if (t.tagName == "BR") {
                      e = [].indexOf.call(t.parentNode.childNodes, t);
                      t = t.parentNode;
                    }
                    if (n.tagName == "BR") {
                      r = [].indexOf.call(n.parentNode.childNodes, n);
                      n = n.parentNode;
                    }
                    var a = document.createRange();
                    a.setStart(t, e);
                    a.setEnd(n, r);
                    i.removeAllRanges();
                    i.addRange(a);
                  }
                } else {
                  i.removeAllRanges();
                  this.root.blur();
                  document.body.focus();
                }
              }
            }
          }
        }, {
          key: "setRange",
          value: function (t, e = false, n = v.default.sources.API) {
            if (typeof e == "string") {
              n = e;
              e = false;
            }
            m.info("setRange", t);
            if (t != null) {
              var r = this.rangeToNative(t);
              this.setNativeRange.apply(this, o(r).concat([e]));
            } else {
              this.setNativeRange(null);
            }
            this.update(n);
          }
        }, {
          key: "update",
          value: function (t = v.default.sources.USER) {
            var e = this.lastRange;
            var n = this.getRange();
            var r = a(n, 2);
            var o = r[0];
            var i = r[1];
            this.lastRange = o;
            if (this.lastRange != null) {
              this.savedRange = this.lastRange;
            }
            if (!(0, d.default)(e, this.lastRange)) {
              var l;
              if (!this.composing && i != null && i.native.collapsed && i.start.node !== this.cursor.textNode) {
                this.cursor.restore();
              }
              var u;
              var s = [v.default.events.SELECTION_CHANGE, (0, h.default)(this.lastRange), (0, h.default)(e), t];
              (l = this.emitter).emit.apply(l, [v.default.events.EDITOR_CHANGE].concat(s));
              if (t !== v.default.sources.SILENT) {
                (u = this.emitter).emit.apply(u, s);
              }
            }
          }
        }]);
        return t;
      }();
      e.Range = _;
      e.default = O;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = r(n(0));
      var u = n(3);
      var c = r(u);
      var f = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(s.default.Container);
      f.allowedChildren = [c.default, u.BlockEmbed, f];
      e.default = f;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.ColorStyle = e.ColorClass = e.ColorAttributor = undefined;
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var c = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "value",
          value: function (t) {
            var n = a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this).call(this, t);
            if (n.startsWith("rgb(")) {
              return "#" + (n = n.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "")).split(",").map(function (t) {
                return ("00" + parseInt(t).toString(16)).slice(-2);
              }).join("");
            } else {
              return n;
            }
          }
        }]);
        return e;
      }(u.default.Attributor.Style);
      var f = new u.default.Attributor.Class("color", "ql-color", {
        scope: u.default.Scope.INLINE
      });
      var h = new c("color", "color", {
        scope: u.default.Scope.INLINE
      });
      e.ColorAttributor = c;
      e.ColorClass = f;
      e.ColorStyle = h;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e, n) {
        if (e in t) {
          Object.defineProperty(t, e, {
            value: n,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          t[e] = n;
        }
        return t;
      }
      function s(t, e) {
        var n;
        var r = t === D.keys.LEFT ? "prefix" : "suffix";
        o(n = {
          key: t,
          shiftKey: e,
          altKey: null
        }, r, /^$/);
        o(n, "handler", function (n) {
          var r = n.index;
          if (t === D.keys.RIGHT) {
            r += n.length + 1;
          }
          var o = this.quill.getLeaf(r);
          return !(b(o, 1)[0] instanceof T.default.Embed) || !(t === D.keys.LEFT ? e ? this.quill.setSelection(n.index - 1, n.length + 1, S.default.sources.USER) : this.quill.setSelection(n.index - 1, S.default.sources.USER) : e ? this.quill.setSelection(n.index, n.length + 1, S.default.sources.USER) : this.quill.setSelection(n.index + n.length + 1, S.default.sources.USER), 1);
        });
        return n;
      }
      function u(t, e) {
        if (t.index !== 0 && !(this.quill.getLength() <= 1)) {
          var n = this.quill.getLine(t.index);
          var o = b(n, 1)[0];
          var i = {};
          if (e.offset === 0) {
            var l = this.quill.getLine(t.index - 1);
            var s = b(l, 1)[0];
            if (s != null && s.length() > 1) {
              var u = o.formats();
              var c = this.quill.getFormat(t.index - 1, 1);
              i = A.default.attributes.diff(u, c) || {};
            }
          }
          var f = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e.prefix) ? 2 : 1;
          this.quill.deleteText(t.index - f, f, S.default.sources.USER);
          if (Object.keys(i).length > 0) {
            this.quill.formatLine(t.index - f, f, i, S.default.sources.USER);
          }
          this.quill.focus();
        }
      }
      function c(t, e) {
        var n = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e.suffix) ? 2 : 1;
        if (!(t.index >= this.quill.getLength() - n)) {
          var r = {};
          var o = 0;
          var i = this.quill.getLine(t.index);
          var a = b(i, 1)[0];
          if (e.offset >= a.length() - 1) {
            var s = this.quill.getLine(t.index + 1);
            var c = b(s, 1)[0];
            if (c) {
              var f = a.formats();
              var h = this.quill.getFormat(t.index, 1);
              r = A.default.attributes.diff(f, h) || {};
              o = c.length();
            }
          }
          this.quill.deleteText(t.index, n, S.default.sources.USER);
          if (Object.keys(r).length > 0) {
            this.quill.formatLine(t.index + o - 1, n, r, S.default.sources.USER);
          }
        }
      }
      function f(t) {
        var e = this.quill.getLines(t);
        var n = {};
        if (e.length > 1) {
          var r = e[0].formats();
          var o = e[e.length - 1].formats();
          n = A.default.attributes.diff(o, r) || {};
        }
        this.quill.deleteText(t, S.default.sources.USER);
        if (Object.keys(n).length > 0) {
          this.quill.formatLine(t.index, 1, n, S.default.sources.USER);
        }
        this.quill.setSelection(t.index, S.default.sources.SILENT);
        this.quill.focus();
      }
      function h(t, e) {
        var n = this;
        if (t.length > 0) {
          this.quill.scroll.deleteAt(t.index, t.length);
        }
        var r = Object.keys(e.format).reduce(function (t, n) {
          if (T.default.query(n, T.default.Scope.BLOCK) && !Array.isArray(e.format[n])) {
            t[n] = e.format[n];
          }
          return t;
        }, {});
        this.quill.insertText(t.index, "\n", r, S.default.sources.USER);
        this.quill.setSelection(t.index + 1, S.default.sources.SILENT);
        this.quill.focus();
        Object.keys(e.format).forEach(function (t) {
          if (r[t] == null) {
            if (!Array.isArray(e.format[t])) {
              if (t !== "link") {
                n.quill.format(t, e.format[t], S.default.sources.USER);
              }
            }
          }
        });
      }
      function p(t) {
        return {
          key: D.keys.TAB,
          shiftKey: !t,
          format: {
            "code-block": true
          },
          handler: function (e) {
            var n = T.default.query("code-block");
            var r = e.index;
            var o = e.length;
            var i = this.quill.scroll.descendant(n, r);
            var l = b(i, 2);
            var a = l[0];
            var s = l[1];
            if (a != null) {
              var u = this.quill.getIndex(a);
              var c = a.newlineIndex(s, true) + 1;
              var f = a.newlineIndex(u + s + o);
              var h = a.domNode.textContent.slice(c, f).split("\n");
              s = 0;
              h.forEach(function (e, i) {
                if (t) {
                  a.insertAt(c + s, n.TAB);
                  s += n.TAB.length;
                  if (i === 0) {
                    r += n.TAB.length;
                  } else {
                    o += n.TAB.length;
                  }
                } else if (e.startsWith(n.TAB)) {
                  a.deleteAt(c + s, n.TAB.length);
                  s -= n.TAB.length;
                  if (i === 0) {
                    r -= n.TAB.length;
                  } else {
                    o -= n.TAB.length;
                  }
                }
                s += e.length + 1;
              });
              this.quill.update(S.default.sources.USER);
              this.quill.setSelection(r, o, S.default.sources.SILENT);
            }
          }
        };
      }
      function d(t) {
        return {
          key: t[0].toUpperCase(),
          shortKey: true,
          handler: function (e, n) {
            this.quill.format(t, !n.format[t], S.default.sources.USER);
          }
        };
      }
      function y(t) {
        if (typeof t == "string" || typeof t == "number") {
          return y({
            key: t
          });
        }
        if ((t === undefined ? "undefined" : v(t)) === "object") {
          t = (0, _.default)(t, false);
        }
        if (typeof t.key == "string") {
          if (D.keys[t.key.toUpperCase()] != null) {
            t.key = D.keys[t.key.toUpperCase()];
          } else {
            if (t.key.length !== 1) {
              return null;
            }
            t.key = t.key.toUpperCase().charCodeAt(0);
          }
        }
        if (t.shortKey) {
          t[B] = t.shortKey;
          delete t.shortKey;
        }
        return t;
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.SHORTKEY = e.default = undefined;
      var v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        if (t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof t;
        }
      };
      function b(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var g = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var _ = r(n(21));
      var w = r(n(12));
      var k = r(n(2));
      var N = r(n(4));
      var A = r(n(20));
      var T = r(n(0));
      var S = r(n(6));
      var L = r(n(10));
      var R = r(n(7));
      var I = (0, L.default)("quill:keyboard");
      var B = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
      var D = function (t) {
        function e(t, n) {
          (function i(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var r = function l(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.bindings = {};
          Object.keys(r.options.bindings).forEach(function (e) {
            if ((e !== "list autofill" || t.scroll.whitelist == null || t.scroll.whitelist.list) && r.options.bindings[e]) {
              r.addBinding(r.options.bindings[e]);
            }
          });
          r.addBinding({
            key: e.keys.ENTER,
            shiftKey: null
          }, h);
          r.addBinding({
            key: e.keys.ENTER,
            metaKey: null,
            ctrlKey: null,
            altKey: null
          }, function () {});
          if (/Firefox/i.test(navigator.userAgent)) {
            r.addBinding({
              key: e.keys.BACKSPACE
            }, {
              collapsed: true
            }, u);
            r.addBinding({
              key: e.keys.DELETE
            }, {
              collapsed: true
            }, c);
          } else {
            r.addBinding({
              key: e.keys.BACKSPACE
            }, {
              collapsed: true,
              prefix: /^.?$/
            }, u);
            r.addBinding({
              key: e.keys.DELETE
            }, {
              collapsed: true,
              suffix: /^.?$/
            }, c);
          }
          r.addBinding({
            key: e.keys.BACKSPACE
          }, {
            collapsed: false
          }, f);
          r.addBinding({
            key: e.keys.DELETE
          }, {
            collapsed: false
          }, f);
          r.addBinding({
            key: e.keys.BACKSPACE,
            altKey: null,
            ctrlKey: null,
            metaKey: null,
            shiftKey: null
          }, {
            collapsed: true,
            offset: 0
          }, u);
          r.listen();
          return r;
        }
        (function a(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        g(e, null, [{
          key: "match",
          value: function (t, e) {
            e = y(e);
            return !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function (n) {
              return !!e[n] !== t[n] && e[n] !== null;
            }) && e.key === (t.which || t.keyCode);
          }
        }]);
        g(e, [{
          key: "addBinding",
          value: function (t, e = {}, n = {}) {
            var r = y(t);
            if (r == null || r.key == null) {
              return I.warn("Attempted to add invalid keyboard binding", r);
            }
            if (typeof e == "function") {
              e = {
                handler: e
              };
            }
            if (typeof n == "function") {
              n = {
                handler: n
              };
            }
            r = (0, k.default)(r, e, n);
            this.bindings[r.key] = this.bindings[r.key] || [];
            this.bindings[r.key].push(r);
          }
        }, {
          key: "listen",
          value: function () {
            var t = this;
            this.quill.root.addEventListener("keydown", function (n) {
              if (!n.defaultPrevented) {
                var r = n.which || n.keyCode;
                var o = (t.bindings[r] || []).filter(function (t) {
                  return e.match(n, t);
                });
                if (o.length !== 0) {
                  var i = t.quill.getSelection();
                  if (i != null && t.quill.hasFocus()) {
                    var l = t.quill.getLine(i.index);
                    var a = b(l, 2);
                    var s = a[0];
                    var u = a[1];
                    var c = t.quill.getLeaf(i.index);
                    var f = b(c, 2);
                    var h = f[0];
                    var p = f[1];
                    var d = i.length === 0 ? [h, p] : t.quill.getLeaf(i.index + i.length);
                    var y = b(d, 2);
                    var g = y[0];
                    var m = y[1];
                    var _ = h instanceof T.default.Text ? h.value().slice(0, p) : "";
                    var O = g instanceof T.default.Text ? g.value().slice(m) : "";
                    var x = {
                      collapsed: i.length === 0,
                      empty: i.length === 0 && s.length() <= 1,
                      format: t.quill.getFormat(i),
                      offset: u,
                      prefix: _,
                      suffix: O
                    };
                    if (o.some(function (e) {
                      if (e.collapsed != null && e.collapsed !== x.collapsed) {
                        return false;
                      }
                      if (e.empty != null && e.empty !== x.empty) {
                        return false;
                      }
                      if (e.offset != null && e.offset !== x.offset) {
                        return false;
                      }
                      if (Array.isArray(e.format)) {
                        if (e.format.every(function (t) {
                          return x.format[t] == null;
                        })) {
                          return false;
                        }
                      } else if (v(e.format) === "object" && !Object.keys(e.format).every(function (t) {
                        if (e.format[t] === true) {
                          return x.format[t] != null;
                        } else if (e.format[t] === false) {
                          return x.format[t] == null;
                        } else {
                          return (0, w.default)(e.format[t], x.format[t]);
                        }
                      })) {
                        return false;
                      }
                      return (e.prefix == null || !!e.prefix.test(x.prefix)) && (e.suffix == null || !!e.suffix.test(x.suffix)) && e.handler.call(t, i, x) !== true;
                    })) {
                      n.preventDefault();
                    }
                  }
                }
              }
            });
          }
        }]);
        return e;
      }(R.default);
      D.keys = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46
      };
      D.DEFAULTS = {
        bindings: {
          bold: d("bold"),
          italic: d("italic"),
          underline: d("underline"),
          indent: {
            key: D.keys.TAB,
            format: ["blockquote", "indent", "list"],
            handler: function (t, e) {
              if (e.collapsed && e.offset !== 0) {
                return true;
              }
              this.quill.format("indent", "+1", S.default.sources.USER);
            }
          },
          outdent: {
            key: D.keys.TAB,
            shiftKey: true,
            format: ["blockquote", "indent", "list"],
            handler: function (t, e) {
              if (e.collapsed && e.offset !== 0) {
                return true;
              }
              this.quill.format("indent", "-1", S.default.sources.USER);
            }
          },
          "outdent backspace": {
            key: D.keys.BACKSPACE,
            collapsed: true,
            shiftKey: null,
            metaKey: null,
            ctrlKey: null,
            altKey: null,
            format: ["indent", "list"],
            offset: 0,
            handler: function (t, e) {
              if (e.format.indent != null) {
                this.quill.format("indent", "-1", S.default.sources.USER);
              } else if (e.format.list != null) {
                this.quill.format("list", false, S.default.sources.USER);
              }
            }
          },
          "indent code-block": p(true),
          "outdent code-block": p(false),
          "remove tab": {
            key: D.keys.TAB,
            shiftKey: true,
            collapsed: true,
            prefix: /\t$/,
            handler: function (t) {
              this.quill.deleteText(t.index - 1, 1, S.default.sources.USER);
            }
          },
          tab: {
            key: D.keys.TAB,
            handler: function (t) {
              this.quill.history.cutoff();
              var e = new N.default().retain(t.index).delete(t.length).insert("\t");
              this.quill.updateContents(e, S.default.sources.USER);
              this.quill.history.cutoff();
              this.quill.setSelection(t.index + 1, S.default.sources.SILENT);
            }
          },
          "list empty enter": {
            key: D.keys.ENTER,
            collapsed: true,
            format: ["list"],
            empty: true,
            handler: function (t, e) {
              this.quill.format("list", false, S.default.sources.USER);
              if (e.format.indent) {
                this.quill.format("indent", false, S.default.sources.USER);
              }
            }
          },
          "checklist enter": {
            key: D.keys.ENTER,
            collapsed: true,
            format: {
              list: "checked"
            },
            handler: function (t) {
              var e = this.quill.getLine(t.index);
              var n = b(e, 2);
              var r = n[0];
              var o = n[1];
              var i = (0, k.default)({}, r.formats(), {
                list: "checked"
              });
              var l = new N.default().retain(t.index).insert("\n", i).retain(r.length() - o - 1).retain(1, {
                list: "unchecked"
              });
              this.quill.updateContents(l, S.default.sources.USER);
              this.quill.setSelection(t.index + 1, S.default.sources.SILENT);
              this.quill.scrollIntoView();
            }
          },
          "header enter": {
            key: D.keys.ENTER,
            collapsed: true,
            format: ["header"],
            suffix: /^$/,
            handler: function (t, e) {
              var n = this.quill.getLine(t.index);
              var r = b(n, 2);
              var o = r[0];
              var i = r[1];
              var l = new N.default().retain(t.index).insert("\n", e.format).retain(o.length() - i - 1).retain(1, {
                header: null
              });
              this.quill.updateContents(l, S.default.sources.USER);
              this.quill.setSelection(t.index + 1, S.default.sources.SILENT);
              this.quill.scrollIntoView();
            }
          },
          "list autofill": {
            key: " ",
            collapsed: true,
            format: {
              list: false
            },
            prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
            handler: function (t, e) {
              var n = e.prefix.length;
              var r = this.quill.getLine(t.index);
              var o = b(r, 2);
              var i = o[0];
              var l = o[1];
              if (l > n) {
                return true;
              }
              var a = undefined;
              switch (e.prefix.trim()) {
                case "[]":
                case "[ ]":
                  a = "unchecked";
                  break;
                case "[x]":
                  a = "checked";
                  break;
                case "-":
                case "*":
                  a = "bullet";
                  break;
                default:
                  a = "ordered";
              }
              this.quill.insertText(t.index, " ", S.default.sources.USER);
              this.quill.history.cutoff();
              var s = new N.default().retain(t.index - l).delete(n + 1).retain(i.length() - 2 - l).retain(1, {
                list: a
              });
              this.quill.updateContents(s, S.default.sources.USER);
              this.quill.history.cutoff();
              this.quill.setSelection(t.index - n, S.default.sources.SILENT);
            }
          },
          "code exit": {
            key: D.keys.ENTER,
            collapsed: true,
            format: ["code-block"],
            prefix: /\n\n$/,
            suffix: /^\s+$/,
            handler: function (t) {
              var e = this.quill.getLine(t.index);
              var n = b(e, 2);
              var r = n[0];
              var o = n[1];
              var i = new N.default().retain(t.index + r.length() - o - 2).retain(1, {
                "code-block": null
              }).delete(1);
              this.quill.updateContents(i, S.default.sources.USER);
            }
          },
          "embed left": s(D.keys.LEFT, false),
          "embed left shift": s(D.keys.LEFT, true),
          "embed right": s(D.keys.RIGHT, false),
          "embed right shift": s(D.keys.RIGHT, true)
        }
      };
      e.default = D;
      e.SHORTKEY = B;
    }, function (t, e, n) {
      "use strict";
  
      t.exports = {
        align: {
          "": n(75),
          center: n(76),
          right: n(77),
          justify: n(78)
        },
        background: n(79),
        blockquote: n(80),
        bold: n(81),
        clean: n(82),
        code: n(40),
        "code-block": n(40),
        color: n(83),
        direction: {
          "": n(84),
          rtl: n(85)
        },
        float: {
          center: n(86),
          full: n(87),
          left: n(88),
          right: n(89)
        },
        formula: n(90),
        header: {
          1: n(91),
          2: n(92)
        },
        italic: n(93),
        image: n(94),
        indent: {
          "+1": n(95),
          "-1": n(96)
        },
        link: n(97),
        list: {
          ordered: n(98),
          bullet: n(99),
          check: n(100)
        },
        script: {
          sub: n(101),
          super: n(102)
        },
        strike: n(103),
        underline: n(104),
        video: n(105)
      };
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var r = n(1);
      var o = function () {
        function t(t) {
          this.domNode = t;
          this.domNode[r.DATA_KEY] = {
            blot: this
          };
        }
        Object.defineProperty(t.prototype, "statics", {
          get: function () {
            return this.constructor;
          },
          enumerable: true,
          configurable: true
        });
        t.create = function (t) {
          if (this.tagName == null) {
            throw new r.ParchmentError("Blot definition missing tagName");
          }
          var e;
          if (Array.isArray(this.tagName)) {
            if (typeof t == "string") {
              t = t.toUpperCase();
              if (parseInt(t).toString() === t) {
                t = parseInt(t);
              }
            }
            e = typeof t == "number" ? document.createElement(this.tagName[t - 1]) : this.tagName.indexOf(t) > -1 ? document.createElement(t) : document.createElement(this.tagName[0]);
          } else {
            e = document.createElement(this.tagName);
          }
          if (this.className) {
            e.classList.add(this.className);
          }
          return e;
        };
        t.prototype.attach = function () {
          if (this.parent != null) {
            this.scroll = this.parent.scroll;
          }
        };
        t.prototype.clone = function () {
          var t = this.domNode.cloneNode(false);
          return r.create(t);
        };
        t.prototype.detach = function () {
          if (this.parent != null) {
            this.parent.removeChild(this);
          }
          delete this.domNode[r.DATA_KEY];
        };
        t.prototype.deleteAt = function (t, e) {
          this.isolate(t, e).remove();
        };
        t.prototype.formatAt = function (t, e, n, o) {
          var i = this.isolate(t, e);
          if (r.query(n, r.Scope.BLOT) != null && o) {
            i.wrap(n, o);
          } else if (r.query(n, r.Scope.ATTRIBUTE) != null) {
            var l = r.create(this.statics.scope);
            i.wrap(l);
            l.format(n, o);
          }
        };
        t.prototype.insertAt = function (t, e, n) {
          var o = n == null ? r.create("text", e) : r.create(e, n);
          var i = this.split(t);
          this.parent.insertBefore(o, i);
        };
        t.prototype.insertInto = function (t, e = null) {
          if (this.parent != null) {
            this.parent.children.remove(this);
          }
          var n = null;
          t.children.insertBefore(this, e);
          if (e != null) {
            n = e.domNode;
          }
          if (this.domNode.parentNode != t.domNode || this.domNode.nextSibling != n) {
            t.domNode.insertBefore(this.domNode, n);
          }
          this.parent = t;
          this.attach();
        };
        t.prototype.isolate = function (t, e) {
          var n = this.split(t);
          n.split(e);
          return n;
        };
        t.prototype.length = function () {
          return 1;
        };
        t.prototype.offset = function (t = this.parent) {
          if (this.parent == null || this == t) {
            return 0;
          } else {
            return this.parent.children.offset(this) + this.parent.offset(t);
          }
        };
        t.prototype.optimize = function (t) {
          if (this.domNode[r.DATA_KEY] != null) {
            delete this.domNode[r.DATA_KEY].mutations;
          }
        };
        t.prototype.remove = function () {
          if (this.domNode.parentNode != null) {
            this.domNode.parentNode.removeChild(this.domNode);
          }
          this.detach();
        };
        t.prototype.replace = function (t) {
          if (t.parent != null) {
            t.parent.insertBefore(this, t.next);
            t.remove();
          }
        };
        t.prototype.replaceWith = function (t, e) {
          var n = typeof t == "string" ? r.create(t, e) : t;
          n.replace(this);
          return n;
        };
        t.prototype.split = function (t, e) {
          if (t === 0) {
            return this;
          } else {
            return this.next;
          }
        };
        t.prototype.update = function (t, e) {};
        t.prototype.wrap = function (t, e) {
          var n = typeof t == "string" ? r.create(t, e) : t;
          if (this.parent != null) {
            this.parent.insertBefore(n, this.next);
          }
          n.appendChild(this);
          return n;
        };
        t.blotName = "abstract";
        return t;
      }();
      e.default = o;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var r = n(11);
      var o = n(29);
      var i = n(30);
      var l = n(1);
      var a = function () {
        function t(t) {
          this.attributes = {};
          this.domNode = t;
          this.build();
        }
        t.prototype.attribute = function (t, e) {
          if (e) {
            if (t.add(this.domNode, e)) {
              if (t.value(this.domNode) != null) {
                this.attributes[t.attrName] = t;
              } else {
                delete this.attributes[t.attrName];
              }
            }
          } else {
            t.remove(this.domNode);
            delete this.attributes[t.attrName];
          }
        };
        t.prototype.build = function () {
          var t = this;
          this.attributes = {};
          var e = r.default.keys(this.domNode);
          var n = o.default.keys(this.domNode);
          var a = i.default.keys(this.domNode);
          e.concat(n).concat(a).forEach(function (e) {
            var n = l.query(e, l.Scope.ATTRIBUTE);
            if (n instanceof r.default) {
              t.attributes[n.attrName] = n;
            }
          });
        };
        t.prototype.copy = function (t) {
          var e = this;
          Object.keys(this.attributes).forEach(function (n) {
            var r = e.attributes[n].value(e.domNode);
            t.format(n, r);
          });
        };
        t.prototype.move = function (t) {
          var e = this;
          this.copy(t);
          Object.keys(this.attributes).forEach(function (t) {
            e.attributes[t].remove(e.domNode);
          });
          this.attributes = {};
        };
        t.prototype.values = function () {
          var t = this;
          return Object.keys(this.attributes).reduce(function (e, n) {
            e[n] = t.attributes[n].value(t.domNode);
            return e;
          }, {});
        };
        return t;
      }();
      e.default = a;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        return (t.getAttribute("class") || "").split(/\s+/).filter(function (t) {
          return t.indexOf(e + "-") === 0;
        });
      }
      var o = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        o(e, t);
        e.keys = function (t) {
          return (t.getAttribute("class") || "").split(/\s+/).map(function (t) {
            return t.split("-").slice(0, -1).join("-");
          });
        };
        e.prototype.add = function (t, e) {
          return !!this.canAdd(t, e) && (this.remove(t), t.classList.add(this.keyName + "-" + e), true);
        };
        e.prototype.remove = function (t) {
          r(t, this.keyName).forEach(function (e) {
            t.classList.remove(e);
          });
          if (t.classList.length === 0) {
            t.removeAttribute("class");
          }
        };
        e.prototype.value = function (t) {
          var n = (r(t, this.keyName)[0] || "").slice(this.keyName.length + 1);
          if (this.canAdd(t, n)) {
            return n;
          } else {
            return "";
          }
        };
        return e;
      }(n(11).default);
      e.default = l;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        var e = t.split("-");
        var n = e.slice(1).map(function (t) {
          return t[0].toUpperCase() + t.slice(1);
        }).join("");
        return e[0] + n;
      }
      var o = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        o(e, t);
        e.keys = function (t) {
          return (t.getAttribute("style") || "").split(";").map(function (t) {
            return t.split(":")[0].trim();
          });
        };
        e.prototype.add = function (t, e) {
          return !!this.canAdd(t, e) && (t.style[r(this.keyName)] = e, true);
        };
        e.prototype.remove = function (t) {
          t.style[r(this.keyName)] = "";
          if (!t.getAttribute("style")) {
            t.removeAttribute("style");
          }
        };
        e.prototype.value = function (t) {
          var e = t.style[r(this.keyName)];
          if (this.canAdd(t, e)) {
            return e;
          } else {
            return "";
          }
        };
        return e;
      }(n(11).default);
      e.default = l;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      function a(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var f = r(n(0));
      var p = r(n(8));
      var d = function (t) {
        function e(t, n) {
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var r = function i(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          r.selection = n;
          r.textNode = document.createTextNode(e.CONTENTS);
          r.domNode.appendChild(r.textNode);
          r._length = 0;
          return r;
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        u(e, null, [{
          key: "value",
          value: function () {}
        }]);
        u(e, [{
          key: "detach",
          value: function () {
            if (this.parent != null) {
              this.parent.removeChild(this);
            }
          }
        }, {
          key: "format",
          value: function (t, n) {
            if (this._length !== 0) {
              return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            }
            for (var r = this, o = 0; r != null && r.statics.scope !== f.default.Scope.BLOCK_BLOT;) {
              o += r.offset(r.parent);
              r = r.parent;
            }
            if (r != null) {
              this._length = e.CONTENTS.length;
              r.optimize();
              r.formatAt(o, e.CONTENTS.length, t, n);
              this._length = 0;
            }
          }
        }, {
          key: "index",
          value: function (t, n) {
            if (t === this.textNode) {
              return 0;
            } else {
              return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "index", this).call(this, t, n);
            }
          }
        }, {
          key: "length",
          value: function () {
            return this._length;
          }
        }, {
          key: "position",
          value: function () {
            return [this.textNode, this.textNode.data.length];
          }
        }, {
          key: "remove",
          value: function () {
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "remove", this).call(this);
            this.parent = null;
          }
        }, {
          key: "restore",
          value: function () {
            if (!this.selection.composing && this.parent != null) {
              var t = this.textNode;
              var n = this.selection.getNativeRange();
              var r = undefined;
              var o = undefined;
              var i = undefined;
              if (n != null && n.start.node === t && n.end.node === t) {
                var l = [t, n.start.offset, n.end.offset];
                r = l[0];
                o = l[1];
                i = l[2];
              }
              while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
              }
              if (this.textNode.data !== e.CONTENTS) {
                var s = this.textNode.data.split(e.CONTENTS).join("");
                if (this.next instanceof p.default) {
                  r = this.next.domNode;
                  this.next.insertAt(0, s);
                  this.textNode.data = e.CONTENTS;
                } else {
                  this.textNode.data = s;
                  this.parent.insertBefore(f.default.create(this.textNode), this);
                  this.textNode = document.createTextNode(e.CONTENTS);
                  this.domNode.appendChild(this.textNode);
                }
              }
              this.remove();
              if (o != null) {
                var u = [o, i].map(function (t) {
                  return Math.max(0, Math.min(r.data.length, t - 1));
                });
                var c = a(u, 2);
                o = c[0];
                i = c[1];
                return {
                  startNode: r,
                  startOffset: o,
                  endNode: r,
                  endOffset: i
                };
              }
            }
          }
        }, {
          key: "update",
          value: function (t, e) {
            var n = this;
            if (t.some(function (t) {
              return t.type === "characterData" && t.target === n.textNode;
            })) {
              var r = this.restore();
              if (r) {
                e.range = r;
              }
            }
          }
        }, {
          key: "value",
          value: function () {
            return "";
          }
        }]);
        return e;
      }(f.default.Embed);
      d.blotName = "cursor";
      d.className = "ql-cursor";
      d.tagName = "span";
      d.CONTENTS = "";
      e.default = d;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var i = function () {
        function t(e, n) {
          (function r(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, t);
          this.quill = e;
          this.options = n;
          this.modules = {};
        }
        o(t, [{
          key: "init",
          value: function () {
            var t = this;
            Object.keys(this.options.modules).forEach(function (e) {
              if (t.modules[e] == null) {
                t.addModule(e);
              }
            });
          }
        }, {
          key: "addModule",
          value: function (t) {
            var e = this.quill.constructor.import("modules/" + t);
            this.modules[t] = new e(this.quill, this.options.modules[t] || {});
            return this.modules[t];
          }
        }]);
        return t;
      }();
      i.DEFAULTS = {
        modules: {}
      };
      i.themes = {
        default: i
      };
      e.default = i;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = r(n(0));
      var h = r(n(8));
      var p = "";
      var d = function (t) {
        function e(t) {
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var n = function i(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          n.contentNode = document.createElement("span");
          n.contentNode.setAttribute("contenteditable", false);
          [].slice.call(n.domNode.childNodes).forEach(function (t) {
            n.contentNode.appendChild(t);
          });
          n.leftGuard = document.createTextNode(p);
          n.rightGuard = document.createTextNode(p);
          n.domNode.appendChild(n.leftGuard);
          n.domNode.appendChild(n.contentNode);
          n.domNode.appendChild(n.rightGuard);
          return n;
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        a(e, [{
          key: "index",
          value: function (t, n) {
            if (t === this.leftGuard) {
              return 0;
            } else if (t === this.rightGuard) {
              return 1;
            } else {
              return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "index", this).call(this, t, n);
            }
          }
        }, {
          key: "restore",
          value: function (t) {
            var e = undefined;
            var n = undefined;
            var r = t.data.split(p).join("");
            if (t === this.leftGuard) {
              if (this.prev instanceof h.default) {
                var o = this.prev.length();
                this.prev.insertAt(o, r);
                e = {
                  startNode: this.prev.domNode,
                  startOffset: o + r.length
                };
              } else {
                n = document.createTextNode(r);
                this.parent.insertBefore(c.default.create(n), this);
                e = {
                  startNode: n,
                  startOffset: r.length
                };
              }
            } else if (t === this.rightGuard) {
              if (this.next instanceof h.default) {
                this.next.insertAt(0, r);
                e = {
                  startNode: this.next.domNode,
                  startOffset: r.length
                };
              } else {
                n = document.createTextNode(r);
                this.parent.insertBefore(c.default.create(n), this.next);
                e = {
                  startNode: n,
                  startOffset: r.length
                };
              }
            }
            t.data = p;
            return e;
          }
        }, {
          key: "update",
          value: function (t, e) {
            var n = this;
            t.forEach(function (t) {
              if (t.type === "characterData" && (t.target === n.leftGuard || t.target === n.rightGuard)) {
                var r = n.restore(t.target);
                if (r) {
                  e.range = r;
                }
              }
            });
          }
        }]);
        return e;
      }(c.default.Embed);
      e.default = d;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.AlignStyle = e.AlignClass = e.AlignAttribute = undefined;
      var o = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var i = {
        scope: o.default.Scope.BLOCK,
        whitelist: ["right", "center", "justify"]
      };
      var l = new o.default.Attributor.Attribute("align", "align", i);
      var a = new o.default.Attributor.Class("align", "ql-align", i);
      var s = new o.default.Attributor.Style("align", "text-align", i);
      e.AlignAttribute = l;
      e.AlignClass = a;
      e.AlignStyle = s;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.BackgroundStyle = e.BackgroundClass = undefined;
      var o = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var i = n(24);
      var l = new o.default.Attributor.Class("background", "ql-bg", {
        scope: o.default.Scope.INLINE
      });
      var a = new i.ColorAttributor("background", "background-color", {
        scope: o.default.Scope.INLINE
      });
      e.BackgroundClass = l;
      e.BackgroundStyle = a;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.DirectionStyle = e.DirectionClass = e.DirectionAttribute = undefined;
      var o = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var i = {
        scope: o.default.Scope.BLOCK,
        whitelist: ["rtl"]
      };
      var l = new o.default.Attributor.Attribute("direction", "dir", i);
      var a = new o.default.Attributor.Class("direction", "ql-direction", i);
      var s = new o.default.Attributor.Style("direction", "direction", i);
      e.DirectionAttribute = l;
      e.DirectionClass = a;
      e.DirectionStyle = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.FontClass = e.FontStyle = undefined;
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var c = {
        scope: u.default.Scope.INLINE,
        whitelist: ["serif", "monospace"]
      };
      var f = new u.default.Attributor.Class("font", "ql-font", c);
      var p = new (function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "value",
          value: function (t) {
            return a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this).call(this, t).replace(/["']/g, "");
          }
        }]);
        return e;
      }(u.default.Attributor.Style))("font", "font-family", c);
      e.FontStyle = p;
      e.FontClass = f;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.SizeStyle = e.SizeClass = undefined;
      var o = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var i = new o.default.Attributor.Class("size", "ql-size", {
        scope: o.default.Scope.INLINE,
        whitelist: ["small", "large", "huge"]
      });
      var l = new o.default.Attributor.Style("size", "font-size", {
        scope: o.default.Scope.INLINE,
        whitelist: ["10px", "18px", "32px"]
      });
      e.SizeClass = i;
      e.SizeStyle = l;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "optimize",
          value: function (t) {
            a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t);
            if (this.domNode.tagName !== this.statics.tagName[0]) {
              this.replaceWith(this.statics.blotName);
            }
          }
        }], [{
          key: "create",
          value: function () {
            return a(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this);
          }
        }, {
          key: "formats",
          value: function () {
            return true;
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(5)).default);
      c.blotName = "bold";
      c.tagName = ["STRONG", "B"];
      e.default = c;
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = function (t) {
        function e(t, n) {
          (function r(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var i = function o(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          i.label.innerHTML = n;
          i.container.classList.add("ql-color-picker");
          [].slice.call(i.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function (t) {
            t.classList.add("ql-primary");
          });
          return i;
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "buildItem",
          value: function (t) {
            var n = a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "buildItem", this).call(this, t);
            n.style.backgroundColor = t.getAttribute("value") || "";
            return n;
          }
        }, {
          key: "selectItem",
          value: function (t, n) {
            a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "selectItem", this).call(this, t, n);
            var r = this.label.querySelector(".ql-color-label");
            var o = t && t.getAttribute("data-value") || "";
            if (r) {
              if (r.tagName === "line") {
                r.style.stroke = o;
              } else {
                r.style.fill = o;
              }
            }
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(16)).default);
      e.default = c;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = function (t) {
        function e(t, n) {
          (function r(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var i = function o(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          i.container.classList.add("ql-icon-picker");
          [].forEach.call(i.container.querySelectorAll(".ql-picker-item"), function (t) {
            t.innerHTML = n[t.getAttribute("data-value") || ""];
          });
          i.defaultItem = i.container.querySelector(".ql-selected");
          i.selectItem(i.defaultItem);
          return i;
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "selectItem",
          value: function (t, n) {
            a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "selectItem", this).call(this, t, n);
            t = t || this.defaultItem;
            this.label.innerHTML = t.innerHTML;
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(16)).default);
      e.default = c;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var i = function () {
        function t(e, n) {
          var o = this;
          (function r(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, t);
          this.quill = e;
          this.boundsContainer = n || document.body;
          this.root = e.addContainer("ql-tooltip");
          this.root.innerHTML = this.constructor.TEMPLATE;
          if (this.quill.root === this.quill.scrollingContainer) {
            this.quill.root.addEventListener("scroll", function () {
              o.root.style.marginTop = o.quill.root.scrollTop * -1 + "px";
            });
          }
          this.hide();
        }
        o(t, [{
          key: "hide",
          value: function () {
            this.root.classList.add("ql-hidden");
          }
        }, {
          key: "position",
          value: function (t) {
            var e = t.left + t.width / 2 - this.root.offsetWidth / 2;
            var n = t.bottom + this.quill.root.scrollTop;
            this.root.style.left = e + "px";
            this.root.style.top = n + "px";
            this.root.classList.remove("ql-flip");
            var r = this.boundsContainer.getBoundingClientRect();
            var o = this.root.getBoundingClientRect();
            var i = 0;
            if (o.right > r.right) {
              i = r.right - o.right;
              this.root.style.left = e + i + "px";
            }
            if (o.left < r.left) {
              i = r.left - o.left;
              this.root.style.left = e + i + "px";
            }
            if (o.bottom > r.bottom) {
              var l = o.bottom - o.top;
              var a = t.bottom - t.top + l;
              this.root.style.top = n - a + "px";
              this.root.classList.add("ql-flip");
            }
            return i;
          }
        }, {
          key: "show",
          value: function () {
            this.root.classList.remove("ql-editing");
            this.root.classList.remove("ql-hidden");
          }
        }]);
        return t;
      }();
      e.default = i;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      function s(t, e, n = false) {
        e.forEach(function (e) {
          var r = document.createElement("option");
          if (e === n) {
            r.setAttribute("selected", "selected");
          } else {
            r.setAttribute("value", e);
          }
          t.appendChild(r);
        });
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.BaseTooltip = undefined;
      var u = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var c = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var h = r(n(2));
      var d = r(n(4));
      var v = r(n(9));
      var g = r(n(25));
      var _ = r(n(32));
      var w = r(n(41));
      var k = r(n(42));
      var N = r(n(16));
      var A = r(n(43));
      var q = [false, "center", "right", "justify"];
      var T = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
      var P = [false, "serif", "monospace"];
      var S = ["1", "2", "3", false];
      var C = ["small", false, "large", "huge"];
      var L = function (t) {
        function e(t, n) {
          o(this, e);
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          t.emitter.listenDOM("click", document.body, function e(n) {
            if (!document.body.contains(t.root)) {
              return document.body.removeEventListener("click", e);
            }
            if (r.tooltip != null && !r.tooltip.root.contains(n.target) && document.activeElement !== r.tooltip.textbox && !r.quill.hasFocus()) {
              r.tooltip.hide();
            }
            if (r.pickers != null) {
              r.pickers.forEach(function (t) {
                if (!t.container.contains(n.target)) {
                  t.close();
                }
              });
            }
          });
          return r;
        }
        l(e, t);
        u(e, [{
          key: "addModule",
          value: function (t) {
            var n = c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "addModule", this).call(this, t);
            if (t === "toolbar") {
              this.extendToolbar(n);
            }
            return n;
          }
        }, {
          key: "buildButtons",
          value: function (t, e) {
            t.forEach(function (t) {
              (t.getAttribute("class") || "").split(/\s+/).forEach(function (n) {
                if (n.startsWith("ql-") && (n = n.slice("ql-".length), e[n] != null)) {
                  if (n === "direction") {
                    t.innerHTML = e[n][""] + e[n].rtl;
                  } else if (typeof e[n] == "string") {
                    t.innerHTML = e[n];
                  } else {
                    var r = t.value || "";
                    if (r != null && e[n][r]) {
                      t.innerHTML = e[n][r];
                    }
                  }
                }
              });
            });
          }
        }, {
          key: "buildPickers",
          value: function (t, e) {
            var n = this;
            this.pickers = t.map(function (t) {
              if (t.classList.contains("ql-align")) {
                if (t.querySelector("option") == null) {
                  s(t, q);
                }
                return new k.default(t, e.align);
              }
              if (t.classList.contains("ql-background") || t.classList.contains("ql-color")) {
                var n = t.classList.contains("ql-background") ? "background" : "color";
                if (t.querySelector("option") == null) {
                  s(t, T, n === "background" ? "#ffffff" : "#000000");
                }
                return new w.default(t, e[n]);
              }
              if (t.querySelector("option") == null) {
                if (t.classList.contains("ql-font")) {
                  s(t, P);
                } else if (t.classList.contains("ql-header")) {
                  s(t, S);
                } else if (t.classList.contains("ql-size")) {
                  s(t, C);
                }
              }
              return new N.default(t);
            });
            this.quill.on(v.default.events.EDITOR_CHANGE, function () {
              n.pickers.forEach(function (t) {
                t.update();
              });
            });
          }
        }]);
        return e;
      }(_.default);
      L.DEFAULTS = (0, h.default)(true, {}, _.default.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              formula: function () {
                this.quill.theme.tooltip.edit("formula");
              },
              image: function () {
                var t = this;
                var e = this.container.querySelector("input.ql-image[type=file]");
                if (e == null) {
                  (e = document.createElement("input")).setAttribute("type", "file");
                  e.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon");
                  e.classList.add("ql-image");
                  e.addEventListener("change", function () {
                    if (e.files != null && e.files[0] != null) {
                      var n = new FileReader();
                      n.onload = function (n) {
                        var r = t.quill.getSelection(true);
                        t.quill.updateContents(new d.default().retain(r.index).delete(r.length).insert({
                          image: n.target.result
                        }), v.default.sources.USER);
                        t.quill.setSelection(r.index + 1, v.default.sources.SILENT);
                        e.value = "";
                      };
                      n.readAsDataURL(e.files[0]);
                    }
                  });
                  this.container.appendChild(e);
                }
                e.click();
              },
              video: function () {
                this.quill.theme.tooltip.edit("video");
              }
            }
          }
        }
      });
      var M = function (t) {
        function e(t, n) {
          o(this, e);
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.textbox = r.root.querySelector("input[type=\"text\"]");
          r.listen();
          return r;
        }
        l(e, t);
        u(e, [{
          key: "listen",
          value: function () {
            var t = this;
            this.textbox.addEventListener("keydown", function (e) {
              if (g.default.match(e, "enter")) {
                t.save();
                e.preventDefault();
              } else if (g.default.match(e, "escape")) {
                t.cancel();
                e.preventDefault();
              }
            });
          }
        }, {
          key: "cancel",
          value: function () {
            this.hide();
          }
        }, {
          key: "edit",
          value: function (t = "link", e = null) {
            this.root.classList.remove("ql-hidden");
            this.root.classList.add("ql-editing");
            if (e != null) {
              this.textbox.value = e;
            } else if (t !== this.root.getAttribute("data-mode")) {
              this.textbox.value = "";
            }
            this.position(this.quill.getBounds(this.quill.selection.savedRange));
            this.textbox.select();
            this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + t) || "");
            this.root.setAttribute("data-mode", t);
          }
        }, {
          key: "restoreFocus",
          value: function () {
            var t = this.quill.scrollingContainer.scrollTop;
            this.quill.focus();
            this.quill.scrollingContainer.scrollTop = t;
          }
        }, {
          key: "save",
          value: function () {
            var t = this.textbox.value;
            switch (this.root.getAttribute("data-mode")) {
              case "link":
                var e = this.quill.root.scrollTop;
                if (this.linkRange) {
                  this.quill.formatText(this.linkRange, "link", t, v.default.sources.USER);
                  delete this.linkRange;
                } else {
                  this.restoreFocus();
                  this.quill.format("link", t, v.default.sources.USER);
                }
                this.quill.root.scrollTop = e;
                break;
              case "video":
                t = function a(t) {
                  var e = t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                  if (e) {
                    return (e[1] || "https") + "://www.youtube.com/embed/" + e[2] + "?showinfo=0";
                  } else if (e = t.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
                    return (e[1] || "https") + "://player.vimeo.com/video/" + e[2] + "/";
                  } else {
                    return t;
                  }
                }(t);
              case "formula":
                if (!t) {
                  break;
                }
                var n = this.quill.getSelection(true);
                if (n != null) {
                  var r = n.index + n.length;
                  this.quill.insertEmbed(r, this.root.getAttribute("data-mode"), t, v.default.sources.USER);
                  if (this.root.getAttribute("data-mode") === "formula") {
                    this.quill.insertText(r + 1, " ", v.default.sources.USER);
                  }
                  this.quill.setSelection(r + 2, v.default.sources.USER);
                }
            }
            this.textbox.value = "";
            this.hide();
          }
        }]);
        return e;
      }(A.default);
      e.BaseTooltip = M;
      e.default = L;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = r(n(46));
      var l = n(34);
      var a = n(36);
      var s = n(62);
      var c = r(n(63));
      var h = r(n(64));
      var p = n(65);
      var d = r(p);
      var y = n(35);
      var v = n(24);
      var b = n(37);
      var g = n(38);
      var _ = r(n(39));
      var w = r(n(66));
      var k = r(n(15));
      var N = r(n(67));
      var A = r(n(68));
      var T = r(n(69));
      var S = r(n(70));
      var L = r(n(71));
      var M = n(13);
      var R = r(M);
      var B = r(n(72));
      var U = r(n(73));
      var H = r(n(74));
      var z = r(n(26));
      var V = r(n(16));
      var G = r(n(41));
      var X = r(n(42));
      var Q = r(n(43));
      var tt = r(n(107));
      var nt = r(n(108));
      i.default.register({
        "attributors/attribute/direction": a.DirectionAttribute,
        "attributors/class/align": l.AlignClass,
        "attributors/class/background": y.BackgroundClass,
        "attributors/class/color": v.ColorClass,
        "attributors/class/direction": a.DirectionClass,
        "attributors/class/font": b.FontClass,
        "attributors/class/size": g.SizeClass,
        "attributors/style/align": l.AlignStyle,
        "attributors/style/background": y.BackgroundStyle,
        "attributors/style/color": v.ColorStyle,
        "attributors/style/direction": a.DirectionStyle,
        "attributors/style/font": b.FontStyle,
        "attributors/style/size": g.SizeStyle
      }, true);
      i.default.register({
        "formats/align": l.AlignClass,
        "formats/direction": a.DirectionClass,
        "formats/indent": s.IndentClass,
        "formats/background": y.BackgroundStyle,
        "formats/color": v.ColorStyle,
        "formats/font": b.FontClass,
        "formats/size": g.SizeClass,
        "formats/blockquote": c.default,
        "formats/code-block": R.default,
        "formats/header": h.default,
        "formats/list": d.default,
        "formats/bold": _.default,
        "formats/code": M.Code,
        "formats/italic": w.default,
        "formats/link": k.default,
        "formats/script": N.default,
        "formats/strike": A.default,
        "formats/underline": T.default,
        "formats/image": S.default,
        "formats/video": L.default,
        "formats/list/item": p.ListItem,
        "modules/formula": B.default,
        "modules/syntax": U.default,
        "modules/toolbar": H.default,
        "themes/bubble": tt.default,
        "themes/snow": nt.default,
        "ui/icons": z.default,
        "ui/picker": V.default,
        "ui/icon-picker": X.default,
        "ui/color-picker": G.default,
        "ui/tooltip": Q.default
      }, true);
      e.default = i.default;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = r(n(0));
      var a = r(n(6));
      var s = n(3);
      var u = r(s);
      var f = r(n(14));
      var p = r(n(23));
      var y = r(n(31));
      var b = r(n(33));
      var m = r(n(5));
      var O = r(n(59));
      var x = r(n(8));
      var E = r(n(60));
      var j = r(n(61));
      var q = r(n(25));
      a.default.register({
        "blots/block": u.default,
        "blots/block/embed": s.BlockEmbed,
        "blots/break": f.default,
        "blots/container": p.default,
        "blots/cursor": y.default,
        "blots/embed": b.default,
        "blots/inline": m.default,
        "blots/scroll": O.default,
        "blots/text": x.default,
        "modules/clipboard": E.default,
        "modules/history": j.default,
        "modules/keyboard": q.default
      });
      i.default.register(u.default, f.default, y.default, m.default, O.default, x.default);
      e.default = a.default;
    }, function (t, e, n) {
      "use strict";
  
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var r = function () {
        function t() {
          this.head = this.tail = null;
          this.length = 0;
        }
        t.prototype.append = function () {
          var t = [];
          for (var e = 0; e < arguments.length; e++) {
            t[e] = arguments[e];
          }
          this.insertBefore(t[0], null);
          if (t.length > 1) {
            this.append.apply(this, t.slice(1));
          }
        };
        t.prototype.contains = function (t) {
          for (var e, n = this.iterator(); e = n();) {
            if (e === t) {
              return true;
            }
          }
          return false;
        };
        t.prototype.insertBefore = function (t, e) {
          if (t) {
            t.next = e;
            if (e != null) {
              t.prev = e.prev;
              if (e.prev != null) {
                e.prev.next = t;
              }
              e.prev = t;
              if (e === this.head) {
                this.head = t;
              }
            } else if (this.tail != null) {
              this.tail.next = t;
              t.prev = this.tail;
              this.tail = t;
            } else {
              t.prev = null;
              this.head = this.tail = t;
            }
            this.length += 1;
          }
        };
        t.prototype.offset = function (t) {
          var e = 0;
          for (var n = this.head; n != null;) {
            if (n === t) {
              return e;
            }
            e += n.length();
            n = n.next;
          }
          return -1;
        };
        t.prototype.remove = function (t) {
          if (this.contains(t)) {
            if (t.prev != null) {
              t.prev.next = t.next;
            }
            if (t.next != null) {
              t.next.prev = t.prev;
            }
            if (t === this.head) {
              this.head = t.next;
            }
            if (t === this.tail) {
              this.tail = t.prev;
            }
            this.length -= 1;
          }
        };
        t.prototype.iterator = function (t = this.head) {
          return function () {
            var e = t;
            if (t != null) {
              t = t.next;
            }
            return e;
          };
        };
        t.prototype.find = function (t, e = false) {
          for (var n, r = this.iterator(); n = r();) {
            var o = n.length();
            if (t < o || e && t === o && (n.next == null || n.next.length() !== 0)) {
              return [n, t];
            }
            t -= o;
          }
          return [null, 0];
        };
        t.prototype.forEach = function (t) {
          for (var e, n = this.iterator(); e = n();) {
            t(e);
          }
        };
        t.prototype.forEachAt = function (t, e, n) {
          if (!(e <= 0)) {
            for (var r, o = this.find(t), i = o[0], a = t - o[1], s = this.iterator(i); (r = s()) && a < t + e;) {
              var u = r.length();
              if (t > a) {
                n(r, t - a, Math.min(e, a + u - t));
              } else {
                n(r, 0, Math.min(u, t + e - a));
              }
              a += u;
            }
          }
        };
        t.prototype.map = function (t) {
          return this.reduce(function (e, n) {
            e.push(t(n));
            return e;
          }, []);
        };
        t.prototype.reduce = function (t, e) {
          for (var n, r = this.iterator(); n = r();) {
            e = t(e, n);
          }
          return e;
        };
        return t;
      }();
      e.default = r;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = n(17);
      var i = n(1);
      var l = {
        attributes: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true
      };
      var a = function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          n.scroll = n;
          n.observer = new MutationObserver(function (t) {
            n.update(t);
          });
          n.observer.observe(n.domNode, l);
          n.attach();
          return n;
        }
        r(e, t);
        e.prototype.detach = function () {
          t.prototype.detach.call(this);
          this.observer.disconnect();
        };
        e.prototype.deleteAt = function (e, n) {
          this.update();
          if (e === 0 && n === this.length()) {
            this.children.forEach(function (t) {
              t.remove();
            });
          } else {
            t.prototype.deleteAt.call(this, e, n);
          }
        };
        e.prototype.formatAt = function (e, n, r, o) {
          this.update();
          t.prototype.formatAt.call(this, e, n, r, o);
        };
        e.prototype.insertAt = function (e, n, r) {
          this.update();
          t.prototype.insertAt.call(this, e, n, r);
        };
        e.prototype.optimize = function (e, n) {
          var r = this;
          if (e === undefined) {
            e = [];
          }
          if (n === undefined) {
            n = {};
          }
          t.prototype.optimize.call(this, n);
          for (var l = [].slice.call(this.observer.takeRecords()); l.length > 0;) {
            e.push(l.pop());
          }
          var a = function (t, e = true) {
            if (t != null && t !== r && t.domNode.parentNode != null) {
              if (t.domNode[i.DATA_KEY].mutations == null) {
                t.domNode[i.DATA_KEY].mutations = [];
              }
              if (e) {
                a(t.parent);
              }
            }
          };
          var s = function (t) {
            if (t.domNode[i.DATA_KEY] != null && t.domNode[i.DATA_KEY].mutations != null) {
              if (t instanceof o.default) {
                t.children.forEach(s);
              }
              t.optimize(n);
            }
          };
          for (var u = e, c = 0; u.length > 0; c += 1) {
            if (c >= 100) {
              throw new Error("[Parchment] Maximum optimize iterations reached");
            }
            u.forEach(function (t) {
              var e = i.find(t.target, true);
              if (e != null) {
                if (e.domNode === t.target) {
                  if (t.type === "childList") {
                    a(i.find(t.previousSibling, false));
                    [].forEach.call(t.addedNodes, function (t) {
                      var e = i.find(t, false);
                      a(e, false);
                      if (e instanceof o.default) {
                        e.children.forEach(function (t) {
                          a(t, false);
                        });
                      }
                    });
                  } else if (t.type === "attributes") {
                    a(e.prev);
                  }
                }
                a(e);
              }
            });
            this.children.forEach(s);
            l = (u = [].slice.call(this.observer.takeRecords())).slice();
            while (l.length > 0) {
              e.push(l.pop());
            }
          }
        };
        e.prototype.update = function (e, n) {
          var r = this;
          if (n === undefined) {
            n = {};
          }
          (e = e || this.observer.takeRecords()).map(function (t) {
            var e = i.find(t.target, true);
            if (e == null) {
              return null;
            } else if (e.domNode[i.DATA_KEY].mutations == null) {
              e.domNode[i.DATA_KEY].mutations = [t];
              return e;
            } else {
              e.domNode[i.DATA_KEY].mutations.push(t);
              return null;
            }
          }).forEach(function (t) {
            if (t != null && t !== r && t.domNode[i.DATA_KEY] != null) {
              t.update(t.domNode[i.DATA_KEY].mutations || [], n);
            }
          });
          if (this.domNode[i.DATA_KEY].mutations != null) {
            t.prototype.update.call(this, this.domNode[i.DATA_KEY].mutations, n);
          }
          this.optimize(e, n);
        };
        e.blotName = "scroll";
        e.defaultChild = "block";
        e.scope = i.Scope.BLOCK_BLOT;
        e.tagName = "DIV";
        return e;
      }(o.default);
      e.default = a;
    }, function (t, e, n) {
      "use strict";
  
      var o = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = n(18);
      var l = n(1);
      var a = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        o(e, t);
        e.formats = function (n) {
          if (n.tagName !== e.tagName) {
            return t.formats.call(this, n);
          }
        };
        e.prototype.format = function (n, r) {
          var o = this;
          if (n !== this.statics.blotName || r) {
            t.prototype.format.call(this, n, r);
          } else {
            this.children.forEach(function (t) {
              if (!(t instanceof i.default)) {
                t = t.wrap(e.blotName, true);
              }
              o.attributes.copy(t);
            });
            this.unwrap();
          }
        };
        e.prototype.formatAt = function (e, n, r, o) {
          if (this.formats()[r] != null || l.query(r, l.Scope.ATTRIBUTE)) {
            this.isolate(e, n).format(r, o);
          } else {
            t.prototype.formatAt.call(this, e, n, r, o);
          }
        };
        e.prototype.optimize = function (n) {
          t.prototype.optimize.call(this, n);
          var o = this.formats();
          if (Object.keys(o).length === 0) {
            return this.unwrap();
          }
          var i = this.next;
          if (i instanceof e && i.prev === this && function r(t, e) {
            if (Object.keys(t).length !== Object.keys(e).length) {
              return false;
            }
            for (var n in t) {
              if (t[n] !== e[n]) {
                return false;
              }
            }
            return true;
          }(o, i.formats())) {
            i.moveChildren(this);
            i.remove();
          }
        };
        e.blotName = "inline";
        e.scope = l.Scope.INLINE_BLOT;
        e.tagName = "SPAN";
        return e;
      }(i.default);
      e.default = a;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = n(18);
      var i = n(1);
      var l = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        r(e, t);
        e.formats = function (n) {
          var r = i.query(e.blotName).tagName;
          if (n.tagName !== r) {
            return t.formats.call(this, n);
          }
        };
        e.prototype.format = function (n, r) {
          if (i.query(n, i.Scope.BLOCK) != null) {
            if (n !== this.statics.blotName || r) {
              t.prototype.format.call(this, n, r);
            } else {
              this.replaceWith(e.blotName);
            }
          }
        };
        e.prototype.formatAt = function (e, n, r, o) {
          if (i.query(r, i.Scope.BLOCK) != null) {
            this.format(r, o);
          } else {
            t.prototype.formatAt.call(this, e, n, r, o);
          }
        };
        e.prototype.insertAt = function (e, n, r) {
          if (r == null || i.query(n, i.Scope.INLINE) != null) {
            t.prototype.insertAt.call(this, e, n, r);
          } else {
            var o = this.split(e);
            var l = i.create(n, r);
            o.parent.insertBefore(l, o);
          }
        };
        e.prototype.update = function (e, n) {
          if (navigator.userAgent.match(/Trident/)) {
            this.build();
          } else {
            t.prototype.update.call(this, e, n);
          }
        };
        e.blotName = "block";
        e.scope = i.Scope.BLOCK_BLOT;
        e.tagName = "P";
        return e;
      }(o.default);
      e.default = l;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var i = function (t) {
        function e() {
          return t !== null && t.apply(this, arguments) || this;
        }
        r(e, t);
        e.formats = function (t) {};
        e.prototype.format = function (e, n) {
          t.prototype.formatAt.call(this, 0, this.length(), e, n);
        };
        e.prototype.formatAt = function (e, n, r, o) {
          if (e === 0 && n === this.length()) {
            this.format(r, o);
          } else {
            t.prototype.formatAt.call(this, e, n, r, o);
          }
        };
        e.prototype.formats = function () {
          return this.statics.formats(this.domNode);
        };
        return e;
      }(n(19).default);
      e.default = i;
    }, function (t, e, n) {
      "use strict";
  
      var r = this && this.__extends || function () {
        var t = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            if (e.hasOwnProperty(n)) {
              t[n] = e[n];
            }
          }
        };
        return function (e, n) {
          function r() {
            this.constructor = e;
          }
          t(e, n);
          e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
        };
      }();
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var o = n(19);
      var i = n(1);
      var l = function (t) {
        function e(e) {
          var n = t.call(this, e) || this;
          n.text = n.statics.value(n.domNode);
          return n;
        }
        r(e, t);
        e.create = function (t) {
          return document.createTextNode(t);
        };
        e.value = function (t) {
          var e = t.data;
          if (e.normalize) {
            e = e.normalize();
          }
          return e;
        };
        e.prototype.deleteAt = function (t, e) {
          this.domNode.data = this.text = this.text.slice(0, t) + this.text.slice(t + e);
        };
        e.prototype.index = function (t, e) {
          if (this.domNode === t) {
            return e;
          } else {
            return -1;
          }
        };
        e.prototype.insertAt = function (e, n, r) {
          if (r == null) {
            this.text = this.text.slice(0, e) + n + this.text.slice(e);
            this.domNode.data = this.text;
          } else {
            t.prototype.insertAt.call(this, e, n, r);
          }
        };
        e.prototype.length = function () {
          return this.text.length;
        };
        e.prototype.optimize = function (n) {
          t.prototype.optimize.call(this, n);
          this.text = this.statics.value(this.domNode);
          if (this.text.length === 0) {
            this.remove();
          } else if (this.next instanceof e && this.next.prev === this) {
            this.insertAt(this.length(), this.next.value());
            this.next.remove();
          }
        };
        e.prototype.position = function (t, e = false) {
          return [this.domNode, t];
        };
        e.prototype.split = function (t, e = false) {
          if (!e) {
            if (t === 0) {
              return this;
            }
            if (t === this.length()) {
              return this.next;
            }
          }
          var n = i.create(this.domNode.splitText(t));
          this.parent.insertBefore(n, this.next);
          this.text = this.statics.value(this.domNode);
          return n;
        };
        e.prototype.update = function (t, e) {
          var n = this;
          if (t.some(function (t) {
            return t.type === "characterData" && t.target === n.domNode;
          })) {
            this.text = this.statics.value(this.domNode);
          }
        };
        e.prototype.value = function () {
          return this.text;
        };
        e.blotName = "text";
        e.scope = i.Scope.INLINE_BLOT;
        return e;
      }(o.default);
      e.default = l;
    }, function (t, e, n) {
      "use strict";
  
      var r = document.createElement("div");
      r.classList.toggle("test-class", false);
      if (r.classList.contains("test-class")) {
        var o = DOMTokenList.prototype.toggle;
        DOMTokenList.prototype.toggle = function (t, e) {
          if (arguments.length > 1 && !this.contains(t) == !e) {
            return e;
          } else {
            return o.call(this, t);
          }
        };
      }
      String.prototype.startsWith ||= function (t, e) {
        e = e || 0;
        return this.substr(e, t.length) === t;
      };
      String.prototype.endsWith ||= function (t, e) {
        var n = this.toString();
        if (typeof e != "number" || !isFinite(e) || Math.floor(e) !== e || e > n.length) {
          e = n.length;
        }
        e -= t.length;
        var r = n.indexOf(t, e);
        return r !== -1 && r === e;
      };
      if (!Array.prototype.find) {
        Object.defineProperty(Array.prototype, "find", {
          value: function (t) {
            if (this === null) {
              throw new TypeError("Array.prototype.find called on null or undefined");
            }
            if (typeof t != "function") {
              throw new TypeError("predicate must be a function");
            }
            var e;
            var n = Object(this);
            for (var r = n.length >>> 0, o = arguments[1], i = 0; i < r; i++) {
              e = n[i];
              if (t.call(o, e, i, n)) {
                return e;
              }
            }
          }
        });
      }
      document.addEventListener("DOMContentLoaded", function () {
        document.execCommand("enableObjectResizing", false, false);
        document.execCommand("autoUrlDetect", false, false);
      });
    }, function (t, e) {
      function n(t, e, n) {
        if (t == e) {
          if (t) {
            return [[v, t]];
          } else {
            return [];
          }
        }
        if (n < 0 || t.length < n) {
          n = null;
        }
        var o = l(t, e);
        var i = t.substring(0, o);
        o = a(t = t.substring(o), e = e.substring(o));
        var s = t.substring(t.length - o);
        var c = r(t = t.substring(0, t.length - o), e = e.substring(0, e.length - o));
        if (i) {
          c.unshift([v, i]);
        }
        if (s) {
          c.push([v, s]);
        }
        u(c);
        if (n != null) {
          c = f(c, n);
        }
        return function h(t) {
          var e = false;
          var n = function (t) {
            return t.charCodeAt(0) >= 56320 && t.charCodeAt(0) <= 57343;
          };
          for (var r = 2; r < t.length; r += 1) {
            if (t[r - 2][0] === v && function (t) {
              return t.charCodeAt(t.length - 1) >= 55296 && t.charCodeAt(t.length - 1) <= 56319;
            }(t[r - 2][1]) && t[r - 1][0] === d && n(t[r - 1][1]) && t[r][0] === y && n(t[r][1])) {
              e = true;
              t[r - 1][1] = t[r - 2][1].slice(-1) + t[r - 1][1];
              t[r][1] = t[r - 2][1].slice(-1) + t[r][1];
              t[r - 2][1] = t[r - 2][1].slice(0, -1);
            }
          }
          if (!e) {
            return t;
          }
          var o = [];
          for (r = 0; r < t.length; r += 1) {
            if (t[r][1].length > 0) {
              o.push(t[r]);
            }
          }
          return o;
        }(c);
      }
      function r(t, e) {
        var r;
        if (!t) {
          return [[y, e]];
        }
        if (!e) {
          return [[d, t]];
        }
        var i = t.length > e.length ? t : e;
        var l = t.length > e.length ? e : t;
        var a = i.indexOf(l);
        if (a != -1) {
          r = [[y, i.substring(0, a)], [v, l], [y, i.substring(a + l.length)]];
          if (t.length > e.length) {
            r[0][0] = r[2][0] = d;
          }
          return r;
        }
        if (l.length == 1) {
          return [[d, t], [y, e]];
        }
        var u = s(t, e);
        if (u) {
          var c = u[0];
          var f = u[1];
          var h = u[2];
          var p = u[3];
          var b = u[4];
          var g = n(c, h);
          var m = n(f, p);
          return g.concat([[v, b]], m);
        }
        return o(t, e);
      }
      function o(t, e) {
        var n = t.length;
        var r = e.length;
        var o = Math.ceil((n + r) / 2);
        var l = o;
        for (var a = o * 2, s = new Array(a), u = new Array(a), c = 0; c < a; c++) {
          s[c] = -1;
          u[c] = -1;
        }
        s[l + 1] = 0;
        u[l + 1] = 0;
        var f = n - r;
        var h = f % 2 != 0;
        var p = 0;
        var v = 0;
        var b = 0;
        var g = 0;
        for (var m = 0; m < o; m++) {
          for (var _ = -m + p; _ <= m - v; _ += 2) {
            var w = l + _;
            for (var x = (O = _ == -m || _ != m && s[w - 1] < s[w + 1] ? s[w + 1] : s[w - 1] + 1) - _; O < n && x < r && t.charAt(O) == e.charAt(x);) {
              O++;
              x++;
            }
            s[w] = O;
            if (O > n) {
              v += 2;
            } else if (x > r) {
              p += 2;
            } else if (h) {
              if ((k = l + f - _) >= 0 && k < a && u[k] != -1) {
                if (O >= (E = n - u[k])) {
                  return i(t, e, O, x);
                }
              }
            }
          }
          for (var N = -m + b; N <= m - g; N += 2) {
            for (var E, k = l + N, j = (E = N == -m || N != m && u[k - 1] < u[k + 1] ? u[k + 1] : u[k - 1] + 1) - N; E < n && j < r && t.charAt(n - E - 1) == e.charAt(r - j - 1);) {
              E++;
              j++;
            }
            u[k] = E;
            if (E > n) {
              g += 2;
            } else if (j > r) {
              b += 2;
            } else if (!h) {
              if ((w = l + f - N) >= 0 && w < a && s[w] != -1) {
                var O;
                x = l + (O = s[w]) - w;
                if (O >= (E = n - E)) {
                  return i(t, e, O, x);
                }
              }
            }
          }
        }
        return [[d, t], [y, e]];
      }
      function i(t, e, r, o) {
        var i = t.substring(0, r);
        var l = e.substring(0, o);
        var a = t.substring(r);
        var s = e.substring(o);
        var u = n(i, l);
        var c = n(a, s);
        return u.concat(c);
      }
      function l(t, e) {
        if (!t || !e || t.charAt(0) != e.charAt(0)) {
          return 0;
        }
        for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {
          if (t.substring(i, o) == e.substring(i, o)) {
            i = n = o;
          } else {
            r = o;
          }
          o = Math.floor((r - n) / 2 + n);
        }
        return o;
      }
      function a(t, e) {
        if (!t || !e || t.charAt(t.length - 1) != e.charAt(e.length - 1)) {
          return 0;
        }
        for (var n = 0, r = Math.min(t.length, e.length), o = r, i = 0; n < o;) {
          if (t.substring(t.length - o, t.length - i) == e.substring(e.length - o, e.length - i)) {
            i = n = o;
          } else {
            r = o;
          }
          o = Math.floor((r - n) / 2 + n);
        }
        return o;
      }
      function s(t, e) {
        function n(t, e, n) {
          for (var r, o, i, s, u = t.substring(n, n + Math.floor(t.length / 4)), c = -1, f = ""; (c = e.indexOf(u, c + 1)) != -1;) {
            var h = l(t.substring(n), e.substring(c));
            var p = a(t.substring(0, n), e.substring(0, c));
            if (f.length < p + h) {
              f = e.substring(c - p, c) + e.substring(c, c + h);
              r = t.substring(0, n - p);
              o = t.substring(n + h);
              i = e.substring(0, c - p);
              s = e.substring(c + h);
            }
          }
          if (f.length * 2 >= t.length) {
            return [r, o, i, s, f];
          } else {
            return null;
          }
        }
        var r = t.length > e.length ? t : e;
        var o = t.length > e.length ? e : t;
        if (r.length < 4 || o.length * 2 < r.length) {
          return null;
        }
        var i;
        var c;
        var f;
        var h;
        var p;
        var s = n(r, o, Math.ceil(r.length / 4));
        var u = n(r, o, Math.ceil(r.length / 2));
        if (s || u) {
          i = u ? s && s[4].length > u[4].length ? s : u : s;
          if (t.length > e.length) {
            c = i[0];
            f = i[1];
            h = i[2];
            p = i[3];
          } else {
            h = i[0];
            p = i[1];
            c = i[2];
            f = i[3];
          }
          return [c, f, h, p, i[4]];
        } else {
          return null;
        }
      }
      function u(t) {
        t.push([v, ""]);
        var e;
        for (var n = 0, r = 0, o = 0, i = "", s = ""; n < t.length;) {
          switch (t[n][0]) {
            case y:
              o++;
              s += t[n][1];
              n++;
              break;
            case d:
              r++;
              i += t[n][1];
              n++;
              break;
            case v:
              if (r + o > 1) {
                if (r !== 0 && o !== 0) {
                  if ((e = l(s, i)) !== 0) {
                    if (n - r - o > 0 && t[n - r - o - 1][0] == v) {
                      t[n - r - o - 1][1] += s.substring(0, e);
                    } else {
                      t.splice(0, 0, [v, s.substring(0, e)]);
                      n++;
                    }
                    s = s.substring(e);
                    i = i.substring(e);
                  }
                  if ((e = a(s, i)) !== 0) {
                    t[n][1] = s.substring(s.length - e) + t[n][1];
                    s = s.substring(0, s.length - e);
                    i = i.substring(0, i.length - e);
                  }
                }
                if (r === 0) {
                  t.splice(n - o, r + o, [y, s]);
                } else if (o === 0) {
                  t.splice(n - r, r + o, [d, i]);
                } else {
                  t.splice(n - r - o, r + o, [d, i], [y, s]);
                }
                n = n - r - o + (r ? 1 : 0) + (o ? 1 : 0) + 1;
              } else if (n !== 0 && t[n - 1][0] == v) {
                t[n - 1][1] += t[n][1];
                t.splice(n, 1);
              } else {
                n++;
              }
              o = 0;
              r = 0;
              i = "";
              s = "";
          }
        }
        if (t[t.length - 1][1] === "") {
          t.pop();
        }
        var c = false;
        for (n = 1; n < t.length - 1;) {
          if (t[n - 1][0] == v && t[n + 1][0] == v) {
            if (t[n][1].substring(t[n][1].length - t[n - 1][1].length) == t[n - 1][1]) {
              t[n][1] = t[n - 1][1] + t[n][1].substring(0, t[n][1].length - t[n - 1][1].length);
              t[n + 1][1] = t[n - 1][1] + t[n + 1][1];
              t.splice(n - 1, 1);
              c = true;
            } else if (t[n][1].substring(0, t[n + 1][1].length) == t[n + 1][1]) {
              t[n - 1][1] += t[n + 1][1];
              t[n][1] = t[n][1].substring(t[n + 1][1].length) + t[n + 1][1];
              t.splice(n + 1, 1);
              c = true;
            }
          }
          n++;
        }
        if (c) {
          u(t);
        }
      }
      function f(t, e) {
        var n = function c(t, e) {
          if (e === 0) {
            return [v, t];
          }
          var n = 0;
          for (var r = 0; r < t.length; r++) {
            var o = t[r];
            if (o[0] === d || o[0] === v) {
              var i = n + o[1].length;
              if (e === i) {
                return [r + 1, t];
              }
              if (e < i) {
                t = t.slice();
                var l = e - n;
                var a = [o[0], o[1].slice(0, l)];
                var s = [o[0], o[1].slice(l)];
                t.splice(r, 1, a, s);
                return [r + 1, t];
              }
              n = i;
            }
          }
          throw new Error("cursor_pos is out of bounds!");
        }(t, e);
        var r = n[1];
        var o = n[0];
        var i = r[o];
        var l = r[o + 1];
        if (i == null) {
          return t;
        }
        if (i[0] !== v) {
          return t;
        }
        if (l != null && i[1] + l[1] === l[1] + i[1]) {
          r.splice(o, 2, l, i);
          return p(r, o, 2);
        }
        if (l != null && l[1].indexOf(i[1]) === 0) {
          r.splice(o, 2, [l[0], i[1]], [0, i[1]]);
          var a = l[1].slice(i[1].length);
          if (a.length > 0) {
            r.splice(o + 2, 0, [l[0], a]);
          }
          return p(r, o, 3);
        }
        return t;
      }
      function p(t, e, n) {
        for (var r = e + n - 1; r >= 0 && r >= e - 1; r--) {
          if (r + 1 < t.length) {
            var o = t[r];
            var i = t[r + 1];
            if (o[0] === i[1]) {
              t.splice(r, 2, [o[0], o[1] + i[1]]);
            }
          }
        }
        return t;
      }
      var d = -1;
      var y = 1;
      var v = 0;
      var b = n;
      b.INSERT = y;
      b.DELETE = d;
      b.EQUAL = v;
      t.exports = b;
    }, function (t, e) {
      function n(t) {
        var e = [];
        for (var n in t) {
          e.push(n);
        }
        return e;
      }
      (t.exports = typeof Object.keys == "function" ? Object.keys : n).shim = n;
    }, function (t, e) {
      function n(t) {
        return Object.prototype.toString.call(t) == "[object Arguments]";
      }
      function r(t) {
        return t && typeof t == "object" && typeof t.length == "number" && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || false;
      }
      var o = function () {
        return Object.prototype.toString.call(arguments);
      }() == "[object Arguments]";
      (e = t.exports = o ? n : r).supported = n;
      e.unsupported = r;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function l(t, e) {
        return Object.keys(e).reduce(function (n, r) {
          if (t[r] != null) {
            if (e[r] === t[r]) {
              n[r] = e[r];
            } else if (Array.isArray(e[r])) {
              if (e[r].indexOf(t[r]) < 0) {
                n[r] = e[r].concat([t[r]]);
              }
            } else {
              n[r] = [e[r], t[r]];
            }
          }
          return n;
        }, {});
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        if (t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof t;
        }
      };
      function u(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var c = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var h = r(n(4));
      var d = r(n(20));
      var v = r(n(0));
      var g = r(n(13));
      var _ = r(n(31));
      var O = n(3);
      var w = r(O);
      var k = r(n(14));
      var N = r(n(21));
      var A = r(n(12));
      var T = r(n(2));
      var P = /^[ -~]*$/;
      var S = function () {
        function t(e) {
          (function i(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, t);
          this.scroll = e;
          this.delta = this.getDelta();
        }
        c(t, [{
          key: "applyDelta",
          value: function (t) {
            var e = this;
            var n = false;
            this.scroll.update();
            var r = this.scroll.length();
            this.scroll.batchStart();
            (t = function a(t) {
              return t.reduce(function (t, e) {
                if (e.insert === 1) {
                  var n = (0, N.default)(e.attributes);
                  delete n.image;
                  return t.insert({
                    image: e.attributes.image
                  }, n);
                }
                if (e.attributes != null && (e.attributes.list === true || e.attributes.bullet === true)) {
                  if ((e = (0, N.default)(e)).attributes.list) {
                    e.attributes.list = "ordered";
                  } else {
                    e.attributes.list = "bullet";
                    delete e.attributes.bullet;
                  }
                }
                if (typeof e.insert == "string") {
                  var r = e.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                  return t.insert(r, e.attributes);
                }
                return t.push(e);
              }, new h.default());
            }(t)).reduce(function (t, o) {
              var i = o.retain || o.delete || o.insert.length || 1;
              var l = o.attributes || {};
              if (o.insert != null) {
                if (typeof o.insert == "string") {
                  var a = o.insert;
                  if (a.endsWith("\n") && n) {
                    n = false;
                    a = a.slice(0, -1);
                  }
                  if (t >= r && !a.endsWith("\n")) {
                    n = true;
                  }
                  e.scroll.insertAt(t, a);
                  var c = e.scroll.line(t);
                  var f = u(c, 2);
                  var h = f[0];
                  var p = f[1];
                  var y = (0, T.default)({}, (0, O.bubbleFormats)(h));
                  if (h instanceof w.default) {
                    var b = h.descendant(v.default.Leaf, p);
                    var m = u(b, 1)[0];
                    y = (0, T.default)(y, (0, O.bubbleFormats)(m));
                  }
                  l = d.default.attributes.diff(y, l) || {};
                } else if (s(o.insert) === "object") {
                  var _ = Object.keys(o.insert)[0];
                  if (_ == null) {
                    return t;
                  }
                  e.scroll.insertAt(t, _, o.insert[_]);
                }
                r += i;
              }
              Object.keys(l).forEach(function (n) {
                e.scroll.formatAt(t, i, n, l[n]);
              });
              return t + i;
            }, 0);
            t.reduce(function (t, n) {
              if (typeof n.delete == "number") {
                e.scroll.deleteAt(t, n.delete);
                return t;
              } else {
                return t + (n.retain || n.insert.length || 1);
              }
            }, 0);
            this.scroll.batchEnd();
            return this.update(t);
          }
        }, {
          key: "deleteText",
          value: function (t, e) {
            this.scroll.deleteAt(t, e);
            return this.update(new h.default().retain(t).delete(e));
          }
        }, {
          key: "formatLine",
          value: function (t, e) {
            var n = this;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            this.scroll.update();
            Object.keys(r).forEach(function (o) {
              if (n.scroll.whitelist == null || n.scroll.whitelist[o]) {
                var i = n.scroll.lines(t, Math.max(e, 1));
                var l = e;
                i.forEach(function (e) {
                  var i = e.length();
                  if (e instanceof g.default) {
                    var a = t - e.offset(n.scroll);
                    var s = e.newlineIndex(a + l) - a + 1;
                    e.formatAt(a, s, o, r[o]);
                  } else {
                    e.format(o, r[o]);
                  }
                  l -= i;
                });
              }
            });
            this.scroll.optimize();
            return this.update(new h.default().retain(t).retain(e, (0, N.default)(r)));
          }
        }, {
          key: "formatText",
          value: function (t, e) {
            var n = this;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            Object.keys(r).forEach(function (o) {
              n.scroll.formatAt(t, e, o, r[o]);
            });
            return this.update(new h.default().retain(t).retain(e, (0, N.default)(r)));
          }
        }, {
          key: "getContents",
          value: function (t, e) {
            return this.delta.slice(t, t + e);
          }
        }, {
          key: "getDelta",
          value: function () {
            return this.scroll.lines().reduce(function (t, e) {
              return t.concat(e.delta());
            }, new h.default());
          }
        }, {
          key: "getFormat",
          value: function (t, e = 0) {
            var n = [];
            var r = [];
            if (e === 0) {
              this.scroll.path(t).forEach(function (t) {
                var o = u(t, 1)[0];
                if (o instanceof w.default) {
                  n.push(o);
                } else if (o instanceof v.default.Leaf) {
                  r.push(o);
                }
              });
            } else {
              n = this.scroll.lines(t, e);
              r = this.scroll.descendants(v.default.Leaf, t, e);
            }
            var o = [n, r].map(function (t) {
              if (t.length === 0) {
                return {};
              }
              for (var e = (0, O.bubbleFormats)(t.shift()); Object.keys(e).length > 0;) {
                var n = t.shift();
                if (n == null) {
                  return e;
                }
                e = l((0, O.bubbleFormats)(n), e);
              }
              return e;
            });
            return T.default.apply(T.default, o);
          }
        }, {
          key: "getText",
          value: function (t, e) {
            return this.getContents(t, e).filter(function (t) {
              return typeof t.insert == "string";
            }).map(function (t) {
              return t.insert;
            }).join("");
          }
        }, {
          key: "insertEmbed",
          value: function (t, e, n) {
            this.scroll.insertAt(t, e, n);
            return this.update(new h.default().retain(t).insert(function o(t, e, n) {
              if (e in t) {
                Object.defineProperty(t, e, {
                  value: n,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                t[e] = n;
              }
              return t;
            }({}, e, n)));
          }
        }, {
          key: "insertText",
          value: function (t, e) {
            var n = this;
            var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            this.scroll.insertAt(t, e);
            Object.keys(r).forEach(function (o) {
              n.scroll.formatAt(t, e.length, o, r[o]);
            });
            return this.update(new h.default().retain(t).insert(e, (0, N.default)(r)));
          }
        }, {
          key: "isBlank",
          value: function () {
            if (this.scroll.children.length == 0) {
              return true;
            }
            if (this.scroll.children.length > 1) {
              return false;
            }
            var t = this.scroll.children.head;
            return t.statics.blotName === w.default.blotName && !(t.children.length > 1) && t.children.head instanceof k.default;
          }
        }, {
          key: "removeFormat",
          value: function (t, e) {
            var n = this.getText(t, e);
            var r = this.scroll.line(t + e);
            var o = u(r, 2);
            var i = o[0];
            var l = o[1];
            var a = 0;
            var s = new h.default();
            if (i != null) {
              a = i instanceof g.default ? i.newlineIndex(l) - l + 1 : i.length() - l;
              s = i.delta().slice(l, l + a - 1).insert("\n");
            }
            var f = this.getContents(t, e + a).diff(new h.default().insert(n).concat(s));
            var p = new h.default().retain(t).concat(f);
            return this.applyDelta(p);
          }
        }, {
          key: "update",
          value: function (t, e = [], n = undefined) {
            var r = this.delta;
            if (e.length === 1 && e[0].type === "characterData" && e[0].target.data.match(P) && v.default.find(e[0].target)) {
              var o = v.default.find(e[0].target);
              var i = (0, O.bubbleFormats)(o);
              var l = o.offset(this.scroll);
              var a = e[0].oldValue.replace(_.default.CONTENTS, "");
              var s = new h.default().insert(a);
              var u = new h.default().insert(o.value());
              t = new h.default().retain(l).concat(s.diff(u, n)).reduce(function (t, e) {
                if (e.insert) {
                  return t.insert(e.insert, i);
                } else {
                  return t.push(e);
                }
              }, new h.default());
              this.delta = r.compose(t);
            } else {
              this.delta = this.getDelta();
              if (!t || !(0, A.default)(r.compose(t), this.delta)) {
                t = r.diff(this.delta, n);
              }
            }
            return t;
          }
        }]);
        return t;
      }();
      e.default = S;
    }, function (t, e) {
      "use strict";
  
      function n() {}
      function r(t, e, n) {
        this.fn = t;
        this.context = e;
        this.once = n || false;
      }
      function o() {
        this._events = new n();
        this._eventsCount = 0;
      }
      var i = Object.prototype.hasOwnProperty;
      var l = "~";
      if (Object.create) {
        n.prototype = Object.create(null);
        if (!new n().__proto__) {
          l = false;
        }
      }
      o.prototype.eventNames = function () {
        var t;
        var e;
        var n = [];
        if (this._eventsCount === 0) {
          return n;
        }
        for (e in t = this._events) {
          if (i.call(t, e)) {
            n.push(l ? e.slice(1) : e);
          }
        }
        if (Object.getOwnPropertySymbols) {
          return n.concat(Object.getOwnPropertySymbols(t));
        } else {
          return n;
        }
      };
      o.prototype.listeners = function (t, e) {
        var n = l ? l + t : t;
        var r = this._events[n];
        if (e) {
          return !!r;
        }
        if (!r) {
          return [];
        }
        if (r.fn) {
          return [r.fn];
        }
        for (var o = 0, i = r.length, a = new Array(i); o < i; o++) {
          a[o] = r[o].fn;
        }
        return a;
      };
      o.prototype.emit = function (t, e, n, r, o, i) {
        var a = l ? l + t : t;
        if (!this._events[a]) {
          return false;
        }
        var s;
        var u;
        var c = this._events[a];
        var f = arguments.length;
        if (c.fn) {
          if (c.once) {
            this.removeListener(t, c.fn, undefined, true);
          }
          switch (f) {
            case 1:
              c.fn.call(c.context);
              return true;
            case 2:
              c.fn.call(c.context, e);
              return true;
            case 3:
              c.fn.call(c.context, e, n);
              return true;
            case 4:
              c.fn.call(c.context, e, n, r);
              return true;
            case 5:
              c.fn.call(c.context, e, n, r, o);
              return true;
            case 6:
              c.fn.call(c.context, e, n, r, o, i);
              return true;
          }
          u = 1;
          s = new Array(f - 1);
          for (; u < f; u++) {
            s[u - 1] = arguments[u];
          }
          c.fn.apply(c.context, s);
        } else {
          var h;
          var p = c.length;
          for (u = 0; u < p; u++) {
            if (c[u].once) {
              this.removeListener(t, c[u].fn, undefined, true);
            }
            switch (f) {
              case 1:
                c[u].fn.call(c[u].context);
                break;
              case 2:
                c[u].fn.call(c[u].context, e);
                break;
              case 3:
                c[u].fn.call(c[u].context, e, n);
                break;
              case 4:
                c[u].fn.call(c[u].context, e, n, r);
                break;
              default:
                if (!s) {
                  h = 1;
                  s = new Array(f - 1);
                  for (; h < f; h++) {
                    s[h - 1] = arguments[h];
                  }
                }
                c[u].fn.apply(c[u].context, s);
            }
          }
        }
        return true;
      };
      o.prototype.on = function (t, e, n) {
        var o = new r(e, n || this);
        var i = l ? l + t : t;
        if (this._events[i]) {
          if (this._events[i].fn) {
            this._events[i] = [this._events[i], o];
          } else {
            this._events[i].push(o);
          }
        } else {
          this._events[i] = o;
          this._eventsCount++;
        }
        return this;
      };
      o.prototype.once = function (t, e, n) {
        var o = new r(e, n || this, true);
        var i = l ? l + t : t;
        if (this._events[i]) {
          if (this._events[i].fn) {
            this._events[i] = [this._events[i], o];
          } else {
            this._events[i].push(o);
          }
        } else {
          this._events[i] = o;
          this._eventsCount++;
        }
        return this;
      };
      o.prototype.removeListener = function (t, e, r, o) {
        var i = l ? l + t : t;
        if (!this._events[i]) {
          return this;
        }
        if (!e) {
          if (--this._eventsCount == 0) {
            this._events = new n();
          } else {
            delete this._events[i];
          }
          return this;
        }
        var a = this._events[i];
        if (a.fn) {
          if (a.fn === e && (!o || !!a.once) && (!r || a.context === r)) {
            if (--this._eventsCount == 0) {
              this._events = new n();
            } else {
              delete this._events[i];
            }
          }
        } else {
          for (var s = 0, u = [], c = a.length; s < c; s++) {
            if (a[s].fn !== e || o && !a[s].once || r && a[s].context !== r) {
              u.push(a[s]);
            }
          }
          if (u.length) {
            this._events[i] = u.length === 1 ? u[0] : u;
          } else if (--this._eventsCount == 0) {
            this._events = new n();
          } else {
            delete this._events[i];
          }
        }
        return this;
      };
      o.prototype.removeAllListeners = function (t) {
        var e;
        if (t) {
          e = l ? l + t : t;
          if (this._events[e]) {
            if (--this._eventsCount == 0) {
              this._events = new n();
            } else {
              delete this._events[e];
            }
          }
        } else {
          this._events = new n();
          this._eventsCount = 0;
        }
        return this;
      };
      o.prototype.off = o.prototype.removeListener;
      o.prototype.addListener = o.prototype.on;
      o.prototype.setMaxListeners = function () {
        return this;
      };
      o.prefixed = l;
      o.EventEmitter = o;
      if (t !== undefined) {
        t.exports = o;
      }
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function a(t) {
        return t instanceof v.default || t instanceof y.BlockEmbed;
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      function s(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var u = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var c = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var h = r(n(0));
      var d = r(n(9));
      var y = n(3);
      var v = r(y);
      var g = r(n(14));
      var _ = r(n(13));
      var w = r(n(23));
      var x = function (t) {
        function e(t, n) {
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var r = function i(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          r.emitter = n.emitter;
          if (Array.isArray(n.whitelist)) {
            r.whitelist = n.whitelist.reduce(function (t, e) {
              t[e] = true;
              return t;
            }, {});
          }
          r.domNode.addEventListener("DOMNodeInserted", function () {});
          r.optimize();
          r.enable();
          return r;
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        u(e, [{
          key: "batchStart",
          value: function () {
            this.batch = true;
          }
        }, {
          key: "batchEnd",
          value: function () {
            this.batch = false;
            this.optimize();
          }
        }, {
          key: "deleteAt",
          value: function (t, n) {
            var r = this.line(t);
            var o = s(r, 2);
            var i = o[0];
            var l = o[1];
            var a = this.line(t + n);
            var f = s(a, 1)[0];
            c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "deleteAt", this).call(this, t, n);
            if (f != null && i !== f && l > 0) {
              if (i instanceof y.BlockEmbed || f instanceof y.BlockEmbed) {
                this.optimize();
                return;
              }
              if (i instanceof _.default) {
                var h = i.newlineIndex(i.length(), true);
                if (h > -1 && (i = i.split(h + 1)) === f) {
                  this.optimize();
                  return;
                }
              } else if (f instanceof _.default) {
                var p = f.newlineIndex(0);
                if (p > -1) {
                  f.split(p + 1);
                }
              }
              var d = f.children.head instanceof g.default ? null : f.children.head;
              i.moveChildren(f, d);
              i.remove();
            }
            this.optimize();
          }
        }, {
          key: "enable",
          value: function () {
            var t = !(arguments.length > 0) || arguments[0] === undefined || arguments[0];
            this.domNode.setAttribute("contenteditable", t);
          }
        }, {
          key: "formatAt",
          value: function (t, n, r, o) {
            if (this.whitelist == null || this.whitelist[r]) {
              c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, n, r, o);
              this.optimize();
            }
          }
        }, {
          key: "insertAt",
          value: function (t, n, r) {
            if (r == null || this.whitelist == null || this.whitelist[n]) {
              if (t >= this.length()) {
                if (r == null || h.default.query(n, h.default.Scope.BLOCK) == null) {
                  var o = h.default.create(this.statics.defaultChild);
                  this.appendChild(o);
                  if (r == null && n.endsWith("\n")) {
                    n = n.slice(0, -1);
                  }
                  o.insertAt(0, n, r);
                } else {
                  var i = h.default.create(n, r);
                  this.appendChild(i);
                }
              } else {
                c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r);
              }
              this.optimize();
            }
          }
        }, {
          key: "insertBefore",
          value: function (t, n) {
            if (t.statics.scope === h.default.Scope.INLINE_BLOT) {
              var r = h.default.create(this.statics.defaultChild);
              r.appendChild(t);
              t = r;
            }
            c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n);
          }
        }, {
          key: "leaf",
          value: function (t) {
            return this.path(t).pop() || [null, -1];
          }
        }, {
          key: "line",
          value: function (t) {
            if (t === this.length()) {
              return this.line(t - 1);
            } else {
              return this.descendant(a, t);
            }
          }
        }, {
          key: "lines",
          value: function (t = 0, e = Number.MAX_VALUE) {
            return function t(e, n, r) {
              var o = [];
              var i = r;
              e.children.forEachAt(n, r, function (e, n, r) {
                if (a(e)) {
                  o.push(e);
                } else if (e instanceof h.default.Container) {
                  o = o.concat(t(e, n, i));
                }
                i -= r;
              });
              return o;
            }(this, t, e);
          }
        }, {
          key: "optimize",
          value: function (t = [], n = {}) {
            if (this.batch !== true) {
              c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t, n);
              if (t.length > 0) {
                this.emitter.emit(d.default.events.SCROLL_OPTIMIZE, t, n);
              }
            }
          }
        }, {
          key: "path",
          value: function (t) {
            return c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "path", this).call(this, t).slice(1);
          }
        }, {
          key: "update",
          value: function (t) {
            if (this.batch !== true) {
              var n = d.default.sources.USER;
              if (typeof t == "string") {
                n = t;
              }
              if (!Array.isArray(t)) {
                t = this.observer.takeRecords();
              }
              if (t.length > 0) {
                this.emitter.emit(d.default.events.SCROLL_BEFORE_UPDATE, n, t);
              }
              c(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "update", this).call(this, t.concat([]));
              if (t.length > 0) {
                this.emitter.emit(d.default.events.SCROLL_UPDATE, n, t);
              }
            }
          }
        }]);
        return e;
      }(h.default.Scroll);
      x.blotName = "scroll";
      x.className = "ql-editor";
      x.tagName = "DIV";
      x.defaultChild = "block";
      x.allowedChildren = [v.default, y.BlockEmbed, w.default];
      e.default = x;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e, n) {
        if (e in t) {
          Object.defineProperty(t, e, {
            value: n,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          t[e] = n;
        }
        return t;
      }
      function s(t, e, n) {
        if ((e === undefined ? "undefined" : x(e)) === "object") {
          return Object.keys(e).reduce(function (t, n) {
            return s(t, n, e[n]);
          }, t);
        } else {
          return t.reduce(function (t, r) {
            if (r.attributes && r.attributes[e]) {
              return t.push(r);
            } else {
              return t.insert(r.insert, (0, j.default)({}, o({}, e, n), r.attributes));
            }
          }, new q.default());
        }
      }
      function u(t) {
        if (t.nodeType !== Node.ELEMENT_NODE) {
          return {};
        } else {
          return t["__ql-computed-style"] ||= window.getComputedStyle(t);
        }
      }
      function c(t, e) {
        for (var n = "", r = t.ops.length - 1; r >= 0 && n.length < e.length; --r) {
          var o = t.ops[r];
          if (typeof o.insert != "string") {
            break;
          }
          n = o.insert + n;
        }
        return n.slice(e.length * -1) === e;
      }
      function f(t) {
        return t.childNodes.length !== 0 && ["block", "list-item"].indexOf(u(t).display) > -1;
      }
      function h(t, e, n) {
        if (t.nodeType === t.TEXT_NODE) {
          return n.reduce(function (e, n) {
            return n(t, e);
          }, new q.default());
        } else if (t.nodeType === t.ELEMENT_NODE) {
          return [].reduce.call(t.childNodes || [], function (r, o) {
            var i = h(o, e, n);
            if (o.nodeType === t.ELEMENT_NODE) {
              i = e.reduce(function (t, e) {
                return e(o, t);
              }, i);
              i = (o[W] || []).reduce(function (t, e) {
                return e(o, t);
              }, i);
            }
            return r.concat(i);
          }, new q.default());
        } else {
          return new q.default();
        }
      }
      function p(t, e, n) {
        return s(n, t, true);
      }
      function d(t, e) {
        var n = P.default.Attributor.Attribute.keys(t);
        var r = P.default.Attributor.Class.keys(t);
        var o = P.default.Attributor.Style.keys(t);
        var i = {};
        n.concat(r).concat(o).forEach(function (e) {
          var n = P.default.query(e, P.default.Scope.ATTRIBUTE);
          if (n == null || !(i[n.attrName] = n.value(t), i[n.attrName])) {
            if ((n = Y[e]) != null && (n.attrName === e || n.keyName === e)) {
              i[n.attrName] = n.value(t) || undefined;
            }
            if ((n = X[e]) != null && (n.attrName === e || n.keyName === e)) {
              n = X[e];
              i[n.attrName] = n.value(t) || undefined;
            }
          }
        });
        if (Object.keys(i).length > 0) {
          e = s(e, i);
        }
        return e;
      }
      function y(t, e) {
        var n = P.default.query(t);
        if (n == null) {
          return e;
        }
        if (n.prototype instanceof P.default.Embed) {
          var r = {};
          var o = n.value(t);
          if (o != null) {
            r[n.blotName] = o;
            e = new q.default().insert(r, n.formats(t));
          }
        } else if (typeof n.formats == "function") {
          e = s(e, n.blotName, n.formats(t));
        }
        return e;
      }
      function m(t, e) {
        if (!c(e, "\n")) {
          if (f(t) || e.length() > 0 && t.nextSibling && f(t.nextSibling)) {
            e.insert("\n");
          }
        }
        return e;
      }
      function _(t, e) {
        if (f(t) && t.nextElementSibling != null && !c(e, "\n\n")) {
          var n = t.offsetHeight + parseFloat(u(t).marginTop) + parseFloat(u(t).marginBottom);
          if (t.nextElementSibling.offsetTop > t.offsetTop + n * 1.5) {
            e.insert("\n");
          }
        }
        return e;
      }
      function w(t, e) {
        var n = t.data;
        if (t.parentNode.tagName === "O:P") {
          return e.insert(n.trim());
        }
        if (n.trim().length === 0 && t.parentNode.classList.contains("ql-clipboard")) {
          return e;
        }
        if (!u(t.parentNode).whiteSpace.startsWith("pre")) {
          function r(t, e) {
            if ((e = e.replace(/[^\u00a0]/g, "")).length < 1 && t) {
              return " ";
            } else {
              return e;
            }
          }
          n = (n = n.replace(/\r\n/g, " ").replace(/\n/g, " ")).replace(/\s\s+/g, r.bind(r, true));
          if (t.previousSibling == null && f(t.parentNode) || t.previousSibling != null && f(t.previousSibling)) {
            n = n.replace(/^\s+/, r.bind(r, false));
          }
          if (t.nextSibling == null && f(t.parentNode) || t.nextSibling != null && f(t.nextSibling)) {
            n = n.replace(/\s+$/, r.bind(r, false));
          }
        }
        return e.insert(n);
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.matchText = e.matchSpacing = e.matchNewline = e.matchBlot = e.matchAttributor = e.default = undefined;
      var x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
        return typeof t;
      } : function (t) {
        if (t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype) {
          return "symbol";
        } else {
          return typeof t;
        }
      };
      function k(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var E = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var j = r(n(2));
      var q = r(n(4));
      var P = r(n(0));
      var C = r(n(6));
      var M = r(n(10));
      var I = r(n(7));
      var B = n(34);
      var D = n(35);
      var F = r(n(13));
      var H = n(24);
      var K = n(36);
      var z = n(37);
      var Z = n(38);
      var V = (0, M.default)("quill:clipboard");
      var W = "__ql-matcher";
      var G = [[Node.TEXT_NODE, w], [Node.TEXT_NODE, m], ["br", function v(t, e) {
        if (!c(e, "\n")) {
          e.insert("\n");
        }
        return e;
      }], [Node.ELEMENT_NODE, m], [Node.ELEMENT_NODE, y], [Node.ELEMENT_NODE, _], [Node.ELEMENT_NODE, d], [Node.ELEMENT_NODE, function O(t, e) {
        var n = {};
        var r = t.style || {};
        if (r.fontStyle && u(t).fontStyle === "italic") {
          n.italic = true;
        }
        if (r.fontWeight && (u(t).fontWeight.startsWith("bold") || parseInt(u(t).fontWeight) >= 700)) {
          n.bold = true;
        }
        if (Object.keys(n).length > 0) {
          e = s(e, n);
        }
        if (parseFloat(r.textIndent || 0) > 0) {
          e = new q.default().insert("\t").concat(e);
        }
        return e;
      }], ["li", function g(t, e) {
        var n = P.default.query(t);
        if (n == null || n.blotName !== "list-item" || !c(e, "\n")) {
          return e;
        }
        var r = -1;
        for (var o = t.parentNode; !o.classList.contains("ql-clipboard");) {
          if ((P.default.query(o) || {}).blotName === "list") {
            r += 1;
          }
          o = o.parentNode;
        }
        if (r <= 0) {
          return e;
        } else {
          return e.compose(new q.default().retain(e.length() - 1).retain(1, {
            indent: r
          }));
        }
      }], ["b", p.bind(p, "bold")], ["i", p.bind(p, "italic")], ["style", function b() {
        return new q.default();
      }]];
      var Y = [B.AlignAttribute, K.DirectionAttribute].reduce(function (t, e) {
        t[e.keyName] = e;
        return t;
      }, {});
      var X = [B.AlignStyle, D.BackgroundStyle, H.ColorStyle, K.DirectionStyle, z.FontStyle, Z.SizeStyle].reduce(function (t, e) {
        t[e.keyName] = e;
        return t;
      }, {});
      var $ = function (t) {
        function e(t, n) {
          (function i(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var r = function l(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.quill.root.addEventListener("paste", r.onPaste.bind(r));
          r.container = r.quill.addContainer("ql-clipboard");
          r.container.setAttribute("contenteditable", true);
          r.container.setAttribute("tabindex", -1);
          r.matchers = [];
          G.concat(r.options.matchers).forEach(function (t) {
            var e = k(t, 2);
            var o = e[0];
            var i = e[1];
            if (n.matchVisual || i !== _) {
              r.addMatcher(o, i);
            }
          });
          return r;
        }
        (function a(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        E(e, [{
          key: "addMatcher",
          value: function (t, e) {
            this.matchers.push([t, e]);
          }
        }, {
          key: "convert",
          value: function (t) {
            if (typeof t == "string") {
              this.container.innerHTML = t.replace(/\>\r?\n +\</g, "><");
              return this.convert();
            }
            var e = this.quill.getFormat(this.quill.selection.savedRange.index);
            if (e[F.default.blotName]) {
              var n = this.container.innerText;
              this.container.innerHTML = "";
              return new q.default().insert(n, o({}, F.default.blotName, e[F.default.blotName]));
            }
            var r = this.prepareMatching();
            var i = k(r, 2);
            var l = i[0];
            var a = i[1];
            var s = h(this.container, l, a);
            if (c(s, "\n") && s.ops[s.ops.length - 1].attributes == null) {
              s = s.compose(new q.default().retain(s.length() - 1).delete(1));
            }
            V.log("convert", this.container.innerHTML, s);
            this.container.innerHTML = "";
            return s;
          }
        }, {
          key: "dangerouslyPasteHTML",
          value: function (t, e, n = C.default.sources.API) {
            if (typeof t == "string") {
              this.quill.setContents(this.convert(t), e);
              this.quill.setSelection(0, C.default.sources.SILENT);
            } else {
              var r = this.convert(e);
              this.quill.updateContents(new q.default().retain(t).concat(r), n);
              this.quill.setSelection(t + r.length(), C.default.sources.SILENT);
            }
          }
        }, {
          key: "onPaste",
          value: function (t) {
            var e = this;
            if (!t.defaultPrevented && this.quill.isEnabled()) {
              var n = this.quill.getSelection();
              var r = new q.default().retain(n.index);
              var o = this.quill.scrollingContainer.scrollTop;
              this.container.focus();
              this.quill.selection.update(C.default.sources.SILENT);
              setTimeout(function () {
                r = r.concat(e.convert()).delete(n.length);
                e.quill.updateContents(r, C.default.sources.USER);
                e.quill.setSelection(r.length() - n.length, C.default.sources.SILENT);
                e.quill.scrollingContainer.scrollTop = o;
                e.quill.focus();
              }, 1);
            }
          }
        }, {
          key: "prepareMatching",
          value: function () {
            var t = this;
            var e = [];
            var n = [];
            this.matchers.forEach(function (r) {
              var o = k(r, 2);
              var i = o[0];
              var l = o[1];
              switch (i) {
                case Node.TEXT_NODE:
                  n.push(l);
                  break;
                case Node.ELEMENT_NODE:
                  e.push(l);
                  break;
                default:
                  [].forEach.call(t.container.querySelectorAll(i), function (t) {
                    t[W] = t[W] || [];
                    t[W].push(l);
                  });
              }
            });
            return [e, n];
          }
        }]);
        return e;
      }(I.default);
      $.DEFAULTS = {
        matchers: [],
        matchVisual: true
      };
      e.default = $;
      e.matchAttributor = d;
      e.matchBlot = y;
      e.matchNewline = m;
      e.matchSpacing = _;
      e.matchText = w;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function s(t) {
        var e = t.reduce(function (t, e) {
          return t + (e.delete || 0);
        }, 0);
        var n = t.length() - e;
        if (function a(t) {
          var e = t.ops[t.ops.length - 1];
          return e != null && (e.insert != null ? typeof e.insert == "string" && e.insert.endsWith("\n") : e.attributes != null && Object.keys(e.attributes).some(function (t) {
            return f.default.query(t, f.default.Scope.BLOCK) != null;
          }));
        }(t)) {
          n -= 1;
        }
        return n;
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.getLastChangeIndex = e.default = undefined;
      var u = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var f = r(n(0));
      var p = r(n(6));
      var v = function (t) {
        function e(t, n) {
          (function o(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var r = function i(t, e) {
            if (!t) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            if (!e || typeof e != "object" && typeof e != "function") {
              return t;
            } else {
              return e;
            }
          }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.lastRecorded = 0;
          r.ignoreChange = false;
          r.clear();
          r.quill.on(p.default.events.EDITOR_CHANGE, function (t, e, n, o) {
            if (t === p.default.events.TEXT_CHANGE && !r.ignoreChange) {
              if (r.options.userOnly && o !== p.default.sources.USER) {
                r.transform(e);
              } else {
                r.record(e, n);
              }
            }
          });
          r.quill.keyboard.addBinding({
            key: "Z",
            shortKey: true
          }, r.undo.bind(r));
          r.quill.keyboard.addBinding({
            key: "Z",
            shortKey: true,
            shiftKey: true
          }, r.redo.bind(r));
          if (/Win/i.test(navigator.platform)) {
            r.quill.keyboard.addBinding({
              key: "Y",
              shortKey: true
            }, r.redo.bind(r));
          }
          return r;
        }
        (function l(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        u(e, [{
          key: "change",
          value: function (t, e) {
            if (this.stack[t].length !== 0) {
              var n = this.stack[t].pop();
              this.stack[e].push(n);
              this.lastRecorded = 0;
              this.ignoreChange = true;
              this.quill.updateContents(n[t], p.default.sources.USER);
              this.ignoreChange = false;
              var r = s(n[t]);
              this.quill.setSelection(r);
            }
          }
        }, {
          key: "clear",
          value: function () {
            this.stack = {
              undo: [],
              redo: []
            };
          }
        }, {
          key: "cutoff",
          value: function () {
            this.lastRecorded = 0;
          }
        }, {
          key: "record",
          value: function (t, e) {
            if (t.ops.length !== 0) {
              this.stack.redo = [];
              var n = this.quill.getContents().diff(e);
              var r = Date.now();
              if (this.lastRecorded + this.options.delay > r && this.stack.undo.length > 0) {
                var o = this.stack.undo.pop();
                n = n.compose(o.undo);
                t = o.redo.compose(t);
              } else {
                this.lastRecorded = r;
              }
              this.stack.undo.push({
                redo: t,
                undo: n
              });
              if (this.stack.undo.length > this.options.maxStack) {
                this.stack.undo.shift();
              }
            }
          }
        }, {
          key: "redo",
          value: function () {
            this.change("redo", "undo");
          }
        }, {
          key: "transform",
          value: function (t) {
            this.stack.undo.forEach(function (e) {
              e.undo = t.transform(e.undo, true);
              e.redo = t.transform(e.redo, true);
            });
            this.stack.redo.forEach(function (e) {
              e.undo = t.transform(e.undo, true);
              e.redo = t.transform(e.redo, true);
            });
          }
        }, {
          key: "undo",
          value: function () {
            this.change("undo", "redo");
          }
        }]);
        return e;
      }(r(n(7)).default);
      v.DEFAULTS = {
        delay: 1000,
        maxStack: 100,
        userOnly: false
      };
      e.default = v;
      e.getLastChangeIndex = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.IndentClass = undefined;
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var f = new (function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "add",
          value: function (t, n) {
            if (n === "+1" || n === "-1") {
              var r = this.value(t) || 0;
              n = n === "+1" ? r + 1 : r - 1;
            }
            if (n === 0) {
              this.remove(t);
              return true;
            } else {
              return a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "add", this).call(this, t, n);
            }
          }
        }, {
          key: "canAdd",
          value: function (t, n) {
            return a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "canAdd", this).call(this, t, n) || a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "canAdd", this).call(this, t, parseInt(n));
          }
        }, {
          key: "value",
          value: function (t) {
            return parseInt(a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this).call(this, t)) || undefined;
          }
        }]);
        return e;
      }(u.default.Attributor.Class))("indent", "ql-indent", {
        scope: u.default.Scope.BLOCK,
        whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
      });
      e.IndentClass = f;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(3)).default);
      s.blotName = "blockquote";
      s.tagName = "blockquote";
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var u = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, null, [{
          key: "formats",
          value: function (t) {
            return this.tagName.indexOf(t.tagName) + 1;
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(3)).default);
      u.blotName = "header";
      u.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
      e.default = u;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function i(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function l(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function a(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.ListItem = undefined;
      var s = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var u = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var f = r(n(0));
      var p = r(n(3));
      var y = r(n(23));
      var v = function (t) {
        function e() {
          i(this, e);
          return l(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        a(e, t);
        s(e, [{
          key: "format",
          value: function (t, n) {
            if (t !== b.blotName || n) {
              u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            } else {
              this.replaceWith(f.default.create(this.statics.scope));
            }
          }
        }, {
          key: "remove",
          value: function () {
            if (this.prev == null && this.next == null) {
              this.parent.remove();
            } else {
              u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "remove", this).call(this);
            }
          }
        }, {
          key: "replaceWith",
          value: function (t, n) {
            this.parent.isolate(this.offset(this.parent), this.length());
            if (t === this.parent.statics.blotName) {
              this.parent.replaceWith(t, n);
              return this;
            } else {
              this.parent.unwrap();
              return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replaceWith", this).call(this, t, n);
            }
          }
        }], [{
          key: "formats",
          value: function (t) {
            if (t.tagName === this.tagName) {
              return undefined;
            } else {
              return u(e.__proto__ || Object.getPrototypeOf(e), "formats", this).call(this, t);
            }
          }
        }]);
        return e;
      }(p.default);
      v.blotName = "list-item";
      v.tagName = "LI";
      var b = function (t) {
        function e(t) {
          i(this, e);
          var n = l(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
          function r(e) {
            if (e.target.parentNode === t) {
              var r = n.statics.formats(t);
              var o = f.default.find(e.target);
              if (r === "checked") {
                o.format("list", "unchecked");
              } else if (r === "unchecked") {
                o.format("list", "checked");
              }
            }
          }
          t.addEventListener("touchstart", r);
          t.addEventListener("mousedown", r);
          return n;
        }
        a(e, t);
        s(e, null, [{
          key: "create",
          value: function (t) {
            var n = t === "ordered" ? "OL" : "UL";
            var r = u(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, n);
            if (t === "checked" || t === "unchecked") {
              r.setAttribute("data-checked", t === "checked");
            }
            return r;
          }
        }, {
          key: "formats",
          value: function (t) {
            if (t.tagName === "OL") {
              return "ordered";
            } else if (t.tagName === "UL") {
              if (t.hasAttribute("data-checked")) {
                if (t.getAttribute("data-checked") === "true") {
                  return "checked";
                } else {
                  return "unchecked";
                }
              } else {
                return "bullet";
              }
            } else {
              return undefined;
            }
          }
        }]);
        s(e, [{
          key: "format",
          value: function (t, e) {
            if (this.children.length > 0) {
              this.children.tail.format(t, e);
            }
          }
        }, {
          key: "formats",
          value: function () {
            return function o(t, e, n) {
              if (e in t) {
                Object.defineProperty(t, e, {
                  value: n,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                t[e] = n;
              }
              return t;
            }({}, this.statics.blotName, this.statics.formats(this.domNode));
          }
        }, {
          key: "insertBefore",
          value: function (t, n) {
            if (t instanceof v) {
              u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n);
            } else {
              var r = n == null ? this.length() : n.offset(this);
              var o = this.split(r);
              o.parent.insertBefore(t, o);
            }
          }
        }, {
          key: "optimize",
          value: function (t) {
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t);
            var n = this.next;
            if (n != null && n.prev === this && n.statics.blotName === this.statics.blotName && n.domNode.tagName === this.domNode.tagName && n.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked")) {
              n.moveChildren(this);
              n.remove();
            }
          }
        }, {
          key: "replace",
          value: function (t) {
            if (t.statics.blotName !== this.statics.blotName) {
              var n = f.default.create(this.statics.defaultChild);
              t.moveChildren(n);
              this.appendChild(n);
            }
            u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replace", this).call(this, t);
          }
        }]);
        return e;
      }(y.default);
      b.blotName = "list";
      b.scope = f.default.Scope.BLOCK_BLOT;
      b.tagName = ["OL", "UL"];
      b.defaultChild = "list-item";
      b.allowedChildren = [v];
      e.ListItem = v;
      e.default = b;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(39)).default);
      s.blotName = "italic";
      s.tagName = ["EM", "I"];
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, null, [{
          key: "create",
          value: function (t) {
            if (t === "super") {
              return document.createElement("sup");
            } else if (t === "sub") {
              return document.createElement("sub");
            } else {
              return a(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            }
          }
        }, {
          key: "formats",
          value: function (t) {
            if (t.tagName === "SUB") {
              return "sub";
            } else if (t.tagName === "SUP") {
              return "super";
            } else {
              return undefined;
            }
          }
        }]);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(5)).default);
      c.blotName = "script";
      c.tagName = ["SUB", "SUP"];
      e.default = c;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(5)).default);
      s.blotName = "strike";
      s.tagName = "S";
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var s = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        return e;
      }(function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(5)).default);
      s.blotName = "underline";
      s.tagName = "U";
      e.default = s;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(0));
      var c = n(15);
      var f = ["alt", "height", "width"];
      var h = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "format",
          value: function (t, n) {
            if (f.indexOf(t) > -1) {
              if (n) {
                this.domNode.setAttribute(t, n);
              } else {
                this.domNode.removeAttribute(t);
              }
            } else {
              a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            }
          }
        }], [{
          key: "create",
          value: function (t) {
            var n = a(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            if (typeof t == "string") {
              n.setAttribute("src", this.sanitize(t));
            }
            return n;
          }
        }, {
          key: "formats",
          value: function (t) {
            return f.reduce(function (e, n) {
              if (t.hasAttribute(n)) {
                e[n] = t.getAttribute(n);
              }
              return e;
            }, {});
          }
        }, {
          key: "match",
          value: function (t) {
            return /\.(jpe?g|gif|png)$/.test(t) || /^data:image\/.+;base64/.test(t);
          }
        }, {
          key: "sanitize",
          value: function (t) {
            if ((0, c.sanitize)(t, ["http", "https", "data"])) {
              return t;
            } else {
              return "//:0";
            }
          }
        }, {
          key: "value",
          value: function (t) {
            return t.getAttribute("src");
          }
        }]);
        return e;
      }(u.default.Embed);
      h.blotName = "image";
      h.tagName = "IMG";
      e.default = h;
    }, function (t, e, n) {
      "use strict";
  
      function r(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function o(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      var l = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var s = n(3);
      var c = function (t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }(n(15));
      var f = ["height", "width"];
      var h = function (t) {
        function e() {
          r(this, e);
          return o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        (function i(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        l(e, [{
          key: "format",
          value: function (t, n) {
            if (f.indexOf(t) > -1) {
              if (n) {
                this.domNode.setAttribute(t, n);
              } else {
                this.domNode.removeAttribute(t);
              }
            } else {
              a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n);
            }
          }
        }], [{
          key: "create",
          value: function (t) {
            var n = a(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            n.setAttribute("frameborder", "0");
            n.setAttribute("allowfullscreen", true);
            n.setAttribute("src", this.sanitize(t));
            return n;
          }
        }, {
          key: "formats",
          value: function (t) {
            return f.reduce(function (e, n) {
              if (t.hasAttribute(n)) {
                e[n] = t.getAttribute(n);
              }
              return e;
            }, {});
          }
        }, {
          key: "sanitize",
          value: function (t) {
            return c.default.sanitize(t);
          }
        }, {
          key: "value",
          value: function (t) {
            return t.getAttribute("src");
          }
        }]);
        return e;
      }(s.BlockEmbed);
      h.blotName = "video";
      h.className = "ql-video";
      h.tagName = "IFRAME";
      e.default = h;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.FormulaBlot = undefined;
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = r(n(33));
      var h = r(n(6));
      var d = r(n(7));
      var y = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        l(e, t);
        a(e, null, [{
          key: "create",
          value: function (t) {
            var n = s(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t);
            if (typeof t == "string") {
              window.katex.render(t, n, {
                throwOnError: false,
                errorColor: "#f00"
              });
              n.setAttribute("data-value", t);
            }
            return n;
          }
        }, {
          key: "value",
          value: function (t) {
            return t.getAttribute("data-value");
          }
        }]);
        return e;
      }(c.default);
      y.blotName = "formula";
      y.className = "ql-formula";
      y.tagName = "SPAN";
      var v = function (t) {
        function e() {
          o(this, e);
          var t = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
          if (window.katex == null) {
            throw new Error("Formula module requires KaTeX.");
          }
          return t;
        }
        l(e, t);
        a(e, null, [{
          key: "register",
          value: function () {
            h.default.register(y, true);
          }
        }]);
        return e;
      }(d.default);
      e.FormulaBlot = y;
      e.default = v;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.CodeToken = e.CodeBlock = undefined;
      var a = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var c = r(n(0));
      var h = r(n(6));
      var d = r(n(7));
      var b = function (t) {
        function e() {
          o(this, e);
          return i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
        }
        l(e, t);
        a(e, [{
          key: "replaceWith",
          value: function (t) {
            this.domNode.textContent = this.domNode.textContent;
            this.attach();
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replaceWith", this).call(this, t);
          }
        }, {
          key: "highlight",
          value: function (t) {
            var e = this.domNode.textContent;
            if (this.cachedText !== e) {
              if (e.trim().length > 0 || this.cachedText == null) {
                this.domNode.innerHTML = t(e);
                this.domNode.normalize();
                this.attach();
              }
              this.cachedText = e;
            }
          }
        }]);
        return e;
      }(r(n(13)).default);
      b.className = "ql-syntax";
      var g = new c.default.Attributor.Class("token", "hljs", {
        scope: c.default.Scope.INLINE
      });
      var m = function (t) {
        function e(t, n) {
          o(this, e);
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          if (typeof r.options.highlight != "function") {
            throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
          }
          var l = null;
          r.quill.on(h.default.events.SCROLL_OPTIMIZE, function () {
            clearTimeout(l);
            l = setTimeout(function () {
              r.highlight();
              l = null;
            }, r.options.interval);
          });
          r.highlight();
          return r;
        }
        l(e, t);
        a(e, null, [{
          key: "register",
          value: function () {
            h.default.register(g, true);
            h.default.register(b, true);
          }
        }]);
        a(e, [{
          key: "highlight",
          value: function () {
            var t = this;
            if (!this.quill.selection.composing) {
              this.quill.update(h.default.sources.USER);
              var e = this.quill.getSelection();
              this.quill.scroll.descendants(b).forEach(function (e) {
                e.highlight(t.options.highlight);
              });
              this.quill.update(h.default.sources.SILENT);
              if (e != null) {
                this.quill.setSelection(e, h.default.sources.SILENT);
              }
            }
          }
        }]);
        return e;
      }(d.default);
      m.DEFAULTS = {
        highlight: window.hljs == null ? null : function (t) {
          return window.hljs.highlightAuto(t).value;
        },
        interval: 1000
      };
      e.CodeBlock = b;
      e.CodeToken = g;
      e.default = m;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function l(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function s(t, e, n) {
        var r = document.createElement("button");
        r.setAttribute("type", "button");
        r.classList.add("ql-" + e);
        if (n != null) {
          r.value = n;
        }
        t.appendChild(r);
      }
      function u(t, e) {
        if (!Array.isArray(e[0])) {
          e = [e];
        }
        e.forEach(function (e) {
          var n = document.createElement("span");
          n.classList.add("ql-formats");
          e.forEach(function (t) {
            if (typeof t == "string") {
              s(n, t);
            } else {
              var e = Object.keys(t)[0];
              var r = t[e];
              if (Array.isArray(r)) {
                (function c(t, e, n) {
                  var r = document.createElement("select");
                  r.classList.add("ql-" + e);
                  n.forEach(function (t) {
                    var e = document.createElement("option");
                    if (t !== false) {
                      e.setAttribute("value", t);
                    } else {
                      e.setAttribute("selected", "selected");
                    }
                    r.appendChild(e);
                  });
                  t.appendChild(r);
                })(n, e, r);
              } else {
                s(n, e, r);
              }
            }
          });
          t.appendChild(n);
        });
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.addControls = e.default = undefined;
      function f(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var h = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var d = r(n(4));
      var v = r(n(0));
      var g = r(n(6));
      var _ = r(n(10));
      var w = r(n(7));
      var x = (0, _.default)("quill:toolbar");
      var k = function (t) {
        function e(t, n) {
          (function i(t, e) {
            if (!(t instanceof e)) {
              throw new TypeError("Cannot call a class as a function");
            }
          })(this, e);
          var a;
          var r = l(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          if (Array.isArray(r.options.container)) {
            var o = document.createElement("div");
            u(o, r.options.container);
            t.container.parentNode.insertBefore(o, t.container);
            r.container = o;
          } else if (typeof r.options.container == "string") {
            r.container = document.querySelector(r.options.container);
          } else {
            r.container = r.options.container;
          }
          if (r.container instanceof HTMLElement) {
            r.container.classList.add("ql-toolbar");
            r.controls = [];
            r.handlers = {};
            Object.keys(r.options.handlers).forEach(function (t) {
              r.addHandler(t, r.options.handlers[t]);
            });
            [].forEach.call(r.container.querySelectorAll("button, select"), function (t) {
              r.attach(t);
            });
            r.quill.on(g.default.events.EDITOR_CHANGE, function (t, e) {
              if (t === g.default.events.SELECTION_CHANGE) {
                r.update(e);
              }
            });
            r.quill.on(g.default.events.SCROLL_OPTIMIZE, function () {
              var t = r.quill.selection.getRange();
              var n = f(t, 1)[0];
              r.update(n);
            });
            return r;
          } else {
            a = x.error("Container required for toolbar", r.options);
            return l(r, a);
          }
        }
        (function a(t, e) {
          if (typeof e != "function" && e !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          }
          t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (e) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(t, e);
            } else {
              t.__proto__ = e;
            }
          }
        })(e, t);
        h(e, [{
          key: "addHandler",
          value: function (t, e) {
            this.handlers[t] = e;
          }
        }, {
          key: "attach",
          value: function (t) {
            var e = this;
            var n = [].find.call(t.classList, function (t) {
              return t.indexOf("ql-") === 0;
            });
            if (n) {
              n = n.slice("ql-".length);
              if (t.tagName === "BUTTON") {
                t.setAttribute("type", "button");
              }
              if (this.handlers[n] == null) {
                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[n] == null) {
                  x.warn("ignoring attaching to disabled format", n, t);
                  return;
                }
                if (v.default.query(n) == null) {
                  x.warn("ignoring attaching to nonexistent format", n, t);
                  return;
                }
              }
              var r = t.tagName === "SELECT" ? "change" : "click";
              t.addEventListener(r, function (r) {
                var i = undefined;
                if (t.tagName === "SELECT") {
                  if (t.selectedIndex < 0) {
                    return;
                  }
                  var l = t.options[t.selectedIndex];
                  i = !l.hasAttribute("selected") && (l.value || false);
                } else {
                  i = !t.classList.contains("ql-active") && (t.value || !t.hasAttribute("value"));
                  r.preventDefault();
                }
                e.quill.focus();
                var a = e.quill.selection.getRange();
                var u = f(a, 1)[0];
                if (e.handlers[n] != null) {
                  e.handlers[n].call(e, i);
                } else if (v.default.query(n).prototype instanceof v.default.Embed) {
                  if (!(i = prompt("Enter " + n))) {
                    return;
                  }
                  e.quill.updateContents(new d.default().retain(u.index).delete(u.length).insert(function o(t, e, n) {
                    if (e in t) {
                      Object.defineProperty(t, e, {
                        value: n,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      });
                    } else {
                      t[e] = n;
                    }
                    return t;
                  }({}, n, i)), g.default.sources.USER);
                } else {
                  e.quill.format(n, i, g.default.sources.USER);
                }
                e.update(u);
              });
              this.controls.push([n, t]);
            }
          }
        }, {
          key: "update",
          value: function (t) {
            var e = t == null ? {} : this.quill.getFormat(t);
            this.controls.forEach(function (n) {
              var r = f(n, 2);
              var o = r[0];
              var i = r[1];
              if (i.tagName === "SELECT") {
                var l = undefined;
                if (t == null) {
                  l = null;
                } else if (e[o] == null) {
                  l = i.querySelector("option[selected]");
                } else if (!Array.isArray(e[o])) {
                  var a = e[o];
                  if (typeof a == "string") {
                    a = a.replace(/\"/g, "\\\"");
                  }
                  l = i.querySelector("option[value=\"" + a + "\"]");
                }
                if (l == null) {
                  i.value = "";
                  i.selectedIndex = -1;
                } else {
                  l.selected = true;
                }
              } else if (t == null) {
                i.classList.remove("ql-active");
              } else if (i.hasAttribute("value")) {
                var s = e[o] === i.getAttribute("value") || e[o] != null && e[o].toString() === i.getAttribute("value") || e[o] == null && !i.getAttribute("value");
                i.classList.toggle("ql-active", s);
              } else {
                i.classList.toggle("ql-active", e[o] != null);
              }
            });
          }
        }]);
        return e;
      }(w.default);
      k.DEFAULTS = {};
      k.DEFAULTS = {
        container: null,
        handlers: {
          clean: function () {
            var t = this;
            var e = this.quill.getSelection();
            if (e != null) {
              if (e.length == 0) {
                var n = this.quill.getFormat();
                Object.keys(n).forEach(function (e) {
                  if (v.default.query(e, v.default.Scope.INLINE) != null) {
                    t.quill.format(e, false);
                  }
                });
              } else {
                this.quill.removeFormat(e, g.default.sources.USER);
              }
            }
          },
          direction: function (t) {
            var e = this.quill.getFormat().align;
            if (t === "rtl" && e == null) {
              this.quill.format("align", "right", g.default.sources.USER);
            } else if (!t && e === "right") {
              this.quill.format("align", false, g.default.sources.USER);
            }
            this.quill.format("direction", t, g.default.sources.USER);
          },
          indent: function (t) {
            var e = this.quill.getSelection();
            var n = this.quill.getFormat(e);
            var r = parseInt(n.indent || 0);
            if (t === "+1" || t === "-1") {
              var o = t === "+1" ? 1 : -1;
              if (n.direction === "rtl") {
                o *= -1;
              }
              this.quill.format("indent", r + o, g.default.sources.USER);
            }
          },
          link: function (t) {
            if (t === true) {
              t = prompt("Enter link URL:");
            }
            this.quill.format("link", t, g.default.sources.USER);
          },
          list: function (t) {
            var e = this.quill.getSelection();
            var n = this.quill.getFormat(e);
            if (t === "check") {
              if (n.list === "checked" || n.list === "unchecked") {
                this.quill.format("list", false, g.default.sources.USER);
              } else {
                this.quill.format("list", "unchecked", g.default.sources.USER);
              }
            } else {
              this.quill.format("list", t, g.default.sources.USER);
            }
          }
        }
      };
      e.default = k;
      e.addControls = u;
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";
    }, function (t, e) {
      t.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";
    }, function (t, e) {
      t.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      e.default = e.BubbleTooltip = undefined;
      var a = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var s = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var c = r(n(2));
      var h = r(n(9));
      var p = n(44);
      var d = r(p);
      var y = n(22);
      var b = r(n(26));
      var g = [["bold", "italic", "link"], [{
        header: 1
      }, {
        header: 2
      }, "blockquote"]];
      var m = function (t) {
        function e(t, n) {
          o(this, e);
          if (n.modules.toolbar != null && n.modules.toolbar.container == null) {
            n.modules.toolbar.container = g;
          }
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.quill.container.classList.add("ql-bubble");
          return r;
        }
        l(e, t);
        s(e, [{
          key: "extendToolbar",
          value: function (t) {
            this.tooltip = new _(this.quill, this.options.bounds);
            this.tooltip.root.appendChild(t.container);
            this.buildButtons([].slice.call(t.container.querySelectorAll("button")), b.default);
            this.buildPickers([].slice.call(t.container.querySelectorAll("select")), b.default);
          }
        }]);
        return e;
      }(d.default);
      m.DEFAULTS = (0, c.default)(true, {}, d.default.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              link: function (t) {
                if (t) {
                  this.quill.theme.tooltip.edit();
                } else {
                  this.quill.format("link", false);
                }
              }
            }
          }
        }
      });
      var _ = function (t) {
        function e(t, n) {
          o(this, e);
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.quill.on(h.default.events.EDITOR_CHANGE, function (t, e, n, o) {
            if (t === h.default.events.SELECTION_CHANGE) {
              if (e != null && e.length > 0 && o === h.default.sources.USER) {
                r.show();
                r.root.style.left = "0px";
                r.root.style.width = "";
                r.root.style.width = r.root.offsetWidth + "px";
                var i = r.quill.getLines(e.index, e.length);
                if (i.length === 1) {
                  r.position(r.quill.getBounds(e));
                } else {
                  var l = i[i.length - 1];
                  var a = r.quill.getIndex(l);
                  var s = Math.min(l.length() - 1, e.index + e.length - a);
                  var u = r.quill.getBounds(new y.Range(a, s));
                  r.position(u);
                }
              } else if (document.activeElement !== r.textbox && r.quill.hasFocus()) {
                r.hide();
              }
            }
          });
          return r;
        }
        l(e, t);
        s(e, [{
          key: "listen",
          value: function () {
            var t = this;
            a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "listen", this).call(this);
            this.root.querySelector(".ql-close").addEventListener("click", function () {
              t.root.classList.remove("ql-editing");
            });
            this.quill.on(h.default.events.SCROLL_OPTIMIZE, function () {
              setTimeout(function () {
                if (!t.root.classList.contains("ql-hidden")) {
                  var e = t.quill.getSelection();
                  if (e != null) {
                    t.position(t.quill.getBounds(e));
                  }
                }
              }, 1);
            });
          }
        }, {
          key: "cancel",
          value: function () {
            this.show();
          }
        }, {
          key: "position",
          value: function (t) {
            var n = a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "position", this).call(this, t);
            var r = this.root.querySelector(".ql-tooltip-arrow");
            r.style.marginLeft = "";
            if (n === 0) {
              return n;
            }
            r.style.marginLeft = n * -1 - r.offsetWidth / 2 + "px";
          }
        }]);
        return e;
      }(p.BaseTooltip);
      _.TEMPLATE = ["<span class=\"ql-tooltip-arrow\"></span>", "<div class=\"ql-tooltip-editor\">", "<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">", "<a class=\"ql-close\"></a>", "</div>"].join("");
      e.BubbleTooltip = _;
      e.default = m;
    }, function (t, e, n) {
      "use strict";
  
      function r(t) {
        if (t && t.__esModule) {
          return t;
        } else {
          return {
            default: t
          };
        }
      }
      function o(t, e) {
        if (!(t instanceof e)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function i(t, e) {
        if (!t) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        if (!e || typeof e != "object" && typeof e != "function") {
          return t;
        } else {
          return e;
        }
      }
      function l(t, e) {
        if (typeof e != "function" && e !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        }
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (e) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(t, e);
          } else {
            t.__proto__ = e;
          }
        }
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
      function a(e, n) {
        if (Array.isArray(e)) {
          return e;
        }
        if (Symbol.iterator in Object(e)) {
          return function t(t, e) {
            var n = [];
            var r = true;
            var o = false;
            var i = undefined;
            try {
              for (var l, a = t[Symbol.iterator](); !(r = (l = a.next()).done) && (n.push(l.value), !e || n.length !== e); r = true);
            } catch (t) {
              o = true;
              i = t;
            } finally {
              try {
                if (!r && a.return) {
                  a.return();
                }
              } finally {
                if (o) {
                  throw i;
                }
              }
            }
            return n;
          }(e, n);
        }
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var s = function t(e, n, r) {
        if (e === null) {
          e = Function.prototype;
        }
        var o = Object.getOwnPropertyDescriptor(e, n);
        if (o === undefined) {
          var i = Object.getPrototypeOf(e);
          if (i === null) {
            return undefined;
          } else {
            return t(i, n, r);
          }
        }
        if ("value" in o) {
          return o.value;
        }
        var l = o.get;
        if (l !== undefined) {
          return l.call(r);
        } else {
          return undefined;
        }
      };
      var u = function () {
        function t(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || false;
            r.configurable = true;
            if ("value" in r) {
              r.writable = true;
            }
            Object.defineProperty(t, r.key, r);
          }
        }
        return function (e, n, r) {
          if (n) {
            t(e.prototype, n);
          }
          if (r) {
            t(e, r);
          }
          return e;
        };
      }();
      var f = r(n(2));
      var p = r(n(9));
      var d = n(44);
      var y = r(d);
      var b = r(n(15));
      var g = n(22);
      var _ = r(n(26));
      var O = [[{
        header: ["1", "2", "3", false]
      }], ["bold", "italic", "underline", "link"], [{
        list: "ordered"
      }, {
        list: "bullet"
      }], ["clean"]];
      var w = function (t) {
        function e(t, n) {
          o(this, e);
          if (n.modules.toolbar != null && n.modules.toolbar.container == null) {
            n.modules.toolbar.container = O;
          }
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.quill.container.classList.add("ql-snow");
          return r;
        }
        l(e, t);
        u(e, [{
          key: "extendToolbar",
          value: function (t) {
            t.container.classList.add("ql-snow");
            this.buildButtons([].slice.call(t.container.querySelectorAll("button")), _.default);
            this.buildPickers([].slice.call(t.container.querySelectorAll("select")), _.default);
            this.tooltip = new x(this.quill, this.options.bounds);
            if (t.container.querySelector(".ql-link")) {
              this.quill.keyboard.addBinding({
                key: "K",
                shortKey: true
              }, function (e, n) {
                t.handlers.link.call(t, !n.format.link);
              });
            }
          }
        }]);
        return e;
      }(y.default);
      w.DEFAULTS = (0, f.default)(true, {}, y.default.DEFAULTS, {
        modules: {
          toolbar: {
            handlers: {
              link: function (t) {
                if (t) {
                  var e = this.quill.getSelection();
                  if (e == null || e.length == 0) {
                    return;
                  }
                  var n = this.quill.getText(e);
                  if (/^\S+@\S+\.\S+$/.test(n) && n.indexOf("mailto:") !== 0) {
                    n = "mailto:" + n;
                  }
                  this.quill.theme.tooltip.edit("link", n);
                } else {
                  this.quill.format("link", false);
                }
              }
            }
          }
        }
      });
      var x = function (t) {
        function e(t, n) {
          o(this, e);
          var r = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
          r.preview = r.root.querySelector("a.ql-preview");
          return r;
        }
        l(e, t);
        u(e, [{
          key: "listen",
          value: function () {
            var t = this;
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "listen", this).call(this);
            this.root.querySelector("a.ql-action").addEventListener("click", function (e) {
              if (t.root.classList.contains("ql-editing")) {
                t.save();
              } else {
                t.edit("link", t.preview.textContent);
              }
              e.preventDefault();
            });
            this.root.querySelector("a.ql-remove").addEventListener("click", function (e) {
              if (t.linkRange != null) {
                var n = t.linkRange;
                t.restoreFocus();
                t.quill.formatText(n, "link", false, p.default.sources.USER);
                delete t.linkRange;
              }
              e.preventDefault();
              t.hide();
            });
            this.quill.on(p.default.events.SELECTION_CHANGE, function (e, n, r) {
              if (e != null) {
                if (e.length === 0 && r === p.default.sources.USER) {
                  var o = t.quill.scroll.descendant(b.default, e.index);
                  var i = a(o, 2);
                  var l = i[0];
                  var s = i[1];
                  if (l != null) {
                    t.linkRange = new g.Range(e.index - s, l.length());
                    var u = b.default.formats(l.domNode);
                    t.preview.textContent = u;
                    t.preview.setAttribute("href", u);
                    t.show();
                    t.position(t.quill.getBounds(t.linkRange));
                    return;
                  }
                } else {
                  delete t.linkRange;
                }
                t.hide();
              }
            });
          }
        }, {
          key: "show",
          value: function () {
            s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "show", this).call(this);
            this.root.removeAttribute("data-mode");
          }
        }]);
        return e;
      }(d.BaseTooltip);
      x.TEMPLATE = ["<a class=\"ql-preview\" target=\"_blank\" href=\"about:blank\"></a>", "<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">", "<a class=\"ql-action\"></a>", "<a class=\"ql-remove\"></a>"].join("");
      e.default = w;
    }]).default;
  });
  Class(function SceneLayout(_name, _options = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var _dataStore;
    var _data;
    var _timeline;
    var _breakpoint;
    var _gizmo;
    const ZERO = new Vector3();
    var _initializers = [];
    var _promises = [];
    var _breakpoints = [];
    var _folders = {};
    var _groups = {};
    var _custom = {};
    var _meshes = {};
    var _exists = {};
    var _layers = {};
    var _uil = UIL.sidebar;
    var _graph;
    var _config;
    var _groupIndex = 0;
    var _groupsSynced = Promise.create();
    function initialize(promise) {
      _promises.push(promise);
    }
    function initGizmo() {
      if (!Utils.query("nogizmo")) {
        _gizmo = _this.initClass(SceneLayoutGizmo);
      }
    }
    function createFolder(name) {
      let folder = new UILFolder(`sl_${_name}_${name}`, {
        label: name,
        closed: true
      });
      folder.hide();
      _folders[`sl_${_name}_${name}`] = folder;
      return folder;
    }
    async function initConfig() {
      let input = InputUIL.create(`CONFIG_sl_${_name}`, _uil);
      input.add("Animation");
      input.add("Layout");
      input.add("Cinema Config");
      if (_graph) {
        _graph.addSpecial("Config", `Config (${_name})`, "Config");
      }
      input.setLabel("Config");
      let animation = input.get("Animation");
      let layout = input.get("Layout");
      if (animation) {
        await ready();
        _groupsSynced.then(async () => {
          animation = animation.replace(/^\//g, "");
          _this.animation = _this.initClass(HierarchyAnimation, animation, linkObjects);
          if (_timeline) {
            _this.startRender(_ => {
              _this.animation.elapsed = _timeline.elapsed;
              _this.animation.update();
            });
          } else if (_uil) {
            let range = new UILControlRange("Animation", {
              min: 0,
              max: 1,
              step: 0.001
            });
            range.onChange(val => {
              _this.animation.elapsed = val;
              _this.animation.update();
            });
            _uil.add(range);
          }
          await _this.animation.ready();
          _this.animation.update();
        });
      }
      if (layout) {
        await ready();
        _this.layout = _this.initClass(HierarchyLayout, layout, linkObjects);
        await _this.layout.ready();
      }
      _config = input;
      await defer();
      _this.configured = true;
    }
    async function linkObjects(data) {
      let array = [];
      for (let i = 0; i < data.length; i++) {
        let name = data[i].name;
        let exists = _this.exists(name);
        if (!exists && name.toLowerCase() != "null") {
          console.warn(`linkAnimation :: ${name} does not exist`);
        }
        let group = new Group();
        let mesh = exists ? await _this.getLayer(name) : null;
        if (mesh) {
          if (_this.layout && mesh instanceof Mesh) {
            mesh._parent.add(group);
            group.add(mesh);
          } else {
            group = mesh.group || mesh;
          }
        }
        group.name = name;
        array.push(group);
      }
      return array;
    }
    async function initGraph() {
      if (_options.noGraph || !window.UILGraph || SceneLayout.noGraph) {
        _uil = null;
        _groupsSynced.resolve();
        return;
      }
      if (_graph = UILGraph.instance().getGraph(_name, _this)) {
        UIL.sidebar.element.show();
        await _this.ready();
        _graph.syncVisibility(_layers);
        _graph.syncGroupNames(_groups, _folders);
        _groupsSynced.resolve();
        if (Global.PLAYGROUND && Utils.getConstructorName(_this.parent) == Global.PLAYGROUND) {
          _graph.open();
        }
      } else {
        _groupsSynced.resolve();
      }
    }
    function initParams() {
      if (_options.rootPath) {
        if (_options.rootPath.charAt(_options.rootPath.length - 1) != "/") {
          _options.rootPath += "/";
        }
      } else {
        _options.rootPath = "";
      }
      _this.timeline = _timeline = _options.timeline;
      if (_timeline && (_timeline.add({
        v: 0
      }, {
        v: 1
      }, 100, "linear"), _uil)) {
        let range = new UILControlRange("Timeline", {
          min: 0,
          max: 1,
          step: 0.001
        });
        range.onChange(val => {
          _timeline.elapsed = val;
          _timeline.update();
        });
        _uil.add(range);
        range.hide();
        if (_graph) {
          _graph.addSpecial("Timeline", "Timeline");
        }
      }
      _this.baseRenderOrder = _options.baseRenderOrder || 0;
      _this.data = _options.data;
      _breakpoint = _options.breakpoint || SceneLayout.breakpoint;
      if (_options.breakpoint) {
        _this.localBreakpoint = true;
      }
      if (_options.uil) {
        _uil = _options.uil;
      }
    }
    async function initData() {
      await UILStorage.ready();
      _dataStore = InputUIL.create(`scenelayout_${_name}`, null);
      if ((_data = JSON.parse(_dataStore.get("data") || "{}")).layers === undefined) {
        _data.layers = -1;
      }
      if (_options.perFrame) {
        if (_data.layers > 0) {
          createLayers();
        } else {
          _this.loaded = true;
        }
      } else {
        for (let i = 0, c = _data.layers + 1; i < c; i++) {
          initialize(createLayer(i));
        }
        _this.loaded = true;
      }
    }
    function createLayers() {
      let index = 0;
      let renderWorker = new Render.Worker(function () {
        initialize(createLayer(index));
        if (index++ == _data.layers) {
          renderWorker.stop();
          _this.loaded = true;
        }
      }, _options.perFrame);
    }
    function getGroup(name) {
      if (!name) {
        return _this.group;
      }
      if (name == _name) {
        return _this.group;
      }
      if (!_groups[name]) {
        let uilGroup = _uil ? createFolder(name) : null;
        if (uilGroup) {
          uilGroup.setLabel(`${name} (Group)`);
          _uil.add(uilGroup);
          if (_graph) {
            _graph.addGroup(uilGroup.id, name);
          }
        }
        let config = InputUIL.create(`GROUP_${_name}_${name}`, uilGroup);
        config.setLabel("Parameters");
        if (_timeline) {
          config.add("tween");
        }
        config.addToggle("billboard");
        config.add("breakpoints");
        config.add("name", "hidden");
        let breakpoints = config.get("breakpoints");
        breakpoints &&= breakpoints.replace(/ /g, "").split(",");
        let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
        if (breakpoint.charAt(breakpoint.length - 1) == "-") {
          breakpoint = "";
        }
        let group = new Group();
        _groups[name] = group;
        _layers[name] = group;
        _exists[name] = "group";
        group.prefix = `${name}_${_name}${breakpoint}`;
        let meshUIL = MeshUIL.add(group, uilGroup);
        meshUIL.setLabel("Mesh");
        _this.add(group);
        if (UIL.global) {
          group._meshUIL = meshUIL;
        }
        if (uilGroup) {
          uilGroup.params = config;
        }
        if (breakpoints) {
          _breakpoints.push(group);
        }
        if (config.get("billboard")) {
          updateBillboard(true, mesh);
        }
      }
      _groupIndex++;
      return _groups[name];
    }
    async function createLayer(index, groupName) {
      let id = typeof index == "number" ? index : ++_data.layers;
      let graphGroupName = groupName;
      if (graphGroupName) {
        let nameLabel = UILStorage.get(`INPUT_GROUP_${_name}_${groupName}_name`);
        if (nameLabel) {
          groupName = nameLabel;
        }
      }
      if (UILStorage.get(`sl_${_name}_${id}_deleted`)) {
        return;
      }
      if (_this.preventLayerCreation && _this.preventLayerCreation(UILStorage.get(`INPUT_Config_${id}_${_name}_name`))) {
        return;
      }
      let group = _uil ? createFolder(id) : null;
      let shader;
      let mesh;
      let input = InputUIL.create(`Config_${id}_${_name}`, group);
      input.setLabel("Parameters");
      input.add("name", "hidden").addFile("geometry", {
        relative: "assets/geometry"
      }).addToggle("visible", true).addToggle("transparent").addToggle("depthWrite", true).addToggle("depthTest", true).addToggle("castShadow").addToggle("receiveShadow").addToggle("receiveLight").addToggle("billboard").add("shader").add("customClass").add("scriptClass").add("wildcard").add("renderOrder", "hidden").add("group", "hidden").add("breakpoints").addSelect("side", [{
        label: "Front Side",
        value: "shader_front_side"
      }, {
        label: "Back Side",
        value: "shader_back_side"
      }, {
        label: "Double Side",
        value: "shader_double_side"
      }, {
        label: "Double Side Transparent",
        value: "shader_double_side_trasparency"
      }]).addSelect("blending", [{
        label: "Normal",
        value: "shader_normal_blending"
      }, {
        label: "Additive",
        value: "shader_additive_blending"
      }, {
        label: "Premultiplied Alpha",
        value: "shader_premultiplied_alpha_blending"
      }]);
      input.name = _name;
      input.prefix = `Element_${id}_${_name}`;
      input.id = id;
      if (group) {
        group.params = input;
      }
      if (_timeline) {
        input.addToggle("tween");
      }
      if (_options.physics) {
        input.addToggle("physics");
        input.add("physicsCode");
      }
      let name = input.get("name") || id;
      let shaderName = input.get("shader") || "SceneLayout";
      let geomPath = input.getFilePath("geometry");
      let visible = input.get("visible");
      let transparent = input.get("transparent");
      let depthWrite = input.get("depthWrite");
      let depthTest = input.get("depthTest");
      let billboard = input.get("billboard");
      let doTween = input.get("tween");
      let renderOrder = input.getNumber("renderOrder");
      let blending = input.get("blending");
      let side = input.get("side");
      let physics = input.get("physics");
      let castShadow = input.get("castShadow");
      let receiveShadow = input.get("receiveShadow");
      let receiveLight = input.get("receiveLight");
      let breakpoints = input.get("breakpoints");
      breakpoints &&= breakpoints.replace(/ /g, "").split(",");
      let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
      if (breakpoint.charAt(breakpoint.length - 1) == "-") {
        breakpoint = "";
      }
      if (name && group) {
        group.setLabel(name);
      }
      if (groupName) {
        input.setValue("group", groupName);
      }
      let groupParent = getGroup(input.get("group"));
      if (group) {
        let groupName = input.get("group");
        let groupId = groupName ? `sl_${_name}_${graphGroupName || groupName}` : undefined;
        if (_graph) {
          _graph.addLayer(group.id, name || id + "", groupId);
        }
      }
      if (_uil) {
        _uil.add(group);
      }
      if (name == "ignore") {
        return;
      }
      let customClass = input.get("customClass");
      let scriptClass = input.get("scriptClass");
      let customCompile;
      if (shaderName.includes("|")) {
        [shaderName, customCompile] = shaderName.split("|");
      }
      _exists[name] = customClass ? "custom" : "mesh";
      if (customClass) {
        if (customClass === _this.parent.constructor.name) {
          return console.warn(`Tried to recursively initialize ${customClass}`);
        }
        if (!window[customClass]) {
          return console.warn(`Tried to initialize ${customClass} but it doesn't  exist!`);
        }
        let obj = _this.initClass(window[customClass], input, group, id, null);
        mesh = obj.group;
        obj.wildcard = input.get("wildcard");
        if (typeof visible == "boolean" && mesh) {
          mesh.visible = visible;
        }
        _custom[name] = obj;
        _layers[name] = obj;
        if (_this.onCreateLayer) {
          let capture = cb => {
            _this.delayedCall(_ => cb(obj, name), 32);
            return true;
          };
          if (_this.onCreateLayer(name, group, capture) === true) {
            return;
          }
        }
        if (obj.group) {
          groupParent.add(obj.group);
        }
        obj.renderOrder = _this.baseRenderOrder + renderOrder;
        if (mesh) {
          if (!obj.camera) {
            mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
            let meshUIL = MeshUIL.add(mesh, group);
            meshUIL.setLabel("Mesh");
            if (UIL.global) {
              mesh._meshUIL = meshUIL;
            }
          }
          _breakpoints.push(mesh);
          if (scriptClass && visible !== false) {
            if (scriptClass.includes(",")) {
              scriptClass = scriptClass.replace(/ /g, "").split(",");
              scriptClass.forEach(script => {
                if (window[script]) {
                  mesh.scriptClass = mesh.scriptClass || [];
                  mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input));
                } else {
                  console.warn(`scriptClass ${script} not found`);
                }
              });
            } else if (window[scriptClass]) {
              mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input);
            } else {
              console.warn(`scriptClass ${scriptClass} not found`);
            }
          }
        }
        return;
      }
      if (_this.onCreateLayer) {
        let capture = cb => {
          let mesh = new Group();
          mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
          MeshUIL.add(mesh, group);
          _meshes[name] = mesh;
          _layers[name] = mesh;
          _this.delayedCall(_ => cb(mesh, name), 32);
          return true;
        };
        if (_this.onCreateLayer(name, group, capture) === true) {
          return;
        }
      }
      let geom = World.PLANE;
      if (geomPath && geomPath.includes(["World", "SceneLayout"])) {
        geom = eval(geomPath);
        geomPath = null;
      }
      if (shaderName.includes(".shader")) {
        let shaderLayer = shaderName.split(".shader")[0];
        let layer = await _this.getLayer(shaderLayer);
        shader = layer.shader;
        shader._copied = layer;
      } else if (shaderName.includes("PBR")) {
        shader = _this.initClass(PBRShader, shaderName, {
          unique: `Element_${id}_${_name}`
        });
      } else {
        let texturePath = input.getImage("texture");
        if (texturePath) {
          if (!texturePath.includes("assets/images")) {
            texturePath = _options.rootPath + texturePath;
          }
        } else {
          texturePath = "assets/images/_scenelayout/uv.jpg";
        }
        shader = _this.initClass(Shader, shaderName, {
          unique: `Element_${id}_${_name}`,
          customCompile: customCompile
        });
        if (shaderName == "SceneLayout" || !window[shaderName]) {
          shader.addUniforms({
            tMap: {
              value: Utils3D.getTexture(texturePath)
            },
            uAlpha: {
              value: 1
            }
          });
        }
        defer(_ => {
          for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (uniform.value instanceof Texture) {
              initialize(uniform.value.promise);
            }
          }
        });
      }
      if (typeof depthWrite == "boolean") {
        shader.depthWrite = depthWrite;
      }
      if (typeof depthTest == "boolean") {
        shader.depthTest = depthTest;
      }
      if (typeof transparent == "boolean") {
        shader.transparent = transparent;
      }
      if (_this.onCreateGeometry) {
        geomPath = _this.onCreateGeometry(geomPath, input.get("wildcard"));
      }
      if (geomPath) {
        geom = await GeomThread.loadGeometry(geomPath);
      }
      mesh = new Mesh(geom, shader);
      if (typeof _options.frustumCulled == "boolean") {
        mesh.frustumCulled = _options.frustumCulled;
      }
      if (typeof visible == "boolean") {
        mesh.visible = visible;
      }
      groupParent.add(mesh);
      mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
      mesh.uilName = name;
      mesh.wildcard = input.get("wildcard");
      let meshUIL = MeshUIL.add(mesh, group);
      meshUIL.setLabel("Mesh");
      if (UIL.global) {
        mesh._meshUIL = meshUIL;
      }
      if (physics) {
        let obj = Physics.instance().create(mesh);
        obj.prefix = `Physics_${id}_${_name}`;
        PhysicsUIL.add(obj, group).setLabel("Physics");
        let code = input.get("physicsCode");
        if (code) {
          _this.initClass(window[code], obj, mesh, group, input);
        }
      }
      _meshes[name] = mesh;
      _layers[name] = mesh;
      if (breakpoints) {
        _breakpoints.push(mesh);
      }
      mesh.renderOrder = _this.baseRenderOrder + (renderOrder || 0);
      if (billboard) {
        updateBillboard(true, mesh);
      }
      if (shaderName != "SceneLayout" && window[shaderName]) {
        mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);
      }
      if (!shader._copied && (shader === mesh.shader || !!shaderName.includes("PBR"))) {
        ShaderUIL.add(shader, group).setLabel("Shader");
      }
      if (shader._copied && shader._copied.shaderClass && shader._copied.shaderClass.applyClone) {
        shader._copied.shaderClass.applyClone(mesh);
      }
      if (typeof index != "number") {
        _dataStore.setValue("data", JSON.stringify(_data));
      }
      if (blending) {
        shader.blending = blending;
      }
      if (side) {
        shader.side = side;
      }
      if (castShadow) {
        mesh.castShadow = castShadow;
      }
      if (receiveShadow) {
        shader.receiveShadow = receiveShadow;
      }
      if (receiveLight) {
        shader.receiveLight = receiveLight;
      }
      if (scriptClass) {
        if (scriptClass.includes(",")) {
          scriptClass = scriptClass.replace(/ /g, "").split(",");
          scriptClass.forEach(script => {
            if (window[script]) {
              mesh.scriptClass = mesh.scriptClass || [];
              mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input));
            } else {
              console.warn(`scriptClass ${script} not found`);
            }
          });
        } else if (window[scriptClass]) {
          mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input);
        } else {
          console.warn(`scriptClass ${scriptClass} not found`);
        }
      }
      input.onUpdate = key => {
        switch (key) {
          case "name":
            group.setLabel(input.get(key));
            break;
          case "visible":
            mesh.visible = input.get(key);
            break;
          case "renderOrder":
            mesh.renderOrder = _this.baseRenderOrder + input.getNumber(key);
            break;
          case "transparent":
            shader.transparent = input.get(key);
            break;
          case "depthWrite":
            shader.depthWrite = input.get(key);
            break;
          case "depthTest":
            shader.depthTest = input.get(key);
            break;
          case "side":
            shader.side = input.get(key);
            break;
          case "blending":
            shader.blending = input.get(key);
            break;
          case "geometry":
            updateGeometry(input.getFilePath(key), mesh);
            break;
          case "shader":
            updateShader(input.get(key), mesh, id, group, input);
            break;
          case "scriptClass":
            updateScriptClass(input.get(key), mesh, group, input);
            break;
          case "receiveShadow":
            updateShadow(input.get(key), mesh);
            break;
          case "receiveLight":
            updateLighting(input.get(key), mesh);
            break;
          case "billboard":
            updateBillboard(input.get(key), mesh);
        }
      };
      if (Hydra.LOCAL && Global.PLAYGROUND) {
        _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({
          file: file
        }) => {
          if (mesh.geometry?._src?.includes(file)) {
            updateGeometry(file, mesh);
          }
        });
        const scriptClassNeedsUpdate = (inst, file) => {
          inst.__cacheName ||= Utils.getConstructorName(inst);
          return !!file.includes(inst.__cacheName) && inst.__cacheName;
        };
        _this.events.sub(SceneLayout.HOTLOAD_SCRIPT, ({
          file: file
        }) => {
          if (file.includes(mesh.shader?.vsName)) {
            shader.hotReloading = true;
            if (window[shaderName]) {
              mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);
            }
            group.remove(shader.UILPrefix);
            delete ShaderUIL.exists[shader.UILPrefix];
            ShaderUIL.add(shader, group).setLabel("Shader");
            shader.hotReloading = false;
          }
          if (mesh.scriptClass) {
            if (Array.isArray(mesh.scriptClass)) {
              mesh.scriptClass.every((inst, index) => {
                let name = scriptClassNeedsUpdate(inst, file);
                return !name || (mesh.scriptClass.remove(inst), updateScriptClass(name, mesh, group, input), false);
              });
            } else {
              let name = scriptClassNeedsUpdate(mesh.scriptClass, file);
              if (name) {
                updateScriptClass(name, mesh, group, input);
              }
            }
          }
        });
      }
    }
    async function updateGeometry(geomPath, mesh) {
      let geom = World.PLANE;
      if (geomPath && geomPath.includes(["World", "SceneLayout"])) {
        geom = eval(geomPath);
        geomPath = null;
      } else if (geomPath) {
        geom = await GeomThread.loadGeometry(geomPath + "?" + Utils.timestamp());
      }
      mesh.geometry = geom;
    }
    async function updateShader(shaderName, mesh, id, group, input) {
      let shader;
      if (shaderName.includes(".shader")) {
        let shaderLayer = shaderName.split(".shader")[0];
        let layer = await _this.getLayer(shaderLayer);
        shader = layer.shader;
        shader._copied = layer;
      } else {
        shader = shaderName.includes("PBR") ? _this.initClass(PBRShader, shaderName, {
          unique: `Element_${id}_${_name}`
        }) : _this.initClass(Shader, shaderName, {
          unique: `Element_${id}_${_name}`
        });
      }
      group.remove(mesh.shader.UILPrefix);
      mesh.shader = shader;
      if (window[shaderName]) {
        mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);
      }
      ShaderUIL.add(shader, group).setLabel("Shader");
    }
    function updateLighting(bool, mesh) {
      mesh.shader.customCompile = Utils.uuid();
      mesh.shader.receiveLight = bool;
      mesh.shader.resetProgram();
      mesh.shader.upload();
    }
    function updateShadow(bool, mesh) {
      mesh.shader.customCompile = Utils.uuid();
      mesh.shader.receiveShadow = bool;
      mesh.shader.resetProgram();
      mesh.shader.upload();
    }
    function updateBillboard(bool, mesh) {
      if (bool) {
        mesh._billboardLoop = _ => Utils3D.billboard(mesh);
        _this.startRender(mesh._billboardLoop);
      } else {
        mesh.rotation.set(0, 0, 0);
        _this.stopRender(mesh._billboardLoop);
      }
    }
    function updateScriptClass(scriptClass, mesh, group, input) {
      if (scriptClass) {
        if (scriptClass.includes(",")) {
          (scriptClass = scriptClass.replace(/ /g, "").split(",")).forEach(script => {
            if (window[script]) {
              mesh.scriptClass = mesh.scriptClass || [];
              mesh.scriptClass.push(_this.initClass(window[script], mesh, mesh.shader, group, input));
            } else {
              console.warn(`scriptClass ${script} not found`);
            }
          });
        } else if (window[scriptClass]) {
          mesh.scriptClass = _this.initClass(window[scriptClass], mesh, mesh.shader, group, input);
        } else {
          console.warn(`scriptClass ${scriptClass} not found`);
        }
      }
    }
    function addListeners() {
      _this.events.sub(SceneLayout.BREAKPOINT, e => _this.localBreakpoint ? null : setBreakpoint(e));
    }
    function setBreakpoint({
      value: value
    }) {
      if (value != _breakpoint) {
        _breakpoint = value;
        _breakpoints.forEach(mesh => {
          if (!mesh.prefix) {
            return;
          }
          mesh.prefix = mesh.prefix.split("-")[0] + "-" + _breakpoint;
          if (mesh.prefix.charAt(mesh.prefix.length - 1) == "-") {
            mesh.prefix = mesh.prefix.slice(0, -1);
          }
          let meshUIL = new MeshUILConfig(mesh);
          if (UIL.global) {
            mesh._meshUIL = meshUIL;
          }
        });
      }
    }
    async function ready() {
      await _this.wait(_this, "loaded");
      if (UIL.sidebar) {
        UIL.sidebar.toolbar.hideAll();
      }
    }
    function copyFolderProps(from, to) {
      let mesh;
      let params;
      let shader;
      to.forEachFolder(child => {
        switch (child.label) {
          case "Parameters":
            params = child;
            break;
          case "Mesh":
            mesh = child;
            break;
          case "Shader":
            shader = child;
        }
      });
      let allowed = ["Parameters", "Mesh", "Shader"];
      from.forEachFolder(child => {
        if (!(allowed.indexOf(child.label) < 0)) {
          child.toClipboard();
          switch (child.label) {
            case "Parameters":
              params.fromClipboard();
              break;
            case "Mesh":
              mesh.fromClipboard();
              break;
            case "Shader":
              shader.fromClipboard();
          }
        }
      });
    }
    this.isSceneLayout = true;
    this.name = _name;
    (async function () {
      _this.group.sceneLayout = _this;
      await initialize(defer());
      SceneLayout.getTexture ||= Utils3D.getTexture;
      initGraph();
      initParams();
      initialize(initConfig());
      initData();
      addListeners();
      ready();
      if (UIL.global) {
        initGizmo();
      }
    })();
    this.ready = async function (early) {
      await _this.wait(_this, "loaded");
      await _this.wait(_this, "configured");
      if (early) {
        return true;
      }
      await defer();
      await defer();
    };
    this.getLayer = async function (name) {
      let timer;
      if (Hydra.LOCAL) {
        timer = _this.delayedCall(_ => {
          if (!_exists[name]) {
            console.warn(`${name} doesn't exist in SceneLayout ${_name}`);
          }
        }, 1000);
      }
      await _this.wait(_layers, name);
      if (timer) {
        clearTimeout(timer);
      }
      return _layers[name];
    };
    this.getLayers = async function () {
      let array = [];
      for (let i = 0; i < arguments.length; i++) {
        array.push(_this.getLayer(arguments[i]));
      }
      return Promise.all(array);
    };
    this.getAllLayers = async function () {
      await this.ready();
      await this.loadedAllLayers();
      return _layers;
    };
    this.getAllMatching = async function (label) {
      let layers = await _this.getAllLayers();
      let array = [];
      for (let key in layers) {
        if (key.includes(label)) {
          layers[key].layerName = key;
          array.push(layers[key]);
        }
      }
      return array;
    };
    this.exists = function (name) {
      return _exists[name];
    };
    this._createLayer = function (parentId) {
      createLayer(null, parentId);
    };
    this._createGroup = function (parentId) {
      getGroup(`group_${_groupIndex}`, parentId);
    };
    this._rename = function (id, name, value) {
      let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
      if (folder) {
        folder.setLabel(value);
        if (folder.params) {
          folder.params.setValue("name", value);
        }
        [_groups, _custom, _meshes, _exists, _layers].forEach(function (store) {
          if (store[name]) {
            store[value] = store[name];
            store[name] = null;
            delete store[name];
          }
        });
      }
    };
    this._deleteLayer = function (id, name) {
      if (id.includes("_")) {
        id = (id = id.split("_"))[id.length - 1];
      }
      let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
      let layer = _layers[id] || _layers[name];
      if (layer && layer.isGroup && layer.length > 1) {
        alert("Can't delete a group that has nested layers.");
        return false;
      } else {
        return !!confirm("Are you sure you want to delete this layer?") && (layer && layer._parent && (layer._parent.remove(layer), layer._parent = null), folder && folder.parent && folder.parent.remove(folder), UILStorage.set(`sl_${_name}_${id}_deleted`, true), true);
      }
    };
    this._changeParent = function (childId, childName, parentId, parentName) {
      let child = _layers[childId] || _layers[childName];
      let parent = _layers[parentId] || _layers[parentName] || _this;
      if (!child) {
        return;
      }
      let folder = _folders[childId] || _folders[`sl_${_name}_${childName}`];
      if (folder && folder.params) {
        folder.params.setValue("group", parentName || null);
      }
      let parentObject = parent.group || parent;
      let childObject = child.group || child;
      if (parentObject.isObject3D && childObject.isObject3D) {
        parentObject.add(childObject);
      }
      if (child.updateMatrix) {
        child.updateMatrix();
      }
    };
    this._visible = function (name, visible) {
      let mesh = _layers[name];
      if (mesh) {
        if (mesh.group) {
          mesh = mesh.group;
        }
        mesh.visible = visible;
      }
    };
    this._focus = function (name) {
      UIL.sidebar.toolbar.filterSingle(name);
    };
    this._blur = function (name) {
      let folder = _folders[name] || _folders[`sl_${_name}_${name}`];
      if (folder && folder.forEachFolder) {
        folder.forEachFolder(f => f.close());
        folder.close();
      }
    };
    this._sort = function (order) {
      order.forEach((label, index) => {
        if (label.children) {
          label.children.forEach(function (child, j, all) {
            let folder = _folders[child];
            if (!folder || !folder.params) {
              return;
            }
            let renderOrder = _this.baseRenderOrder + index + (j + 1) / (all.length + 1);
            folder.params.setValue("renderOrder", renderOrder - _this.baseRenderOrder);
            let mesh = _layers[child] || _layers[folder.label];
            if (mesh) {
              mesh.renderOrder = renderOrder;
            }
          });
        }
        let folder = _folders[label];
        if (!folder || !folder.params) {
          return;
        }
        let renderOrder = _this.baseRenderOrder + index;
        folder.params.setValue("renderOrder", renderOrder - _this.baseRenderOrder);
        let mesh = _layers[label] || _layers[folder.label];
        if (mesh) {
          mesh.renderOrder = renderOrder;
        }
      });
    };
    this._duplicateLayer = function (id, parentId) {
      let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
      if (folder) {
        createLayer(null, parentId);
        copyFolderProps(folder, Object.values(_folders).last());
      }
    };
    this._duplicateGroup = function (id, children) {
      let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
      if (!folder) {
        return;
      }
      let copyId = `group_${_groupIndex + 1}`;
      getGroup(copyId);
      copyFolderProps(folder, Object.values(_folders).last());
      children.forEach(childId => {
        _this._duplicateLayer(childId, copyId);
      });
    };
    this._getCinemaConfig = async function () {
      let _cinemaConfig = _config.get("Cinema Config").replace(".json", "");
      return await get(Assets.getPath(`assets/geometry/${_cinemaConfig}.json`));
    };
    this._applyCinemaConfig = function (id, params) {
      let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
      if (!folder) {
        return;
      }
      let mesh = folder.getAll().filter(sub => sub.label == "Mesh")[0];
      if (params.geometry) {
        folder.params.setValue("geometry", params.geometry.replace("assets/geometry/", ""));
      }
      ["position", "quaternion", "scale"].forEach(transform => {
        if (params[transform]) {
          let value = JSON.parse(params[transform]);
          if (transform == "quaternion") {
            let quat = new Quaternion().fromArray(value);
            value = new Euler().setFromQuaternion(quat).toArray().slice(0, 3).map(angle => angle * 180 / Math.PI);
            transform = "rotation";
          }
          mesh.getAll().filter(control => control.label == transform)[0].force(value);
        }
      });
      if (params.visible && params.visible === "false" && !params.geometry && (folder.params.setValue("geometry", "World.PLANE"), folder.params.setValue("side", "shader_double_side"), !Global.PLAYGROUND)) {
        _meshes[folder.params.get("name")].shader.neverRender = true;
      }
      if (params.shader) {
        folder.params.setValue("shader", params.shader);
      }
    };
    this.loadedAllLayers = async function () {
      await _this.ready();
      return Promise.all(_promises);
    };
    this.set("breakpoint", value => {
      _this.localBreakpoint = true;
      setBreakpoint({
        value: value
      });
    });
    this.get("breakpoint", _ => _breakpoint);
    this.get("layers", _ => _layers);
    this.get("layerCount", _ => _data.layers);
    this.onDestroy = function () {
      if (_this.textures && !_options.persistTextures) {
        _this.textures.forEach(t => {
          if (t.destroy) {
            t.destroy();
          }
        });
      }
    };
    this.addInitializer = function (callback) {
      _initializers.push(callback);
    };
    this._completeInitialization = async function (sync) {
      if (!_initializers.length) {
        return true;
      }
      for (let i = 0; i < _initializers.length; i++) {
        await _initializers[i](sync);
      }
      _initializers.length = 0;
    };
  }, _ => {
    SceneLayout.BREAKPOINT = "sl_breakpoint";
    SceneLayout.HOTLOAD_GEOMETRY = "sl_hotload_geom";
    SceneLayout.HOTLOAD_SCRIPT = "sl_hotload_script";
    SceneLayout.setBreakpoint = function (value) {
      if (SceneLayout.breakpoint !== value) {
        SceneLayout.breakpoint = value;
        Events.emitter._fireEvent(SceneLayout.BREAKPOINT, {
          value: value
        });
      }
    };
  });
  Class(function SceneLayoutGizmo() {
    Inherit(this, Object3D);
    const _this = this;
    var _controls;
    var _update;
    var _attached;
    var _lastVal;
    function findCamera() {
      let camera = World.CAMERA;
      let p = _this.group._parent;
      while (p) {
        if (p instanceof Scene && p.nuke) {
          camera = p.nuke.camera;
        }
        p = p._parent;
      }
      return camera;
    }
    function update() {
      let uil = _attached._cameraUIL || _attached._meshUIL;
      let key = _controls.getMode() == "translate" ? "position" : "scale";
      let value = _attached[key].toArray();
      if (!function same(a, b) {
        return !!a && !!b && !(Math.abs(a[0] - b[0]) > 0.0001) && !(Math.abs(a[1] - b[1]) > 0.0001) && !(Math.abs(a[2] - b[2]) > 0.0001);
      }(value, _lastVal)) {
        _lastVal = value;
        if (_attached._cameraUIL && key == "position") {
          key = "groupPos";
        }
        uil?.[`forceUpdate${key.toUpperCase()}`]?.(value);
      }
    }
    function startMoving() {
      _update = setInterval(update, 250);
    }
    function stopMoving() {
      clearInterval(_update);
      update();
    }
    function keyDown(e) {
      if (!document.activeElement.tagName.toLowerCase().includes(["textarea", "input"])) {
        if (e.key == ".") {
          _controls.setMode("translate");
        }
        if (e.key == "/") {
          _controls.setMode("scale");
        }
      }
    }
    function playgroundEvent(camera) {
      camera ||= findCamera();
      _controls.camera = camera;
    }
    async function nodeFocused(e) {
      _controls.visible = false;
      if (e.name != "Config" && e.layoutInstance == _this.parent) {
        let layer = await _this.parent.getLayer(e.name);
        let group = layer.group || layer;
        if (!group || !group.updateMatrixWorld) {
          return;
        }
        _controls.attach(group);
        _attached = group;
        _controls.visible = true;
      }
    }
    (_controls = new TransformControls(findCamera(), World.ELEMENT.div)).onChange = _controls.onMouseDown = _controls.onMouseUp = _controls.onObjectChange = e => {};
    _controls.onMouseDown = startMoving;
    _controls.onMouseUp = stopMoving;
    _controls.draggingChanged = e => {
      let activeControls = Playground.instance().activeControls;
      if (activeControls) {
        activeControls.enabled = !e.value;
      }
    };
    if (SceneLayoutGizmo.initialized) {
      _controls.visible = false;
    } else {
      SceneLayoutGizmo.initialized = true;
    }
    _this.group.add(_controls);
    AppState.bind("playground_camera_active", playgroundEvent);
    (function addListeners() {
      _this.events.sub(Keyboard.DOWN, keyDown);
      _this.events.sub(UILGraphNode.FOCUSED, nodeFocused);
    })();
    _this.delayedCall(_ => {
      _controls.camera = findCamera();
    }, 500);
  });
  Class(function SceneLayoutPreloader(_name) {
    Inherit(this, Component);
    function findMatch(src) {
      if (!src) {
        return false;
      }
      src = src.trim();
      for (let i = ASSETS.length - 1; i > -1; i--) {
        if (ASSETS[i].includes(src)) {
          return true;
        }
      }
      return false;
    }
    this.load = function (name) {
      let ext;
      let promise = Promise.create();
      let array = [];
      let settings_dxt = !!Renderer.extensions.s3tc;
      let settings_etc = !!Renderer.extensions.etc1;
      let settings_pvrtc = !!Renderer.extensions.pvrtc;
      let settings_astc = !!Renderer.extensions.astc;
      if (settings_dxt) {
        ext = "dxt";
      } else if (settings_etc) {
        ext = "astc";
      } else if (settings_pvrtc) {
        ext = "pvrtc";
      } else if (settings_astc) {
        ext = "astc";
      }
      let keys = UILStorage.getKeys();
      let i = 0;
      let worker = new Render.Worker(_ => {
        let key = keys[i];
        if (!key) {
          worker.stop();
          Promise.all(array).then(promise.resolve);
          return;
        }
        if (key.includes(name)) {
          let val = UILStorage.get(key);
          if (!val || !val.includes) {
            return i++;
          }
          if (key.includes("geometry")) {
            if (val.charAt(0) == "{") {
              val = JSON.parse(val).src;
            }
            if (!val.includes(".json")) {
              val += ".json";
            }
            if (!val.includes("assets/")) {
              val = "assets/geometry/" + val;
            }
            array.push(GeomThread.loadGeometry(val, null, true));
          }
          if (val.includes(".json")) {
            if (!val.includes("assets/")) {
              val = "assets/geometry/" + val;
            }
            if (findMatch(val.split("assets/")[1])) {
              array.push(fetch(Assets.getPath(val)).catch(e => {}));
            }
          } else if (val.includes("src")) {
            let obj = JSON.parse(val);
            let src = obj.src;
            if (obj.compressed) {
              let src0 = src.split(".")[0];
              let src1 = src0.split("/");
              src = src0 + "/" + src1[src1.length - 1] + "-" + ext + ".ktx";
            }
            if (findMatch(src.split("assets/")[1])) {
              array.push(fetch(Assets.getPath(src)).catch(e => {}));
            }
          }
        }
        i++;
      }, 1);
      return promise;
    };
  }, "static");
  Class(function Scroll(_object, _params) {
    Inherit(this, Component);
    const _this = this;
    const PROHIBITED_ELEMENTS = ["prevent_interactionScroll"];
    this.x = 0;
    this.y = 0;
    this.max = {
      x: 0,
      y: 0
    };
    this.delta = {
      x: 0,
      y: 0
    };
    this.enabled = true;
    _this.bounds = null;
    const _scrollTarget = {
      x: 0,
      y: 0
    };
    const _scrollInertia = {
      x: 0,
      y: 0
    };
    let _axes = ["x", "y"];
    var _lastDelta;
    var _deltaChange = 0;
    function checkIfProhibited(element) {
      let el = element;
      while (el) {
        if (el.classList) {
          for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++) {
            if (el.classList.contains(PROHIBITED_ELEMENTS[i])) {
              return true;
            }
          }
        }
        el = el.parentNode;
      }
      return false;
    }
    function loop() {
      if (_this.object) {
        if (Math.round(_this.object.div.scrollLeft) !== Math.round(_this.x) || Math.round(_this.object.div.scrollTop) !== Math.round(_this.y)) {
          _this.x = _scrollTarget.x = _this.object.div.scrollLeft;
          _this.y = _scrollTarget.y = _this.object.div.scrollTop;
          stopInertia();
        }
      }
      _axes.forEach(axis => {
        if (_this.isInertia) {
          _scrollInertia[axis] *= 0.9;
          _scrollTarget[axis] += _scrollInertia[axis];
        }
        if (_this.limit) {
          _scrollTarget[axis] = Math.max(_scrollTarget[axis], 0);
        }
        if (_this.limit) {
          _scrollTarget[axis] = Math.min(_scrollTarget[axis], _this.max[axis] / _this.scale);
        }
        _this.delta[axis] = _this.flag("block") ? 0 : (_scrollTarget[axis] * _this.scale - _this[axis]) * 0.5;
        _this[axis] += _this.delta[axis];
        if (Math.abs(_this.delta[axis]) < 0.01) {
          _this.delta[axis] = 0;
        }
        if (Math.abs(_this[axis]) < 0.001) {
          _this[axis] = 0;
        }
        if (_this.flag("block")) {
          _scrollTarget[axis] = 0;
          _this.delta[axis] = 0;
          _this[axis] = 0;
        }
        if (_this.object) {
          if (axis == "x") {
            _this.object.div.scrollLeft = Math.round(_this.x);
          }
          if (axis == "y") {
            _this.object.div.scrollTop = Math.round(_this.y);
          }
        }
      });
    }
    function stopInertia() {
      _this.isInertia = false;
      clearTween(_scrollTarget);
    }
    function edgeScroll(e) {
      let element = document.elementFromPoint(Math.clamp(Mouse.x, 0, Stage.width), Math.clamp(Mouse.y, 0, Stage.height));
      if ((!element || !checkIfProhibited(element)) && (!_params.lockMouseX || !(Mouse.x > Stage.width))) {
        if (e.pointerType === "touch" && _this.enabled) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          _axes.forEach(axis => {
            let dir = axis.toUpperCase();
            let delta = `offset${dir}`;
            let diff = (_this[`ieDelta${dir}`] || e[delta]) - e[delta];
            _scrollTarget[axis] += diff;
            _scrollInertia[axis] = diff;
            _this.isInertia = true;
            _this[`ieDelta${dir}`] = e[delta];
          });
          if (_this.onUpdate) {
            _this.onUpdate();
          }
          _this.events.fire(Events.UPDATE, _scrollInertia);
        }
      }
    }
    function edgeScrollEnd() {
      _this.ieDeltaX = false;
      _this.ieDeltaY = false;
    }
    function scroll(e) {
      let element = document.elementFromPoint(Math.clamp(Mouse.x, 0, Stage.width), Math.clamp(Mouse.y, 0, Stage.height));
      if (element && checkIfProhibited(element)) {
        return;
      }
      if (_params.lockMouseX && Mouse.x > Stage.width) {
        return;
      }
      if (!_this.enabled) {
        return;
      }
      if (!checkBounds(e)) {
        return;
      }
      if (_this.object && _this.limit && e.preventDefault) {
        e.preventDefault();
      }
      if (!_this.mouseWheel) {
        return;
      }
      stopInertia();
      let newDelta = 0;
      _axes.forEach(axis => {
        let delta = "delta" + axis.toUpperCase();
        if (Device.system.os == "mac") {
          if (Device.system.browser == "firefox") {
            if (e.deltaMode === 1) {
              _scrollTarget[axis] += e[delta] * 4;
              _scrollInertia[axis] = e[delta] * 4;
              _this.isInertia = true;
              newDelta = _scrollInertia[axis];
              return;
            } else {
              _scrollTarget[axis] += e[delta];
              return;
            }
          }
          if (Device.system.browser.includes(["chrome", "safari"])) {
            _scrollTarget[axis] += e[delta] * 0.33;
            _scrollInertia[axis] = e[delta] * 0.33;
            _this.isInertia = true;
            newDelta = _scrollInertia[axis];
            return;
          }
        }
        if (Device.system.os == "windows") {
          if (Device.system.browser == "firefox" && e.deltaMode === 1) {
            _scrollTarget[axis] += e[delta] * 10;
            _scrollInertia[axis] = e[delta] * 10;
            _this.isInertia = true;
            newDelta = _scrollInertia[axis];
            return;
          }
          if (Device.system.browser.includes(["chrome"])) {
            let s = 0.25;
            _scrollTarget[axis] += e[delta] * s;
            _scrollInertia[axis] = e[delta] * s;
            _this.isInertia = true;
            newDelta = _scrollInertia[axis];
            return;
          }
          if (Device.system.browser == "ie") {
            _scrollTarget[axis] += e[delta];
            _scrollInertia[axis] = e[delta];
            _this.isInertia = true;
            newDelta = _scrollInertia[axis];
            return;
          }
        }
        _scrollTarget[axis] += e[delta];
        newDelta = _scrollInertia[axis];
      });
      newDelta = Math.abs(newDelta);
      if (newDelta != _lastDelta) {
        _deltaChange++;
      }
      if (!_this.flag("hardBlock")) {
        if (_deltaChange > 3) {
          if (newDelta > _lastDelta) {
            _this.flag("block", false);
          }
        } else if (newDelta >= _lastDelta) {
          _this.flag("block", false);
        }
      }
      _lastDelta = newDelta;
      if (_this.onUpdate) {
        _this.onUpdate();
      }
      _this.events.fire(Events.UPDATE, _scrollInertia);
      _this.events.fire(Scroll.EVENT, e);
    }
    function down(e) {
      if (!_this.enabled) {
        return;
      }
      if (!checkBounds(e)) {
        return;
      }
      let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
      if (!element || !checkIfProhibited(element)) {
        stopInertia();
      }
    }
    function drag(e) {
      if (!_this.enabled) {
        return;
      }
      if (!checkBounds(e)) {
        return;
      }
      let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
      if (!element || !checkIfProhibited(element)) {
        _axes.forEach(axis => {
          let newDelta = Math.abs(Mouse.delta[axis]);
          if (!_this.flag("hardBlock")) {
            if (newDelta > _lastDelta) {
              _this.flag("block", false);
            }
          }
          _lastDelta = newDelta;
          _scrollTarget[axis] -= Mouse.delta[axis];
        });
        _this.events.fire(Events.UPDATE);
      }
    }
    function up(e) {
      if (!_this.enabled || _this.preventInertia) {
        return;
      }
      if (!checkBounds(e)) {
        return;
      }
      let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
      if (element && checkIfProhibited(element)) {
        return;
      }
      const m = Device.system.os == "android" ? 35 : 25;
      const obj = {};
      _axes.forEach(axis => {
        obj[axis] = _scrollTarget[axis] - Mouse.delta[axis] * m;
      });
      tween(_scrollTarget, obj, 2500, "easeOutQuint");
    }
    function resize() {
      if (!_this.enabled) {
        return;
      }
      stopInertia();
      if (!_this.object) {
        return;
      }
      const p = {};
      if (Device.mobile) {
        _axes.forEach(axis => p[axis] = _this.max[axis] ? _scrollTarget[axis] / _this.max[axis] : 0);
      }
      if (_params.height === undefined) {
        _this.max.y = _this.object.div.scrollHeight - _this.object.div.clientHeight;
      }
      if (_params.width === undefined) {
        _this.max.x = _this.object.div.scrollWidth - _this.object.div.clientWidth;
      }
      if (Device.mobile) {
        _axes.forEach(axis => _this[axis] = _scrollTarget[axis] = p[axis] * _this.max[axis]);
      }
    }
    function checkBounds(e) {
      return !_this.bounds || !(e.x / Stage.width > _this.bounds.x.y) && !(e.x / Stage.width < _this.bounds.x.x) && !(e.y / Stage.height > _this.bounds.y.y) && !(e.y / Stage.height < _this.bounds.y.x);
    }
    (function initParams() {
      if (!_object || !_object.div) {
        _params = _object;
        _object = null;
      }
      _params ||= {};
      _this.object = _object;
      _this.hitObject = _params.hitObject || _this.object;
      _this.max.y = _params.height || 0;
      _this.max.x = _params.width || 0;
      _this.scale = _params.scale || 1;
      _this.drag = _params.drag !== undefined ? _params.drag : !!Device.mobile;
      _this.mouseWheel = _params.mouseWheel !== false;
      _this.limit = typeof _params.limit == "boolean" && _params.limit;
      _this.bounds = _params.bounds || null;
      if (Array.isArray(_params.axes)) {
        _axes = _params.axes;
      }
    })();
    if (_this.object) {
      (function style() {
        _this.object.css({
          overflow: "auto"
        });
      })();
    }
    (function addHandlers() {
      if (!Device.mobile) {
        if (Device.system.browser === "ie" && Device.system.browserVersion >= 17) {
          document.body.addEventListener("pointermove", edgeScroll, true);
          document.body.addEventListener("pointerup", edgeScrollEnd, true);
        }
        if (Device.system.browser == "ie") {
          document.body.addEventListener("wheel", scroll, true);
        } else {
          __window.bind("wheel", scroll);
        }
      }
      if (_this.drag) {
        if (_this.hitObject) {
          _this.hitObject.bind("touchstart", e => {
            let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
            if (!element || !checkIfProhibited(element)) {
              e.preventDefault();
            }
          });
        }
        let input = _this.hitObject ? _this.initClass(Interaction, _this.hitObject) : Mouse.input;
        _this.events.sub(input, Interaction.START, down);
        _this.events.sub(input, Interaction.DRAG, drag);
        _this.events.sub(input, Interaction.END, up);
      }
      _this.events.sub(Events.RESIZE, resize);
    })();
    resize();
    _this.startRender(loop);
    this.reset = function () {
      if (_this.object && _this.object.div) {
        _this.object.div.scrollLeft = _this.x = 0;
        _this.object.div.scrollTop = _this.y = 0;
      }
      _scrollTarget.x = _scrollTarget.y = 0;
      _scrollInertia.x = _scrollInertia.y = 0;
      stopInertia();
      return this;
    };
    this.onDestroy = function () {
      __window.unbind("wheel", scroll);
    };
    this.resize = resize;
    this.scrollTo = function (value, axis = "y") {
      let values = {
        [axis]: value
      };
      tween(_scrollTarget, values, 800, "easeInOutCubic");
    };
    this.setTarget = function (value, axis = "y") {
      _scrollTarget[axis] = value;
    };
    this.blockUntilNewScroll = function () {
      _this.reset();
      _this.flag("block", true);
      _this.flag("hardBlock", true, 200);
      return this;
    };
    this.stopInertia = stopInertia;
  }, _ => {
    var _scroll;
    Scroll.EVENT = "scroll_event";
    Scroll.createUnlimited = Scroll.getUnlimited = function (options) {
      _scroll ||= new Scroll({
        limit: false,
        drag: Device.mobile
      });
      return _scroll;
    };
  });
  Class(function ScrollCamera(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _scroll;
    var _config;
    var _visible;
    var _breakpoints;
    var _breakpoint;
    var _observables = [];
    var _target = new Vector3();
    var _velocity = new VelocityTracker(_target);
    var _frustum = new Frustum();
    var _dynamic = {};
    function createConfig(initialConfig = false) {
      let suffix = _breakpoint ? `-${_breakpoint}` : "";
      let name = `${_input.prefix}_scroll${suffix}`;
      let config = InputUIL.create(name, initialConfig ? _group : null);
      config.setLabel("Config" + (_breakpoint ? ` (${_breakpoint})` : ""));
      config.add("multiplier", 1);
      config.add("lerp", 0.2);
      config.add("zLerp", 0.02);
      config.add("zMove", 3);
      config.addNumber("top", 0, 0.05);
      config.addNumber("bottom", -10, 0.05);
      return config;
    }
    function loop() {
      _velocity.update();
      _target.y -= _scroll.delta.y * 0.003 * _this.multiplier;
      let top = _this.top;
      let bottom = _this.bottom;
      if (_target.y > top) {
        _target.y = top;
      }
      if (_target.y < bottom) {
        _target.y = bottom;
      }
      _target.z = Math.range(Math.abs(_velocity.value.y), 0, 0.1, 0, 1, true) * _this.zMove;
      _this.group.position.y = Math.lerp(_target.y, _this.group.position.y, _this.lerp);
      _this.baseCamera.group.position.z = Math.lerp(_target.z, _this.baseCamera.group.position.z, _this.zLerp);
    }
    function runObservables() {
      _frustum.setFromCamera(_this.baseCamera.camera);
      for (let i = _observables.length - 1; i > -1; i--) {
        let obj = _observables[i];
        if (_frustum.intersectsObject(obj.mesh)) {
          if (!obj.intersecting) {
            obj.intersecting = true;
            obj.callback(true);
          }
        } else if (obj.intersecting) {
          obj.intersecting = false;
          obj.callback(false);
        }
      }
    }
    function handleBreakpoint({
      value: breakpoint
    }) {
      if (_breakpoint !== breakpoint && _breakpoints.includes(breakpoint)) {
        _breakpoint = breakpoint;
        _config = createConfig(false);
      }
    }
    function handleKeyDown({
      key: key,
      shiftKey: shiftKey
    }) {
      if (_visible) {
        switch (key) {
          case "Up":
          case "ArrowUp":
            _this.scrollTo(_target.y + getLineHeight());
            break;
          case "Down":
          case "ArrowDown":
            _this.scrollTo(_target.y - getLineHeight());
            break;
          case "Home":
            _this.scrollTo(_this.top);
            break;
          case "End":
            _this.scrollTo(_this.bottom);
            break;
          case "PageUp":
            _this.scrollTo(_target.y + getPageHeight());
            break;
          case "PageDown":
            _this.scrollTo(_target.y - getPageHeight());
            break;
          case " ":
          case "Spacebar":
            handleKeyDown(shiftKey ? {
              key: "PageUp"
            } : {
              key: "PageDown"
            });
        }
      }
    }
    function getLineHeight() {
      return getPageHeight() / Stage.height * 40;
    }
    function getPageHeight() {
      return Utils3D.getHeightFromCamera(_this.baseCamera.camera, _this.group.getWorldPosition().z);
    }
    this.baseCamera = _this.initClass(BaseCamera, _input, _group, undefined);
    this.velocity = _velocity;
    (function initConfig() {
      if (_breakpoints = _input.get("breakpoints")) {
        _breakpoints = _breakpoints.replace(/ /g, "").split(",");
      }
      _breakpoints ||= [];
      if (!_breakpoints.includes("")) {
        _breakpoints.push("");
      }
      _breakpoint = _breakpoints.includes(SceneLayout.breakpoint) ? SceneLayout.breakpoint : "";
      _config = createConfig(true);
      _this.events.sub(SceneLayout.BREAKPOINT, handleBreakpoint);
    })();
    (function addHandlers() {
      _this.events.sub(Keyboard.DOWN, handleKeyDown);
    })();
    _scroll = Scroll.createUnlimited();
    _this.startRender(loop);
    _this.startRender(runObservables, 24);
    (function initDynamicOverrides() {
      ["multiplier", "lerp", "zLerp", "zMove", "top", "bottom"].forEach(key => {
        _this.get(key, _ => _dynamic[key] === undefined ? _config.getNumber(key) : _dynamic[key]);
        _this.set(key, value => _dynamic[key] = value);
      });
    })();
    this.observe = function (mesh, callback) {
      _observables.push({
        callback: callback,
        mesh: mesh
      });
    };
    this.scrollTo = function (y, animate = true) {
      _target.y = y;
      let top = _this.top;
      let bottom = _this.bottom;
      if (_target.y > top) {
        _target.y = top;
      }
      if (_target.y < bottom) {
        _target.y = bottom;
      }
      if (!animate) {
        _this.group.position.y = _target.y;
      }
    };
    this.reset = function (animate = false) {
      _this.scrollTo(_this.top, animate);
    };
    this.onVisible = function () {
      _visible = true;
    };
    this.onInvisible = function () {
      _visible = false;
    };
  });
  Class(function Shaders() {
    Inherit(this, Component);
    var _this = this;
    function parseSingleShader(code, fileName) {
      let uniforms = code.split("#!UNIFORMS")[1].split("#!")[0];
      let varyings = code.split("#!VARYINGS")[1].split("#!")[0];
      let attributes = code.split("#!ATTRIBUTES")[1].split("#!")[0];
      while (code.includes("#!SHADER")) {
        let split = (code = code.slice(code.indexOf("#!SHADER"))).split("#!SHADER")[1];
        let br = split.indexOf("\n");
        let name = split.slice(0, br).split(": ")[1];
        if (name.slice(0, 6).includes("Vertex")) {
          name = fileName.split(".")[0] + ".vs";
        }
        if (name.slice(0, 8).includes("Fragment")) {
          name = fileName.split(".")[0] + ".fs";
        }
        let glsl = split.slice(br);
        glsl = name.includes(".vs") ? attributes + uniforms + varyings + glsl : uniforms + varyings + glsl;
        let splitName = name.split(".");
        _this[splitName[0] + (splitName[1].includes("vs") ? ".vs" : ".fs")] = glsl;
        code = code.replace("#!SHADER", "$");
      }
    }
    function parseCompiled(shaders) {
      var split = shaders.split("{@}");
      split.shift();
      for (var i = 0; i < split.length; i += 2) {
        var name = split[i];
        var text = split[i + 1];
        if (text.includes("#!UNIFORMS")) {
          parseSingleShader(text, name);
        } else {
          _this[name] = text;
        }
      }
    }
    function parseRequirements() {
      for (var key in _this) {
        var obj = _this[key];
        if (typeof obj == "string") {
          _this[key] = require(obj);
        }
      }
    }
    function require(shader) {
      if (!shader.includes("require")) {
        return shader;
      }
      for (shader = shader.replace(/# require/g, "#require"); shader.includes("#require");) {
        var name = shader.split("#require(")[1].split(")")[0];
        name = name.replace(/ /g, "");
        if (!_this[name]) {
          throw "Shader required " + name + ", but not found in compiled shaders.\n" + shader;
        }
        shader = shader.replace("#require(" + name + ")", _this[name]);
      }
      return shader;
    }
    this.parse = function (code, file) {
      if (code.includes("{@}")) {
        parseCompiled(code);
        parseRequirements();
      } else {
        file = (file = file.split("/"))[file.length - 1];
        _this[file] = code;
      }
      _this.shadersParsed = true;
    };
    this.parseSingle = parseSingleShader;
    this.onReady = this.ready = function (callback) {
      let promise = Promise.create();
      if (callback) {
        promise.then(callback);
      }
      _this.wait(() => promise.resolve(), _this, "shadersParsed");
      return promise;
    };
    this.getShader = function (string) {
      if (_this.FALLBACKS && _this.FALLBACKS[string]) {
        string = _this.FALLBACKS[string];
      }
      var code = _this[string];
      if (!code) {
        throw `No shader ${string} found`;
      }
      while (code.includes("#test ")) {
        try {
          var test = code.split("#test ")[1];
          var name = test.split("\n")[0];
          var glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
          if (!eval(name)) {
            code = code.replace(glsl, "");
          }
          code = code.replace("#test " + name + "\n", "");
          code = code.replace("#endtest", "");
        } catch (e) {
          throw "Error parsing test :: " + string;
        }
      }
      return code;
    };
  }, "static");
  Class(function Smooth(_object, _params) {
    Inherit(this, Component);
    const _this = this;
    var _current;
    var _views;
    this.position = 0;
    this.last = 0;
    this.delta = 0;
    this.direction = 0;
    this.index1 = 0;
    this.index2 = 0;
    this.progress = 0;
    var _index = 0;
    var _bottomScrolled = false;
    var _topScrolled = false;
    var _timer = null;
    var _totalHeight = 0;
    var _config;
    var _lerpSpeed = 0.00075;
    var _retryTimer = null;
    var _initLoaded = false;
    function initParams() {
      _params ||= {};
      _this.object = _object;
      _this.smoothScroll = _params.smoothScroll !== false;
      _this.relativePositioning = _params.relativePositioning;
    }
    function initConfig() {
      (_config = InputUIL.create("Smooth")).setLabel("Smooth");
      _config.add("lerpSpeed", _lerpSpeed);
      _config.onUpdate = readConfig;
      readConfig();
    }
    function readConfig() {
      _lerpSpeed = _config.getNumber("lerpSpeed");
      if (isNaN(_lerpSpeed)) {
        _lerpSpeed = eval(_config.get("lerpSpeed"));
      }
    }
    function style() {
      if (_this.smoothScroll) {
        _this.object.css({
          position: "fixed",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          overflow: "hidden"
        });
      } else {
        _this.object.css({
          width: "100%"
        });
      }
    }
    function addHandlers() {
      _this.events.sub(Events.RESIZE, resize);
      _this.events.sub(ViewController.NEWS_TRANSITION_ANIMATING, newsAnimating);
      _this.events.sub(ViewController.NEWS_TRANSITION_IDLE, newsIdle);
      _this.events.sub(InteractiveSection.INITIAL_LOADED, onLoaded);
      _this.startRender(loop);
      if (_this.smoothScroll) {
        _this.events.sub(Keyboard.DOWN, keydown);
      }
    }
    function onLoaded() {
      _this.delayedCall(_ => {
        _initLoaded = true;
      }, 1000);
    }
    function removeHandlers() {
      _this.events.unsub(Events.RESIZE, resize);
      _this.stopRender(loop);
      if (_this.smoothScroll) {
        _this.events.unsub(Keyboard.DOWN, keydown);
      }
    }
    async function keydown(e) {
      if (_views && e.code === "Tab") {
        await defer();
        _this.object.div.scrollTop = 0;
        if (!_this.object.div.contains(document.activeElement)) {
          return;
        }
        _this.scroll = document.activeElement.getBoundingClientRect().top + document.scrollingElement.scrollTop + -Stage.height / 2;
      }
    }
    async function resize() {
      if (_views) {
        await defer();
        await defer();
        _totalHeight = 0;
        for (let i = 0, l = _views.length; i < l; i++) {
          let view = _views[i];
          let layout = view.ui || view;
          if (!layout.element) {
            return;
          }
          if (!_this.relativePositioning) {
            layout.element.css({
              top: _totalHeight
            });
          }
          view.start = _totalHeight;
          layout.start = _totalHeight;
          let height = layout.element.div.getBoundingClientRect().height;
          view.height = height;
          layout.height = height;
          _totalHeight += height;
          if (layout.parallax) {
            layout.element.willChange("transform");
          }
        }
        if (_totalHeight != 0) {
          __body.css({
            height: _totalHeight
          });
          update();
        } else {
          _retryTimer = _this.delayedCall(() => {
            resize();
          }, 100);
        }
      }
    }
    function newsAnimating() {
      _this.flag("newsAnimating", true);
    }
    function newsIdle() {
      _this.flag("newsAnimating", false);
    }
    function loop() {
      if (_this.smoothScroll) {
        if (_this.flag("newsAnimating")) {
          _this.position = document.scrollingElement.scrollTop;
        } else {
          _this.position = Math.lerp(document.scrollingElement.scrollTop, _this.position, _lerpSpeed);
        }
      } else {
        _this.position = document.scrollingElement.scrollTop;
      }
      _this.delta = _this.position - _this.last;
      _this.last = _this.position;
      _this.direction = Math.sign(_this.delta);
      if (!(Math.abs(_this.delta) < 0.001) || !_initLoaded) {
        update();
      }
    }
    function update() {
      if (!_views) {
        return;
      }
      if (_this.smoothScroll) {
        _current.element.y = -Math.floor(_this.position);
        _current.element.transform();
      }
      let height = 0;
      for (let i = 0, l = _views.length; i < l; i++) {
        height += _views[i].height;
        if (_this.position < height && Math.abs(_this.position - height) > 1) {
          _this.index1 = i;
          _this.index2 = i + 1;
          if (_this.index2 > l - 1) {
            _this.index2 = l - 1;
          }
          break;
        }
      }
      if (_views[_this.index1]?.height < Stage.height) {
        _this.progress = (_this.position - _views[_this.index1].start) / _views[_this.index1].height;
      } else {
        let current = _this.position + Stage.height - _views[_this.index2].start;
        _this.progress = Math.clamp(current / Stage.height, 0, 1);
      }
      parallax(_views[_this.index1]);
      parallax(_views[_this.index2]);
      if (_index !== _this.index1) {
        _index = _this.index1;
        let event = {
          index: _index,
          direction: _this.direction,
          view: _views[_index]
        };
        _this.events.fire(Smooth.VIEW_CHANGE, event);
      }
      if (Math.abs(_totalHeight - Stage.height - _this.position) < Stage.height * 0.2) {
        if (!_bottomScrolled) {
          _bottomScrolled = true;
          _timer = _this.delayedCall(() => {
            let event = {
              index: _this.index2,
              direction: 1,
              view: _views[_this.index2]
            };
            _this.events.fire(Smooth.BOTTOM, event);
          }, 850);
        }
      } else {
        if (_timer) {
          clearTimeout(_timer);
          _timer = null;
        }
        _bottomScrolled &&= false;
      }
    }
    function parallax(view) {
      let current = _this.position + Stage.height - view.start;
      let progress = Math.clamp(current / (view.height + Stage.height), 0, 1);
      view.progress = progress;
      view.direction = _this.direction;
      let layout = view.ui;
      if (layout) {
        layout.progress = progress;
        if (layout.parallax) {
          current = view.height * layout.parallax - view.height;
          layout.element.y = Math.floor(current * 0.5 - current * progress);
          layout.element.transform();
        }
      }
    }
    initParams();
    initConfig();
    style();
    addHandlers();
    Mobile.allowNativeScroll();
    if (Tests.generatePreview()) {
      _this.delayedCall(_ => {
        _this.startRender(_ => {
          _this.scroll += 30;
        });
      }, 5000);
    }
    this.get("scroll", _ => document.scrollingElement.scrollTop);
    this.set("scroll", s => document.scrollingElement.scrollTop = Math._round(s));
    this.show = async function (page) {
      if (_this.smoothScroll) {
        page.element.willChange("transform");
      }
      _current = page;
      _views = page.views;
      await _this.wait(10);
      _this.scroll = 0;
      _this.position = 0;
      resize();
    };
    this.lock = function () {
      __body.css({
        overflow: "hidden"
      });
    };
    this.unlock = function () {
      __body.css({
        overflow: ""
      });
    };
    this.resize = function () {
      resize();
    };
    this.onDestroy = function () {
      removeHandlers();
    };
    Dev.expose("lock", this.lock);
    Dev.expose("unlock", this.unlock);
  }, _ => {
    Smooth.VIEW_CHANGE = "smooth_view_change";
    Smooth.BOTTOM = "smooth_bottom";
    Smooth.TOP = "smooth_top";
  });
  Class(function SmoothRenderManager() {
    Inherit(this, Component);
    const _this = this;
    var _object;
    var _mesh;
    var _transitionShader;
    var _smooth;
    var _views;
    var _index1 = 0;
    var _index2 = 0;
    var _renderCount = 0;
    function onSmoothViewChange(e) {
      _this.events.fire(_this.VIEW_CHANGE, e);
    }
    function onSmoothBottom(e) {
      _this.events.fire(_this.BOTTOM, e);
    }
    function onSmoothTop(e) {
      _this.events.fire(_this.TOP, e);
    }
    function loop() {
      if (_views) {
        if (_index1 !== _smooth.index1 || _index2 !== _smooth.index2) {
          if (_views[_index1].rt && _index1 != _smooth.index2 && _index1 != _smooth.index2) {
            _views[_index1]._smoothShowing = false;
            _views[_index1].hide();
          }
          if (_views[_index2].rt && _index2 != _smooth.index1 && _index2 != _smooth.index2) {
            _views[_index2].hide();
            _views[_index2]._smoothShowing = false;
          }
          _index1 = _smooth.index1;
          _index2 = _smooth.index2;
          if (_views[_index1].rt) {
            _views[_index1].show();
            _views[_index1]._smoothShowing = true;
          }
          if (_views[_index2].rt && _smooth.progress > 0.01) {
            _views[_index2].show();
            _views[_index2]._smoothShowing = true;
          }
        } else if (!_views[_index1]._smoothShowing || !_views[_index2]._smoothShowing) {
          if (_views[_index1].rt) {
            _views[_index1].show();
            _views[_index1]._smoothShowing = true;
          }
          if (_index1 != _index2 && _views[_index2].rt && _smooth.progress > 0.01) {
            _views[_index2].show();
            _views[_index2]._smoothShowing = true;
          }
        }
        _transitionShader.set("tMap1", _views[_index1].rt ? _views[_index1] : null);
        _transitionShader.set("tMap2", _views[_index2].rt ? _views[_index2] : null);
        _transitionShader.set("uTransition", _smooth.progress);
        if (_this.pingPong && _views.length > 1 && _index1 != _index2) {
          if ((_renderCount = Math.abs(_renderCount - 1)) === 0 && _views[_index1].rt) {
            _views[_index1].preventRTDraw = false;
            _views[_index2].preventRTDraw = true;
          }
          if (_renderCount === 1 && _views[_index2].rt) {
            _views[_index2].preventRTDraw = false;
            _views[_index1].preventRTDraw = true;
          }
        } else {
          _views[_index2].preventRTDraw = false;
          _views[_index1].preventRTDraw = false;
        }
      }
    }
    this.VIEW_CHANGE = "SmoothRenderManager_view_change";
    this.BOTTOM = "SmoothRenderManager_bottom";
    this.TOP = "SmoothRenderManager_top";
    this.initialize = function (object, transitionShader, params = {}) {
      _transitionShader = transitionShader;
      (_mesh = new Mesh(World.QUAD, _transitionShader)).frustumCulled = false;
      (_object = object).add(_mesh);
      _smooth = _this.initClass(Smooth, params.container, params);
      _this.events.sub(_smooth, Smooth.VIEW_CHANGE, onSmoothViewChange);
      _this.events.sub(_smooth, Smooth.BOTTOM, onSmoothBottom);
      _this.events.sub(_smooth, Smooth.TOP, onSmoothTop);
      _this.object = object;
      _this.transitionShader = transitionShader;
      _this.pingPong = params.pingPong;
      if (_this.pingPong) {
        Render.setRefreshScale(2);
      }
      _this.smooth = _smooth;
    };
    this.show = function (page) {
      _smooth.show(page);
      (_views = page.views).forEach(view => {
        view._smoothShowing = false;
      });
      _this.startRender(loop);
    };
    this.hide = function () {
      _this.stopRender(loop);
    };
    this.lock = function () {
      _smooth.lock();
    };
    this.unlock = function () {
      _smooth.unlock();
    };
    this.createLocal = function () {
      return new SmoothRenderManager();
    };
    this.resize = function () {
      _smooth.resize();
    };
    this.onDestroy = function () {
      if (_object && _object.remove) {
        _object.remove(_mesh);
      }
    };
  }, "static");
  Class(function StageLayout(_name, _options = {}) {
    Inherit(this, Component);
    const _this = this;
    var _dataStore;
    var _data;
    var $create;
    const GLUI = _options.glui === undefined || _options.glui;
    var _uil = getTopLevelUIL();
    var _folders = {};
    var _layers = {};
    var _exists = {};
    var _resize = [];
    var _graph;
    var _config;
    function getTopLevelUIL() {
      let uil = UIL.sidebar;
      if (!_options.uil && _this.parent && uil && Utils.getConstructorName(_this.parent) != Global.PLAYGROUND) {
        uil = new UILFolder(`stl_${_name}_nested`, {
          label: `${_name.capitalize()} (Nested)`,
          closed: true
        });
        if (UIL.sidebar) {
          UIL.sidebar.add(uil);
        }
      }
      return uil;
    }
    function createFolder(name) {
      let folder = new UILFolder(`stl_${_name}_${name}`, {
        label: name,
        closed: true
      });
      _folders[`stl_${_name}_${name}`] = folder;
      return folder;
    }
    async function initGraph() {
      if (!_options.noGraph && !!window.UILGraph && !StageLayout.noGraph) {
        if (_graph = UILGraph.instance().getGraph(_name, _this, !!GLUI)) {
          UIL.sidebar.element.show();
          if (Global.PLAYGROUND) {
            Utils.getConstructorName(_this.parent);
            Global.PLAYGROUND;
          }
          _graph.open();
        }
      }
    }
    function initParams() {
      if (_options.rootPath) {
        if (_options.rootPath.charAt(_options.rootPath.length - 1) != "/") {
          _options.rootPath += "/";
        }
      } else {
        _options.rootPath = "";
      }
      _this.baseZ = _options.baseZ || 0;
      _this.data = _options.data;
      if (_options.uil) {
        _uil = _options.uil;
      }
      if (GLUI) {
        _this.element = $gl(1, 1);
        _this.element.stageLayout = _this;
      } else {
        _this.element = $("StageLayout_" + _name);
        _this.element.size("100%");
      }
    }
    async function initData() {
      await UILStorage.ready();
      _dataStore = InputUIL.create(`stagelayout_${_name}`, null);
      if ((_data = JSON.parse(_dataStore.get("data") || "{}")).layers === undefined) {
        _data.layers = -1;
      }
      if (_options.perFrame) {
        if (_data.layers > 0) {
          createLayers();
        }
      } else {
        for (let i = 0, c = _data.layers + 1; i < c; i++) {
          createLayer(i);
        }
        _this.loaded = true;
      }
    }
    function initRoot() {
      let name = _name + "Root";
      let group = _uil ? createFolder(name) : null;
      let $obj = _this.element;
      let input = InputUIL.create(`Config_${name}_${_name}`, group);
      input.setLabel("Parameters");
      input.add("size").addTextarea("fontStyle").addTextarea("css", GLUI ? "hidden" : undefined).add("onResize", "hidden");
      input.add("compiled", "hidden");
      input.add("Figma Config");
      _config = input;
      if (!group) {
        return createCompiledLayer(`${name}_${_name}`, input);
      }
      StageLayoutUtil.create(`${name}_${_name}`);
      group.hide();
      group.setLabel(name);
      let size = input.get("size");
      let css = input.get("css");
      input.get("fontStyle");
      let resizeCode = input.get("onResize");
      let doCSS = change => {
        if (GLUI) {
          return;
        }
        css = css || "";
        let obj = {};
        let objSave = {};
        css = css.split("\n");
        css.forEach(line => {
          let key = (line = line.split(":"))[0];
          let val = line[1];
          let valSave = val;
          val &&= parseData(val.replace(/ /g, ""));
          if (key.length) {
            obj[key] = isNaN(Number(val)) ? val : Number(val);
            valSave &&= valSave.replace(/ /g, "");
            objSave[key] = isNaN(Number(valSave)) ? valSave : Number(valSave);
          }
        });
        if (change) {
          StageLayoutUtil.save("css", objSave, input);
        }
        $obj.css(obj);
      };
      let doSize = change => {
        if (size) {
          let s = parseData(size).replace(/ /g, "").split(",");
          let s0 = s[0].includes("%") ? s[0] : Number(s[0]) || s[0];
          let s1 = s[1].includes("%") ? s[1] : Number(s[1]) || s[1];
          $obj.size(s0, s1);
          if (change) {
            StageLayoutUtil.save("size", [s0, s1], input);
          }
        } else {
          $obj.size(100, 100);
        }
      };
      let doResize = change => {
        if (resizeCode) {
          let fn = new Function("$this", resizeCode);
          _resize.push({
            fn: fn,
            $obj: $obj
          });
          fn($obj);
        }
      };
      let doFont = change => {
        let fontStyle = parseData(input.get("fontStyle"));
        if (fontStyle) {
          fontStyle = fontStyle.split("\n");
          $obj.fontStyle(fontStyle[0], Number(fontStyle[1]), fontStyle[2], fontStyle[3]);
          if (change) {
            StageLayoutUtil.save("fontStyle", fontStyle, input);
          }
        }
      };
      doCSS();
      doSize();
      doFont();
      doResize();
      input.onUpdate = key => {
        switch (key) {
          case "css":
            css = input.get("css");
            doCSS(true);
            break;
          case "size":
            size = input.get("size");
            doSize(true);
            break;
          case "onResize":
            resizeCode = input.get("onResize");
            doResize();
            break;
          case "fontStyle":
            doFont(true);
        }
      };
      group.params = input;
      if (_graph) {
        _graph.addSpecial(group.id, name, "Root");
      }
      _uil.add(group);
      (_ => {
        let folder = new UILFolder(`stl_${_name}_${name}_resize`, {
          label: "Resize Logic",
          closed: true
        });
        let button = new UILControlButton("button", {
          actions: [{
            title: "Open Editor",
            callback: _ => {
              let editor = new UILWindow(_name, {
                label: "Resize Logic",
                height: "auto",
                drag: true
              });
              let text = new UILControlTextarea(`stl_${_name}_${name}_resize`, {
                label: "Resize",
                value: input.get("onResize"),
                monospace: true,
                rows: 10,
                resize: "both",
                minWidth: 400,
                hideLabel: true,
                tab: true
              });
              editor.add(text);
              text.onFinishChange(value => input.setValue("onResize", value));
              UIL.add(editor);
            }
          }],
          hideLabel: true
        });
        folder.add(button);
        group.add(folder);
      })();
    }
    function createLayers() {
      let index = 0;
      let renderWorker = new Render.Worker(function () {
        createLayer(index);
        if (index++ == _data.layers) {
          renderWorker.stop();
          _this.loaded = true;
        }
      }, _options.perFrame);
    }
    function parseData(text) {
      if (!text || typeof text != "string" || !text.includes("$DATA")) {
        return text;
      }
      while (text.includes("$DATA")) {
        let code = text.split("$DATA")[1].split(" ")[0].split("\n")[0];
        let line = "$DATA" + code;
        text = text.replace(line, eval(line.replace("$DATA", "_options.data")));
      }
      return text;
    }
    async function createCompiledLayer(key, input) {
      let compiled = StageLayoutUtil.getCompiled(key);
      if (!compiled) {
        return;
      }
      let $obj;
      let name = input.get("name");
      let text = input.get("text");
      $obj = GLUI ? text ? $glText(parseData(text), null, null, compiled.fontStyle) : $gl(1, 1, parseData(input.get("bg"))) : key == `${_name}Root_${_name}` ? _this.element : $(name || "Layer", parseData(input.get("type") || "div"));
      let nestedGroup = input.get("group");
      if (nestedGroup) {
        let layer;
        layer = nestedGroup === _name ? _this.element : await _this.getLayer(nestedGroup);
        layer.add($obj);
      } else if (_this.element != $obj) {
        _this.element.add($obj);
      }
      if (Global.PLAYGROUND) {
        $obj._input = input;
      }
      _layers[name] = $obj;
      _exists[name] = true;
      checkNameHook($obj, name);
      if (compiled.css && $obj.css) {
        for (let key in compiled.css) {
          compiled.css[key] = parseData(compiled.css[key]);
        }
        $obj.css(compiled.css);
      }
      if (compiled.transform) {
        for (let key in compiled.transform) {
          $obj[key] = compiled.transform[key];
        }
        if ($obj.transform) {
          $obj.transform();
        }
      }
      if (compiled.size) {
        $obj.size(compiled.size[0], compiled.size[1]);
      }
      if (compiled.attributes && $obj.attr) {
        for (let key in compiled.attributes) {
          $obj.attr(key, parseData(compiled.attributes[key]));
        }
      }
      if (!GLUI) {
        let bg = input.get("bg");
        if (bg) {
          $obj.bg(parseData(bg) || "#ff0000");
        }
      }
      if (!GLUI) {
        if (text) {
          text = parseData(text);
          let helper = compiled.helper;
          if (helper) {
            let helperName = helper.split("(")[0];
            let args = helper.split("(")[1];
            if (args) {
              args = args.replace(")", "").replace(/,\ /g, ",").split(",");
              args.forEach(function (arg, i) {
                if (arg == "$text") {
                  args[i] = text;
                }
              });
              if (args.indexOf(text) < 0) {
                args.unshift(text);
              }
            } else {
              args = [text];
            }
            let helperFn = _options[helperName] || StageLayout.helpers[helperName];
            if (helperFn) {
              $obj.html(helperFn.apply(null, args));
              return;
            } else {
              return console.warn(`No helper function ${helperName} found.`);
            }
          }
          if (text.includes(["</", "/>"])) {
            $obj.html(text);
          } else {
            $obj.text(text);
          }
        }
        let fs = compiled.fontStyle;
        if (fs) {
          $obj.fontStyle(fs[0], Number(fs[1]), fs[2], fs[3]);
        }
      }
      let zIndex = input.getNumber("zIndex");
      if (typeof zIndex == "number" && $obj && $obj.setZ && !isNaN(zIndex)) {
        $obj.setZ(zIndex);
      }
      if (compiled.resize) {
        _resize.push({
          $obj: $obj,
          fn: compiled.resize
        });
        compiled.resize($obj);
      }
      let customClass = input.get("customClass");
      if (customClass) {
        let Class = window[customClass];
        if (customClass.includes(".")) {
          let split = customClass.split(".");
          Class = window[split[0]] && window[split[0]][split[1]];
        }
        if (!Class) {
          return console.warn(`No custom class ${customClass} found.`);
        }
        _layers[name] = _this.initClass(Class, $obj, _options.data, input);
      }
    }
    function checkNameHook($obj, name) {
      if (_this.layerHooks) {
        for (let i = 0, l = _this.layerHooks.length; i < l; i++) {
          console.log(i);
          let {
            test: test,
            callback: callback,
            classConstructor: classConstructor
          } = _this.layerHooks[i];
          if (test && test(name)) {
            if (classConstructor) {
              _this.initClass(classConstructor, $obj, name);
            }
            if (callback) {
              callback($obj, name);
            }
          }
        }
      }
      for (let i = 0, l = StageLayout.LAYER_HOOKS.length; i < l; i++) {
        let {
          test: test,
          callback: callback,
          classConstructor: classConstructor
        } = StageLayout.LAYER_HOOKS[i];
        if (test && test(name)) {
          if (classConstructor) {
            _this.initClass(classConstructor, $obj, name);
          }
          if (callback) {
            callback($obj, name);
          }
        }
      }
    }
    async function createLayer(index, groupName) {
      let id = typeof index == "number" ? index : ++_data.layers;
      if (UILStorage.get(`stl_${_name}_${id}_deleted`)) {
        return;
      }
      let $obj;
      let group = _uil ? createFolder(id) : null;
      let input = InputUIL.create(`Config_${id}_${_name}`, group);
      input.setLabel("Parameters");
      input.add("name").add("type", GLUI ? "hidden" : undefined).add("bg").add("size").add("group").add("customClass").add("wildcard").add("helper", GLUI ? "hidden" : undefined).add("zIndex", "hidden").addTextarea("attributes", GLUI ? "hidden" : undefined).addTextarea("text").addTextarea("fontStyle").addTextarea("css", GLUI ? "hidden" : undefined).addTextarea("transform").add("onResize", "hidden");
      input.add("compiled", "hidden");
      if (!group) {
        return createCompiledLayer(`${id}_${_name}`, input);
      }
      StageLayoutUtil.create(`${id}_${_name}`);
      if (groupName) {
        input.setValue("group", groupName);
      }
      let name = input.get("name") || id + "";
      let size = input.get("size");
      let bg = input.get("bg");
      let css = input.get("css");
      let transform = input.get("transform");
      let type = input.get("type");
      let attributes = input.get("attributes");
      let text = input.get("text");
      input.get("fontStyle");
      let nestedGroup = input.get("group");
      let resizeCode = input.get("onResize");
      let zIndex = input.getNumber("zIndex");
      let customClass = input.get("customClass");
      let helper = input.get("helper");
      input.get("wildcard");
      group.setLabel(name);
      group.params = input;
      let getGLUIFontObject = _ => {
        let font = input.get("fontStyle") || "";
        let obj = {};
        font = font.split("\n");
        font.forEach(line => {
          let key = (line = line.split(":"))[0];
          let val = line[1];
          val &&= val.replace(/ /g, "");
          if (key.length) {
            obj[key] = isNaN(Number(val)) ? val : Number(val);
            if (val === "false") {
              obj[key] = false;
            }
            if (val === "true") {
              obj[key] = true;
            }
          }
        });
        return obj;
      };
      $obj = GLUI ? text ? $glText(parseData(text), null, null, getGLUIFontObject()) : $gl(1, 1, bg ? parseData(bg) : bg || name ? undefined : "assets/images/_scenelayout/uv.jpg") : $(name || "Layer", parseData(type));
      $obj._uil = group;
      if (nestedGroup) {
        let layer;
        layer = nestedGroup === _name ? _this.element : await _this.getLayer(nestedGroup);
        if (layer.add) {
          layer.add($obj);
        }
        if (group) {
          _uil.add(group);
        }
      } else {
        _this.element.add($obj);
        if (group) {
          _uil.add(group);
        }
      }
      if (_graph) {
        _graph.addGroup(group.id, name || id + "", nestedGroup);
      }
      (_ => {
        let folder = new UILFolder(`stl_${_name}_${name}_resize`, {
          label: "Resize Logic",
          closed: true
        });
        let button = new UILControlButton("button", {
          actions: [{
            title: "Open Editor",
            callback: _ => {
              let editor = new UILWindow(_name, {
                label: "Resize Logic",
                height: "auto",
                drag: true
              });
              let text = new UILControlTextarea(`stl_${_name}_${name}_resize`, {
                label: "Resize",
                value: input.get("onResize"),
                monospace: true,
                rows: 10,
                resize: "both",
                minWidth: 400,
                hideLabel: true,
                tab: true
              });
              editor.add(text);
              text.onFinishChange(value => input.setValue("onResize", value));
              UIL.add(editor);
            }
          }],
          hideLabel: true
        });
        folder.add(button);
        group.add(folder);
      })();
      if (Global.PLAYGROUND) {
        $obj._input = input;
      }
      _layers[name] = $obj;
      _exists[name] = true;
      checkNameHook($obj, name);
      let doBG = change => {
        if (GLUI) {
          if (change) {
            $obj.bg(parseData(bg));
          }
        } else if (bg || !bg && !name) {
          $obj.bg(parseData(bg) || "#ff0000");
        }
      };
      let doType = change => {
        if (!GLUI) {
          if (change) {
            StageLayoutUtil.save("type", {
              type: type
            }, input);
          }
        }
      };
      let doCSS = change => {
        if (GLUI) {
          return;
        }
        css = css || "";
        let obj = {};
        css = css.split("\n");
        css.forEach(line => {
          let key = (line = line.split(":"))[0];
          let val = line[1];
          val &&= parseData(val.replace(/ /g, ""));
          if (key.length) {
            obj[key] = isNaN(Number(val)) ? val : Number(val);
          }
        });
        if (change) {
          StageLayoutUtil.save("css", obj, input);
        }
        $obj.css(obj);
      };
      let doTransform = change => {
        transform = transform || "";
        let obj = {};
        transform = transform.split("\n");
        transform.forEach(line => {
          let key = (line = line.split(":"))[0];
          let val = line[1];
          val &&= val.replace(/ /g, "");
          if (key.length) {
            obj[key] = $obj[key] = isNaN(Number(val)) ? val : Number(val);
          }
        });
        if (change) {
          StageLayoutUtil.save("transform", obj, input);
        }
        if (!GLUI) {
          $obj.transform();
        }
      };
      let doResize = change => {
        if (resizeCode) {
          let fn = new Function("$this", resizeCode);
          _resize.push({
            fn: fn,
            $obj: $obj
          });
          fn($obj);
        }
      };
      let doSize = change => {
        if (size) {
          let s = parseData(size).replace(/ /g, "").split(",");
          let s0 = Number(s[0]) || s[0];
          let s1 = Number(s[1]) || s[1];
          $obj.size(s0, s1);
          if (change) {
            StageLayoutUtil.save("size", [s0, s1], input);
          }
        } else {
          $obj.size(100, 100);
        }
      };
      let doAttributes = change => {
        if (GLUI) {
          return;
        }
        attributes = attributes || "";
        let obj = {};
        attributes.split("\n").forEach(function (line, i) {
          let key = (line = line.split(":"))[0];
          let val = line[1];
          val &&= val.replace(/ /g, "");
          obj[key] = val;
          val = parseData(val);
          $obj.attr(key, val);
        });
        if (change) {
          StageLayoutUtil.save("attributes", obj, input);
        }
      };
      let doText = change => {
        text = parseData(text);
        if (GLUI) {
          if (!text) {
            return $obj;
          }
          if ($obj instanceof GLUIObject) {
            return $obj;
          }
          let fontStyle = getGLUIFontObject();
          if (change) {
            StageLayoutUtil.save("fontStyle", fontStyle, input);
          }
          $obj.setText(text, fontStyle);
          if (fontStyle.color) {
            $obj.setColor(fontStyle.color);
          }
        } else {
          let fontStyle = parseData(input.get("fontStyle"));
          if (fontStyle) {
            fontStyle = fontStyle.split("\n");
            $obj.fontStyle(fontStyle[0] || "", Number(fontStyle[1]), fontStyle[2], fontStyle[3]);
            if (change) {
              StageLayoutUtil.save("fontStyle", fontStyle, input);
            }
          } else if (change) {
            StageLayoutUtil.save("fontStyle", "", input);
          }
          if (!text) {
            return;
          }
          if (helper) {
            let helperName = helper.split("(")[0];
            let args = helper.split("(")[1];
            if (args) {
              args = args.replace(")", "").replace(/,\ /g, ",").split(",");
              args.forEach(function (arg, i) {
                if (arg == "$text") {
                  args[i] = text;
                }
              });
              if (args.indexOf(text) < 0) {
                args.unshift(text);
              }
            } else {
              args = [text];
            }
            let helperFn = _options[helperName] || StageLayout.helpers[helperName];
            if (helperFn) {
              $obj.html(helperFn.apply(null, args));
              StageLayoutUtil.save("helper", helper, input);
              return;
            } else {
              return console.warn(`No helper function ${helperName} found.`);
            }
          }
          if (text.includes(["</", "/>"])) {
            $obj.html(text);
          } else {
            $obj.text(text);
          }
        }
      };
      let doZ = _ => {
        if (typeof zIndex == "number") {
          $obj.setZ(zIndex);
        }
      };
      doType();
      doCSS();
      doBG();
      doSize();
      doAttributes();
      doTransform();
      doText();
      doResize();
      doZ();
      input.onUpdate = key => {
        switch (key) {
          case "name":
            group.setLabel(input.get("name"));
            break;
          case "type":
            type = input.get("type");
            doType(true);
            break;
          case "css":
            css = input.get("css");
            doCSS(true);
            break;
          case "size":
            size = input.get("size");
            doSize(true);
            break;
          case "attributes":
            attributes = input.get("attributes");
            doAttributes(true);
            break;
          case "transform":
            transform = input.get("transform");
            doTransform(true);
            break;
          case "onResize":
            resizeCode = input.get("onResize");
            doResize();
            break;
          case "text":
          case "fontStyle":
            text = input.get("text");
            doText(true);
            break;
          case "bg":
            bg = input.get("bg");
            doBG(true);
            break;
          case "zIndex":
            zIndex = input.getNumber("zIndex") || 0;
            doZ();
        }
      };
      if (customClass) {
        let Class = window[customClass];
        if (customClass.includes(".")) {
          let split = customClass.split(".");
          Class = window[split[0]] && window[split[0]][split[1]];
        }
        if (!Class) {
          return console.warn(`No custom class ${customClass} found.`);
        }
        _layers[name] = _this.initClass(Class, $obj, _options.data, input, group);
      }
      if (typeof index != "number") {
        _dataStore.setValue("data", JSON.stringify(_data));
      }
      return $obj;
    }
    function resizeHandler() {
      _resize.forEach(({
        $obj: $obj,
        fn: fn
      }) => fn($obj));
    }
    function sortChild(label, index = 0, parent, baseZ, step) {
      let folder = _folders[label.id || label];
      if (!folder || !folder.params) {
        return;
      }
      let zIndex = 0;
      zIndex = GLUI && baseZ != _this.baseZ ? baseZ + (index + 1) * step : baseZ + index;
      folder.params.setValue("zIndex", zIndex);
      if (label.children) {
        label.children.forEach(function (child, j, all) {
          sortChild(child, j, all, zIndex, step / (parent.length + 1));
        });
      }
    }
    function copyFolderProps(from, to) {
      let params;
      to.forEachFolder(child => {
        switch (child.label) {
          case "Parameters":
            params = child;
        }
      });
      let allowed = ["Parameters"];
      from.forEachFolder(child => {
        if (!(allowed.indexOf(child.label) < 0)) {
          child.toClipboard();
          switch (child.label) {
            case "Parameters":
              params.fromClipboard();
          }
        }
      });
    }
    this.isStageLayout = true;
    this.name = _name;
    this.layers = _layers;
    if (_options.layerHooks) {
      _this.layerHooks = _options.layerHooks;
    }
    _this.onResize(resizeHandler);
    initParams();
    initGraph();
    initData();
    defer(() => {
      initRoot();
    });
    this._createLayer = function (parentId) {
      return createLayer(null, parentId);
    };
    this._createGroup = function (parentId) {
      return createLayer(null, parentId);
    };
    this._rename = function (id, name, value) {
      if (name == value) {
        return;
      }
      let folder = _folders[id] || _folders[`stl_${_name}_${name}`];
      if (folder) {
        folder.setLabel(value);
        if (folder.params) {
          folder.params.setValue("name", value);
        }
        Object.values(_layers).filter(layer => layer._uil.params.get("group") == name).forEach(layer => layer._uil.params.setValue("group", value));
        [_exists, _layers].forEach(function (store) {
          if (store[name]) {
            store[value] = store[name];
            store[name] = null;
            delete store[name];
          }
        });
      }
    };
    this._deleteLayer = function (id, name) {
      let $obj = _layers[name];
      if (!$obj) {
        return false;
      }
      if ($obj.div && $obj.div.children.length) {
        alert("Can't delete a group that has nested layers.");
        return false;
      }
      if (!confirm("Are you sure you want to delete this layer?")) {
        return;
      }
      let folder = _folders[id];
      _uil.remove(folder);
      ($obj.element || $obj).remove();
      UILStorage.set(`${id}_deleted`, true);
      return true;
    };
    this._changeParent = function (childId, childName, parentId, parentName) {
      let child = _layers[childId] || _layers[childName];
      let parent = _layers[parentId] || _layers[parentName] || _this;
      if (!child) {
        return;
      }
      child = child.element || child;
      if (parent == _this) {
        parent = _this.element;
      }
      let folder = _folders[childId] || _folders[`sl_${_name}_${childName}`];
      if (folder && folder.params) {
        folder.params.setValue("group", parentName || null);
      }
      (typeof child.parent == "function" ? child.parent() : child.parent).removeChild(child, true);
      parent.add(child);
    };
    this._visible = function (name, visible) {
      let $obj = _layers[name];
      if ($obj && $obj.css) {
        if (visible) {
          $obj.css({
            opacity: 1
          });
        } else {
          $obj.css({
            opacity: 0
          });
        }
      }
    };
    this._focus = function (name) {
      UIL.sidebar.toolbar.filterSingle(name);
    };
    this._blur = function (name) {
      let folder = _folders[name];
      if (folder && folder.forEachFolder) {
        folder.forEachFolder(f => f.close());
        folder.close();
      }
    };
    this._sort = function (order) {
      order.forEach(function (item, i, all) {
        sortChild(item, i, all, _this.baseZ, 1);
      });
    };
    this._duplicateLayer = function (id, parentId) {
      let folder = _folders[id];
      if (!folder) {
        return;
      }
      createLayer(null, parentId);
      let copy = Object.values(_folders).last();
      copyFolderProps(folder, copy);
      if (parentId) {
        copy.params.setValue("group", parentId);
      }
    };
    this._duplicateGroup = function (id, children, parentId) {
      _this._duplicateLayer(id, parentId);
      let pid = _data.layers;
      children.forEach(childId => {
        _this._duplicateGroup(childId, _graph.listChildren(childId), pid);
      });
    };
    this._getFigmaConfig = async function () {
      let _figmaConfig = _config.get("Figma Config").replace(".json", "");
      return await get(Assets.getPath(`assets/data/${_figmaConfig}.json`));
    };
    this._applyFigmaConfig = function (id, params, $obj) {
      if (params.type === "TEXT") {
        $obj._input.setValue("text", params.characters);
        let figmaConfig;
        let lineHeight;
        let fontStyle = "";
        let align = params.textAlignHorizontal.toLowerCase();
        let fontName = StageLayout.FIGMA_FONT.DEFAULT;
        let fontScale = 1;
        let ptToPixel = 0.75;
        let family = StageLayout.FIGMA_FONT[params.fontName.family];
        if (family) {
          let font = family[params.fontName.style.toLowerCase()];
          if (font) {
            fontName = font.name;
            if (Stage.FIGMA_FONT_CONFIG && Stage.FIGMA_FONT_CONFIG[fontName]) {
              figmaConfig = Stage.FIGMA_FONT_CONFIG[fontName];
            }
            if (font.scale) {
              fontScale = font.scale;
            }
            if (figmaConfig && figmaConfig.fontScale && figmaConfig.fontScale > 0.1) {
              fontScale = figmaConfig.fontScale;
            }
          }
        }
        if (fontName) {
          fontStyle += `font: ${fontName}\n`;
        }
        fontStyle += `size: ${params.fontSize * ptToPixel * fontScale}\n`;
        fontStyle += `align: ${align}\n`;
        if (params.letterSpacing.unit === "PERCENT" && params.letterSpacing.value) {
          fontStyle += `letterSpacing: ${params.letterSpacing.value / 100 * fontScale}\n`;
        }
        if (figmaConfig && figmaConfig.lineHeight) {
          lineHeight = figmaConfig.lineHeight;
        }
        if (params.lineHeight.unit === "PERCENT" && params.lineHeight.value) {
          lineHeight *= params.lineHeight.value / 100;
        }
        if (lineHeight) {
          fontStyle += `lineHeight: ${lineHeight}\n`;
        }
        fontStyle += `width: ${params.width}\n`;
        fontStyle += `height: ${params.height}\n`;
        let fill = params.fills[0];
        if (fill && fill.color) {
          let c = fill.color;
          fontStyle += `color: ${new Color(c.r, c.g, c.b).getHexString()}\n`;
        }
        $obj._input.setValue("fontStyle", fontStyle);
        let x = params.x;
        if (align === "center") {
          x += params.width / 2;
        } else if (align === "right") {
          x += params.width;
        }
        let transform = `x: ${x}\ny: ${params.y}`;
        if (params.rotation) {
          transform += `\nrotation: ${params.rotation}`;
        }
        $obj._input.setValue("transform", transform);
      } else if (params.type === "RECTANGLE") {
        $obj._input.setValue("size", `${params.width}, ${params.height}`);
        let fill = params.fills[0];
        if (!fill) {
          return;
        }
        if (fill.type === "IMAGE") {
          $obj._input.setValue("bg", "assets/images/_scenelayout/uv.jpg");
        } else if (fill.type === "SOLID") {
          let c = fill.color;
          let color = new Color(c.r, c.g, c.b);
          $obj._input.setValue("bg", color.getHexString());
        }
        let transform = `x: ${params.x}\ny: ${params.y}`;
        if (params.rotation) {
          transform += `\nrotation: ${params.rotation}`;
        }
        $obj._input.setValue("transform", transform);
      }
    };
    this.getLayer = async function (name) {
      let timer;
      if (Hydra.LOCAL) {
        timer = _this.delayedCall(_ => {
          if (!_exists[name] && name !== "mockup") {
            console.warn(`${name} doesn't exist in StageLayout ${_name}`);
          }
        }, 1000);
      }
      for (let key in _layers) {
        let layer = _layers[key];
        if (layer._uil) {
          let uil = layer._uil;
          if (uil.id === name || uil.label === name) {
            if (timer) {
              clearTimeout(timer);
            }
            return layer;
          }
        }
      }
      await _this.wait(_layers, name);
      if (timer) {
        clearTimeout(timer);
      }
      return _layers[name];
    };
    this.getLayers = async function () {
      let array = [];
      for (let i = 0; i < arguments.length; i++) {
        array.push(_this.getLayer(arguments[i]));
      }
      return Promise.all(array);
    };
    this.getAllLayers = async function () {
      await this.ready();
      return _layers;
    };
    this.ready = this.loadedAllLayers = async function () {
      await _this.wait(_this, "loaded");
      await defer();
    };
    this.exists = function (key) {
      return !!_exists[key];
    };
    this.get("graph", _ => _graph);
    this.get("config", _ => _config);
    this.get("layerCount", _ => _data.layers);
  }, () => {
    StageLayout.FIGMA_FONT = {};
    StageLayout.LAYER_HOOKS = [];
    StageLayout.helpers = {};
    StageLayout.loadFontConfig = async (path, json) => {
      if (!json) {
        path = path || "assets/data/figma-font.json";
        try {
          json = await get("assets/data/figma-font.json");
        } catch (e) {
          return;
        }
      }
      Stage.FIGMA_FONT_CONFIG = json.config;
    };
  });
  Class(function StageLayoutCapture(_layout, _w, _h, _rtPool, _strict) {
    Inherit(this, Component);
    const _this = this;
    var _rt;
    var _camera;
    var _hitCamera;
    var _interaction;
    var _ray;
    var _needsRender;
    var _rendered;
    var _hitEvt;
    var _usingFingers;
    var $glObj;
    var _scene = new Scene();
    var _mouse = new Vector2();
    var _stage = new Vector2();
    var _v3 = new Vector3();
    var _enabled = true;
    var _width = _w;
    var _height = _h;
    var _cacheHits = [];
    function loop() {
      if (!_enabled) {
        return;
      }
      if (_this.manualRender && !_needsRender) {
        return;
      }
      let clearAlpha = World.RENDERER.getClearAlpha();
      let autoClear = World.RENDERER.autoClear;
      if (_this.disableClear) {
        World.RENDERER.autoClear = false;
      }
      let clearColor = World.RENDERER.getClearColor().getHex();
      if (clearColor > 0) {
        World.RENDERER.setClearColor(0, 0);
      } else {
        World.RENDERER.setClearAlpha(0);
      }
      World.RENDERER.render(_scene, _camera, _rt);
      if (clearColor > 0) {
        World.RENDERER.setClearColor(clearColor, clearAlpha);
      } else {
        World.RENDERER.setClearAlpha(clearAlpha);
      }
      if (_this.disableClear) {
        World.RENDERER.autoClear = autoClear;
      }
      _rendered = true;
    }
    function noop() {}
    function hitUpdate(hit) {
      let x = hit.uv.x * _width;
      let y = (1 - hit.uv.y) * _height;
      _usingFingers = hit.usingFinger;
      _this.isHitting = true;
      _mouse.set(x, y);
      if (_enabled && _interaction) {
        if (hit.usingFinger) {
          _interaction.testWithFinger(_mouse, hit.distance);
        } else {
          _interaction.testWith(_mouse);
        }
      }
    }
    function missUpdate() {
      _this.isHitting = false;
      _mouse.set(9999, 9999);
      if (_interaction) {
        if (_usingFingers) {
          _interaction.testWithFinger(_mouse, 9999);
        } else {
          _interaction.testWith(_mouse);
        }
      }
    }
    function raycastMove(e) {
      _ray ||= _this.initClass(Raycaster, _hitCamera);
      let hit;
      let input = Interaction3D.find(_hitCamera).input;
      if (Array.isArray(input.obj)) {
        _cacheHits.length = 0;
        for (let i = 0; i < input.obj.length; i++) {
          let obj = input.obj[i];
          _v3.set(0, 0, -1).applyQuaternion(obj.quaternion);
          let hit = _ray.checkFromValues($glObj.mesh, obj.position, _v3)[0];
          if (hit) {
            _cacheHits.push(hit);
          }
        }
        _cacheHits.sort((a, b) => a.distance - b.distance);
        hit = _cacheHits[0];
      } else if (input.type == "2d") {
        hit = _ray.checkHit($glObj.mesh, input.position, input.rect || Stage)[0];
      } else {
        _v3.set(0, 0, -1).applyQuaternion(input.quaternion);
        hit = _ray.checkFromValues($glObj.mesh, input.position, _v3)[0];
      }
      _hitEvt ||= {
        normal: new Vector2(),
        tilt: new Vector2(),
        pos: new Vector2()
      };
      if (hit) {
        _hitEvt.normal.set(hit.uv.x, 1 - hit.uv.y);
        _hitEvt.tilt.set(Math.range(_hitEvt.normal.x, 0, 1, -1, 1), Math.range(_hitEvt.normal.y, 0, 1, -1, 1));
        _hitEvt.pos.set(_hitEvt.normal.x * _width, _hitEvt.normal.y * _height);
        _hitEvt.hit = hit;
        if (_this.onDragMove) {
          _this.onDragMove(_hitEvt);
        }
      } else if (_this.onDragMove) {
        _this.onDragMove(null);
      }
    }
    function flipNeedsRender() {
      if (_needsRender && !_rendered) {
        return callAfterAtLeast(flipNeedsRender, 1);
      }
      _needsRender = false;
    }
    function callAfterAtLeast(callback, ms) {
      let callAt = Date.now() + ms;
      if (callAt > (callback.__intervalExpiry || 0)) {
        clearTimeout(callback.__interval);
        callback.__interval = Timer.create(callback, ms);
        callback.__intervalExpiry = callAt;
      }
    }
    function doCheckObjectHit(object, callback) {
      let hit = callback(Interaction3D.find(_hitCamera));
      if (hit) {
        let x = hit.uv.x * _width;
        let y = (1 - hit.uv.y) * _height;
        return _interaction.checkObjectHit(object, {
          x: x,
          y: y
        });
      }
    }
    this.disableClear = false;
    (function () {
      if (typeof _layout == "number") {
        _strict = _rtPool;
        _rtPool = _h;
        _h = _w;
        _w = _layout;
        _layout = {
          element: $gl()
        };
      }
      _width = _w;
      _height = _h;
      if (typeof _rtPool == "boolean") {
        _strict = _rtPool;
        _rtPool = null;
      }
      let dpr = _strict ? 1 : RenderManager.DPR;
      if (_rtPool) {
        _this.rt = _rtPool.nullRT;
      } else {
        _rt = Utils3D.createRT(_width * dpr, _height * dpr, null, Texture.RGBAFormat);
        _this.rt = _rt;
      }
      _this.root = _layout.element;
      _this.root.stageLayoutCapture = _this;
      _scene.add(_layout.element.group);
      (_camera = new OrthographicCamera()).setViewport(_width, _height);
      _camera.position.z = 1;
      _camera.position.x = _width / 2;
      _camera.position.y = -_height / 2;
      _scene.disableAutoSort = true;
      _stage.set(_width, _height);
      (function findHitCamera() {
        let p = _this.parent;
        while (p) {
          if (_hitCamera = p.nuke?.camera) {
            return;
          }
          p = p.parent;
        }
        _hitCamera = World.CAMERA;
      })();
      _interaction = _this.initClass(GLUIStageInteraction2D, _camera, _scene, _stage, true);
      _this.startRender(loop, RenderManager.AFTER_LOOPS);
    })();
    this.onVisible = function () {
      if (_rtPool) {
        _rt = _this.rt = _rtPool.getRT();
      }
    };
    this.onInvisible = function () {
      if (_rtPool) {
        _rtPool.putRT(_rt);
      }
    };
    this.setSize = function (width, height) {
      _width = width;
      _height = height;
      _camera.setViewport(_width, _height);
      _camera.position.z = 1;
      _camera.position.x = _width / 2;
      _camera.position.y = -_height / 2;
      _stage.set(width, height);
    };
    this.render = function () {
      loop();
    };
    this.get("object3d", () => $glObj);
    this.set("object3d", gl => {
      if (!gl.mesh) {
        gl = {
          mesh: gl
        };
      }
      ($glObj = gl).mesh.onHitUpdate = hitUpdate;
      $glObj.mesh.onMissUpdate = missUpdate;
      if (_hitCamera) {
        Interaction3D.find(_hitCamera).add($glObj.mesh, noop, noop);
      }
    });
    this.get("camera", () => _camera);
    this.set("hitCamera", camera => {
      if (camera != _hitCamera) {
        if ($glObj) {
          Interaction3D.find(_hitCamera).remove($glObj.mesh);
        }
        _hitCamera = camera;
        if ($glObj) {
          Interaction3D.find(_hitCamera).add($glObj.mesh, noop, noop);
        }
        if (_ray) {
          _ray.camera = _hitCamera;
        }
      }
    });
    this.set("enabled", v => {
      _interaction._disabled = !v;
      _enabled = v;
    });
    this.get("enabled", _ => _enabled);
    this.set("mouseEnabled", v => {
      if (v) {
        _interaction._disabled = false;
        $glObj.mesh.onHitUpdate = hitUpdate;
        $glObj.mesh.onMissUpdate = missUpdate;
        if (_hitCamera) {
          Interaction3D.find(_hitCamera).add($glObj.mesh, noop, noop);
        }
      } else {
        _interaction._disabled = true;
        if ($glObj) {
          if (_hitCamera) {
            Interaction3D.find(_hitCamera).remove($glObj.mesh);
          }
          delete $glObj.mesh.onHitUpdate;
          delete $glObj.mesh.onMissUpdate;
        }
      }
    });
    this.set("layout", layout => {
      if (_layout) {
        _scene.remove(_layout.element.group);
      }
      _scene.add(layout.element.group);
      _layout = layout;
    });
    this.get("layout", _ => _layout);
    this.get("scene", _ => _scene);
    this.get("width", _ => _width);
    this.get("height", _ => _height);
    this.onVisible = function () {
      if (_rtPool) {
        _rt = _this.rt = _rtPool.getRT();
      }
    };
    this.onInvisible = function () {
      if (_rtPool && _this.rt != _rtPool.nullRT) {
        _rtPool.putRT(_this.rt);
        _rt = _this.rt = _rtPool.nullRT;
      }
    };
    this.onDestroy = function () {
      if (_rtPool) {
        _this.onInvisible();
      } else {
        _this.rt.destroy();
      }
      if ($glObj) {
        Interaction3D.find(_hitCamera).remove($glObj.mesh);
        delete $glObj.mesh.onHitUpdate;
        delete $glObj.mesh.onMissUpdate;
      }
    };
    this.bindMove = function () {
      _this.startRender(raycastMove);
    };
    this.unbindMove = function () {
      _this.stopRender(raycastMove);
    };
    this.set("needsRender", value => {
      _needsRender = true;
      _rendered = false;
      callAfterAtLeast(flipNeedsRender, typeof value == "number" ? value : 1000);
    });
    _this.checkObjectHit = function (object, mouse) {
      return doCheckObjectHit(object, interaction => interaction.checkObjectHit($glObj.mesh, mouse));
    };
    _this.checkObjectFromValues = function (object, origin, direction) {
      return doCheckObjectHit(object, interaction => interaction.checkObjectFromValues($glObj.mesh, origin, direction));
    };
    _this.getObjectHitLocalCoords = function (v, object, mouse) {
      Interaction3D.find(_hitCamera).getObjectHitLocalCoords(v, $glObj.mesh, mouse);
      mouse = {
        x: (0.5 + v.x) * _width,
        y: (0.5 - v.y) * _height
      };
      return _interaction.getObjectHitLocalCoords(v, object.mesh, mouse);
    };
  }, _ => {
    StageLayoutCapture.createRTPool = function (width, height, strict) {
      let pool = RTPool.instance().clone({
        format: Texture.RGBAFormat
      });
      let dpr = strict ? 1 : RenderManager.DPR;
      pool.setSize(width * dpr, height * dpr);
      return pool;
    };
  });
  Class(function StageLayoutUtil() {
    Inherit(this, Component);
    var _data;
    const KEY = "stagelayoututil_keys";
    var _compiled = {};
    async function init() {
      await UILStorage.ready();
      _data = JSON.parse(UILStorage.get(KEY) || "[]");
      (function compile() {
        _data.forEach(key => {
          _compiled[key] = JSON.parse(UILStorage.get(`INPUT_Config_${key}_compiled`) || "{}");
          let resizeCode = UILStorage.get(`INPUT_Config_${key}_onResize`);
          if (resizeCode) {
            _compiled[key].resize = new Function("$this", resizeCode);
          }
        });
      })();
    }
    (async function () {
      await Hydra.ready();
      if (!window.Platform || !Platform.isPlatform) {
        init();
      }
    })();
    this.save = function (key, data, input) {
      let compiled = JSON.parse(input.get("compiled") || "{}");
      compiled[key] = data;
      input.setValue("compiled", JSON.stringify(compiled));
    };
    this.create = function (key) {
      if (!_data.includes(key)) {
        _data.push(key);
        UILStorage.set(KEY, JSON.stringify(_data));
      }
    };
    this.getCompiled = function (key) {
      return _compiled[key];
    };
    this.reload = function () {
      return init();
    };
  }, "static");
  Class(function Text3D(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config;
    var _fontObject;
    var $text;
    function initUIL() {
      (_config = InputUIL.create(_input.prefix + "_text3d", _group)).setLabel("Text3D");
      _config.addTextarea("text").addTextarea("fontStyle");
      _config.addToggle("anchor2D", false);
      _config.addToggle("renderRetina", false);
      _config.add("data", "hidden");
      if (UIL.sidebar) {
        _config.onUpdate = key => {
          if (key != "data") {
            let text = parseData(_config.get("text"));
            let obj = getFontObject();
            _config.setValue("data", JSON.stringify(obj));
            if ($text) {
              $text.setText(text, obj);
              if (obj.color) {
                $text.setColor(obj.color);
              }
            }
            if (_this.onUpdate) {
              _this.onUpdate();
            }
          }
        };
      }
    }
    function parseData(text) {
      if (!text || !text.includes("$DATA")) {
        return text;
      }
      while (text.includes("$DATA")) {
        let code = text.split("$DATA")[1].split(" ")[0].split("\n")[0];
        let line = "$DATA" + code;
        text = text.replace(line, eval(line.replace("$DATA", "_this.parent.data")));
      }
      return text;
    }
    function getFontObject() {
      let font = _config.get("fontStyle") || "";
      let obj = {};
      font = font.split("\n");
      font.forEach(line => {
        let key = (line = line.split(":"))[0];
        let val = line[1];
        val &&= val.replace(/ /g, "");
        if (key.length) {
          obj[key] = isNaN(Number(val)) ? val : Number(val);
          if (val === "false") {
            obj[key] = false;
          }
          if (val === "true") {
            obj[key] = true;
          }
        }
      });
      return obj;
    }
    function initText() {
      if (!(_fontObject = JSON.parse(_config.get("data") || "{}")).size) {
        return;
      }
      if (Text3D.FONT_CONFIG) {
        _fontObject.config = Text3D.FONT_CONFIG;
      }
      if (Text3D.LANG_BREAK) {
        _fontObject.langBreak = Text3D.LANG_BREAK;
      }
      _fontObject.shader ||= "Text3D";
      let text = parseData(_config.get("text"));
      if (text) {
        createText(text, _fontObject);
      }
    }
    async function overrideLocalize(text, fontObject, cb) {
      if (!text) {
        return;
      }
      _this.localized = true;
      fontObject.text = text;
      if (_this.text && _this.text.destroy) {
        _this.text.destroy();
      }
      _this.text = new Text3D.FallbackText();
      _this.text.setColor(_fontObject.color);
      _this.text.onSetText = text => _this.setText(text);
      Text3D.createFallbackTexture(text, fontObject).then(texture => {
        _this.text.setColor(fontObject.color);
        let geom = new PlaneGeometry(texture.width, texture.height);
        geom.computeBoundingBox();
        if (fontObject.align != "center") {
          geom.applyMatrix(new Matrix4().makeTranslation(texture.width / 2, 0, 0));
        }
        while (_this.group.children.length) {
          _this.group.remove(_this.group.children[0]);
        }
        _this.text.createMesh(geom, texture);
        _this.add(_this.text.group);
        return _this.text;
      });
    }
    function createText(text, fontObject) {
      if ((fontObject.localize || _input.forceLocalize) && Text3D.missingChars(text, fontObject)) {
        return overrideLocalize(text, fontObject);
      }
      ($text = $glText(text, null, null, fontObject)).enable3D(_config.get("anchor2D"));
      if (_config.get("renderRetina") && RenderManager.type !== RenderManager.WEBVR) {
        let gluiToRTScene;
        $text.anchor ||= new Group();
        _this.add($text.anchor);
        let p = _this.parent;
        while (p) {
          if (p.glSceneEnabled) {
            gluiToRTScene = p;
          }
          p = p.parent;
        }
        if (gluiToRTScene) {
          gluiToRTScene.addGLUI3D($text);
        } else {
          GLUI.Scene.add($text);
        }
      } else {
        _this.add($text.group);
      }
      $text.text.onCreateShader = shader => {
        let shaderName = _input.get("shader");
        if (shaderName) {
          if (shader.fragmentShader?.length) {
            shader.fragmentShader = shader.fragmentShader.split("void main")[0] + "\n" + Shaders.getShader(shaderName + ".fs");
          }
          shader.customCompile = shaderName;
        }
        $text.text3d = _this;
        if (window[shaderName]) {
          _this.shaderClass = _this.parent.initClass(window[shaderName], $text, shader, _group, _input);
          ShaderUIL.add(shader, _group).setLabel("Shader");
        }
      };
      _this.text = $text;
      let setText = $text.setText.bind($text);
      $text.setText = function (text, obj) {
        if (obj) {
          for (let key in obj) {
            _fontObject[key] = obj[key];
          }
        }
        _fontObject.text = text;
        setText(text, _fontObject);
        _this.events.fire(Events.UPDATE);
        defer(setUniforms);
      };
      $text.loaded().then(_ => {
        if ($text) {
          _this.shader = $text.mesh.shader;
          _this.shader.addUniforms({
            uTransition: {
              value: 1,
              ignoreUIL: true
            },
            uOpacity: {
              value: 1,
              ignoreUIL: true
            },
            uTranslate: {
              value: _this.translate
            },
            uRotate: {
              value: _this.rotate
            },
            uWordCount: {
              value: 0,
              ignoreUIL: true
            },
            uLetterCount: {
              value: 0,
              ignoreUIL: true
            },
            uLineCount: {
              value: 0,
              ignoreUIL: true
            },
            uByWord: {
              value: 0,
              ignoreUIL: true
            },
            uByLine: {
              value: 0,
              ignoreUIL: true
            },
            uPadding: {
              value: 0.3,
              ignoreUIL: true
            },
            uBoundingMin: {
              value: new Vector3().copy($text.dimensions.min),
              ignoreUIL: true
            },
            uBoundingMax: {
              value: new Vector3().copy($text.dimensions.max),
              ignoreUIL: true
            }
          });
          if (Text3D.onCreateShader) {
            Text3D.onCreateShader(_this.shader);
          }
        }
      });
      setUniforms();
    }
    async function setUniforms() {
      await _this.wait(_this, "shader");
      await $text.loaded();
      if (_input && _input.get) {
        let depthWrite = _input.get("depthWrite");
        let depthTest = _input.get("depthTest");
        if (typeof depthWrite == "boolean") {
          $text.mesh.shader.depthWrite = depthWrite;
        }
        if (typeof depthTest == "boolean") {
          $text.mesh.shader.depthTest = depthTest;
        }
        let blending = _input.get("blending");
        if (blending) {
          $text.mesh.shader.blending = blending;
        }
      }
      _this.shader.set("uWordCount", $text.mesh.geometry.wordCount);
      _this.shader.set("uLetterCount", $text.mesh.geometry.letterCount);
      _this.shader.set("uLineCount", $text.mesh.geometry.lineCount);
      _this.shader.set("uBoundingMin", new Vector3().copy($text.dimensions.min));
      _this.shader.set("uBoundingMax", new Vector3().copy($text.dimensions.max));
    }
    this.translate = new Vector3();
    this.rotate = new Vector3();
    _this.wildcard = _input.get("wildcard");
    (async function () {
      _this.group.text = _this;
      initUIL();
      initText();
      if (Text3D.onCreate) {
        Text3D.onCreate(_this);
      }
    })();
    this.get("fontObject", _ => _fontObject);
    this.setProperties = function (obj = _fontObject) {
      if ($text) {
        $text.setText(obj.text, obj);
        setUniforms();
      } else {
        createText(obj.text, obj);
      }
      return _this.text.loaded();
    };
    this.setPropertiesCheck = function (obj, force) {
      let applyProperties = false;
      for (const key in obj) {
        if (_fontObject[key] !== obj[key]) {
          applyProperties = true;
          _fontObject[key] = obj[key];
        }
      }
      if (applyProperties || force) {
        return _this.setProperties();
      } else {
        return Promise.resolve();
      }
    };
    this.setText = function (text) {
      _fontObject.text = text;
      if ($text) {
        if (_fontObject.localize && Text3D.missingChars(text, _fontObject)) {
          _this.group.remove($text.group);
          _this.shader = undefined;
          $text = null;
          createText(text, _fontObject);
          return;
        }
        $text.setText(text);
        setUniforms();
        if ($text.mesh) {
          $text.mesh.onBeforeRender();
          $text.mesh.updateMatrixWorld(true);
        }
      } else {
        createText(text, _fontObject);
      }
    };
    this.setColor = function (color) {
      _fontObject.color = color;
      if (_this.text) {
        _this.text.setColor(color);
      }
    };
    this.set("animateByWord", async bool => {
      if (!_this.localized) {
        await _this.wait(_this, "shader");
        _this.shader.set("uByWord", bool ? 1 : 0);
      }
    });
    this.set("animateByLine", async bool => {
      if (!_this.localized) {
        await _this.wait(_this, "shader");
        _this.shader.set("uByLine", bool ? 1 : 0);
      }
    });
    this.set("animationPadding", async p => {
      if (!_this.localized) {
        await _this.wait(_this, "shader");
        _this.shader.set("uPadding", p);
      }
    });
    this.set("transition", async v => {
      if (_this.localized) {
        return _this.text.alpha = v;
      }
      await _this.wait(_this, "shader");
      _this.shader.set("uTransition", v);
    });
    this.tween = async function (val, time, ease, delay) {
      if (_this.localized) {
        return _this.text.tween(val, time, ease, delay);
      } else {
        await _this.wait(_this, "shader");
        return _this.shader.tween("uTransition", val, time, ease, delay);
      }
    };
    this.upload = function () {
      if ($text) {
        $text.upload();
      }
    };
    this.ready = function () {
      return _this.wait(_this, "shader");
    };
    this.set("renderOrder", v => {
      if ($text) {
        $text.setZ(v);
      }
    });
    this.getDimensions = async _ => {
      await $text.loaded();
      await $text.text.ready();
      return $text.dimensions;
    };
  }, _ => {
    var _projection;
    Text3D.missingChars = function () {
      return false;
    };
    Text3D.measureScreen = async function ($text, camera = World.CAMERA, z = 0) {
      _projection ||= new ScreenProjection(World.CAMERA);
      if ($text instanceof Text3D) {
        $text = $text.text;
      }
      await $text.loaded();
      $text.mesh.onBeforeRender();
      $text.mesh.updateMatrixWorld(true);
      await defer();
      _projection.camera = camera;
      let bb = new Box3();
      bb.setFromObject($text.mesh);
      bb.min.z = bb.max.z = z;
      let min = _projection.project(bb.min).clone();
      let max = _projection.project(bb.max).clone();
      return {
        width: Math.abs(min.x - max.x),
        height: Math.abs(min.y - max.y)
      };
    };
  });
  Class(function TimelineCameraLink(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _nullObject;
    var _link;
    var _config;
    function loop() {
      _this.group.position.lerp(_nullObject.position, _this.lerp);
      _this.group.quaternion.slerp(_nullObject.quaternion, _this.lerp);
    }
    this.isCameraLink = true;
    this.lerp = 0.07;
    if (!(_input instanceof InputUILConfig)) {
      _config = _input;
      _group = _input = undefined;
    }
    (function () {
      if (!_config && !_input) {
        throw "TimelineCameraLink requires a config";
      }
      if (_config) {
        if (!_config.prefix || !_config.layoutName || !_config.layerName) {
          throw "TimelineCameraLink requires config.prefix, config.layoutName, config.layerName";
        }
        if (!_config.group) {
          console.warn("Pass in a UIL folder as config.group to organize your cameras");
        }
      }
      (function initCamera() {
        _nullObject = new Group();
        if (_config) {
          _this.gazeCamera = _this.initClass(GazeCamera);
          _this.gazeCamera.prefix = _config.prefix;
          CameraUIL.add(_this.gazeCamera, _config.group).setLabel("Camera");
        } else {
          _this.gazeCamera = _this.initClass(GazeCamera, _input, _group);
        }
        _this.group.add(_this.gazeCamera.group);
      })();
      (function initLink() {
        (_link = _this.initClass(TimelineObjectLink, _nullObject, _config ? _config.layoutName : _this.parent.name, _config ? _config.layerName : _input.get("name"))).lerp = null;
        let first = false;
        _link.onFrame = _ => {
          if (!first) {
            first = true;
            _this.group.position.copy(_nullObject.position);
            _this.group.quaternion.copy(_nullObject.quaternion);
          }
        };
      })();
      (function initConfig() {
        let config = InputUIL.create((_config ? _config.prefix : _input.prefix) + "camera_link", _group || _config?.group);
        config.setLabel("Camera Config");
        config.add("lerp", 0.07);
        config.onUpdate = _ => {
          _this.lerp = config.getNumber("lerp");
        };
        config.onUpdate();
      })();
      _this.startRender(loop);
    })();
  });
  Class(function TimelineLayoutLink(_layout, _shaderMap = {}, _properties = []) {
    Inherit(this, Object3D);
    const _this = this;
    var _layers = {};
    const STANDARD = ["position", "rotation", "scale"];
    const DEBUG = Hydra.LOCAL;
    this.lerp = 1;
    var _v2 = new Vector2();
    var _v3 = new Vector3();
    var _v4 = new Vector4();
    var _color = new Color();
    function onMessage({
      layers: layers,
      force: force
    }) {
      if (!_this.group.determineVisible() && !force) {
        return false;
      }
      _this.lerp = TimelineOSC.lerp;
      for (let i = 0; i < layers.length; i++) {
        let e = layers[i];
        if (!e.scene.includes(_layout.name)) {
          continue;
        }
        let layer = _layers[e.layer];
        let scene = e.scene;
        if (!layer) {
          scene = e.scene.replace(_layout.name + "_", "");
          layer = _layers[scene];
        }
        if (layer) {
          if (e.type != "i") {
            if (_properties.includes(e.param)) {
              layer[e.param] = e.value;
            } else if (!layer.isCameraLink) {
              if (e.param.includes(STANDARD)) {
                let mesh = layer[e.param];
                if (!mesh && layer.group) {
                  mesh = layer.group[e.param];
                }
                if (!mesh) {
                  if (DEBUG) {
                    console.warn(`${_layout.name}::${e.layer} doesn't have param ${e.param}`);
                  }
                  continue;
                }
                if (_this.lerp == 1) {
                  mesh.fromArray(e.value);
                  if (e.param == "position" || e.param == "rotation") {
                    mesh.z *= -1;
                  }
                } else {
                  _v3.fromArray(e.value);
                  if (e.param == "position" || e.param == "rotation") {
                    _v3.z *= -1;
                  }
                  mesh.lerp(_v3, _this.lerp, false);
                }
              } else {
                let shader;
                shader = e.layer == "shader" ? layer.shader : _shaderMap[e.scene.replace(_layout.name + "_", "") + "_" + e.layer];
                if (!shader) {
                  if (DEBUG) {
                    console.warn(`No shader found for ${scene} :: ${e.layer}`);
                  }
                  continue;
                }
                if (!shader.uniforms) {
                  if (DEBUG) {
                    console.warn(`No uniforms found on shader object ${scene} :: ${e.layer}`);
                  }
                  continue;
                }
                let uniform = shader.uniforms[e.param];
                if (uniform) {
                  switch (e.type) {
                    case "f":
                      if (typeof uniform.value != "number") {
                        if (DEBUG) {
                          console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got float but not a float`);
                        }
                        continue;
                      }
                      if (_this.lerp == 1) {
                        uniform.value = e.value;
                      } else {
                        uniform.value = Math.lerp(e.value, uniform.value, _this.lerp, false);
                      }
                      break;
                    case "v2":
                    case "v3":
                    case "v4":
                      if (!uniform.value.fromArray) {
                        if (DEBUG) {
                          console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got vector but not a vector`);
                        }
                        continue;
                      }
                      if (_this.lerp == 1) {
                        uniform.value.fromArray(e.value);
                      } else {
                        let v = e.type == "v2" ? _v2 : e.type == "v3" ? _v3 : _v4;
                        v.fromArray(e.value);
                        uniform.value.lerp(v, _this.lerp, false);
                      }
                      break;
                    case "c":
                      if (!uniform.value.setStyle) {
                        if (DEBUG) {
                          console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got color but not a color`);
                        }
                        continue;
                      }
                      if (_this.lerp == 1) {
                        uniform.value.setStyle(e.value);
                      } else {
                        _color.setStyle(e.value);
                        uniform.value.lerp(_color, _this.lerp, false);
                      }
                  }
                  if (shader.ubo) {
                    shader.ubo.needsUpdate = true;
                  }
                } else {
                  console.warn(`No uniform found for ${scene} ${e.layer} :: ${e.param}`);
                }
              }
            }
          } else {
            let lastVal = layer[e.param];
            layer[e.param] = !!e.value;
            if (layer[e.param] != lastVal) {
              _this.events.fire(TimelineLayoutLink.TOGGLE, {
                param: e.param,
                layer: layer,
                value: !!e.value
              });
            }
          }
        }
      }
    }
    (async function () {
      if (Array.isArray(_shaderMap)) {
        _properties = _shaderMap;
        _shaderMap = {};
      }
      _layers = _layout.layers;
      (function addListeners() {
        _this.events.sub(TimelineOSC, Events.UPDATE, onMessage);
      })();
    })();
    this.get("shaderMap", _ => _shaderMap);
  }, _ => {
    TimelineLayoutLink.TOGGLE = "timeline_layout_link_toggle";
  });
  Class(function TimelineOSC() {
    Inherit(this, Component);
    const _this = this;
    var _socket;
    var _playing = {};
    var _data = {};
    var _store = [];
    var _evt = {
      layers: _store
    };
    function flush() {
      if (_store.length > 0) {
        _this.events.fire(Events.UPDATE, _evt);
      }
      _store.length = 0;
    }
    function socketUpdate(e) {
      _store.push(e);
    }
    function playbackUpdate({
      array: array
    }) {
      array.forEach(socketUpdate);
    }
    this.data = _data;
    this.lerp = 1;
    (async function () {
      await Hydra.ready();
      if (Utils.query("osc")) {
        (function initSocket() {
          _socket = new SocketConnection(`ws://${location.host}:8919`);
          _this.events.sub(_socket, "update", socketUpdate);
        })();
      }
      _this.startRender(flush);
    })();
    this.test = function (key, type, param, value) {
      let underscore = key.lastIndexOf("_");
      socketUpdate({
        scene: key.slice(0, underscore),
        layer: key.slice(underscore + 1),
        type: type,
        param: param,
        value: value
      });
    };
    this.load = async function (name, src) {
      if (!src.includes(".json")) {
        src += ".json";
      }
      _data[name] = await get(Assets.getPath(src));
    };
    this.play = function (name, fps) {
      let playback = _this.initClass(TimelineOSCPlayback, _data[name], name, fps);
      _this.events.sub(playback, Events.UPDATE, playbackUpdate);
      _this.events.sub(playback, Events.COMPLETE, _ => {
        delete _playing[name];
        _this.events.fire(Events.COMPLETE, name);
      });
      _playing[name] = playback;
      return playback;
    };
    this.stop = function (name) {
      _playing[name].stop();
      delete _playing[name];
    };
    this.setInitialState = async function (name) {
      await _this.wait(_data, name);
      _this.events.fire(Events.UPDATE, {
        layers: _data[name][0],
        force: true
      });
    };
  }, "static");
  Class(function TimelineOSCPlayback(_data, _name, _fps = 60) {
    Inherit(this, Component);
    const _this = this;
    const RATE = _fps;
    const MSRATE = 1000 / RATE;
    var _frame = 0;
    var _totalFrames = _data.length;
    var _evt = {
      array: []
    };
    var _blurTime = performance.now();
    var _time = performance.now();
    var _floatFrame = 0;
    var _objectPool = new ObjectPool(Object, 200);
    var _arrayPool = new ObjectPool(Array, 200);
    var _color = new Color();
    var _color2 = new Color();
    function loop() {
      let now = performance.now();
      let delta = now - _time;
      _time = now;
      _floatFrame += delta / MSRATE;
      if (Render.REFRESH_RATE <= RATE) {
        _evt.array = _data[Math.round(_floatFrame)];
      } else {
        interpolate();
      }
      _frame = Math.round(_floatFrame);
      _evt.progress = _frame / _totalFrames;
      _this.events.fire(Events.UPDATE, _evt);
      if (_frame >= _totalFrames - 1) {
        _this.stopRender(loop);
        _this.events.fire(Events.COMPLETE, {
          name: _name
        });
        _this.destroy();
      }
    }
    function interpolate() {
      if (_evt.array.length) {
        for (let i = _evt.array.length - 1; i > -1; i--) {
          let obj = _evt.array[i];
          if (Array.isArray(obj.value)) {
            obj.value.length = 0;
            _arrayPool.put(obj.value);
          }
          _objectPool.put(obj);
        }
        _evt.array.length = 0;
      }
      let currentFrame = Math.floor(_floatFrame);
      let nextFrame = Math.ceil(_floatFrame);
      let fract = Math.fract(_floatFrame);
      let data0 = _data[currentFrame];
      let data1 = _data[nextFrame];
      if (!!data0 && !(data0.length < 1)) {
        data0.forEach(frameData => {
          let nextData = function getDataFromNextFrame(obj, data) {
            if (!obj || !data) {
              return;
            }
            for (let i = data.length - 1; i > -1; i--) {
              let obj2 = data[i];
              if (obj.layer == obj2.layer && obj.param == obj2.param && obj.type == obj2.type && obj.scene == obj2.scene) {
                return obj2;
              }
            }
          }(frameData, data1);
          let obj = _objectPool.get();
          obj.layer = frameData.layer;
          obj.param = frameData.param;
          obj.type = frameData.type;
          obj.scene = frameData.scene;
          _evt.array.push(obj);
          if (nextData) {
            switch (obj.type) {
              case "f":
                obj.value = frameData.value * (1 - fract) + nextData.value * fract;
                break;
              case "v2":
              case "v3":
              case "v4":
                obj.value = _arrayPool.get();
                (function interpolateArray(currentValue, nextValue, fract, output) {
                  for (let i = 0; i < currentValue.length; i++) {
                    output[i] = currentValue[i] * (1 - fract) + nextValue[i] * fract;
                  }
                })(frameData.value, nextData.value, fract, obj.value);
                break;
              case "c":
                _color.set(frameData.value).lerp(_color2.set(nextData.value), fract);
                obj.value = _color.getHexString();
                break;
              case "i":
                obj.value = frameData.value;
            }
          } else if (Array.isArray(frameData.value)) {
            obj.value = _arrayPool.get();
            for (let i = 0; i < frameData.value.length; i++) {
              obj.value[i] = frameData.value[i];
            }
          } else {
            obj.value = frameData.value;
          }
        });
      }
    }
    function focus(e) {
      if (!_this.flag("paused") && !_this.flag("seeking")) {
        if (e.type == "blur") {
          _blurTime = performance.now();
          _this.stopRender(loop);
        } else {
          _this.startRender(loop);
          _time += performance.now() - _blurTime;
        }
      }
    }
    _this.startRender(loop);
    (function addListeners() {
      _this.events.sub(Events.VISIBILITY, focus);
    })();
    this.seek = function (percent) {
      _floatFrame = Math.min(percent * _totalFrames, _totalFrames - 1);
      interpolate();
      _frame = Math.round(_floatFrame);
      _evt.progress = _frame / _totalFrames;
      _this.events.fire(Events.UPDATE, _evt);
      _this.stopRender(loop);
      _this.flag("seeking", true);
    };
    this.pause = function () {
      if (!_this.flag("paused")) {
        _this.stopRender(loop);
        focus({
          type: "blur"
        });
        _this.flag("paused", true);
      }
    };
    this.resume = function () {
      if (_this.flag("paused")) {
        _this.flag("seeking", false);
        _this.flag("paused", false);
        focus({
          type: "focus"
        });
      }
    };
    this.stop = function () {
      _this.stopRender(loop);
      _this.destroy();
    };
  });
  Class(function TimelineObjectLink(_object, _scene, _layer) {
    Inherit(this, Object3D);
    const _this = this;
    this.lerp = 1;
    var _v3 = new Vector3();
    const DEBUG = Hydra.LOCAL;
    const STANDARD = ["position", "rotation", "scale"];
    function onMessage({
      layers: layers,
      force: force
    }) {
      if (!_this.group.determineVisible() && !force) {
        return false;
      }
      if (_this.lerp != null) {
        _this.lerp = TimelineOSC.lerp || 1;
      }
      for (let i = 0; i < layers.length; i++) {
        let e = layers[i];
        if (e.scene.includes(_scene) && e.layer == _layer) {
          if (e.type != "i") {
            if (_object.uniforms) {
              let uniform = _object.uniforms[e.param];
              if (uniform) {
                switch (e.type) {
                  case "f":
                    if (typeof uniform.value != "number") {
                      if (DEBUG) {
                        console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got float but not a float`);
                      }
                      continue;
                    }
                    if (_this.lerp == 1 || _this.lerp == null) {
                      uniform.value = e.value;
                    } else {
                      uniform.value = Math.lerp(e.value, uniform.value, _this.lerp, false);
                    }
                    break;
                  case "v2":
                  case "v3":
                  case "v4":
                    if (!uniform.value.fromArray) {
                      if (DEBUG) {
                        console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got vector but not a vector`);
                      }
                      continue;
                    }
                    if (_this.lerp == 1 || _this.lerp == null) {
                      uniform.value.fromArray(e.value);
                    } else {
                      let v = e.type == "v2" ? _v2 : e.type == "v3" ? _v3 : _v4;
                      v.fromArray(e.value);
                      uniform.value.lerp(v, _this.lerp, false);
                    }
                    break;
                  case "c":
                    if (!uniform.value.setStyle) {
                      if (DEBUG) {
                        console.warn(`Type mismatch on ${scene} ${e.layer} :: ${e.param} -- got color but not a color`);
                      }
                      continue;
                    }
                    if (_this.lerp == 1 || _this.lerp == null) {
                      uniform.value.setStyle(e.value);
                    } else {
                      _color.setStyle(e.value);
                      uniform.value.lerp(_color, _this.lerp, false);
                    }
                }
                if (_object.ubo) {
                  _object.ubo.needsUpdate = true;
                }
              }
            } else if (e.param.includes(STANDARD)) {
              let mesh = _object[e.param];
              if (!mesh) {
                if (DEBUG) {
                  console.warn(`${_layer}::${e.layer} doesn't have param ${e.param}`);
                }
                continue;
              }
              if (_this.lerp == 1 || _this.lerp == null) {
                mesh.fromArray(e.value);
                if (e.param == "position" || e.param == "rotation") {
                  mesh.z *= -1;
                }
              } else {
                _v3.fromArray(e.value);
                if (e.param == "position" || e.param == "rotation") {
                  _v3.z *= -1;
                }
                mesh.lerp(_v3, _this.lerp, false);
              }
            } else {
              _object[e.param] = e.value;
            }
          } else {
            let lastVal = _object[e.param];
            _object[e.param] = !!e.value;
            if (_object[e.param] != lastVal) {
              _this.events.fire(TimelineLayoutLink.TOGGLE, {
                param: e.param,
                layer: _object,
                value: !!e.value
              });
            }
          }
        }
      }
      if (_this.onFrame) {
        _this.onFrame();
      }
    }
    _this.events.sub(TimelineOSC, Events.UPDATE, onMessage);
  });
  Class(function TimelinePlayback(_name) {
    Inherit(this, Component);
    const _this = this;
    var _osc;
    var _fps;
    (async function () {
      let config = InputUIL.create("TimelinePlayback_" + _name);
      config.add("json");
      config.add("fps", 60);
      let json = config.get("json");
      if (!json) {
        return;
      }
      if (json.includes("()")) {
        json = eval(json);
      }
      let prefix = "assets/data/";
      if (json.includes("http")) {
        prefix = "";
      }
      await TimelineOSC.load(_name, `${prefix}${json}`);
      _this.flag("loaded", true);
      config.addButton("actions", {
        label: "Actions",
        actions: [{
          title: "Play",
          callback: _this.play
        }, {
          title: "Pause",
          callback: _this.pause
        }]
      });
      config.addRange("Scrub", 0, {
        min: 0,
        max: 1,
        step: 0.0005
      });
      config.onUpdate = key => {
        if (key == "Scrub") {
          let value = config.getNumber("Scrub");
          _this.seek(value);
        }
      };
      _fps = config.get("fps");
      if (typeof _fps == "string" && _fps.includes("()")) {
        _fps = eval(_fps);
      }
      _fps = Number(_fps);
      if (!isFinite(_fps)) {
        _fps = 60;
      }
    })();
    this.play = async function () {
      let promise = Promise.create();
      await _this.ready();
      if (_osc) {
        _osc.resume();
      } else {
        _osc = TimelineOSC.play(_name, _fps);
        _this.events.sub(_osc, Events.COMPLETE, _ => {
          _osc = null;
          promise.resolve();
          _this.events.fire(Events.COMPLETE, _name);
        });
        _this.events.bubble(_osc, Events.UPDATE);
        _this.osc = _osc;
      }
      return promise;
    };
    this.kill = async function () {
      await _this.ready();
      if (_osc) {
        TimelineOSC.stop(_name);
      }
    };
    this.pause = async function () {
      await _this.ready();
      if (_osc) {
        _osc.pause();
      }
    };
    this.ready = function () {
      return this.wait("loaded");
    };
    this.seek = function (percent) {
      if (!_osc) {
        _osc = TimelineOSC.play(_name, _fps);
        _this.events.sub(_osc, Events.COMPLETE, _ => {
          _osc = null;
          _this.events.fire(Events.COMPLETE, {
            name: _name
          });
        });
        _osc.pause();
        _this.osc = _osc;
      }
      _osc.seek(percent);
    };
  });
  Class(function Track() {
    Inherit(this, Model);
    const DEBUG = Utils.query("debug");
    function getAnalyticsType() {
      if (Config.SERVICES?.analytics) {
        return "firebase_analytics";
      } else if (window.gtag && Config.ANALYTICS_ID.includes("UA-") || window.gtag && Config.ANALYTICS_ID.includes("G-")) {
        return "google_analytics_4";
      } else if (window.dataLayer) {
        return "google_tag_manager";
      } else {
        return null;
      }
    }
    this.page = function (path, title) {
      let data = {
        page_title: title || null,
        page_path: path || null
      };
      switch (getAnalyticsType()) {
        case "google_analytics_4":
          gtag("event", "page_view", data);
          break;
        case "universal_analytics":
          gtag("config", Config.ANALYTICS_ID, data);
          break;
        case "firebase_analytics":
          PlatformAnalytics.event("page_view", data);
          break;
        case "google_tag_manager":
          dataLayer.push(data);
      }
      if (DEBUG) {
        if (!Config.ANALYTICS_ID) {
          console.warn("Config.ANALYTICS_ID required");
        }
        console.log(`>>> Track Page [${getAnalyticsType()}]: `, data);
      }
    };
    this.event = function (category, params, label, action, value) {
      let gtag_action;
      let data = {
        event: "event",
        event_category: category || null,
        event_action: action || null,
        event_label: label || null,
        value: value || null
      };
      data = {
        ...data,
        ...params
      };
      switch (getAnalyticsType()) {
        case "google_analytics_4":
          gtag_action = category;
          if (action) {
            gtag_action += `_${action}`;
          }
          if (label) {
            gtag_action += `_${label}`;
          }
          gtag("event", gtag_action, data);
          break;
        case "universal_analytics":
          gtag("config", Config.ANALYTICS_ID, data);
          break;
        case "firebase_analytics":
          let props = {};
          if (label) {
            props.label = label;
          }
          if (value) {
            props.value = value;
          }
          PlatformAnalytics.event(`${category}_${action}`, props);
          break;
        case "google_tag_manager":
          dataLayer.push(data);
      }
      if (DEBUG) {
        if (gtag_action) {
          console.log(`>>> Track Event: [${getAnalyticsType()}]: `, `action: ${gtag_action}`, data);
        } else {
          console.log(`>>> Track Event [${getAnalyticsType()}]: `, gtag_action, data);
        }
      }
    };
  }, "Static");
  Class(function UIL() {
    Inherit(this, Component);
    const _this = this;
    let _style;
    let $el;
    let _ui = {};
    Hydra.ready(async _ => {
      if (!Utils.query("editMode") && (!Hydra.LOCAL || !window.Platform || !window.Platform.isDreamPlatform || !Utils.query("uil")) && (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !Utils.query("uil") && !Device.detect("hydra"))) {
        return function doNotLoad() {
          if (Hydra.LOCAL && Utils.query("remoteUIL")) {
            _this.sidebar = _this.global = new UILPanel("null");
          }
        }();
      }
      (function init() {
        (function initContainer() {
          $el = $("UIL");
          $el.css({
            position: "fixed",
            contain: "strict"
          }).size("100%", "100%").mouseEnabled(false);
          document.body.insertAdjacentElement("beforeend", $el.div);
          $el.setZ(100000);
        })();
        (function initStyle() {
          let initial = "\n            .UIL ::-webkit-scrollbar { width:2px; }\n            .UIL ::-webkit-scrollbar-track { background:#161616; }\n            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }\n        ";
          let style = document.head.appendChild(document.createElement("style"));
          style.type = "text/css";
          style.id = "uil-style";
          style.appendChild(document.createTextNode(initial));
          _style = style;
        })();
        (function initSidebar() {
          _this.add(new UILPanel("sidebar"));
          _this.add(new UILPanel("global", {
            side: "left"
          }));
        })();
        (function initGraph() {
          if (!_this.sidebar) {
            return;
          }
          let parent = _ui.sidebar.element.div;
          parent.insertBefore(UILGraph.instance().element.div, parent.firstChild);
        })();
      })();
      _this.loaded = true;
    });
    this.ready = function () {
      return _this.wait(_this, "loaded");
    };
    this.add = function (panel) {
      _ui[panel.id] = panel;
      _this[panel.id] = panel;
      $el.add(panel);
      return _this;
    };
    this.remove = function (id) {
      let $panel = _ui[id];
      if ($panel.eliminate) {
        $panel.eliminate();
      }
      $panel.destroy();
      delete _ui[id];
      delete _this[id];
      return _this;
    };
    this.find = function (id) {
      return Object.values(_ui).reduce((acc, el) => acc.concat(el.find(id)), []);
    };
    this.enableSorting = function (id, enable) {
      let el = _this.find(id)[0];
      if (el && el.enableSorting) {
        el.enableSorting(enable);
      }
      return _this;
    };
    this.addCSS = function (control, style) {
      if (control.styled) {
        return;
      }
      let node = document.createTextNode(style);
      if (_style) {
        _style.appendChild(node);
      }
      control.styled = true;
      return _this;
    };
    this.REORDER = "uil_reorder";
  }, "static");
  Class(function CameraUIL() {
    this.UPDATE = "camera_uil_update";
    this.add = function (light, group) {
      return new CameraUILConfig(light, group === null ? null : group || UIL.global);
    };
  }, "static");
  Class(function CameraUILConfig(_camera, _uil) {
    const _this = this;
    if (!_camera.prefix) {
      throw "camera.prefix required when using MeshUIL";
    }
    var prefix = "CAMERA_" + _camera.prefix;
    var _group = _uil ? createFolder() : null;
    var _dynamicFOVCallback = null;
    function createFolder() {
      if (!UIL.sidebar) {
        return null;
      }
      let folder = new UILFolder(prefix, {
        label: _camera.prefix,
        closed: true
      });
      _uil.add(folder);
      return folder;
    }
    function initFOV(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        number.onFinishChange(e => {
          if (_group) {
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              fov: true,
              group: _this
            });
          }
          _camera.setFOV(e);
          UILStorage.set(`${prefix}${key}`, e);
        });
        _group.add(number);
      }
      defer(_ => {
        _camera.setFOV(initValue);
      });
    }
    function initVec(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _camera[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        vector.onChange(e => {
          if (_group) {
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              vec: true,
              group: _this
            });
            _this["tweenUIL_" + key]?.(e);
          }
          _camera[key].fromArray(e);
        });
        vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(vector);
        _this["forceUpdate" + key.toUpperCase()] = _ => {
          let val = _camera[key].toArray();
          if (_this["tweenUIL_" + key]) {
            _this["tweenUIL_" + key](val);
          } else {
            vector.force(_camera[key].toArray(), true);
          }
        };
      }
      _camera[key].fromArray(initValue);
    }
    function initNumber(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || (_camera[key] === undefined ? 9999 : _camera[key]);
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        number.onChange(e => {
          _camera[key] = e;
          if (_group) {
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              number: true,
              group: _this
            });
          }
        });
        number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(number);
      }
      _camera[key] = initValue;
    }
    function initRotation() {
      let key = "rotation";
      let toRadians = array => array ? (array.length = 3, array.map(x => Math.radians(x))) : [0, 0, 0];
      let initValue = toRadians(UILStorage.get(`${prefix}${key}`));
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: (array = initValue, array ? (array.length = 3, array.map(x => Math.degrees(x))) : [0, 0, 0])
        });
        vector.onChange(e => {
          if (_group) {
            Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: toRadians(e),
              rotation: true,
              group: _this
            });
          }
          _camera.group[key].fromArray(toRadians(e));
        });
        vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(vector);
      }
      var array;
      _camera.group[key].fromArray(initValue);
    }
    function initDynamicFOV(key) {
      let defaultCode = "";
      let code = UILStorage.get(`${prefix}${key}Code`) || defaultCode;
      let evalCode = value => {
        let method = value.includes("return") ? `(function(){ return function getFOV() { ${value}}})()` : `(function(){ return function getFOV() { return ${value}}})()`;
        _camera._getDynamicFOV = eval(method);
      };
      let editCode = _ => {
        let editor = new UILExternalEditor(`${prefix}${key}`, 400, 900);
        editor.setCode(code, "c");
        editor.onSave = value => {
          UILStorage.set(`${prefix}${key}Code`, value);
          evalCode(value);
          code = value;
          _camera.dynamicFOV();
        };
      };
      let btn = new UILControlButton("btn", {
        actions: [{
          title: "Dynamic FOV",
          callback: editCode
        }],
        hideLabel: true
      });
      if (_group) {
        _group.add(btn);
      }
      defer(_ => {
        evalCode(code);
        _camera.dynamicFOV = _ => {
          let fov = _camera._getDynamicFOV?.() || _camera.camera.fov;
          if (isNaN(fov)) {
            return console.warn(`${prefix} Dynamic FOV requires a float value`);
          }
          _camera.setFOV(fov);
        };
        _camera.onResize(_ => _camera.dynamicFOV());
      });
    }
    function addListeners() {
      Events.emitter._addEvent(CameraUIL.UPDATE, update, _this);
    }
    function update(e) {
      if (e.prefix == prefix && e.group != _this) {
        if (e.fov) {
          _camera.setFOV(e.val);
        }
        if (e.number) {
          _camera[e.key] = e.val;
        }
        if (e.rotation) {
          _camera.group[e.key].fromArray(e.val);
        }
        if (e.vec) {
          _camera[e.key].fromArray(e.val);
        }
      }
    }
    if (_camera.position) {
      initVec("position");
    }
    if (_camera.group) {
      _camera.groupPos = _camera.group.position;
      initVec("groupPos");
      initRotation();
    }
    initFOV("fov");
    if (_camera.moveXY) {
      initVec("moveXY");
      initVec("lookAt");
      initNumber("lerpSpeed");
      initNumber("lerpSpeed2");
      initNumber("deltaRotate");
      initNumber("deltaLerp");
      initNumber("wobbleSpeed");
      initNumber("wobbleStrength");
      initNumber("wobbleZ");
    }
    initDynamicFOV("dynamicFOV");
    if (_group) {
      addListeners();
    }
    this.setLabel = function (name) {
      if (_group) {
        _group.setLabel(name);
      }
    };
  });
  Class(function InputUIL() {
    this.UPDATE = "inputUil_Update";
    this.create = function (name, group, decoupled) {
      return new InputUILConfig(name, group === null ? null : group || UIL.global, decoupled);
    };
  }, "static");
  Class(function InputUILConfig(_name, _uil, _decoupled, _slim) {
    var _cache;
    var _this = this;
    const prefix = "INPUT_" + _name;
    var _group = _uil ? function createFolder() {
      if (!UIL.sidebar) {
        return null;
      }
      let folder = new UILFolder(_name, {
        closed: true
      });
      if (!_decoupled) {
        _uil.add(folder);
        if (_uil == UIL.sidebar) {
          folder.hide();
        }
      }
      return folder;
    }() : null;
    var _fields = _uil ? {} : null;
    function externalUpdate(e) {
      if (e.prefix == prefix && e.group != _this) {
        UILStorage.set(`${prefix}_${e.key}`, e.value);
        if (_this.onUpdate) {
          _this.onUpdate(e.key);
        }
      }
    }
    _this.group = _group;
    if (_uil) {
      (function addListeners() {
        Events.emitter._addEvent(InputUIL.UPDATE, externalUpdate, _this);
      })();
    }
    this.get = function (key) {
      if (_cache && _cache[key] !== undefined) {
        return _cache[key];
      }
      let val = UILStorage.get(`${prefix}_${key}`);
      if (typeof val == "boolean") {
        return val;
      } else if (val && val != "") {
        return val === "true" || val !== "false" && (val.charAt && val.charAt(0) == "[" ? JSON.parse(val) : (UIL.global || (_cache ||= {}, _cache[key] ||= val), val));
      } else {
        return undefined;
      }
    };
    this.getFilePath = function (key) {
      let data = this.get(key);
      if (data?.charAt(0) === "{") {
        data = JSON.parse(data);
        if (data.relative.includes(".")) {
          return data.relative;
        } else {
          return data.src;
        }
      } else {
        return data;
      }
    };
    this.getNumber = function (key) {
      return Number(this.get(key));
    };
    if (!_slim) {
      this.add = function (key, initValue, uil = window.UILControlText, options, params = {}) {
        if (!_group || initValue == "hidden" || !UIL.sidebar) {
          return this;
        }
        let value = UILStorage.get(`${prefix}_${key}`);
        if (value === "true") {
          value = true;
        }
        if (value === "false") {
          value = false;
        }
        if (uil == UILControlVector && typeof value == "string") {
          value = JSON.parse(value);
        }
        if (value === undefined) {
          value = initValue;
        }
        if (typeof value == "string" && (uil == UILControlImage || uil == UILControlFile)) {
          try {
            value = JSON.parse(value);
          } catch (e) {}
        }
        let change = (val, fromInit) => {
          val = typeof val == "string" ? val : JSON.stringify(val);
          UILStorage.set(`${prefix}_${key}`, val);
          if (_this.onUpdate) {
            _this.onUpdate(key, val);
          }
          if (!fromInit) {
            Events.emitter._fireEvent(InputUIL.UPDATE, {
              prefix: prefix,
              key: key,
              value: val,
              group: _this
            });
          }
        };
        if ((typeof initValue == "string" || typeof initValue == "number" || uil == UILControlVector) && !UILStorage.get(`${prefix}_${key}`)) {
          change(initValue, true);
        }
        let opts = Utils.mergeObject(params, {
          label: key,
          value: value,
          options: options
        });
        if (uil == window.UILControlButton) {
          opts = options;
        }
        let config = new uil(`${prefix}_${key}`, opts);
        config.onFinishChange(change);
        if (uil == UILControlVector || uil == UILControlRange) {
          config.onChange(change);
        }
        _group.add(config);
        _fields[key] = config;
        return this;
      };
      this.addToggle = function (key, initValue) {
        if (UIL.sidebar) {
          return this.add(key, initValue, UILControlCheckbox);
        } else {
          return this;
        }
      };
      this.addSelect = function (key, options) {
        if (UIL.sidebar) {
          return this.add(key, null, UILControlSelect, options);
        } else {
          return this;
        }
      };
      this.addImage = function (key, options) {
        if (UIL.sidebar) {
          return this.add(key, null, UILControlImage, null, options);
        } else {
          return this;
        }
      };
      this.addFile = function (key, options) {
        if (!UIL.sidebar) {
          return this;
        }
        let existing = this.get(key);
        if (existing?.length > 3 && !existing.includes("{")) {
          return this.add(key);
        } else {
          return this.add(key, null, UILControlFile, null, options);
        }
      };
      this.addRange = function (key, initValue, options) {
        if (UIL.sidebar) {
          return this.add(key, initValue, UILControlRange, null, options);
        } else {
          return this;
        }
      };
      this.addNumber = function (key, initValue, step) {
        if (UIL.sidebar) {
          return this.add(key, initValue, UILControlNumber, null, {
            step: step
          });
        } else {
          return this;
        }
      };
      this.addColor = function (key, initValue = new Color()) {
        if (UIL.sidebar) {
          return this.add(key, initValue.getHexString(), UILControlColor);
        } else {
          return this;
        }
      };
      this.addTextarea = function (key, initValue) {
        if (UIL.sidebar) {
          return this.add(key, initValue, UILControlTextarea, null, {
            monospace: true,
            rows: 4
          });
        } else {
          return this;
        }
      };
      this.addButton = function (key, options) {
        if (UIL.sidebar) {
          return this.add(key, null, UILControlButton, options);
        } else {
          return this;
        }
      };
      this.addVector = function (key, initValue, options) {
        if (UIL.sidebar) {
          options ||= {
            step: 0.05
          };
          return this.add(key, initValue, UILControlVector, null, options);
        } else {
          return this;
        }
      };
      this.getImage = function (key) {
        let data = this.get(key);
        if (data) {
          return JSON.parse(data).src;
        }
      };
      this.setValue = function (key, value) {
        UILStorage.set(`${prefix}_${key}`, value);
        if (_this.onUpdate) {
          _this.onUpdate(key);
        }
        if (_fields) {
          let field = _fields[key];
          if (field) {
            field.value = value;
            if (field.update) {
              field.update();
            }
          }
        }
        return this;
      };
      this.copyFrom = function (input, fields) {
        fields.forEach(key => {
          let val = input.get(key);
          if (val !== undefined) {
            if (typeof val != "string") {
              val = JSON.stringify(val);
            }
            _this.setValue(key, val);
          }
        });
      };
      this.setLabel = function (name) {
        if (_group) {
          _group.setLabel(name);
        }
      };
      this.getField = function (key) {
        if (_fields) {
          return _fields[key];
        }
      };
    }
  });
  Class(function ListUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;
    var _created = {};
    function removePanel() {
      if (_panel && _panel.destroy) {
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
      }
    }
    this.create = function (id, version = 1, group) {
      if (typeof version != "number") {
        group = version;
        version = 1;
      }
      group = group === null ? null : group || UIL.global;
      let config = new ListUILConfig(id, version, UIL.global && !_created[id]);
      if (UIL.global) {
        if (!_created[id]) {
          _created[id] = config;
          if (group != null) {
            config.appendUILGroup(group || UIL.global);
          }
        }
      }
      return config;
    };
    this.openPanel = function (id, name, template) {
      removePanel();
      _panel = new ListUILEditor(id, name, template);
      _this.events.sub(_panel, Events.COMPLETE, removePanel);
      return _panel;
    };
    this.set = function () {};
    this.get = function () {};
    this.getPanel = function () {
      return _panel;
    };
  }, "static");
  Class(function ListUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items;
    var _folder;
    var _config;
    var _template = {
      onSort: _ => {},
      onAdd: _ => {},
      onRemove: _ => {}
    };
    var _name = "";
    function name() {
      return `LIST_${_id}_config`;
    }
    function updateConfig() {
      _config.version = _version;
      UILStorage.setWrite(name(), _config);
    }
    function edit() {
      let panel = ListUIL.openPanel(_id, _name, _this.template);
      _this.events.bubble(panel, Events.UPDATE);
      _this.events.fire(ListUIL.OPEN);
    }
    if (_store) {
      _items = [];
    }
    (function initConfig() {
      if (_config = UILStorage.get(name())) {
        if (_config.version != _version) {
          updateConfig();
          UILStorage.clearMatch(name().split("_config")[0]);
        }
      } else {
        _config = {};
        updateConfig();
      }
    })();
    this.add = function (item) {
      if (_items) {
        _items.push(item);
      }
      return item;
    };
    this.template = function (config) {
      if (typeof config == "function") {
        _template = config;
      }
      return _template;
    };
    this.appendUILGroup = function (uil) {
      let folder = new UILFolder("LIST_" + _id, {
        closed: true
      });
      let button = new UILControlButton("button", {
        actions: [{
          title: "Edit List",
          callback: edit
        }],
        hideLabel: true
      });
      folder.add(button);
      uil.add(folder);
      _folder = folder;
    };
    this.setLabel = function (name) {
      if (_folder) {
        _folder.setLabel(name);
      }
      _name = name;
    };
    this.onAdd = function (cb) {
      _template.onAdd = cb;
    };
    this.onRemove = function (cb) {
      _template.onRemove = cb;
    };
    this.onSort = function (cb) {
      _template.onSort = cb;
    };
    this.internalAddItems = function (count) {
      if (!count) {
        return;
      }
      let array = [];
      for (let i = 0; i < count; i++) {
        let id = `${_id}_${Utils.timestamp()}`;
        array.push(id);
      }
      UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    };
  }, _ => {
    ListUIL.OPEN = "list_uil_open";
  });
  Class(function ListUILEditor(_id, _name, _template) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = {
      label: _name || "List",
      width: "400px",
      height: "auto",
      drag: true
    };
    var _gui;
    var _list;
    var _add;
    var _items;
    var _tabs = [];
    var _index = 0;
    function initList() {
      (function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if (data === undefined) {
          data = "[]";
        }
        _items = JSON.parse(data);
      })();
      (_list = new UILFolder(`${_id}_list`, {
        hideTitle: true
      })).enableSorting(_id);
      _gui.add(_list);
      for (let id of _items) {
        let view = new ListUILItem(id, _list, _template, _index++);
        _this.events.sub(view, Events.UPDATE, reorder);
        _this.events.sub(view, Events.END, remove);
        _tabs.push(view);
      }
    }
    function initAdd() {
      (function initButton(title, callback) {
        _add = new UILControlButton("button", {
          actions: [{
            title: title,
            callback: callback
          }],
          hideLabel: true
        });
        _gui.add(_add);
      })("Add Item", add);
    }
    function add() {
      let id = `${_id}_${Utils.timestamp()}`;
      let view = new ListUILItem(id, _list, _template, _index++);
      _this.events.sub(view, Events.UPDATE, reorder);
      _this.events.sub(view, Events.END, remove);
      _tabs.push(view);
      _items.push(id);
      write();
    }
    function reorder(e) {
      let order = [];
      for (let item of e.order) {
        order.push(item.split("_folder")[0]);
      }
      _items = order;
      _template().onSort(_items);
      write();
      _this.events.fire(Events.UPDATE, {
        order: order
      });
    }
    function close() {
      _this.events.fire(Events.COMPLETE);
    }
    function remove(e) {
      _items.remove(e.id);
      write();
      refresh();
    }
    function write() {
      let data = JSON.stringify(_items);
      UILStorage.set(`${_id}_list_items`, data);
    }
    function refresh() {
      _index = 0;
      if (_list && _list.destroy) {
        _list = _list.destroy();
      }
      if (_add && _add.destroy) {
        _add = _add.destroy();
      }
      initList();
      initAdd();
    }
    (function initPanel() {
      _this.gui = _gui = new UILWindow(_id, PANEL_CONFIG);
      _this.gui.onClose = close;
      UIL.add(_gui);
    })();
    refresh();
    this.onDestroy = function () {
      _gui.destroy();
    };
    this.add = function () {
      add();
    };
  });
  Class(function ListUILItem(_id, _parent, _template, _index) {
    Inherit(this, Component);
    const _this = this;
    var _folder;
    function onDelete() {
      if (!confirm("You sure you want to delete this?")) {
        return;
      }
      let id = _id;
      _template().onRemove(id);
      _this.events.fire(Events.END, {
        id: id
      });
    }
    function onReorder(e) {
      _this.events.fire(Events.UPDATE, e);
    }
    (async function initFolder() {
      (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item");
      _folder.group.draggable(true);
      _this.events.sub(_folder.group, UIL.REORDER, onReorder);
      _folder.listUILItem = _this;
    })();
    (function initTemplate() {
      let id = _id;
      (0, _template().onAdd)(id, _folder, _index);
    })();
    (function initUI() {
      let actions = [{
        title: "Delete",
        callback: onDelete
      }];
      let hideLabel = true;
      _folder.addButton("delete", {
        actions: actions,
        hideLabel: hideLabel
      });
    })();
    this.setLabel = function (label) {
      _folder.setLabel(label);
    };
    this.forceSort = function (index) {
      _folder.group.forceSort(index);
    };
    this.open = function () {
      _folder.group.open();
      _folder.group.openChildren();
    };
    this.close = function () {
      _folder.group.close();
    };
  });
  Class(function MeshUIL() {
    Inherit(this, Component);
    this.exists = {};
    this.UPDATE = "mesh_uil_update";
    this.add = function (mesh, group) {
      return new MeshUILConfig(mesh, group === null ? null : group || UIL.global);
    };
  }, "static");
  Class(function MeshUILConfig(_mesh, _uil) {
    const _this = this;
    if (!_mesh.prefix) {
      throw "mesh.prefix required when using MeshUIL";
    }
    var prefix = "MESH_" + _mesh.prefix;
    var _group = _uil && !MeshUIL.exists[prefix] ? function createFolder() {
      if (!UIL.sidebar) {
        return null;
      }
      let folder = new UILFolder(prefix, {
        label: _mesh.prefix,
        closed: true
      });
      _uil.add(folder);
      return folder;
    }() : null;
    var _controls = _group ? {} : null;
    function initVec(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        vector.onChange(e => {
          _mesh[key].fromArray(e);
          if (_group) {
            Events.emitter._fireEvent(MeshUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              group: _this
            });
            _this["tweenUIL_" + key]?.(e);
          }
        });
        vector.onFinishChange(save);
        _group.add(vector);
        _this["forceUpdate" + key.toUpperCase()] = _ => {
          let val = _mesh[key].toArray();
          if (_this["tweenUIL_" + key]) {
            _this["tweenUIL_" + key](val);
          } else {
            vector.force(_mesh[key].toArray(), true);
          }
        };
        _controls[key] = vector;
      }
      _mesh[key].fromArray(initValue);
    }
    function save() {
      for (let key in _controls) {
        let value = _controls[key].value;
        UILStorage.set(`${prefix}${key}`, value);
      }
    }
    function update(e) {
      if (e.prefix == prefix && e.group != _this) {
        _mesh[e.key].fromArray(e.val);
      }
    }
    this.group = _group;
    MeshUIL.exists[prefix] = true;
    initVec("position");
    initVec("scale");
    (function initRotation() {
      let key = "rotation";
      let toRadians = array => array ? (array.length = 3, array.map(x => Math.radians(x))) : [0, 0, 0];
      let toDegrees = array => array ? (array.length = 3, array.map(x => Math.degrees(x))) : [0, 0, 0];
      let initValue = toRadians(UILStorage.get(`${prefix}${key}`));
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: toDegrees(initValue)
        });
        vector.onChange(e => {
          _mesh[key].fromArray(toRadians(e));
          if (_group) {
            Events.emitter._fireEvent(MeshUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: toRadians(e),
              group: _this
            });
            _this["tweenUIL_" + key]?.(e);
          }
        });
        vector.onFinishChange(save);
        _group.add(vector);
        _controls[key] = vector;
      }
      _mesh[key].fromArray(initValue);
      let rotationEuler = new Euler().fromArray(initValue);
      _mesh.customRotation = new Quaternion().setFromEuler(rotationEuler);
    })();
    if (_group) {
      (function addListeners() {
        Events.emitter._addEvent(MeshUIL.UPDATE, update, _this);
      })();
    }
    this.setLabel = function (name) {
      if (_group) {
        _group.setLabel(name);
      }
    };
  });
  Class(function ShaderUIL() {
    this.exists = {};
    this.UPDATE = "shader_update";
    this.TEXTURE_UPDATE = "shader_texture_update";
    this.SHADER_UPDATE = "shader_shader_update";
    this.add = function (shader, group) {
      return new ShaderUILConfig(shader.shader || shader, group === null ? null : group || UIL.global);
    };
    this.createOverride = function (prefix, obj, group, shaderOnly) {
      let uniforms = {};
      if (Array.isArray(obj)) {
        obj.forEach(o => {
          o = o.uniforms || o;
          for (let key in o) {
            if (!o[key].ignoreUIL) {
              uniforms[key] = o[key];
            }
          }
        });
      } else {
        uniforms = obj.uniforms || obj;
      }
      let shader = Utils3D.getTestShader();
      shader.vetexShader = shader.fragmentShader = "";
      for (let key in uniforms) {
        shader.uniforms[key] = uniforms[key];
      }
      shader.UILPrefix = prefix;
      if (shaderOnly === null) {
        return shader;
      } else {
        return this.add(shader, group);
      }
    };
    this.createDecorator = function (shader, prefix, obj, group) {
      let uniforms = {};
      for (let key in obj) {
        uniforms[key] = shader.uniforms[key];
      }
      let nShader = Utils3D.getTestShader();
      nShader.vetexShader = shader.fragmentShader = "";
      nShader.uniforms = uniforms;
      nShader.UILPrefix = prefix;
      return this.add(nShader, group);
    };
    this.createClone = function (prefix, obj) {
      let uniforms = obj.uniforms || obj;
      let shader = Utils3D.getTestShader();
      for (let key in uniforms) {
        let value = uniforms[key].value;
        let ignoreUIL = uniforms[key].ignoreUIL || value === null;
        if (!ignoreUIL && value.clone) {
          value = value.clone();
        }
        shader.uniforms[key] = {
          value: value,
          ignoreUIL: ignoreUIL
        };
      }
      shader.UILPrefix = prefix;
      return shader;
    };
    this.lerpShader = function (from, to, alpha, hz, uniformsFilter) {
      from = from.uniforms || from;
      to = to.uniforms || to;
      for (let key in from) {
        let f = from[key];
        let t = to[key];
        if (f && t) {
          if (!uniformsFilter || uniformsFilter.indexOf(key) !== -1) {
            if (typeof t.value == "number") {
              f.value = Math.lerp(t.value, f.value, alpha, hz);
            } else if (f.type === "c") {
              f.value.r = Math.lerp(t.value.r, f.value.r, alpha, hz);
              f.value.g = Math.lerp(t.value.g, f.value.g, alpha, hz);
              f.value.b = Math.lerp(t.value.b, f.value.b, alpha, hz);
            } else if (f.type === "v3") {
              f.value.x = Math.lerp(t.value.x, f.value.x, alpha, hz);
              f.value.y = Math.lerp(t.value.y, f.value.y, alpha, hz);
              f.value.z = Math.lerp(t.value.z, f.value.z, alpha, hz);
            }
          }
        }
      }
    };
  }, "static");
  Class(function ShaderUILConfig(_shader, _uil) {
    var _textures;
    var _this = this;
    const prefix = _shader.UILPrefix;
    var _group = _uil && !ShaderUIL.exists[prefix] ? function createFolder() {
      if (!UIL.sidebar) {
        return null;
      }
      let label = function getName() {
        let split = _shader.UILPrefix.split("/");
        if (split.length > 2) {
          return split[0] + "_" + split[2];
        } else {
          return split[0];
        }
      }();
      if (label.charAt(label.length - 1) == "_") {
        label = label.slice(0, -1);
      }
      let folder = new UILFolder(prefix + label, {
        label: label,
        closed: true
      });
      _uil.add(folder);
      return folder;
    }() : null;
    function createVector(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
          description: obj.description
        });
        vector.onChange(val => {
          obj.value.fromArray(val);
          if (_shader.ubo) {
            _shader.ubo.needsUpdate = true;
          }
          Events.emitter._fireEvent(ShaderUIL.UPDATE, {
            prefix: prefix,
            key: key,
            val: val,
            group: _this,
            vector: true
          });
        });
        vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(vector);
      }
      obj.value.fromArray(initValue);
    }
    function createTexture(obj, key) {
      if (_group && !_textures) {
        _textures = {};
      }
      const getTexture = obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture;
      const set = _shader.parent && _shader.parent.setOverride ? _shader.parent.setOverride : _shader.set || _shader.setUniform;
      const get = _shader.get || _shader.getUniform;
      let prefix = _shader.UILPrefix + "_tx";
      let data = UILStorage.get(`${prefix}_${key}`);
      data &&= JSON.parse(data);
      let value = data ? data.src : null;
      let change = data => {
        let val = data.src;
        let cleanPath = val.includes("?") && !data.hotreload ? val.split("?")[0] : val;
        if (data.compressed) {
          val += "-compressedKtx";
        }
        if (_textures) {
          _textures[cleanPath] = change;
        }
        data.src = cleanPath;
        UILStorage.set(`${prefix}_${key}`, JSON.stringify(data));
        set(key, getTexture(val, {
          premultiplyAlpha: obj.premultiplyAlpha,
          scale: obj.scale
        }), _shader);
        if (_group) {
          Events.emitter._fireEvent(ShaderUIL.UPDATE, {
            prefix: _shader.UILPrefix,
            key: key,
            val: val,
            texture: get(key, _shader),
            group: _this
          });
        }
      };
      if (value && value.length) {
        change(data);
      }
      if (_group) {
        let img = new UILControlImage(prefix + key, {
          label: key,
          value: data,
          description: obj.description
        });
        img.onFinishChange(change);
        _group.add(img);
      }
    }
    function createNumber(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (initValue === undefined) {
        initValue = obj.value;
      }
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
          description: obj.description
        });
        number.onChange(val => {
          if (_shader.ubo) {
            _shader.ubo.needsUpdate = true;
          }
          Events.emitter._fireEvent(ShaderUIL.UPDATE, {
            prefix: prefix,
            key: key,
            val: val,
            group: _this
          });
          obj.value = val;
        });
        number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(number);
      }
      obj.value = initValue;
    }
    function createColor(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.getHexString();
      if (_group) {
        let color = new UILControlColor(`${prefix}${key}`, {
          label: key,
          value: initValue,
          description: obj.description
        });
        color.onChange(val => {
          obj.value.set(val);
          if (_shader.ubo) {
            _shader.ubo.needsUpdate = true;
          }
          if (_group) {
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              color: true,
              group: _this
            });
          }
        });
        color.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(color);
      }
      if (initValue) {
        obj.value.set(initValue);
      }
    }
    function createSelect(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (_group) {
        let {
          options: options,
          description: description
        } = obj;
        let select = new UILControlSelect(`${prefix}${key}`, {
          label: key,
          value: initValue,
          options: options,
          description: description
        });
        select.onChange(val => {
          if (_group) {
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this
            });
          }
          obj.value = val;
          UILStorage.set(`${prefix}${key}`, val);
        });
        _group.add(select);
      }
      if (initValue) {
        obj.value = initValue;
      }
    }
    function textureUpdate(e) {
      if (!_textures) {
        return;
      }
      let cleanPath = e.file.split("?")[0];
      for (let key in _textures) {
        if (cleanPath == (key.includes("?") ? key.split("?")[0] : key)) {
          _textures[key]({
            src: e.file,
            hotreload: true
          });
        }
      }
    }
    function update(e) {
      if (e.prefix == _shader.UILPrefix && e.group != _this) {
        if (e.color) {
          let val = e.val;
          let obj = _shader.uniforms[e.key];
          if (Array.isArray(val)) {
            obj.value.setRGB(val[0], val[1], val[2]);
          } else {
            obj.value.set(val);
          }
        } else if (e.texture) {
          if (e.texture != "remote") {
            _shader.set(e.key, e.texture);
          }
        } else if (e.vector) {
          _shader.uniforms[e.key].value.fromArray(e.val);
        } else {
          _shader.uniforms[e.key].value = e.val;
        }
      }
    }
    this.group = _group;
    this.shader = _shader;
    ShaderUIL.exists[_shader.UILPrefix] = true;
    (function initItems() {
      for (var key in _shader.uniforms) {
        let obj = _shader.uniforms[key];
        if (obj && !obj.ignoreUIL) {
          if (obj.options && Array.isArray(obj.options)) {
            createSelect(obj, key);
          } else {
            if (typeof obj.value == "number") {
              createNumber(obj, key);
            }
            if (obj.value instanceof Color) {
              createColor(obj, key);
            }
            if (obj.value === null || obj.value instanceof Texture) {
              createTexture(obj, key);
            }
            if (obj.value instanceof Vector2) {
              createVector(obj, key);
            }
            if (obj.value instanceof Vector3) {
              createVector(obj, key);
            }
            if (obj.value instanceof Vector4) {
              createVector(obj, key);
            }
          }
        }
      }
    })();
    if (_group) {
      (function addListeners() {
        Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this);
        Events.emitter._addEvent(ShaderUIL.TEXTURE_UPDATE, textureUpdate, _this);
      })();
    }
    this.setLabel = function (name) {
      if (_group) {
        _group.setLabel(name);
      }
    };
  });
  Class(function ShadowUIL() {
    this.add = function (light, group) {
      return new ShadowUILConfig(light, group === null ? null : group || UIL.global);
    };
  }, "static");
  Class(function ShadowUILConfig(_light, _uil) {
    if (!_light.prefix) {
      throw "light.prefix required when using MeshUIL";
    }
    var prefix = "SHADOW_" + _light.prefix;
    var _group = _uil ? function createFolder() {
      if (!UIL.sidebar) {
        return null;
      }
      let folder = new UILFolder(prefix, {
        label: _light.prefix,
        closed: true
      });
      _uil.add(folder);
      return folder;
    }() : null;
    function initNumber(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        number.onFinishChange(e => {
          _light.shadow[key] = e;
          UILStorage.set(`${prefix}${key}`, e);
        });
        _group.add(number);
      }
      _light.shadow[key] = initValue;
    }
    function initVec(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05
        });
        vector.onChange(e => {
          _light[key].fromArray(e);
          if (key == "target") {
            _light.shadow.camera.lookAt(_light.target);
          }
        });
        vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
        _group.add(vector);
      }
      _light[key].fromArray(initValue);
    }
    _light.target = _light.shadow.target;
    initVec("position");
    initVec("target");
    initNumber("fov");
    initNumber("size");
    initNumber("area");
    initNumber("near");
    initNumber("far");
    (function initTick(key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (_group) {
        let tick = new UILControlCheckbox(`${prefix}${key}`, {
          label: key,
          value: initValue
        });
        tick.onFinishChange(e => {
          _light[key] = e;
          UILStorage.set(`${prefix}${key}`, e);
        });
        _group.add(tick);
      }
      _light[key] = initValue;
    })("static");
    this.setLabel = function (name) {
      if (_group) {
        _group.setLabel(name);
      }
    };
  });
  Class(function TimelineUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;
    var _created = {};
    function removePanel() {
      if (_panel && _panel.destroy) {
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
      }
    }
    this.create = function (id, version = 1, group) {
      if (typeof version != "number") {
        group = version;
        version = 1;
      }
      group = group === null ? null : group || UIL.global;
      let config = new TimelineUILConfig(id, version, UIL.global && !_created[id]);
      if (UIL.global) {
        if (!_created[id]) {
          _created[id] = config;
          if (group != null) {
            config.appendUILGroup(group || UIL.global);
          }
        }
      }
      return config;
    };
    this.openPanel = function (id, name, template) {
      removePanel();
      _panel = new TimelineUILEditor(id, name, template);
      _this.events.sub(_panel, Events.COMPLETE, removePanel);
      return _panel;
    };
    this.set = function () {};
    this.get = function () {};
  }, "static");
  Class(function TimelineUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items;
    var _folder;
    var _config;
    var _template = {
      onSort: _ => {},
      onAdd: _ => {},
      onRemove: _ => {}
    };
    var _name = "";
    function name() {
      return `TL_${_id}_config`;
    }
    function updateConfig() {
      _config.version = _version;
      UILStorage.setWrite(name(), _config);
    }
    function edit() {
      let panel = TimelineUIL.openPanel(name(), _name, _this.template);
      _this.events.bubble(panel, Events.UPDATE);
      _this.events.fire(TimelineUIL.OPEN);
    }
    this.model = new TimelineUILModel(name());
    if (_store) {
      _items = [];
    }
    (function initConfig() {
      if (_config = UILStorage.get(name())) {
        if (_config.version != _version) {
          updateConfig();
          UILStorage.clearMatch(name().split("_config")[0]);
        }
      } else {
        _config = {};
        updateConfig();
      }
    })();
    this.add = function (item) {
      if (_items) {
        _items.push(item);
      }
      return item;
    };
    this.template = function (config) {
      if (typeof config == "function") {
        _template = config;
      }
      return _template;
    };
    this.appendUILGroup = function (uil) {
      let folder = new UILFolder("TL_" + _id, {
        closed: true
      });
      let button = new UILControlButton("button", {
        actions: [{
          title: "Edit Timeline",
          callback: edit
        }],
        hideLabel: true
      });
      folder.add(button);
      uil.add(folder);
      _folder = folder;
    };
    this.setLabel = function (name) {
      if (_folder) {
        _folder.setLabel(name);
      }
      _name = name;
    };
    this.onAdd = function (cb) {
      _template.onAdd = cb;
    };
    this.onRemove = function (cb) {
      _template.onRemove = cb;
    };
    this.onSort = function (cb) {
      _template.onSort = cb;
    };
    this.internalAddItems = function (count) {
      if (!count) {
        return;
      }
      let array = [];
      for (let i = 0; i < count; i++) {
        let id = `${_id}_${Utils.timestamp()}`;
        array.push(id);
      }
      UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    };
  }, _ => {
    TimelineUIL.OPEN = "list_uil_open";
  });
  Class(function TimelineUILEditor(_id, _name, _template) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = {
      label: "Timeline Editor",
      width: "800px",
      height: "auto",
      drag: true
    };
    var _gui;
    var _list;
    var _add;
    var _config;
    var _items;
    var _tabs = [];
    var _index = 0;
    function initList() {
      (function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if (data === undefined) {
          data = "[]";
        }
        _items = JSON.parse(data);
      })();
      _list = new UILFolder(`${_id}_list`, {
        hideTitle: true
      });
      _gui.add(_list);
      for (let id of _items) {
        let view = _this.initClass(TimelineUILItem, id, _list, _template, _index++);
        _this.events.sub(view, Events.UPDATE, reorder);
        _this.events.sub(view, Events.END, remove);
        _tabs.push(view);
      }
      if (_config.rails) {
        (function attachRails() {
          _tabs.forEach((t, i) => {
            t.onUpdate = v => {
              _tabs.forEach((t2, j) => {
                if (t2 != t) {
                  if (j < i && t.getValue() < t2.getValue()) {
                    t2.setValue(t.getValue());
                  }
                  if (j > i && t.getValue() > t2.getValue()) {
                    t2.setValue(t.getValue());
                  }
                }
              });
            };
          });
        })();
      }
    }
    function initButton(title, callback) {
      let btn = new UILControlButton("button", {
        actions: [{
          title: title,
          callback: callback
        }],
        hideLabel: true
      });
      _gui.add(btn);
      return btn;
    }
    function spaceEvenly() {
      _tabs.forEach((t, i) => {
        let perc = Math.range(i, 0, _tabs.length - 1, 0, 1);
        t.setValue(perc);
      });
    }
    function add() {
      let id = `${_id}_${Utils.timestamp()}`;
      let view = new TimelineUILItem(id, _list, _template, _index++);
      _this.events.sub(view, Events.UPDATE, reorder);
      _this.events.sub(view, Events.END, remove);
      _tabs.push(view);
      _items.push(id);
      write();
    }
    function reorder(e) {
      let order = [];
      for (let item of e.order) {
        order.push(item.split("_folder")[0]);
      }
      _items = order;
      _template().onSort(_items);
      write();
      _this.events.fire(Events.UPDATE, {
        order: order
      });
    }
    function remove(e) {
      _items.remove(e.id);
      write();
      refresh();
    }
    function write() {
      let data = JSON.stringify(_items);
      UILStorage.set(`${_id}_list_items`, data);
    }
    function refresh() {
      _index = 0;
      if (_list && _list.destroy) {
        _list = _list.destroy();
      }
      if (_add && _add.destroy) {
        _add = _add.destroy();
      }
      initList();
      (function initAdd() {
        if (!_config.lock) {
          (_add = initButton("Add Item", add)).element.css({
            width: "20%"
          });
        }
        initButton("Space Evenly", spaceEvenly).element.css({
          width: "20%"
        });
      })();
    }
    _this.config = _config = JSON.parse(UILStorage.get(`${_id}_config`) || "{}");
    (function initPanel() {
      _this.gui = _gui = new UILWindow(_id, PANEL_CONFIG);
      UIL.add(_gui);
    })();
    refresh();
    this.onDestroy = function () {
      _gui.destroy();
    };
  });
  Class(function TimelineUILItem(_id, _parent, _template, _index) {
    Inherit(this, Component);
    const _this = this;
    var _folder;
    function onDelete() {
      if (!confirm("You sure you want to delete this?")) {
        return;
      }
      let id = _id;
      _template().onRemove(id);
      _this.events.fire(Events.END, {
        id: id
      });
    }
    function onReorder(e) {
      _this.events.fire(Events.UPDATE, e);
    }
    (async function initFolder() {
      (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item");
      if (!_this.parent || !_this.parent.config.lock) {
        _folder.group.draggable(true);
      }
      _this.events.sub(_folder.group, UIL.REORDER, onReorder);
      _folder.group.open();
    })();
    (function initTemplate() {
      let id = _id;
      (0, _template().onAdd)(id, _folder, _index);
    })();
    (function initUI() {
      _folder.add("label", _this.parent && _this.parent.config.lock ? "hidden" : undefined);
      _folder.addRange("keyframe");
      _folder.add("percent", "hidden");
      _folder.getField("keyframe").force(Math.round(_folder.getNumber("percent") * 100) || 0);
      _folder.onUpdate = key => {
        if (key == "keyframe") {
          let val = _folder.getNumber(key) / 100;
          _folder.setValue("percent", val);
          if (_this.onUpdate) {
            _this.onUpdate(val);
          }
        }
      };
      let label = _folder.get("label");
      if (label) {
        _folder.setLabel(label);
      }
      if (!_this.parent || !_this.parent.config.lock) {
        let actions = [{
          title: "Delete",
          callback: onDelete
        }];
        let hideLabel = true;
        _folder.addButton("delete", {
          actions: actions,
          hideLabel: hideLabel
        });
        let btn = _folder.getField("delete");
        if (btn) {
          btn.$content.css({
            width: "20%"
          });
        }
      }
    })();
    this.setLabel = function (label) {
      _folder.setLabel(label);
    };
    this.getValue = function (value) {
      return _folder.getNumber("percent");
    };
    this.setValue = function (value) {
      _folder.setValue("percent", value);
      _folder.getField("keyframe").force(Math.round(value * 100) || 0);
    };
  });
  Class(function TimelineUILModel(_id) {
    var _items;
    var _config;
    var _data = [];
    var _map = {};
    (function initItems() {
      _config = JSON.parse(UILStorage.get(`${_id}_config`) || "{}");
      _items = JSON.parse(UILStorage.get(`${_id}_list_items`) || "[]");
    })();
    (function initData() {
      _items.forEach((item, i) => {
        let input = InputUIL.create(`${item}_folder`, null, null, !!UIL.global);
        let data = {};
        data.label = input.get("label") || "Item";
        data.value = input.getNumber("percent") || 0;
        data.arbitrary = input.get("arbitrary");
        _data.push(data);
        _map[data.label] = data;
        if (UIL.global) {
          Render.start(_ => {
            data.label = input.get("label") || "Item";
            data.value = input.getNumber("percent") || 0;
          }, 10);
        }
      });
    })();
    this.setState = function (array) {
      for (let i = 0; i < array.length; i++) {
        if (!_items[i]) {
          _items.push(`${_id}_${Utils.timestamp()}`);
        }
      }
      if (_items.length > array.length) {
        _items = _items.slice(0, array.length);
      }
      _items.forEach((item, i) => {
        let data = array[i];
        let input = InputUIL.create(`${item}_folder`, null);
        input.setValue("label", data.label);
        if (data.percent) {
          input.setValue("percent", data.percent);
        }
        if (data.arbitrary) {
          input.setValue("percent", data.arbitrary);
        }
      });
      UILStorage.set(`${_id}_list_items`, JSON.stringify(_items));
    };
    this.lock = function () {
      if (!_config.lock) {
        _config.lock = true;
        if (UIL.global) {
          UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        }
      }
      return this;
    };
    this.rails = function () {
      if (!_config.rails) {
        _config.rails = true;
        if (UIL.global) {
          UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        }
      }
      return this;
    };
    this.getData = function () {
      return _data;
    };
    this.get = function (key) {
      return _map[key];
    };
  });
  Class(function TweenUIL() {
    var _folders = {};
    var _activeFolder = "Tweens";
    var _cache = {};
    this.TOGGLE = "tweenuil_toggle";
    this.create = function (name, config, group) {
      if (typeof group == "boolean") {
        group = undefined;
      }
      let noCache = false;
      if (group == "nocache") {
        noCache = true;
        group = undefined;
      }
      let folderName = _activeFolder;
      if (typeof group == "string") {
        folderName = group;
        group = null;
      }
      if (!_folders[folderName]) {
        (function initFolder() {
          if (UIL.global) {
            let folder = new UILFolder(_activeFolder, {
              label: _activeFolder,
              closed: true
            });
            _folders[_activeFolder] = folder;
            UIL.global.add(folder);
          }
        })();
      }
      if (!_cache[name] || !!noCache) {
        _cache[name] = new TweenUILConfig(name, config, group || _folders[folderName]);
      }
      return _cache[name];
    };
    this.setFolder = function (name) {
      _activeFolder = name;
    };
  }, "static");
  Class(function TweenUILAnchor() {
    Inherit(this, Object3D);
    this.isTweenAnchor = true;
  });
  Class(function TweenUILConfig(_name, _config, _group) {
    Inherit(this, Component);
    const _this = this;
    var _input;
    var _editor;
    var _promise;
    var _project;
    var _meshes;
    var _keyframes;
    var _flatMap = {};
    var _sheets = {};
    var _duration = 0;
    function findTrueDuration(sequence) {
      let duration = 0;
      let tracks = sequence.tracksByObject;
      for (let k1 in tracks) {
        let obj = tracks[k1];
        if (k1 == "tween_anchor") {
          findAnchorKeyframes(obj);
        }
        for (let k2 in obj.trackData) {
          let trackData = obj.trackData[k2];
          for (let k3 in trackData.keyframes) {
            let keyframe = trackData.keyframes[k3];
            if (keyframe.position) {
              duration = Math.max(duration, keyframe.position);
            }
          }
        }
      }
      return duration;
    }
    function findAnchorKeyframes(obj) {
      for (let k1 in obj) {
        for (let k2 in obj[k1]) {
          let keyframes = obj[k1][k2].keyframes;
          if (keyframes) {
            _keyframes = keyframes;
          }
        }
      }
    }
    async function play(options) {
      if (!_config.sheets) {
        await prepareConfig();
        linkLocally();
      }
      if (_duration === 0) {
        for (let key in _sheets) {
          _duration = Math.max(_duration, _sheets[key].length);
        }
      }
      for (let key in _sheets) {
        _sheets[key].sequence.position = options?.direction === "reverse" ? _duration : 0;
        _sheets[key].sequence.play(options);
      }
      return _promise = _this.wait(_duration * 1000);
    }
    function linkLocally() {
      makeSendable().sheets.forEach(obj => {
        let layoutName = Object.keys(obj)[0].split("&")[0];
        const sheet = _sheets[layoutName];
        for (let key in obj) {
          let name = key.split("&");
          name.shift();
          name = name.join("_");
          for (let key2 in obj[key]) {
            let finalObj = obj[key][key2];
            for (let key3 in finalObj) {
              finalObj[key3] = finalObj[key3];
            }
          }
          sheet.object(name, obj[key]).onValuesChange(newValue => {
            completeDataLink(newValue, _flatMap[key]);
          });
        }
      });
    }
    async function prepareConfig() {
      let array = Array.isArray(_config) ? _config : [_config];
      (_config = {}).nudgeMultiplier = 0.05;
      _config.sheets = [];
      for (let i = 0; i < array.length; i++) {
        let layoutName;
        let objects = array[i];
        let options = {};
        if (objects instanceof SceneLayout) {
          layoutName = objects.name;
          options.isSceneLayout = true;
          objects = await getObjectsFromLayout(objects);
        } else {
          if (typeof objects != "object") {
            throw "TweenUIL :: Type not supported";
          }
          if (i === 0) {
            let obj0 = objects[Object.keys(objects)[0]];
            if (obj0 instanceof Mesh) {
              layoutName = "Scene";
            } else if (obj0.uniforms) {
              layoutName = "Shader";
            } else if (isElement(obj0)) {
              layoutName = "Elements";
            }
          }
        }
        layoutName ||= `Scene${i + 1}`;
        _config.sheets.push(createSheetFromObjects(objects, layoutName, options));
      }
    }
    function getMeshObject(layer, parent, layerName) {
      if (parent?.isTweenAnchor) {
        let obj = {};
        obj.anchor = {
          anchor: 0,
          link: {
            copy: e => {
              _this.keyframeSection = Math.fract(e.anchor);
            }
          }
        };
        return obj;
      }
      layer.rotationLink = {
        copy: obj => {
          layer.rotation.x = Math.radians(obj.x);
          layer.rotation.y = Math.radians(obj.y);
          layer.rotation.z = Math.radians(obj.z);
        },
        get x() {
          return Math.degrees(layer.rotation.x);
        },
        get y() {
          return Math.degrees(layer.rotation.y);
        },
        get z() {
          return Math.degrees(layer.rotation.z);
        }
      };
      let obj = {
        position: {
          x: layer.position.x,
          y: layer.position.y,
          z: layer.position.z,
          link: layer.position
        },
        scale: {
          x: layer.scale.x,
          y: layer.scale.y,
          z: layer.scale.z,
          link: layer.scale
        },
        rotation: {
          x: Math.degrees(layer.rotation.x),
          y: Math.degrees(layer.rotation.y),
          z: Math.degrees(layer.rotation.z),
          link: layer.rotationLink
        }
      };
      if (UIL.global) {
        _meshes ||= [];
        layer._uilLayerName = layerName;
        _meshes.push(layer);
      }
      if (parent?.tweenToggle) {
        obj.toggle = {
          on: 0,
          link: {
            copy: e => {
              if (e.on == 0 && parent.flag("tweenToggle")) {
                parent.flag("tweenToggle", false);
                parent.events.fire(TweenUIL.TOGGLE, {
                  on: false
                });
              } else if (e.on == 1 && !parent.flag("tweenToggle")) {
                parent.events.fire(TweenUIL.TOGGLE, {
                  on: true
                });
                parent.flag("tweenToggle", true);
              }
            }
          }
        };
      }
      return obj;
    }
    function getShaderObject(shader) {
      let obj = {};
      for (let key in shader.uniforms) {
        let uniform = shader.uniforms[key];
        let value = uniform.value;
        if (value !== undefined && !uniform.ignoreUIL && key != "HZ") {
          if (typeof value == "number") {
            obj[key] = {
              value: value,
              link: uniform
            };
          } else if (value instanceof Vector2) {
            obj[key] = {
              x: value.x,
              y: value.y,
              link: value
            };
          } else if (value instanceof Vector3) {
            obj[key] = {
              x: value.x,
              y: value.y,
              z: value.z,
              link: value
            };
          } else if (value instanceof Vector4) {
            obj[key] = {
              x: value.x,
              y: value.y,
              z: value.z,
              w: value.w,
              link: value
            };
          } else if (value instanceof Color) {
            obj[key] = {
              hex: value.getHexString(),
              link: value
            };
          }
        }
      }
      return obj;
    }
    function isElement(object) {
      return !!object?.div?.hydraObject || GLUIObject !== undefined && (object instanceof GLUIObject || object instanceof GLUIText);
    }
    function getElementObject($element) {
      let obj = {
        _config: {
          nudgeMultiplier: 1
        }
      };
      if ($element.x !== undefined) {
        obj.x = {
          value: $element.x,
          link: $element
        };
      }
      if ($element.y !== undefined) {
        obj.y = {
          value: $element.y,
          link: $element
        };
      }
      if ($element.z !== undefined) {
        obj.z = {
          value: $element.z,
          link: $element
        };
      }
      if ($element.scale !== undefined) {
        obj.scale = {
          value: $element.scale,
          link: $element
        };
      }
      if ($element.scaleX !== undefined) {
        obj.scaleX = {
          value: $element.scaleX,
          link: $element
        };
      }
      if ($element.scaleY !== undefined) {
        obj.scaleY = {
          value: $element.scaleY,
          link: $element
        };
      }
      if ($element.rotation !== undefined) {
        obj.rotation = {
          value: $element.rotation,
          link: $element
        };
      }
      if ($element.rotationX !== undefined) {
        obj.rotationX = {
          value: $element.rotationX,
          link: $element
        };
      }
      if ($element.rotationY !== undefined) {
        obj.rotationY = {
          value: $element.rotationY,
          link: $element
        };
      }
      if ($element.rotationZ !== undefined) {
        obj.rotationZ = {
          value: $element.rotationZ,
          link: $element
        };
      }
      if ($element.alpha !== undefined) {
        obj.alpha = {
          value: $element.alpha,
          link: $element
        };
      }
      return obj;
    }
    function getPlainObject(object) {
      let obj = {};
      for (let key in object) {
        let value = object[key];
        if (typeof value == "number") {
          obj[key] = {
            value: value,
            link: object
          };
        } else if (value instanceof Vector2) {
          obj[key] = {
            x: value.x,
            y: value.y,
            link: value
          };
        } else if (value instanceof Vector3) {
          obj[key] = {
            x: value.x,
            y: value.y,
            z: value.z,
            link: value
          };
        } else if (value instanceof Vector4) {
          obj[key] = {
            x: value.x,
            y: value.y,
            z: value.z,
            w: value.w,
            link: value
          };
        } else if (value instanceof Color) {
          obj[key] = {
            hex: value.getHexString(),
            link: value
          };
        }
      }
      if (Object.keys(obj).length) {
        return obj;
      }
    }
    async function getObjectsFromLayout(layout) {
      let layers = await layout.getAllLayers();
      let objects = {};
      for (let key in layers) {
        let layer = layers[key];
        if (layer.ready) {
          await layer.ready();
        }
        objects[key] = layer;
      }
      return objects;
    }
    function createSheetFromObjects(objects, layoutName, {
      isSceneLayout: isSceneLayout
    }) {
      let sheet = {};
      for (let name in objects) {
        let object = objects[name];
        let key = `${layoutName}&${name}`;
        let matched = false;
        if (object.uniforms) {
          _flatMap[key] = sheet[key] = getShaderObject(object);
        } else if (isElement(object)) {
          _flatMap[key] = sheet[key] = getElementObject(object);
        } else {
          if (object instanceof Mesh) {
            _flatMap[key] = sheet[key] = getMeshObject(object, null, key);
            matched = true;
          }
          if (object.shader) {
            _flatMap[`${key}&shader`] = sheet[`${key}&shader`] = getShaderObject(object.shader);
            matched = true;
          }
          if (object.behavior) {
            _flatMap[`${key}&behavior`] = sheet[`${key}&behavior`] = getShaderObject(object.behavior);
            matched = true;
          }
          if (object.group) {
            _flatMap[key] = sheet[key] = getMeshObject(object.group, object, key);
            matched = true;
          }
          if (!matched && !isSceneLayout) {
            let obj = getPlainObject(object);
            if (obj) {
              _flatMap[key] = sheet[key] = obj;
            } else {
              console.warn(`Unclear how to animate object ${key}`, object);
            }
          }
        }
      }
      return sheet;
    }
    function makeSendable() {
      const cleanObject = obj => {
        let newObj = {};
        for (let key in obj) {
          if (key != "link") {
            newObj[key] = obj[key];
          }
        }
        return newObj;
      };
      let obj = {
        sheets: [],
        nudgeMultiplier: _config.nudgeMultiplier
      };
      obj.filePath = Assets.getPath(`assets/data/timeline-${_name}.json`);
      if (!obj.filePath.includes("http")) {
        obj.filePath = Hydra.absolutePath(obj.filePath);
      }
      _config.sheets.forEach(sheet => {
        let newSheet = {};
        for (let key in sheet) {
          let top = sheet[key];
          newSheet[key] = {};
          for (let key2 in top) {
            newSheet[key][key2] = cleanObject(top[key2]);
          }
        }
        obj.sheets.push(newSheet);
      });
      return obj;
    }
    function completeDataLink(dataObj, realObj) {
      let transform;
      for (let key2 in realObj) {
        if (key2 === "_config") {
          continue;
        }
        let valueObj = dataObj[key2];
        let link = realObj[key2].link;
        if (!valueObj.hex) {
          if (valueObj.value !== undefined) {
            if (link.value !== undefined) {
              link.value = valueObj.value;
            } else {
              link[key2] = valueObj.value;
            }
            transform = link.transform;
            if (transform && key2 == "alpha") {
              link.css("opacity", valueObj.value);
            }
          } else {
            link.copy(valueObj);
          }
        }
      }
      if (transform) {
        transform();
      }
    }
    function linkData(data) {
      for (let key in data) {
        completeDataLink(data[key], _flatMap[key]);
      }
    }
    async function openEditor() {
      if (!_config.sheets) {
        await prepareConfig();
      }
      console.log(_config.sheets);
      (_editor = new UILExternalTimeline(_name, 800, 1200, makeSendable())).onMessage = linkData;
      _editor.onSave = _ => {
        _input.setValue("saved", true);
      };
      _editor.onDestroy = _ => {
        _editor = null;
        _meshes?.forEach(mesh => {
          if (mesh._cameraUIL) {
            mesh._cameraUIL.tweenUIL_groupPos = null;
            mesh._cameraUIL.tweenUIL_scale = null;
            mesh._cameraUIL.tweenUIL_rotation = null;
          }
          if (mesh._meshUIL) {
            mesh._meshUIL.tweenUIL_scale = null;
            mesh._meshUIL.tweenUIL_position = null;
            mesh._meshUIL.tweenUIL_rotation = null;
          }
        });
      };
      _meshes?.forEach(mesh => {
        if (mesh._cameraUIL) {
          mesh._cameraUIL.tweenUIL_groupPos = value => _editor.sendUpdate(mesh._uilLayerName, value, "position");
          mesh._cameraUIL.tweenUIL_scale = value => _editor.sendUpdate(mesh._uilLayerName, value, "scale");
          mesh._cameraUIL.tweenUIL_rotation = value => _editor.sendUpdate(mesh._uilLayerName, value, "rotation");
        } else if (mesh._meshUIL) {
          mesh._meshUIL.tweenUIL_position = value => _editor.sendUpdate(mesh._uilLayerName, value, "position");
          mesh._meshUIL.tweenUIL_scale = value => _editor.sendUpdate(mesh._uilLayerName, value, "scale");
          mesh._meshUIL.tweenUIL_rotation = value => _editor.sendUpdate(mesh._uilLayerName, value, "rotation");
        }
      });
    }
    function updateKeyframeData() {
      for (let key in _sheets) {
        _this.keyframeTotalProgress = _keyframes.positionObject.position / _sheets[key].length;
      }
      _this.keyframeIndex = _keyframes.current;
      _this.keyframeLocalProgress = Math.fract(_keyframes.positionObject.position);
    }
    function updateKeyframeLoop(hz) {
      _keyframes.positionObject.position = Math.lerp(_keyframes.positionObject.target, _keyframes.positionObject.position, hz * 0.07, false);
      for (let key in _sheets) {
        _sheets[key].sequence.position = _keyframes.positionObject.position;
      }
      updateKeyframeData();
    }
    (async function () {
      (_input = InputUIL.create(_name + "_tween", _group)).setLabel(_name);
      _input.addButton("edit", {
        label: "Edit",
        actions: [{
          title: "Editor",
          callback: openEditor
        }]
      });
      if (_input.get("saved")) {
        let state = await get(Assets.getPath(`assets/data/timeline-${_name}.json`));
        _project = Theatre.core.getProject(_name, {
          state: state
        });
        await _project.ready;
        for (let key in state.sheetsById) {
          _sheets[key] = _project.sheet(key);
          _sheets[key].length = findTrueDuration(state.sheetsById[key].sequence);
        }
        _input.addButton("play", {
          label: "Play",
          actions: [{
            title: "Play",
            callback: play
          }]
        });
        _input.addRange("Scrub", 0, {
          min: 0,
          max: 1,
          step: 0.0005
        });
        _input.onUpdate = async key => {
          if (key == "Scrub") {
            if (!_config.sheets) {
              await play();
            }
            let value = _input.getNumber("Scrub");
            _this.seek(value);
          }
        };
      }
      _this.flag("ready", true);
    })();
    this.play = async function (options) {
      await _this.wait("ready");
      return play(options);
    };
    this.seek = function (value) {
      if (_this.flag("ready")) {
        for (let key in _sheets) {
          _sheets[key].sequence.position = _sheets[key].length * value;
        }
      }
    };
    this.promise = async function () {
      await _this.wait("ready");
      return _promise;
    };
    this.setLabel = function (label) {
      if (_input) {
        _input.setLabel(label);
      }
    };
    this.preload = async function () {
      await _this.wait("ready");
      if (!_config.sheets) {
        await prepareConfig();
        linkLocally();
      }
      _this.seek(0);
    };
    this.seekToKeyframe = async function (index) {
      await _this.preload();
      if (!_keyframes) {
        return console.warn("TweenUILConfig :: Missing keyframes! Add tween_anchor layer");
      }
      _keyframes.current = index;
      _keyframes.positionObject = {
        position: _keyframes[index].position,
        target: _keyframes[index].position
      };
      _this.seek(_keyframes[index].position);
      updateKeyframeData();
      _this.startRender(updateKeyframeLoop, RenderManager.NATIVE_FRAMERATE);
    };
    this.playToKeyframe = async function (index, time, ease = "linear", delay) {
      await _this.wait("ready");
      if (!_keyframes.positionObject) {
        await _this.seekToKeyframe(0);
      }
      let nextKeyframe = _keyframes[index];
      let currentKeyframe = _keyframes[_keyframes.current];
      if (!nextKeyframe) {
        return;
      }
      let position = nextKeyframe.position;
      time ||= Math.abs(nextKeyframe.position - currentKeyframe.position) * 1000;
      _keyframes.tween &&= clearTween(_keyframes.tween);
      _keyframes.current = index;
      _this.flag("playingToKeyframe", true, time + 50);
      _keyframes.tween = tween(_keyframes.positionObject, {
        target: position
      }, time, ease, delay);
      return _keyframes.tween.promise();
    };
    this.peekInKeyframeDirection = function (dir, percent) {
      if (!_keyframes || _this.flag("playingToKeyframe")) {
        return;
      }
      let currentKeyframe = _keyframes[_keyframes.current];
      let nextKeyframe = _keyframes[_keyframes.current + dir];
      if (nextKeyframe) {
        _keyframes.positionObject.target = Math.mix(currentKeyframe.position, nextKeyframe.position, percent);
      }
    };
    this.playToNextKeyframe = async function (time, ease, delay) {
      return this.playToKeyframe(_keyframes.current + 1, time, ease, delay);
    };
    this.playToPrevKeyframe = async function (time, ease, delay) {
      return this.playToKeyframe(_keyframes.current - 1, time, ease, delay);
    };
    this.playToDirKeyframe = async function (dir, time, ease, delay) {
      return this.playToKeyframe(_keyframes.current + dir, time, ease, delay);
    };
    this.get("totalKeyframes", _ => _keyframes ? _keyframes.length : 0);
    this.get("currentKeyframe", _ => _keyframes ? _keyframes.current : 0);
  });
  Class(function UILFile(_offline, _path) {
    Inherit(this, Component);
    this.load = async function () {
      let path = window.UIL_STATIC_PATH || "assets/data/uil.json";
      try {
        let data = await get(path);
        if (typeof data == "string") {
          if (Hydra.LOCAL) {
            return null;
          } else {
            return {};
          }
        } else {
          return data;
        }
      } catch (e) {
        return {};
      }
    };
    this.save = async function (sessionData, data) {
      Dev.writeFile(window.UIL_STATIC_PATH || "assets/data/uil.json", data);
      if (_offline) {
        let partial = {};
        try {
          partial = await get("assets/data/uil-partial.json", data);
          for (let key in sessionData) {
            partial[key] = sessionData[key];
          }
        } catch (e) {
          partial = sessionData;
        }
        Dev.writeFile("assets/data/uil-partial.json", partial);
        Storage.set("uil_update_partial", true);
      }
    };
  });
  Class(function UILStorage() {
    Inherit(this, Component);
    const _this = this;
    var _storage;
    var _platform;
    var _fs;
    var _keys;
    var _storeIds = [];
    var _data = {};
    var _dataSession = {};
    var _id = window.UIL_ID || "default";
    var _remote = window.UIL_REMOTE || false;
    window.UIL_ID = _id = _id.replaceAll(/[^a-zA-Z0-9 _-]/g, "");
    this.SAVE = "uil_save";
    const OFFLINE_FIREBASE = Utils.query("offlineFB");
    function clearOfflineData() {
      Storage.set("uil_update_partial", false);
      Dev.writeFile("assets/data/uil-partial.json", {});
    }
    async function init() {
      if (_fs) {
        _fs.destroy();
      }
      _fs = _this.initClass(uilFile() ? UILFile : UILRemote, OFFLINE_FIREBASE);
      let data = await _fs.load();
      if (data === null) {
        let remoteFs = _this.initClass(UILRemote);
        let remoteData = await remoteFs.load();
        if (confirm("Looks like the local uil.json has merge conflicts, do you want to sync from Firebase and resolve it?")) {
          _data[_id] = remoteData;
          await write();
          window.location.reload();
        } else {
          data = {};
        }
      }
      _data[_id] = data;
      _this.loaded = true;
      if (!OFFLINE_FIREBASE && Storage.get("uil_update_partial") && !uilFile()) {
        if (!confirm("Looks like you have UIL data captured offline, do you want to sync it to Firebase?")) {
          return clearOfflineData();
        }
        let data = await get("assets/data/uil-partial.json");
        for (let key in data) {
          _this.set(key, data[key]);
        }
        write(true, true);
        clearOfflineData();
      }
    }
    async function write(direct, silent) {
      let prevent = false;
      let e = {
        prevent: _ => prevent = true
      };
      _this.events.fire(_this.SAVE, e);
      if (!!direct || !(e.wait && (await e.wait()), prevent)) {
        _fs.save(_dataSession, _data[_id]);
        _dataSession = {};
        if (!silent) {
          __body.css({
            display: "none"
          });
          _this.delayedCall(() => {
            __body.css({
              display: "block"
            });
          }, 100);
        }
      }
    }
    function uilFile() {
      return !Utils.query("editMode") && (!Hydra.LOCAL || (!window.Config || !Config.PLATFORM_CONFIG || !Utils.query("uil")) && (!!Device.mobile || !!OFFLINE_FIREBASE || !!window._BUILT_ || !!window.AURA || !!window._UIL_FILE_ || !window._FIREBASE_UIL_ && !window.UIL_ID || !Device.detect("hydra") && !Utils.query("uil")));
    }
    Hydra.ready(async _ => {
      if (window.Platform && Platform.isDreamPlatform && Config.PLATFORM_CONFIG) {
        (async function initLocalCached() {
          _fs = _this.initClass(UILFile);
          _data[_id] = await _fs.load();
          _this.loaded = true;
        })();
      } else if (!Hydra.LOCAL || !window.Platform || !window.Platform.isPlatform) {
        init();
      }
      if (Utils.query("editMode") || Hydra.LOCAL && window.Platform && window.Platform.isDreamPlatform && Utils.query("uil") || Hydra.LOCAL && !Device.mobile && !window._BUILT_ && (Utils.query("uil") || Device.detect("hydra"))) {
        __window.bind("keydown", e => {
          if ((e.ctrlKey || e.metaKey) && e.keyCode == 83) {
            e.preventDefault();
            write();
          }
        });
      }
    });
    this.reload = function (id, path, persist) {
      _this.loaded = false;
      _platform ||= _id;
      if (persist) {
        _storeIds.push(id);
      }
      _id = id;
      window.UIL_ID = id;
      window.UIL_STATIC_PATH = path;
      init();
    };
    this.set = function (key, value) {
      if (value === null) {
        delete _data[_id][key];
        delete _dataSession[key];
      } else {
        _data[_id][key] = value;
        _dataSession[key] = value;
      }
    };
    this.setWrite = function (key, value) {
      this.set(key, value);
      write(true);
    };
    this.clearMatch = function (string) {
      for (let key in _data[_id]) {
        if (key.includes(string)) {
          delete _data[_id][key];
        }
      }
      write(true);
    };
    this.write = function (silent) {
      write(true, silent);
    };
    this.get = function (key) {
      let val = _data[_id] && _data[_id][key];
      if (val === undefined && _platform) {
        val = _data[_platform][key];
      }
      if (val === undefined && _storeIds) {
        for (let i = 0; i < _storeIds.length; i++) {
          val = _data[_storeIds[i]][key];
        }
      }
      return val;
    };
    this.ready = function () {
      return _this.wait(_this, "loaded");
    };
    this.getKeys = function () {
      _keys ||= Object.keys(_data[_id]);
      return _keys;
    };
    this.hasData = function () {
      return !!_data[_id];
    };
    _this.uploadFileToRemoteBucket = async function ({
      file: file,
      progress: progress
    }) {
      if (!_remote) {
        return;
      }
      if (!_storage) {
        await Services.ready();
        _storage = Services.app().storage();
      }
      let filename = file.name.replace(/ /g, "_");
      const ref = _storage.ref(`_tmp/${filename}`);
      const path = `https://storage.googleapis.com/${ref.bucket}/uploads/${_id}/${filename}`.toLowerCase();
      const metadata = {
        customMetadata: {
          id: _id,
          path: path,
          contentType: file.type
        }
      };
      const result = ref.put(file, metadata);
      let exists;
      for (progress && result.on("state_changed", snapshot => {
        let _progress = snapshot.bytesTransferred / snapshot.totalBytes * 95;
        progress.css({
          width: _progress + "%"
        });
      }, error => {
        if (err) {
          console.log(error);
        }
        progress.css({
          width: 0
        });
      }, () => {
        progress.css({
          width: 0
        });
      }); !exists;) {
        try {
          if (await fetch(path).then(r => r.ok)) {
            exists = true;
          }
        } catch (err) {
          exists = false;
        }
      }
      return metadata;
    };
    this.parse = function (key, hint) {
      let data = _data[_id][key];
      if (data === undefined) {
        return null;
      }
      if (Array.isArray(data)) {
        if (hint instanceof Vector2) {
          return {
            value: new Vector2().fromArray(data)
          };
        }
        if (hint instanceof Vector3) {
          return {
            value: new Vector3().fromArray(data)
          };
        }
        if (hint instanceof Vector4) {
          return {
            value: new Vector4().fromArray(data)
          };
        }
      } else if (typeof data == "string" && data.charAt(0) === "#") {
        return {
          value: new Color(data)
        };
      }
      return {
        value: data
      };
    };
  }, "static");
  Class(function UILControl() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $label;
    let $content;
    let $view;
    let _value;
    let _previous;
    let _label;
    let _opts;
    let _visible = true;
    let _onChange = () => {};
    let _onFinishChange = () => {};
    function isEqual(a, b) {
      if (Array.isArray(a) || Array.isArray(b)) {
        return a + "" == b + "";
      } else if (typeof a == "object" || typeof b == "object") {
        return JSON.stringify(a) === JSON.stringify(b);
      } else {
        return a === b;
      }
    }
    function clone(value) {
      if (Array.isArray(value)) {
        return [...value];
      } else if (typeof value == "object") {
        return Object.assign({}, value);
      } else {
        return value;
      }
    }
    (function initHTML() {
      $this = _this.element;
      $this.size("100%", "auto");
      $this.css({
        position: "relative",
        display: "inline-block",
        borderBottom: "1px solid #161616",
        padding: "2px 0",
        boxSizing: "border-box"
      });
      $this.attr("data-type", "UILControl");
      $this.div._this = _this;
    })();
    (function initLabel() {
      $label = $this.create("label");
      $label.size("100px", "auto").fontStyle("sans-serif", 12, "#9B9C9B");
      $label.css({
        paddingLeft: 4,
        paddingTop: 2,
        boxSizing: "border-box",
        verticalAlign: "top",
        float: "left"
      });
      _this.$label = $label;
    })();
    (function initContent() {
      $content = $this.create("content");
      $content.size("calc(100% - 100px)", "auto").css({
        float: "left"
      });
      _this.$content = $content;
    })();
    this.init = function (id, opts = {}) {
      _this.id = id;
      _opts = opts;
      _value = clone(opts.value);
      _previous = clone(_value);
      _this.setLabel(opts.label || id);
      $this.attr("data-id", id);
    };
    this.finish = function (history = true) {
      _onFinishChange(_value);
      if (!isEqual(_value, _previous)) {
        if (history) {
          UILHistory.set(_this, _previous);
        }
        UILLocalStorage.set(_this.id, _value);
        _previous = clone(_value);
      }
    };
    this.force = function (value) {
      _this.value = clone(value);
      _this.finish(false);
    };
    this.debounce = function (callback, time = 250) {
      let interval;
      return (...args) => {
        clearTimeout(interval);
        interval = setTimeout(() => {
          interval = null;
          callback(...args);
        }, time);
      };
    };
    this.onChange = function (cb) {
      _onChange = cb;
      return _this;
    };
    this.onFinishChange = function (cb) {
      _onFinishChange = cb;
      return _this;
    };
    this.get("value", () => _value);
    this.set("value", value => {
      if (!isEqual(value, _value)) {
        _value = clone(value);
        if (_this.update) {
          _this.update(_value);
        }
        _onChange(_value);
      }
    });
    this.get("view", () => $view);
    this.set("view", view => {
      if ($view) {
        $view.destroy();
      }
      $view = view;
      $content.add($view);
    });
    this.hide = function () {
      _visible = false;
      $this.css({
        display: "none"
      });
      return _this;
    };
    this.show = function () {
      _visible = true;
      $this.css({
        display: "inline-block"
      });
      return _this;
    };
    this.isVisible = function () {
      return _visible;
    };
    this.setLabel = function (label) {
      _label = label;
      _this.label = label;
      $label.text(label);
      let title = label;
      if (_opts.description) {
        title = title + "\n" + _opts.description;
      }
      $label.attr("title", title);
    };
  });
  Class(function UILFolder(_id, _opts = {
    drag: true
  }) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $header;
    let $container;
    let $toggle;
    let $drag;
    let $title;
    let _children = {};
    let _open = !_opts.closed;
    let _visible = true;
    let _order = [];
    let _draggable = false;
    let _sortableChildren = false;
    let _headerDrag = false;
    var _hasClipboard = false;
    _this.id = _id;
    _this.label = `${_opts.label || _id}`;
    _this.level = -1;
    function removeDragHandlers() {
      $this.div.removeEventListener("dragstart", dragStart, false);
      $this.div.removeEventListener("dragover", dragOver, false);
      $this.div.removeEventListener("drop", drop, false);
    }
    function matchItem(str, item) {
      return UILFuzzySearch.search(str, item.id.toLowerCase()) || UILFuzzySearch.search(str, item.label.toLowerCase());
    }
    function dragStart(e) {
      if (!UILFolder.DragLock) {
        if (!_headerDrag) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        UILFolder.DragLock = _this.id;
        e.dataTransfer.setData("text/plain", _this.id);
        e.dataTransfer.effectAllowed = "move";
        $this.css({
          opacity: 0.5
        });
      }
    }
    function dragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    }
    function drop(e) {
      if (!UILFolder.DragLock) {
        return;
      }
      if (e.dataTransfer.items) {
        for (var i = 0; i < e.dataTransfer.items.length; i++) {
          if (e.dataTransfer.items[i].kind === "file") {
            return;
          }
        }
      }
      e.preventDefault();
      _headerDrag = false;
      let target = e.currentTarget._this;
      let dragging = _this.parent.get(UILFolder.DragLock);
      UILFolder.DragLock = null;
      if (target && target.parent && dragging) {
        dragging.element.css({
          opacity: 1
        });
        if (dragging.parent.get(target.id)) {
          e.stopPropagation();
          target.parent.container.insertBefore(dragging.element.div, target.element.div);
          _order = [...target.parent.container.childNodes].map(el => el._this.id);
          _this.events.fire(UIL.REORDER, {
            order: [..._order]
          });
          (function saveSort() {
            UILStorage.set(`UIL_${UIL.sortKey}_${_this.parent.id}_order`, JSON.stringify(_order));
          })();
        }
      }
    }
    function getUrlID() {
      return `${Global.PLAYGROUND || "Global"}_folder_${_id}`;
    }
    function saveFolderState() {
      sessionStorage.setItem(getUrlID(), JSON.stringify({
        open: _open
      }));
    }
    function open(keepClosed = false) {
      _open = true;
      $container.css({
        display: "flex"
      });
      if ($toggle) {
        $toggle.text("");
      }
      if (keepClosed != 1) {
        forEachFolder(f => f.close());
      }
      saveFolderState();
      if (_this.onOpen) {
        _this.onOpen();
      }
    }
    function close() {
      _open = false;
      $container.css({
        display: "none"
      });
      if ($toggle) {
        $toggle.text("");
      }
      saveFolderState();
    }
    function onToggle(e) {
      if (_open) {
        close();
      } else {
        open();
      }
    }
    function onMouseDown(e) {
      _headerDrag = true;
      $header.div.addEventListener("mouseup", onMouseUp);
    }
    function onMouseUp(e) {
      _headerDrag = false;
      $header.div.removeEventListener("mouseup", onMouseUp);
    }
    function onKeydown(e) {
      if (e.which === 13) {
        if (_open) {
          close();
        } else {
          open();
        }
      }
    }
    function onKeyup(e) {
      if (_hasClipboard) {
        if (e.key == "c" && e.metaKey) {
          (function onCopy() {
            UILClipboard.copy(_children);
          })();
        } else if (e.key == "v" && e.metaKey) {
          (function onPaste() {
            UILClipboard.paste(_children);
          })();
        }
      }
    }
    function onFocus() {
      $this.css({
        border: "1px solid #37a1ef"
      });
      $this.div.classList.add("active");
      _hasClipboard = true;
    }
    function onBlur() {
      $this.css({
        border: "none",
        border: "1px solid #161616"
      });
      $this.div.classList.remove("active");
      _hasClipboard = false;
    }
    function forEachFolder(cb) {
      Object.values(_children).forEach(el => {
        if (el instanceof UILFolder) {
          cb(el);
          el.forEachFolder(cb);
        }
      });
      return _this;
    }
    (function init() {
      $this = _this.element;
      $this.size("100%", "auto").bg(_opts.background || "#272727");
      $this.css({
        position: "relative",
        border: "1px solid #161616",
        boxSizing: "border-box",
        maxHeight: _opts.maxHeight || "none"
      });
      $this.attr("data-id", _id);
      $this.attr("data-type", "UILFolder");
      $this.div._this = _this;
    })();
    (function style() {
      UIL.addCSS(UILFolder, "\n            .UILFolder *:focus { outline: none; }\n            .UILFolder input:focus { border-color:#37a1ef!important; }\n            .UILFolder button:focus { border-color:#37a1ef!important; }\n            .UILFolder .UILFolder .UILFolder .toggle {margin-left:8px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:16px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:24px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:32px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:40px; }\n        ");
    })();
    (function initHeader() {
      if (!_opts.hideTitle) {
        $header = $this.create("title", "a");
        $header.attr("tabindex", "0");
        $header.size("100%", "auto").bg("#272727");
        $header.css({
          display: "block",
          padding: "4px 4px",
          boxSizing: "border-box",
          fontWeight: "bold",
          userSelect: "none",
          borderBottom: "1px solid #161616"
        });
        $header.fontStyle("sans-serif", 11, "#B1B1B1");
        $header.div.addEventListener("keydown", onKeydown, false);
        $header.div.addEventListener("click", onToggle, false);
        $header.div.addEventListener("mousedown", onMouseDown);
        $header.div.addEventListener("focus", onFocus, false);
        $header.div.addEventListener("blur", onBlur, false);
        $header.div.addEventListener("keydown", onKeyup, false);
        $toggle = $header.create("toggle");
        $toggle.text(_open ? "" : "").css({
          fontSize: 8,
          display: "inline-block",
          verticalAlign: "middle"
        });
        $drag = $header.create("drag");
        $drag.text("").css({
          position: "absolute",
          right: 7,
          top: 3,
          display: "inline-block",
          pointerEvents: "none"
        });
        $drag.hide();
        $title = $header.create("title");
        $title.text(_this.label).css({
          display: "inline-block",
          marginLeft: 4
        });
      }
    })();
    (function initContainer() {
      $container = $this.create("container");
      $container.size("100%", "100%").css({
        display: "flex",
        flexDirection: "column",
        position: "relative",
        overflowY: "auto"
      });
      if (!_open) {
        $container.css({
          display: "none"
        });
      }
      _this.container = $container.div;
    })();
    (function restoreFolderState() {
      let json = JSON.parse(sessionStorage.getItem(getUrlID()));
      if (json) {
        if (json.open) {
          open();
        } else {
          close();
        }
      }
    })();
    this.add = function (child) {
      if (child.draggable) {
        child.draggable(_sortableChildren);
      }
      child.parent = _this;
      _children[child.id] = child;
      $container.add(child);
      return _this;
    };
    this.remove = function (x) {
      let id = typeof x == "string" ? x : x.id;
      let child = _children[id];
      if (!child) {
        for (let key in _children) {
          if (key.includes(x)) {
            child = _children[key];
            delete _children[key];
            break;
          }
        }
      }
      if (child.eliminate) {
        child.eliminate();
      }
      child.destroy();
      _order &&= _order.filter(child => child !== id);
      delete _children[id];
      return _this;
    };
    this.get = function (id) {
      return _children[id];
    };
    this.getAll = function () {
      return Object.values(_children);
    };
    this.getVisible = function () {
      return Object.values(_children).filter(x => x.isVisible());
    };
    this.find = function (id) {
      if (id === _id) {
        return _this;
      } else {
        return Object.values(_children).reduce((acc, item) => item.id === id ? acc.concat(item) : item instanceof UILFolder ? acc.concat(item.find(id)) : acc, []);
      }
    };
    this.filter = function (str) {
      return function filter(str, match = false) {
        str = str.toLowerCase();
        let result = [];
        let haystack = Object.values(_children);
        for (let el of haystack) {
          if (el instanceof UILFolder) {
            let matches = el.filter(str, true);
            if (matches.length) {
              result.concat(matches);
              el.show();
              el.open();
            } else if (matchItem(str, el)) {
              result.push(el);
              el.show();
              el.showChildren();
              el.close();
            } else if (el.getVisible().length) {
              el.show();
            } else {
              el.hide();
            }
          } else if (matchItem(str, el)) {
            result.push(el);
            el.show();
          } else {
            el.hide();
          }
        }
        return result;
      }(str);
    };
    this.filterSingle = function filterSingle(str) {
      str = str.toLowerCase();
      let haystack = Object.values(_children);
      for (let el of haystack) {
        if (el instanceof UILFolder) {
          el.filterSingle(str);
          if (str == el.label.toLowerCase() || str == el.id.toLowerCase()) {
            el.show();
            el.showChildren();
            el.open(true);
          } else if (el.getVisible().length) {
            el.show();
          } else {
            el.hide();
          }
        } else if (matchItem(str, el)) {
          el.show();
          if (el.open) {
            el.open(true);
          }
        } else {
          el.hide();
        }
      }
      return [];
    };
    this.open = function (keepClosed) {
      open(keepClosed);
      return _this;
    };
    this.close = function () {
      close();
      return _this;
    };
    this.setLabel = function (label) {
      _this.label = `${label}`;
      $title.text(label);
      return _this;
    };
    this.hide = function () {
      _visible = false;
      $this.css({
        display: "none"
      });
      return _this;
    };
    this.show = function () {
      _visible = true;
      $this.css({
        display: "block"
      });
      return _this;
    };
    this.showChildren = function () {
      Object.values(_children).forEach(el => el instanceof UILFolder ? el.showChildren() : el.show());
      _this.show();
      return _this;
    };
    this.isOpen = function () {
      return _open;
    };
    this.isVisible = function () {
      return _visible;
    };
    this.forEachFolder = function (cb) {
      return forEachFolder(cb);
    };
    this.forEachControl = function (cb) {
      Object.values(_children).forEach(el => {
        if (el instanceof UILFolder) {
          el.forEachControl(cb);
        } else {
          cb(el);
        }
      });
      return _this;
    };
    this.enableSorting = function (key) {
      _sortableChildren = true;
      UIL.sortKey = key;
      Object.values(_children).forEach(el => {
        if (el instanceof UILFolder) {
          el.draggable(true);
        }
      });
      let order = function getSort() {
        let sort = UILStorage.get(`UIL_${UIL.sortKey}_${_id}_order`);
        if (sort) {
          return JSON.parse(sort);
        }
      }();
      if (order) {
        _order = order;
        (function restoreSort() {
          _order.forEach(id => {
            if (_children[id]) {
              $container.add(_children[id]);
            }
          });
        })();
      }
      return _this;
    };
    this.draggable = function (enable) {
      _draggable = enable;
      $this.attr("draggable", enable);
      if (enable) {
        (function addDragHandlers() {
          $this.div.addEventListener("dragstart", dragStart, false);
          $this.div.addEventListener("dragover", dragOver, false);
          $this.div.addEventListener("drop", drop, false);
        })();
        if ($drag) {
          $drag.show();
        }
      } else {
        removeDragHandlers();
        if ($drag) {
          $drag.hide();
        }
      }
    };
    this.toClipboard = function () {
      UILClipboard.copy(_children);
    };
    this.fromClipboard = function () {
      UILClipboard.paste(_children);
    };
    this.eliminate = function () {
      if (!_opts.hideTitle) {
        $header.div.removeEventListener("keydown", onToggle, false);
        $header.div.removeEventListener("click", onToggle, false);
        $header.div.removeEventListener("mousedown", onMouseDown);
        $header.div.removeEventListener("focus", onFocus, false);
        $header.div.removeEventListener("blur", onBlur, false);
      }
      if (_draggable) {
        removeDragHandlers();
      }
    };
    this.forceSort = function (index) {
      _this.parent.container.insertBefore(_this.element.div, _this.parent.container.children[index]);
      _order = [..._this.parent.container.childNodes].map(el => el._this.id);
      _this.events.fire(UIL.REORDER, {
        order: [..._order]
      });
    };
    this.openChildren = function () {
      Object.values(_children).forEach(el => el instanceof UILFolder ? el.open() : null);
    };
  });
  Class(function UILPanel(_title, _opts = {}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let _folder;
    let _toolbar;
    let _hidden = false;
    function onKeydown(e) {
      if (e.ctrlKey || e.metaKey) {
        if (e.keyCode == 72 && e.shiftKey) {
          if (`${document.activeElement.type}`.includes(["textarea", "input", "number"])) {
            return;
          }
          e.preventDefault();
          if (_hidden) {
            (function show() {
              $this.visible();
              _hidden = false;
            })();
          } else {
            (function hide() {
              $this.invisible();
              _hidden = true;
            })();
          }
        }
        if (e.keyCode == 37 && e.shiftKey) {
          e.preventDefault();
          $this.css({
            left: 0,
            right: "auto"
          });
        }
        if (e.keyCode == 39 && e.shiftKey) {
          e.preventDefault();
          $this.css({
            left: "auto",
            right: 0
          });
        }
        if (e.which == 67 && e.shiftKey) {
          e.preventDefault();
          _folder.forEachFolder(f => f.close());
        }
        if (e.which == 79 && e.shiftKey) {
          e.preventDefault();
          _folder.forEachFolder(f => f.open());
        }
      }
    }
    function undim() {
      $this.css({
        opacity: 1
      });
    }
    function dim() {
      $this.css({
        opacity: 0.3
      });
    }
    _this.id = _title;
    (function initHTML() {
      $this = _this.element;
      $this.size(_opts.width || "300px", _opts.height || "auto").bg("#161616").mouseEnabled(true);
      if (_opts.side === "left") {
        $this.css({
          left: 0
        });
      } else {
        $this.css({
          right: 0
        });
      }
      $this.css({
        top: 0,
        maxHeight: _opts.maxHeight || "100%",
        position: "absolute",
        userSelect: "none",
        padding: 4,
        overflowY: "auto",
        borderRadius: 4
      });
      $this.hide();
    })();
    (function initToolbar() {
      _toolbar = _this.toolbar = _this.initClass(UILPanelToolbar);
    })();
    (function initGroup() {
      _folder = _this.initClass(UILFolder, _title, {
        hideTitle: true,
        drag: false,
        background: "#161616"
      });
      _this.folder = _folder;
    })();
    (function addHandlers() {
      document.addEventListener("keydown", onKeydown, false);
      if (_opts.hide) {
        $this.div.addEventListener("mouseover", undim, false);
        $this.div.addEventListener("mouseleave", dim, false);
      }
    })();
    this.add = function (child) {
      $this.show();
      _folder.add(child);
      return _this;
    };
    this.remove = function (x) {
      _folder.remove(x.id);
      return _this;
    };
    this.get = function (id) {
      return _folder.get(id);
    };
    this.find = function (id) {
      return _folder.find(id);
    };
    this.filter = function (str) {
      return _folder.filter(str);
    };
    this.enableSorting = function (key) {
      if (_folder.enableSorting) {
        _folder.enableSorting(key);
      }
      return _this;
    };
    this.eliminate = function () {
      _toolbar.eliminate();
      $this.div.removeEventListener("mouseover", undim, false);
      $this.div.removeEventListener("mouseleave", dim, false);
      document.removeEventListener("keydown", onKeydown, false);
    };
  });
  Class(function UILControlButton(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _buttons = [];
    (function init() {
      _this.init(_id, _opts);
      if (_opts.hideLabel) {
        _this.$label.css({
          display: "none"
        });
        _this.$content.css({
          width: "100%"
        });
      }
    })();
    (function initActions() {
      $view = $("inputs");
      let config = [].concat(_opts.actions);
      _buttons = [].concat(_opts.actions).map(({
        title: title,
        callback: callback
      }) => {
        let btn = $view.create(`btn btn-${title}`, "button");
        btn.text(title).bg("#1d1d1d");
        btn.css({
          width: `calc(100% / ${config.length || 1}`,
          border: "1px solid #2e2e2e",
          color: "#37a1ef",
          position: "relative"
        });
        btn.interact(e => function hover(btn, e) {
          if (e.action === "over") {
            btn.css({
              border: "1px solid #9b9c9b"
            });
          } else {
            btn.css({
              border: "1px solid #2e2e2e"
            });
          }
        }(btn, e));
        btn.click(e => function click(e, title, callback) {
          _this.value = title;
          if (callback) {
            callback(title, e);
          }
          _this.finish();
        }(e, title, callback));
        return btn;
      });
      _this.view = $view;
    })();
    this.setTitle = function (text) {
      _buttons.forEach(btn => {
        btn.text(text);
      });
    };
  });
  Class(function UILControlCheckbox(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $label;
    let $checkbox;
    let $slider;
    function toggle() {
      $checkbox.attr("checked", _this.value);
      $slider.css({
        right: _this.value ? 0 : "auto"
      });
      $label.bg(_this.value ? "#37a1ef" : "#1d1d1d");
    }
    function click() {
      _this.value = !_this.value;
      toggle();
      _this.finish();
    }
    function focus() {
      $label.css({
        border: "1px solid #37a1ef"
      });
    }
    function blur() {
      $label.css({
        border: "1px solid #2e2e2e"
      });
    }
    (function init() {
      _opts.value = _opts.value || false;
      _this.init(_id, _opts);
    })();
    (function initView() {
      $view = $("view");
      $label = $view.create("label", "label");
      $label.size(30, 15).css({
        position: "relative",
        display: "inline-block",
        borderRadius: 15,
        border: "1px solid #2e2e2e"
      }).bg(_this.value ? "#37a1ef" : "#1d1d1d");
      $checkbox = $label.create("checkbox", "input");
      $checkbox.attr("type", "checkbox");
      $checkbox.attr("checked", _this.value);
      $checkbox.css({
        opacity: 0,
        width: "100%",
        position: "absolute"
      });
      $slider = $label.create("slider");
      $slider.size(15, 15).css({
        borderRadius: 15,
        position: "absolute",
        right: _this.value ? 0 : "auto",
        boxSizing: "border-box"
      }).bg("#ffffff");
      _this.view = $view;
    })();
    (function addHandlers() {
      $checkbox.div.addEventListener("focus", focus, false);
      $checkbox.div.addEventListener("blur", blur, false);
      $checkbox.div.addEventListener("click", click, false);
      $checkbox.div.addEventListener("keypress", click, false);
    })();
    this.update = function () {
      toggle();
    };
    this.onDestroy = function () {
      $checkbox.div.removeEventListener("focus", focus, false);
      $checkbox.div.removeEventListener("blur", blur, false);
      $checkbox.div.removeEventListener("click", click, false);
      $checkbox.div.removeEventListener("keypress", click, false);
    };
  });
  Class(function UILControlColor(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $hex;
    let $colorPicker;
    let $hexInput;
    let $colorInput;
    function syncColorValue(frame, hexUpdate = false) {
      let needsUpdate = true;
      if (hexUpdate) {
        if ($hexInput.div.value !== _this.value) {
          _this.value = $hexInput.div.value;
        }
      } else if ($colorInput.div.value !== _this.value) {
        _this.value = $colorInput.div.value;
      } else {
        needsUpdate = false;
      }
      if (needsUpdate) {
        $hexInput.div.value = _this.value;
        $colorInput.div.value = _this.value;
        $colorPicker.bg(_this.value);
      }
    }
    function onClick() {
      $colorInput.div.click();
      $colorInput.div.focus();
      _this.startRender(syncColorValue, 24);
    }
    function onTextFocus() {
      $hexInput.div.select();
    }
    function onColorBlur() {
      _this.stopRender(syncColorValue);
      finishChange();
    }
    function onChange(v) {
      syncColorValue(0, true);
      finishChange();
    }
    function finishChange() {
      _this.finish();
    }
    (function init() {
      _opts.value = _opts.value || "#ffffff";
      _this.init(_id, _opts);
    })();
    (function initInput() {
      let $view = $("color");
      $view.css({
        position: "relative",
        display: "flex"
      });
      $hex = $view.create("colorHex");
      $hex.size("100%", "100%");
      $hex.css({
        boxSizing: "border-box",
        flex: "2",
        marginRight: 4
      });
      $hexInput = $hex.create("hex", "input");
      $hexInput.size("100%").css({
        fontSize: 12,
        fontFamily: "sans-serif",
        padding: 1,
        color: "#37A1EF",
        border: "1px solid #2E2E2E"
      }).bg("#1D1D1D");
      $hexInput.attr("value", _this.value);
      $hexInput.attr("maxlength", 7);
      $colorPicker = $view.create("colorPicker");
      $colorPicker.size("100%", "auto").bg(_this.value);
      $colorPicker.css({
        border: "1px solid #2E2E2E",
        position: "relative",
        flex: "3"
      });
      $colorInput = $colorPicker.create("colorInput", "input");
      $colorInput.attr("type", "color");
      $colorInput.attr("value", _this.value);
      $colorInput.size(0, 0).css({
        border: 0,
        top: 6,
        zIndex: -1,
        position: "absolute"
      });
      _this.view = $view;
    })();
    (function addHandlers() {
      $colorPicker.interact(null, onClick);
      finishChange = _this.debounce(finishChange, 250);
      $hexInput.div.addEventListener("input", onChange, false);
      $hexInput.div.addEventListener("focus", onTextFocus, false);
      $hexInput.div.addEventListener("change", finishChange, false);
      $colorInput.div.addEventListener("blur", onColorBlur, false);
    })();
    this.force = function (value) {
      $hexInput.div.value = value;
      syncColorValue(0, true);
    };
    this.update = function () {
      $hexInput.attr("value", _this.value);
      $colorPicker.bg(_this.value);
      $colorInput.attr("value", _this.value);
      finishChange();
    };
    this.onDestroy = function () {
      $hexInput.div.removeEventListener("input", onChange, false);
      $hexInput.div.removeEventListener("focus", onTextFocus, false);
      $hexInput.div.removeEventListener("change", finishChange, false);
      $colorInput.div.removeEventListener("blur", onColorBlur, false);
    };
  });
  Class(function UILControlFile(_id, _opts = {
    value: {}
  }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview;
    let $img;
    let $input;
    let $$copy;
    let $progress;
    let _value;
    async function change(e) {
      let file = $picker.div.files[0];
      if (!file) {
        return;
      }
      let name = file.name;
      if (window.UIL_REMOTE) {
        const {
          customMetadata: customMetadata
        } = await UILStorage.uploadFileToRemoteBucket({
          file: file,
          progress: $progress
        });
        name = customMetadata.path;
      }
      _value.filename = name;
      _value.relative = function getRelative() {
        if (_value.filename.includes("http")) {
          return "";
        } else if (_value.relative.includes(_value.prefix)) {
          return _value.relative.replace(`${_value.prefix}`, "");
        } else {
          return _value.relative;
        }
      }();
      _value.src = function getSrc() {
        if (_value.filename.includes("http")) {
          return _value.filename;
        } else {
          return `${_value.prefix ? _value.prefix + "/" : ""}${_value.relative ? _value.relative + "/" : ""}${_value.filename}`;
        }
      }();
      if (await function fileExists(url) {
        return !!url.includes("http") || fetch(Assets.getPath(url)).then(e => e.status != 404).catch(e => console.warn("UILControlFile image url validation failed", e));
      }(_value.src)) {
        _this.value = Object.assign({}, _value);
        $img.attr("title", _value.src);
        $$copy.text(_value.filename);
        _this.finish();
      } else {
        $picker.div.value = "";
        console.warn("UIL: Could not find file", _value);
        alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
      }
    }
    function focus() {
      $img.css({
        border: "1px solid #37a1ef"
      });
    }
    function blur() {
      $img.css({
        border: "1px dotted #2e2e2e"
      });
    }
    function inputChange() {
      _value.relative = $input.div.value;
      if (_value.relative.includes(".")) {
        _this.value = Object.assign({}, _value);
        _this.finish();
      }
    }
    (function init() {
      _opts.value = Object.assign({
        src: "",
        relative: _opts.relative || "",
        prefix: _opts.prefix,
        filename: ""
      }, _opts.value);
      _value = Object.assign({}, _opts.value);
      _this.init(_id, _opts);
    })();
    (function initView() {
      $view = $("view");
      $view.css({
        position: "relative",
        padding: 5
      });
      $input = $view.create("path", "input");
      $input.size("100%").bg("#1D1D1D");
      $input.css({
        boxSizing: "border-box",
        border: "1px solid #2E2E2E",
        color: "#37A1EF",
        marginBottom: 5
      });
      if (_this.value.relative) {
        $input.div.value = _this.value.relative;
      } else {
        $input.attr("placeholder", "Relative Path");
      }
      $preview = $view.create("preview");
      $preview.size("100%", 60);
      $preview.css({
        boxSizing: "border-box",
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      });
      $img = $preview.create("img");
      $img.size("100%");
      $img.css({
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundSize: "cover",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        border: "1px dotted #2e2e2e",
        boxSizing: "border-box"
      });
      $picker = $preview.create("picker", "input");
      $picker.attr("type", "file");
      $picker.css({
        opacity: 0,
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      });
      $progress = $preview.create("progress");
      $progress.css({
        position: "absolute",
        bottom: 0,
        height: 10,
        left: 0,
        background: "#9B9C9B"
      });
      $$copy = $preview.create("copy");
      $$copy.html("Drag file here<br><small>or Click to Select</small>");
      $$copy.fontStyle("sans-serif", 11, "#9B9C9B").css({
        textAlign: "center"
      });
      _this.view = $view;
      if (_value.src) {
        $img.attr("title", _value.src);
        $$copy.text(_value.filename);
      }
    })();
    (function addHandlers() {
      $picker.div.addEventListener("change", change, false);
      $picker.div.addEventListener("focus", focus, false);
      $picker.div.addEventListener("blur", blur, false);
      $input.div.addEventListener("change", inputChange, false);
    })();
    this.force = function (value) {
      _value = Object.assign({}, value);
      $input.div.value = _value.relative;
      $img.attr("title", _value.src);
      $$copy.text(_value.filename);
    };
    this.onDestroy = function () {
      $picker.div.removeEventListener("change", change, false);
      $picker.div.removeEventListener("focus", focus, false);
      $picker.div.removeEventListener("blur", blur, false);
      $input.div.removeEventListener("change", inputChange, false);
    };
  });
  Class(function UILControlImage(_id, _opts = {
    value: {}
  }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview;
    let $img;
    let $input;
    let $check;
    let $compress;
    let $delete;
    let $progress;
    let _value;
    async function compressClick() {
      if (_value.src && !_this.flag("compressPending")) {
        _this.flag("compressPending", true);
        $compress.bg("#f4ee42").text("---");
        try {
          if ((await Dev.execUILScript("compressktx", {
            src: _value.src.split("?")[0]
          })) == "Error") {
            $compress.bg("#f44141").html("Failed");
          } else {
            $compress.bg("#46f441").html("Success");
          }
        } catch (e) {
          $compress.bg("#f44141").html("Failed");
          console.error(e);
        }
        _this.flag("compressPending", false);
      }
    }
    function checkChange() {
      _this.value.compressed = _value.compressed = !!$check.div.checked;
      _this.finish(false);
    }
    async function change(e) {
      let file = $picker.div.files[0];
      if (!file) {
        return;
      }
      let name = file.name;
      if (window.UIL_REMOTE) {
        const {
          customMetadata: customMetadata
        } = await UILStorage.uploadFileToRemoteBucket({
          file: file,
          progress: $progress
        });
        name = customMetadata.path;
      }
      _value.filename = name;
      _value.relative = function getRelative() {
        if (_value.filename.includes("http")) {
          return "";
        } else if (_value.relative.includes(_value.prefix)) {
          return _value.relative.replace(`${_value.prefix}`, "");
        } else {
          return _value.relative;
        }
      }();
      _value.src = function getSrc() {
        if (_value.filename.includes("http")) {
          return _value.filename;
        } else {
          return `${_value.prefix ? _value.prefix + "/" : ""}${_value.relative ? _value.relative + "/" : ""}${_value.filename}`;
        }
      }();
      _value.compressed = !!$check.div.checked;
      if (await function imageExists(url) {
        return !!url.includes("http") || (url = Assets.getPath(url), fetch(url).then(e => e.status != 404).catch(e => console.warn("UILControlImage image url validation failed", e)));
      }(_value.src)) {
        _this.value = Object.assign({}, _value);
        $picker.div.value = "";
        $picker.attr("title", _value.src);
        $img.css({
          backgroundImage: `url(${Assets.getPath(_value.src)})`
        });
        $delete.show();
        _this.finish();
      } else {
        $picker.div.value = "";
        console.warn("UIL: Could not find image", _value);
        alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
      }
    }
    function deleteImage() {
      _value = {
        src: "",
        relative: "",
        prefix: "assets/images",
        filename: ""
      };
      $input.div.value = "";
      $picker.div.value = "";
      $picker.attr("title", null);
      $img.css({
        backgroundImage: ""
      });
      $delete.hide();
      _this.value = Object.assign({}, _value);
      _this.finish();
    }
    function focus() {
      $img.css({
        border: "1px solid #37a1ef"
      });
    }
    function blur() {
      $img.css({
        border: "1px dotted #2e2e2e"
      });
    }
    function inputChange() {
      _value.relative = $input.div.value;
    }
    (function init() {
      _opts.value = Object.assign({
        src: "",
        relative: _opts.relative || "",
        prefix: _opts.prefix || "assets/images",
        filename: ""
      }, _opts.value);
      _value = Object.assign({}, _opts.value);
      _this.init(_id, _opts);
    })();
    (function initView() {
      $view = $("view");
      $view.css({
        position: "relative",
        padding: 5
      });
      $input = $view.create("path", "input");
      $input.size("100%").bg("#1D1D1D");
      $input.css({
        boxSizing: "border-box",
        border: "1px solid #2E2E2E",
        color: "#37A1EF",
        marginBottom: 5
      });
      if (_this.value.relative) {
        $input.div.value = _this.value.relative;
      } else {
        $input.attr("placeholder", "Relative Path");
      }
      $compress = $view.create("compress");
      $compress.text("Compress").bg("#fff").css({
        top: 3,
        width: 70,
        height: 15,
        textAlign: "center",
        borderRadius: 5,
        position: "relative",
        float: "left",
        paddingTop: 2
      }).fontStyle("sans-serif", 11, "#000");
      $check = $view.create("#compressed", "input");
      $check.attr("type", "checkbox");
      $check.size(20, 20);
      $check.css({
        boxSizing: "border-box",
        position: "relative"
      });
      $check.div.checked = !!_this.value.compressed;
      let $label = $view.create("compressed-label", "label");
      $label.attr("for", "compressed");
      $label.text("Use Compressed").fontStyle("sans-serif", 9, "#9B9C9B").css({
        top: -6,
        position: "relative"
      });
      $preview = $view.create("preview");
      $preview.size("100%", 60);
      $preview.css({
        boxSizing: "border-box",
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      });
      $img = $preview.create("img");
      $img.size("100%");
      $img.css({
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundSize: "cover",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        border: "1px dotted #2e2e2e",
        boxSizing: "border-box"
      });
      $picker = $preview.create("picker", "input");
      $picker.attr("type", "file");
      $picker.attr("accept", "image/*");
      $picker.css({
        opacity: 0,
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      });
      $progress = $preview.create("progress");
      $progress.css({
        position: "absolute",
        bottom: 0,
        height: 10,
        left: 0,
        background: "#9B9C9B"
      });
      $delete = $preview.create("delete", "button");
      $delete.size(18, 18).css({
        border: "none",
        padding: 0,
        position: "absolute",
        top: 8,
        right: 8,
        borderRadius: "50%",
        background: "#1D1D1D",
        color: "#9B9C9B",
        textAlign: "center"
      }).html("<svg width=\"10\" height=\"10\" viewBox=\"0 0 10 10\" fill=\"none\" stroke=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-width=\"2\" stroke-linecap=\"round\" d=\"M2 2l6 6M2 8l6-6\"/></svg>");
      $delete.hide();
      let copy = $preview.create("copy");
      copy.html("Drag image here<br><small>or Click to Select</small>");
      copy.fontStyle("sans-serif", 11, "#9B9C9B").css({
        textAlign: "center"
      });
      if (_this.value.src) {
        $img.css({
          backgroundImage: `url('${Assets.getPath(_this.value.src)}')`
        });
        $picker.attr("title", _this.value.src);
        $delete.show();
      }
      _this.view = $view;
    })();
    (function addHandlers() {
      $picker.div.addEventListener("change", change, false);
      $picker.div.addEventListener("focus", focus, false);
      $picker.div.addEventListener("blur", blur, false);
      $input.div.addEventListener("change", inputChange, false);
      $delete.div.onclick = deleteImage;
      $compress.div.onclick = compressClick;
      $check.div.onchange = checkChange;
    })();
    this.force = function (value, isClipboard) {
      _value = Object.assign({}, value);
      if (isClipboard === true) {
        _this.value = _value;
      }
      $input.div.value = _value.relative;
      $picker.div.value = "";
      $picker.attr("title", _value.src);
      $img.css({
        backgroundImage: `url('${Assets.getPath(_value.src)}')`
      });
      $check.div.checked = _value.compressed;
    };
    this.onDestroy = function () {
      $picker.div.removeEventListener("change", change, false);
      $picker.div.removeEventListener("focus", focus, false);
      $picker.div.removeEventListener("blur", blur, false);
      $input.div.removeEventListener("change", inputChange, false);
    };
  });
  Class(function UILControlNumber(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let _input;
    (function init() {
      _opts.value = _opts.value || 0;
      _this.init(_id, _opts);
    })();
    (function initInput() {
      _input = _this.initClass(UILInputNumber, Object.assign(_opts, {
        value: _this.value
      }));
      _input.onInput(v => _this.value = v);
      _input.onFinish(v => _this.finish());
      _this.view = _input.input;
    })();
    this.update = function (value) {
      _input.value = _this.value || 0;
    };
  });
  Class(function UILControlRange(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $slider;
    let _max = _opts.max || 100;
    let _min = _opts.min || 0;
    let _step = _opts.step || 1;
    function change() {
      _this.finish();
    }
    function input(e) {
      _this.value = Number($slider.div.value);
    }
    function focus() {
      $slider.css({
        border: "1px solid #37a1ef"
      });
    }
    function blur() {
      $slider.css({
        border: "1px solid #2e2e2e"
      });
    }
    (function init() {
      _opts.value = _opts.value || 0;
      _this.init(_id, _opts);
    })();
    (function style() {
      UIL.addCSS(UILControlRange, "\n            .UILControlRange input { -webkit-appearance:none; appearance:none; }\n            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }\n            .UILControlRange input::-webkit-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n            .UILControlRange input::-moz-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n        ");
    })();
    (function initView() {
      $view = $("view");
      $slider = $view.create("range", "input");
      $slider.attr("type", "range");
      $slider.attr("max", _max);
      $slider.attr("min", _min);
      $slider.attr("step", _step);
      $slider.div.value = _this.value;
      $slider.css({
        width: "100%",
        margin: 0,
        padding: 0,
        background: "#1d1d1d",
        height: 4,
        borderRadius: 15,
        border: "1px solid #2e2e2e",
        boxSizing: "border-box"
      });
      _this.view = $view;
    })();
    (function addHandlers() {
      $slider.div.addEventListener("change", change, false);
      $slider.div.addEventListener("input", input, false);
      $slider.div.addEventListener("focus", focus, false);
      $slider.div.addEventListener("blur", blur, false);
    })();
    this.force = function (value) {
      _this.value = value;
      $slider.div.value = value;
      _this.finish(false);
    };
    this.onDestroy = function () {
      $slider.div.removeEventListener("change", change, false);
      $slider.div.removeEventListener("input", input, false);
      $slider.div.removeEventListener("focus", focus, false);
      $slider.div.removeEventListener("blur", blur, false);
    };
  });
  Class(function UILControlSelect(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $select;
    let _options;
    function change() {
      _this.finish();
    }
    function input() {
      let i = $select.div.selectedIndex;
      _this.value = _options[i].value;
    }
    function focus() {
      $select.css({
        border: "1px solid #37a1ef"
      });
    }
    function blur() {
      $select.css({
        border: "1px solid #2e2e2e"
      });
    }
    (function init() {
      if (!_opts.options) {
        throw "UILControlSelect is missing select options";
      }
      _opts.value = _opts.value || _opts.options[0].value;
      _this.init(_id, _opts);
    })();
    (function style() {
      UIL.addCSS(UILControlSelect, "\n            .UILControlSelect select { -webkit-appearance:none; appearance:none; }\n        ");
    })();
    (function initView() {
      $view = $("view");
      $view.css({
        position: "relative"
      });
      $select = $view.create("dropdown", "select");
      $select.css({
        width: "100%",
        margin: 0,
        padding: 0,
        background: "#1d1d1d",
        height: 15,
        border: "1px solid #2e2e2e",
        boxSizing: "border-box",
        color: "#37a1ef",
        borderRadius: 0,
        height: 17
      });
      $view.create("arrow").text("").css({
        color: "#37a1ef",
        fontSize: 6,
        position: "absolute",
        right: 8,
        top: 7,
        pointerEvents: "none"
      });
      _this.view = $view;
    })();
    (function initOptions() {
      _options = _opts.options.map(({
        value: value,
        label: label
      }) => {
        let el = document.createElement("option");
        el.setAttribute("value", value);
        if (_this.value === value) {
          el.setAttribute("selected", true);
        }
        el.text = label || value;
        el.value = value;
        $select.add(el);
        return el;
      });
      $select.div.value = _this.value;
    })();
    (function addHandlers() {
      $select.div.addEventListener("change", change, false);
      $select.div.addEventListener("input", input, false);
      $select.div.addEventListener("focus", focus, false);
      $select.div.addEventListener("blur", blur, false);
    })();
    this.force = function (value) {
      $select.div.value = value;
      _this.value = value;
    };
    this.onDestroy = function () {
      $select.div.removeEventListener("change", change, false);
      $select.div.removeEventListener("input", input, false);
      $select.div.removeEventListener("focus", focus, false);
      $select.div.removeEventListener("blur", blur, false);
    };
  });
  Class(function UILControlText(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;
    function onChange(v) {
      clearTimeout(_timeout);
      _timeout = setTimeout(onFinishChange, 400);
      _this.value = $input.div.value;
    }
    function onFinishChange() {
      if (_timeout !== null) {
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
      }
    }
    _this.init(_id, _opts);
    (function initInput() {
      $input = $("input", "input");
      $input.size("100%").bg("#1D1D1D");
      $input.css({
        boxSizing: "border-box",
        border: "1px solid #2E2E2E",
        color: "#37A1EF"
      });
      if (_this.value) {
        $input.div.value = _this.value || "";
      }
      _this.view = $input;
    })();
    (function addHandlers() {
      $input.div.addEventListener("input", onChange, false);
      $input.div.addEventListener("change", onFinishChange, false);
    })();
    this.update = function () {
      $input.div.value = _this.value || "";
    };
    this.onDestroy = function () {
      $input.div.removeEventListener("input", onChange, false);
      $input.div.removeEventListener("change", onBlur, false);
    };
  });
  Class(function UILControlTextarea(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;
    function onChange(v) {
      clearTimeout(_timeout);
      _timeout = setTimeout(onFinishChange, 400);
      _this.value = $input.div.value;
    }
    function onFinishChange() {
      if (_timeout !== null) {
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
      }
    }
    _this.init(_id, _opts);
    (function initInput() {
      $input = $("input", "textarea");
      $input.attr("maxlength", _opts.max || Infinity);
      $input.attr("minlength", _opts.min || -Infinity);
      $input.attr("rows", _opts.rows || 2);
      $input.attr("readonly", _opts.readonly || false);
      $input.size("100%").bg("#1D1D1D");
      $input.css({
        boxSizing: "border-box",
        resize: _opts.resize || "vertical",
        minWidth: _opts.minWidth || 0,
        border: "1px solid #2E2E2E",
        color: "#37A1EF"
      });
      if (_opts.monospace || _opts.editor) {
        $input.css({
          fontFamily: "monospace"
        });
      }
      if (_this.value) {
        $input.div.value = _this.value || "";
      }
      _this.view = $input;
    })();
    if (_opts.editor) {
      (function enableTab() {
        $input.div.onkeydown = function (e) {
          if (e.keyCode === 9) {
            let val = this.value;
            let start = this.selectionStart;
            let end = this.selectionEnd;
            this.value = val.substring(0, start) + "\t" + val.substring(end);
            this.selectionStart = this.selectionEnd = start + 1;
            e.preventDefault();
          }
        };
      })();
    }
    (function addHandlers() {
      $input.div.addEventListener("input", onChange, false);
      $input.div.addEventListener("change", onFinishChange, false);
    })();
    this.update = function () {
      $input.div.value = _this.value || "";
    };
    this.onDestroy = function () {
      $input.div.removeEventListener("input", onChange, false);
      $input.div.removeEventListener("change", onBlur, false);
    };
  });
  Class(function UILControlVector(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _length;
    let _inputs = [];
    let _vector = [];
    function onInput(value, index, master) {
      if (master) {
        _vector = _vector.map(v => value);
      } else {
        _vector[index] = value;
      }
      _this.value = [..._vector];
    }
    function onFinish(value, index, master) {
      _this.finish();
    }
    (function init() {
      if (_opts.value) {
        _length = _vector.length;
      } else {
        if (!_opts.components) {
          throw "UILControlVector: Cannot detect vector type. Define \"options.components\" count or init with a initial value";
        }
        _opts.value = new Array(_opts.components).fill(0);
      }
      _length = _opts.value.length;
      _this.init(_id, _opts);
      _vector = [..._this.value];
    })();
    (function initInputs() {
      $view = $("inputs");
      for (let i = 0; i < _length; i++) {
        let input = _this.initClass(UILInputNumber, _opts);
        input.value = _this.value[i];
        input.onInput((v, m) => onInput(v, i, m));
        input.onFinish((v, m) => onFinish(v, i, m));
        input.input.css({
          display: "inline-block",
          width: `calc(100% / ${_length})`
        });
        _inputs.push(input);
        $view.add(input.input);
      }
      _this.view = $view;
    })();
    this.force = function (value, history = false) {
      _vector = [...value];
      _this.value = [..._vector];
      _inputs.forEach((input, index) => input.value = _this.value[index]);
      _this.finish(history);
    };
    this.update = function () {
      _inputs.forEach((input, index) => input.value = _this.value[index]);
    };
  });
  Class(function UILInputNumber(_opts = {}) {
    Inherit(this, Component);
    const _this = this;
    let $input;
    let _timeout;
    let _distance;
    let _onMouseDownValue;
    let _editing = false;
    let _precision = _opts.precision || 3;
    let _step = _opts.step || 1;
    let _min = _opts.min || -Infinity;
    let _max = _opts.max || Infinity;
    let _value = _opts.value || 0;
    let _pointer = [0, 0];
    let _prevPointer = [0, 0];
    let _onInputCB = () => {};
    let _onFinishCB = () => {};
    function setValue(value) {
      if ((value = parseFloat(value) || 0) < _min) {
        value = _min;
      }
      if (value > _max) {
        value = _max;
      }
      _value = value;
      _onInputCB(value, _this.master);
    }
    function onBlur() {
      onFinishChange();
      $input.div.value = parseFloat(_value).toFixed(_precision);
    }
    function onKeyUp(e) {
      if (e.keyCode === 13 && e.altKey) {
        _this.master = true;
        onInput();
      }
    }
    function onInput(e) {
      _timeout = setTimeout(onFinishChange, 400);
      _editing = true;
      setValue(parseFloat($input.div.value));
    }
    function onFinishChange() {
      if (_editing) {
        _editing = false;
        clearTimeout(_timeout);
        _onFinishCB(_value, _this.master);
        _this.master = false;
      }
    }
    function onMouseDown(e) {
      if (e.button === 1 || e.button === 0 && e.metaKey || e.ctrlKey) {
        e.preventDefault();
        $input.css({
          cursor: "col-resize"
        });
        _distance = 0;
        _onMouseDownValue = _value;
        _prevPointer = [e.screenX, e.screenY];
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mouseup", onMouseUp, false);
      }
    }
    function onMouseMove(e) {
      clearTimeout(_timeout);
      _editing = true;
      let currentValue = _value;
      _pointer = [e.screenX, e.screenY];
      _distance += _pointer[0] - _prevPointer[0] - (_pointer[1] - _prevPointer[1]);
      let value = _onMouseDownValue + _distance / (e.shiftKey ? 5 : 50) * _step;
      value = Math.min(_max, Math.max(_min, value));
      _this.master = e.altKey;
      if (currentValue !== value) {
        (function setValueDrag(value) {
          if (value !== undefined || value !== $input.div.value) {
            setValue(value);
            $input.div.value = _value.toFixed(_precision);
          }
        })(value);
      }
      _prevPointer = [e.screenX, e.screenY];
    }
    function onMouseUp(e) {
      onFinishChange();
      $input.css({
        cursor: ""
      });
      document.removeEventListener("mousemove", onMouseMove, false);
      document.removeEventListener("mouseup", onMouseUp, false);
    }
    (function initInput() {
      $input = $("input", "input");
      $input.attr("type", "number");
      $input.attr("step", _step);
      $input.size("100%").bg("#1D1D1D");
      $input.css({
        boxSizing: "border-box",
        border: "1px solid #2E2E2E",
        color: "#37A1EF",
        boxShadow: "none"
      });
      $input.div.value = parseFloat(_value).toFixed(_precision);
      _this.input = $input;
    })();
    (function addHandlers() {
      $input.div.addEventListener("mousedown", onMouseDown, false);
      $input.div.addEventListener("keyup", onKeyUp, false);
      $input.div.addEventListener("change", onFinishChange, false);
      $input.div.addEventListener("blur", onBlur, false);
      $input.div.addEventListener("input", onInput, false);
    })();
    this.set("value", value => {
      _value = value;
      if (!_editing) {
        $input.div.value = parseFloat(value).toFixed(_precision);
      }
    });
    this.get("value", () => _value);
    this.onInput = cb => _onInputCB = cb;
    this.onFinish = cb => _onFinishCB = cb;
    this.onDestroy = function () {
      $input.div.removeEventListener("mousedown", onMouseDown, false);
      $input.div.removeEventListener("change", onFinishChange, false);
      $input.div.removeEventListener("blur", onBlur, false);
      $input.div.removeEventListener("input", onInput, false);
    };
  });
  Class(function UILExternalColor(_title, _value) {
    Inherit(this, Component);
    const _this = this;
    var _window;
    function onReload() {
      _this.onDestroy();
    }
    (_window = window.open(location.protocol + "//localhost/hydra/editor/color/index.html", `hydra_color_${_title}`, "width=480,height=220,left=200,top=100,location=no")).window.onload = _ => {
      _window.window.initPicker(_title, _value, _this);
    };
    window.addEventListener("beforeunload", onReload);
    this.update = function (value) {
      _this.events.fire(Events.UPDATE, {
        value: value
      });
    };
    this.onDestroy = function () {
      window.removeEventListener("beforeunload", onReload);
      if (_window && _window.window) {
        _window.window.close();
      }
    };
  });
  Class(function UILExternalEditor(_title, _height = 500, _width = 700) {
    Inherit(this, Component);
    const _this = this;
    var _window;
    var _code;
    var _language;
    _window = window.open(location.protocol + "//localhost/hydra/editor/code/index.html", "_blank", `width=${_width},height=${_height},left=200,top=100`);
    _this.events.sub(Events.UNLOAD, _ => _window.close());
    _window.window.onload = _ => {
      _window.window.initEditor(_title, _code, _language, _this);
    };
    this.setCode = function (code, language) {
      _code = code;
      _language = language;
    };
    this.saved = async function (code) {
      if (_this.onSave) {
        _this.onSave(code);
      }
      await defer();
      UILStorage.write();
    };
  });
  Class(function UILPanelToolbar() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $filter;
    let _state = new Map();
    function restoreFolderState() {
      _this.parent.folder.forEachFolder(folder => {
        if (_state.get(folder)) {
          folder.open();
        } else {
          folder.close();
        }
      });
      _state.clear();
    }
    function onInput(e) {
      if (!$filter.div.value.length) {
        restoreFolderState();
        return _this.parent.folder.showChildren();
      }
      _this.parent.folder.filter($filter.div.value);
    }
    function onFocus() {
      (function saveFolderState() {
        _this.parent.folder.forEachFolder(folder => {
          _state.set(folder, folder.isOpen());
        });
      })();
      $filter.css({
        border: "1px solid #37a1ef"
      });
    }
    function onBlur() {
      $filter.css({
        border: "1px solid #2e2e2e"
      });
    }
    function onKeyPressed(e) {
      if (e.keyCode === 27) {
        $filter.div.value = "";
        restoreFolderState();
        return _this.parent.folder.showChildren();
      }
    }
    (function initHTML() {
      $this = _this.element;
      $this.size("100%", "auto").bg("#272727");
      $this.css({
        padding: 4,
        boxSizing: "border-box",
        marginBottom: 4
      });
    })();
    (function initFilter() {
      $filter = $this.create("filter", "input");
      $filter.div.addEventListener("input", onInput, false);
      $filter.div.addEventListener("keydown", onKeyPressed, false);
      $filter.div.addEventListener("focus", onFocus, false);
      $filter.div.addEventListener("blur", onBlur, false);
      $filter.size("100%", "auto").bg("#161616");
      $filter.css({
        color: "#B1B1B1",
        border: "1px solid #2e2e2e",
        outline: "none",
        padding: 2,
        boxSizing: "border-box"
      });
    })();
    this.eliminate = function () {
      $filter.div.removeEventListener("input", onInput, false);
      $filter.div.removeEventListener("keydown", onKeyPressed, false);
      $filter.div.removeEventListener("focus", onFocus, false);
      $filter.div.removeEventListener("blur", onBlur, false);
    };
    this.filter = function (text) {
      $filter.div.value = text;
      onInput();
    };
    this.filterSingle = function (text) {
      $filter.div.value = text;
      _this.parent.folder.filterSingle($filter.div.value);
    };
    this.hideAll = function () {
      if (!_this.flag("init")) {
        _this.flag("init", true);
        this.filterSingle("xxxxxx");
      }
    };
  });
  Namespace("FX");
  FX.Class(function UnrealBloom(_nuke, options, _unique) {
    Inherit(this, Component);
    var _triangleGeometry;
    var _luminosityShader;
    var _compositeShader;
    var _mesh;
    var _inputTexture;
    var _this = this;
    if (typeof options == "string") {
      _unique = _params;
      options = {};
      _nuke = World.NUKE;
    } else if (typeof _nuke == "string") {
      _unique = _nuke;
      options = {};
      _nuke = World.NUKE;
    } else if (!_nuke || _nuke instanceof Nuke) {
      _nuke = _nuke || World.NUKE;
      options = options || {};
      _unique = _unique || "";
    } else {
      options = _nuke;
      _nuke = World.NUKE;
    }
    var _oldClearColor = new Color();
    var _oldClearAlpha = 1;
    var _renderTargetsHorizontal = [];
    var _renderTargetsVertical = [];
    var _separableBlurShaders = [];
    var _nMips = options.nMips || 5;
    var _DPR = _nuke.dpr;
    var _blurDirectionX = new Vector2(_DPR, 0);
    var _blurDirectionY = new Vector2(0, _DPR);
    var _kernelSizeArray = options.kernelSizeArray || [3, 5, 7, 9, 11];
    var _bloomFactors = options.bloomFactors || [1, 0.8, 0.6, 0.4, 0.2];
    var _useRTPool = options.useRTPool || false;
    function render() {
      if (!_this.enabled || _this.visible === false) {
        return;
      }
      let renderer = _nuke.renderer;
      _oldClearColor.copy(renderer.getClearColor());
      _oldClearAlpha = renderer.getClearAlpha();
      let oldAutoClear = renderer.autoClear;
      renderer.autoClear = true;
      renderer.setClearColor(_this.clearColor, 0);
      let inputRenderTarget = _inputTexture || _nuke.rttBuffer.texture;
      if (_luminosityShader.uniforms.luminosityThreshold.value > 0.01) {
        _luminosityShader.uniforms.tDiffuse.value = inputRenderTarget;
        _mesh.shader = _luminosityShader;
        renderer.renderSingle(_mesh, _nuke.camera, _this.renderTargetBright);
        inputRenderTarget = _this.renderTargetBright;
      }
      for (let i = 0; i < _nMips; i++) {
        _mesh.shader = _separableBlurShaders[i];
        _separableBlurShaders[i].uniforms.colorTexture.value = inputRenderTarget;
        _separableBlurShaders[i].uniforms.direction.value = _blurDirectionX;
        renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsHorizontal[i]);
        _separableBlurShaders[i].uniforms.colorTexture.value = _renderTargetsHorizontal[i].texture;
        _separableBlurShaders[i].uniforms.direction.value = _blurDirectionY;
        renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsVertical[i]);
        inputRenderTarget = _renderTargetsVertical[i];
      }
      _mesh.shader = _compositeShader;
      renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsHorizontal[0]);
      renderer.setClearColor(_oldClearColor, _oldClearAlpha);
      renderer.autoClear = oldAutoClear;
    }
    function resizeHandler() {
      _this.resolution.set(_nuke.stage.width, _nuke.stage.height).multiplyScalar(_DPR);
      _blurDirectionX.x = _DPR;
      _blurDirectionY.y = _DPR;
      let resx = Math.round(_this.resolution.x / 2);
      let resy = Math.round(_this.resolution.y / 2);
      if (_this.renderTargetBright) {
        _this.renderTargetBright.setSize(resx, resy);
      }
      for (var i = 0; i < _renderTargetsHorizontal.length; i++) {
        _renderTargetsHorizontal[i].setSize(resx, resy);
        _renderTargetsVertical[i].setSize(resx, resy);
        _separableBlurShaders[i].uniforms.texSize.value = new Vector2(resx, resy);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }
    }
    this.uniforms = {
      tUnrealBloom: {
        value: null,
        ignoreUIL: true
      },
      unique: _unique
    };
    this.resolution = new Vector2(_nuke.stage.width * _DPR, _nuke.stage.height * _DPR);
    this.clearColor = new Color(0, 0, 0);
    this.enabled = typeof options.enabled != "boolean" || options.enabled;
    this.outputTexture = null;
    (function initRTs() {
      if (_useRTPool) {
        RTPool.instance(null, 3, Texture.RGBAFormat).disableResize();
        return;
      }
      let pars = {
        minFilter: Texture.LINEAR,
        magFilter: Texture.LINEAR,
        format: Texture.RGBAFormat
      };
      let resx = Math.round(_this.resolution.x / 2);
      let resy = Math.round(_this.resolution.y / 2);
      _this.renderTargetBright = new RenderTarget(resx, resy, pars);
      _this.renderTargetBright.texture.generateMipmaps = false;
      for (let i = 0; i < _nMips; i++) {
        let renderTargetHorizonal = new RenderTarget(resx, resy, pars);
        renderTargetHorizonal.texture.generateMipmaps = false;
        _renderTargetsHorizontal.push(renderTargetHorizonal);
        let renderTargetVertical = new RenderTarget(resx, resy, pars);
        renderTargetVertical.texture.generateMipmaps = false;
        _renderTargetsVertical.push(renderTargetVertical);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }
      _this.outputTexture = _renderTargetsHorizontal[0].texture;
      _this.uniforms.tUnrealBloom.value = _renderTargetsHorizontal[0].texture;
    })();
    (function initScene() {
      _triangleGeometry = World.QUAD;
      _luminosityShader = _this.initClass(Shader, "UnrealBloomLuminosity", {
        tDiffuse: {
          value: null,
          ignoreUIL: true
        },
        luminosityThreshold: {
          value: 1
        },
        smoothWidth: {
          value: 0.01,
          ignoreUIL: true
        },
        defaultColor: {
          value: new Color(0),
          ignoreUIL: true
        },
        defaultOpacity: {
          value: 0,
          ignoreUIL: true
        },
        unique: _unique
      });
      (_mesh = new Mesh(_triangleGeometry, _luminosityShader)).frustumCulled = false;
    })();
    (function initBlurShaders() {
      let resx = Math.round(_this.resolution.x / 2);
      let resy = Math.round(_this.resolution.y / 2);
      for (let i = 0; i < _nMips; i++) {
        let shader = _this.initClass(Shader, "UnrealBloomGaussian", {
          unique: _unique,
          colorTexture: {
            value: null
          },
          texSize: {
            value: new Vector2(resx, resy)
          },
          direction: {
            value: new Vector2(0.5, 0.5)
          }
        }, null, glsl => `\n#define KERNEL_RADIUS ${_kernelSizeArray[i]}\n#define SIGMA ${_kernelSizeArray[i]}\n${glsl}`, `gaussian${i}`);
        _separableBlurShaders.push(shader);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }
    })();
    (function initCompositeShader() {
      let uniforms = {
        bloomStrength: {
          value: 1
        },
        bloomTintColor: {
          value: new Color("#ffffff")
        },
        bloomRadius: {
          value: 0
        },
        unique: _unique
      };
      for (let i = 0; i < _nMips; i++) {
        uniforms[`blurTexture${i + 1}`] = {
          value: _useRTPool ? null : _renderTargetsVertical[i].texture,
          ignoreUIL: true
        };
      }
      (_compositeShader = _this.initClass(Shader, "UnrealBloomComposite", uniforms, null, (glsl, type) => {
        if (type === "vs") {
          return glsl;
        }
        let compositeUniforms = "";
        let compositeMain = "";
        for (let i = 0; i < _nMips; i++) {
          compositeUniforms += `uniform sampler2D blurTexture${i + 1};\n`;
          compositeMain += `lerpBloomFactor(${_bloomFactors[i].toFixed(4)}) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture${i + 1}, vUv) ${i < _nMips - 1 ? "+ " : ""}`;
        }
        return (glsl = glsl.replace("uniform sampler2D blurTexture1;", compositeUniforms)).replace("lerpBloomFactor(1.0) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture1, vUv)", compositeMain);
      })).needsUpdate = true;
    })();
    (function initPass() {
      _this.pass = _this.initClass(NukePass, "UnrealBloomPass", _this.uniforms);
    })();
    (function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
      _this.startRender(render, RenderManager.POST_RENDER);
    })();
    if (!options.noUIL) {
      ShaderUIL.add(_luminosityShader).setLabel("UnrealBloom Luminosity");
      ShaderUIL.add(_compositeShader).setLabel("UnrealBloom Composite");
    }
    this.set("texture", texture => {
      _inputTexture = texture;
    });
    this.get("luminosityShader", _ => _luminosityShader);
    this.get("compositeShader", _ => _compositeShader);
    this.set("dpr", dpr => {
      _DPR = dpr;
      resizeHandler();
    });
    this.renderBloom = render;
    this.renderMesh = _mesh;
    this.onDestroy = function () {
      _renderTargetsHorizontal.forEach(r => r.destroy());
      _renderTargetsVertical.forEach(r => r.destroy());
      if (_this.renderTargetBright) {
        _this.renderTargetBright.destroy();
      }
    };
    this.getRTs = function () {
      _this.renderTargetBright = RTPool.instance().getRT();
      for (let i = 0; i < _nMips; i++) {
        _renderTargetsHorizontal.push(RTPool.instance().getRT());
        _renderTargetsVertical.push(RTPool.instance().getRT());
        _compositeShader.uniforms[`blurTexture${i + 1}`].value = _renderTargetsVertical[i].texture;
      }
      _this.outputTexture = _renderTargetsHorizontal[0].texture;
      _this.uniforms.tUnrealBloom.value = _renderTargetsHorizontal[0].texture;
      resizeHandler();
    };
    this.putRTs = function () {
      if (_this.renderTargetBright) {
        RTPool.instance().putRT(_this.renderTargetBright);
      }
      _this.renderTargetBright = null;
      for (let i = 0; i < _renderTargetsHorizontal.length; i++) {
        RTPool.instance().putRT(_renderTargetsHorizontal[i]);
        RTPool.instance().putRT(_renderTargetsVertical[i]);
      }
      _renderTargetsHorizontal = [];
      _renderTargetsVertical = [];
    };
  });
  Class(function VelocityTracker(_vector) {
    Inherit(this, Component);
    var _this = this;
    var Vector = typeof _vector.z == "number" ? Vector3 : Vector2;
    var _velocity = new Vector();
    var _last = new Vector();
    function loop() {
      _velocity.subVectors(_vector, _last);
      _last.copy(_vector);
    }
    this.value = _velocity;
    this.start = function () {
      _this.startRender(loop);
    };
    this.onDestroy = this.stop = function () {
      _this.stopRender(loop);
    };
    this.copy = function () {
      _last.copy(_vector);
    };
    this.update = loop;
  });
  Class(function Video(_params) {
    Inherit(this, Component);
    const _this = this;
    let $video;
    let _video;
    let _loadingState;
    let _handlers;
    let _ready = Promise.create();
    let _loaded = Promise.create();
    let _initialPlay = true;
    function startPreload() {
      _loadingState = true;
      _video.load();
      return _ready;
    }
    async function startPlayback() {
      if (!_this.playing && (_loadingState = false, _video.readyState < 2 && (_video.load(), await _ready), !_this.playing)) {
        if (_initialPlay) {
          _initialPlay = false;
          if (_params.currentTime) {
            _video.currentTime = _params.currentTime;
          }
        }
        _this.playing = true;
        try {
          return await _video.play();
        } catch (error) {
          _this.playing = false;
          throw error;
        }
      }
    }
    function getSource(src = "") {
      if (src && !src.includes(["webm", "mp4", "ogv", "blob", "?"])) {
        src += "." + Device.media.video;
      }
      return src;
    }
    function progress(e) {
      _this.events.fire(Video.PROGRESS, e);
    }
    function timeupdate(e) {
      _this.events.fire(Video.UPDATE, e);
    }
    function play(e) {
      if (_loadingState) {
        return _loadingState = false;
      }
      _this.events.fire(Video.PLAY, e);
    }
    function pause(e) {
      _this.events.fire(Video.PAUSE, e);
    }
    function playing(e) {
      _this.events.fire(Video.PLAYING, e);
    }
    function ended(e) {
      _this.events.fire(Video.ENDED, e);
    }
    function waiting(e) {
      _this.events.fire(Video.WAITING, e);
    }
    function canplay(e) {
      loadeddata();
      _this.events.fire(Video.CANPLAY, e);
    }
    function loadedmetadata(e) {
      _this.dimensions.width = _video.videoWidth;
      _this.dimensions.height = _video.videoHeight;
      _this.events.fire(Video.LOADEDMETADATA, e);
    }
    function loadeddata(e) {
      if (_video.readyState >= 2) {
        _ready.resolve();
      }
      if (_video.readyState >= 4) {
        _loaded.resolve();
      }
    }
    function error() {
      _this.playing &&= false;
      _this.events.fire(Video.ERROR, _video.error);
    }
    (function initParam() {
      let defaults = {
        muted: true,
        loop: false,
        autoplay: false,
        inline: true,
        controls: false,
        currentTime: 0,
        playback: 1,
        preload: false,
        width: 640,
        height: 360,
        events: [],
        disableRemotePlayback: true
      };
      _params = Object.assign(defaults, _params);
    })();
    (function init() {
      _video = document.createElement("video");
      if (_params.src) {
        _video.src = getSource(_params.src);
      }
      _video.setAttribute("crossorigin", "anonymous");
      _video.disableRemotePlayback = _params.disableRemotePlayback;
      _video.autoplay = _params.autoplay;
      _video.loop = _params.loop;
      _video.controls = _params.controls;
      _video.height = _params.height;
      _video.width = _params.width;
      _video.defaultMuted = _params.muted;
      _video.defaultPlaybackRate = _params.playback;
      _video.preload = typeof _params.preload == "string" ? _params.preload : _params.preload ? "auto" : "none";
      _video.muted = _params.autoplay || _params.muted;
      _video.setAttribute("webkit-playsinline", _params.inline);
      _video.setAttribute("playsinline", _params.inline);
      _this.dimensions = {
        width: _params.width,
        height: _params.height
      };
      if (_video.autoplay) {
        _video.setAttribute("autoplay", _params.autoplay);
      }
      _video.setAttribute("muted", _params.muted);
      if (_params.loop) {
        _video.setAttribute("loop", _params.loop);
      }
      _this.div = _video;
      $video = $(_video);
      if (_params.autoplay) {
        return startPlayback();
      } else if (_params.preload) {
        return startPreload();
      } else {
        return undefined;
      }
    })();
    (function addHandlers() {
      ["loadedmetadata", "loadeddata", "error"].forEach(ev => {
        if (!_params.events.includes(ev)) {
          _params.events.push(ev);
        }
      });
      _handlers = {
        play: play,
        pause: pause,
        ended: ended,
        playing: playing,
        progress: progress,
        waiting: waiting,
        timeupdate: timeupdate,
        loadedmetadata: loadedmetadata,
        loadeddata: loadeddata,
        canplay: canplay,
        error: error
      };
      _params.events.forEach(ev => _video.addEventListener(ev, _handlers[ev], true));
    })();
    this.set("loop", bool => _video.loop = bool);
    this.get("loop", () => _video.loop);
    this.set("src", src => {
      if ((src = getSource(src)) !== _video.src) {
        _ready = Promise.create();
        _loaded = Promise.create();
        _video.src = src;
        if (_this.playing) {
          _this.playing = false;
          startPlayback();
        } else if (_params.preload) {
          startPreload();
        }
      }
    });
    this.get("src", () => _video.currentSrc);
    this.set("volume", v => {
      _video.muted = v === 0;
      _video.volume = v;
    });
    this.get("volume", () => _video.volume);
    this.set("muted", bool => _video.muted = bool);
    this.get("muted", () => _video.muted);
    this.set("controls", bool => _video.controls = bool);
    this.get("controls", () => _video.controls);
    this.get("duration", () => _video.duration);
    this.get("ended", () => _video.ended);
    this.get("playback", () => _video.playbackRate);
    this.get("time", () => _video.currentTime);
    this.get("error", () => _video.error);
    this.get("canRender", () => _video.readyState >= 2);
    this.get("canPlayThrough", () => _video.readyState >= 4);
    this.get("paused", () => _video.paused);
    this.get("element", () => $video);
    this.get("object", () => $video);
    this.get("video", () => _video);
    this.get("bufferedSeconds", _ => _video.readyState < 2 ? 0 : _video.buffered.end(0) - _video.buffered.start(0));
    this.load = async function () {
      return startPreload();
    };
    this.play = async function () {
      return startPlayback();
    };
    this.pause = function () {
      _this.playing = false;
      _video.pause();
    };
    this.stop = function () {
      _this.playing = false;
      _video.pause();
      _this.seek(0);
    };
    this.seek = function (t) {
      if (_video.fastSeek) {
        return _video.fastSeek(t);
      }
      _video.currentTime = t;
    };
    this.seekExact = function (t) {
      _video.currentTime = t;
    };
    this.ready = function () {
      return _ready;
    };
    this.loaded = function () {
      return _loaded;
    };
    this.onDestroy = function () {
      _this.stop();
      _video.src = "";
      (function removeListeners() {
        _params.events.forEach(ev => _video.removeEventListener(ev, _handlers[ev], true));
      })();
      _video = null;
    };
    this.setSize = function (width, height) {
      _video.width = width;
      _video.height = height;
      _this.dimensions.width = width;
      _this.dimensions.height = height;
    };
  }, () => {
    Video.PLAY = "hydra_video_play";
    Video.CANPLAY = "hydra_video_can_play";
    Video.LOADEDMETADATA = "hydra_video_loaded_metadata";
    Video.PAUSE = "hydra_video_pause";
    Video.PROGRESS = "hydra_video_progress";
    Video.UPDATE = "hydra_video_update";
    Video.PLAYING = "hydra_video_playing";
    Video.ENDED = "hydra_video_ended";
    Video.WAITING = "hydra_video_waiting";
    Video.ERROR = "hydra_video_error";
  });
  Class(function VideoTexture(_path, _props = {}) {
    Inherit(this, Component);
    const _this = this;
    let _video;
    let _requestId;
    let _hasRequestCallback = false;
    let _sharedVideo = false;
    _this.canUpdate = true;
    if (typeof _path == "object" && !(_path instanceof HTMLVideoElement)) {
      let path = _path.path;
      _props = _path;
      _path = path;
      delete _props.path;
    }
    let {
      loop: loop,
      preload: preload,
      autoplay: autoplay,
      muted: muted,
      firstFrame: firstFrame,
      parseColor: parseColor,
      events = []
    } = _props;
    function update() {
      _requestId = null;
      let updateTex = _video.canRender && _this.canUpdate;
      if (firstFrame && updateTex) {
        updateTex = _video.time > 0;
      }
      if (updateTex) {
        if (_this.videoTexture) {
          _this.texture.destroy();
          _this.texture = _this.videoTexture;
          delete _this.videoTexture;
        }
        if (!_this.texture.image) {
          _this.texture.image = _video.video;
          _this.texture.upload();
        }
        if (_this.colorParser) {
          _this.colorParser.update(_video.time);
        }
        _this.texture.loaded = _this.texture.needsUpdate = true;
        _this.uniform.value = _this.texture;
      }
      if (_hasRequestCallback) {
        _requestId = _video.element.div.requestVideoFrameCallback(update);
      }
    }
    function noop() {}
    function handleSharedVideoPlaying() {
      start();
    }
    function handleSharedVideoPause() {
      stop();
    }
    function start() {
      _this.active = true;
      if (_requestId) {
        _video.element.div.cancelVideoFrameCallback(_requestId);
        _requestId = null;
      }
      if (_hasRequestCallback) {
        _this.startRender(noop);
      } else {
        _this.startRender(update, 30);
      }
      update();
    }
    function stop() {
      _this.active = false;
      if (_hasRequestCallback) {
        if (_requestId) {
          _video.element.div.cancelVideoFrameCallback(_requestId);
        }
      } else {
        _this.stopRender(update);
      }
    }
    if (loop === undefined) {
      loop = true;
    }
    if (preload === undefined) {
      preload = true;
    }
    if (autoplay === undefined) {
      autoplay = true;
    }
    if (muted === undefined) {
      muted = true;
    }
    if (firstFrame === undefined) {
      firstFrame = false;
    }
    if (parseColor === undefined) {
      parseColor = false;
    }
    if (events === undefined) {
      events = [];
    }
    _this.uniform = {
      value: null
    };
    (function () {
      let src;
      if (_props.start) {
        defer(_ => _this.start());
      }
      if (_path instanceof HTMLVideoElement) {
        _sharedVideo = true;
        src = _path;
        autoplay = false;
        preload = false;
        events = [...events, "pause"];
      } else {
        src = _path.includes("blob") ? _path : Assets.getPath(_path);
      }
      if (!_sharedVideo && _path.includes(["jpg", "png"])) {
        let noop = _ => {};
        _this.texture = Utils3D.getTexture(src);
        _this.video = {
          play: noop,
          pause: noop
        };
        if (parseColor) {
          _this.colorParser = _this.initClass(VideoTextureColorParser, src, true);
        }
      } else {
        let videoEvents = ["timeupdate", "playing", "ended"];
        events.forEach(ev => {
          if (!videoEvents.includes(ev)) {
            videoEvents.push(ev);
          }
        });
        _video = _this.initClass(Video, {
          src: src,
          loop: loop,
          preload: preload,
          autoplay: autoplay,
          muted: muted,
          events: videoEvents
        });
        _this.texture = new Texture();
        _this.texture.format = Texture.RGBFormat;
        _this.texture.minFilter = _this.texture.magFilter = Texture.LINEAR;
        _this.texture.generateMipmaps = false;
        _this.texture.loaded = false;
        _this.video = _video;
        _this.dimensions = _video.dimensions;
        _this.texture.dimensions = _this.dimensions;
        _this.events.bubble(_video, Video.PLAYING);
        if (parseColor) {
          _this.colorParser = _this.initClass(VideoTextureColorParser, src, false);
        }
        if (firstFrame) {
          _this.videoTexture = _this.texture;
          _this.texture = Utils3D.getTexture(firstFrame);
        }
      }
      _this.uniform.value = _this.texture;
      _hasRequestCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype;
      if (Device.system.browser === "safari") {
        _hasRequestCallback = false;
      }
      if (_sharedVideo) {
        (function initSharedVideo() {
          _this.events.sub(_video, Video.PLAYING, handleSharedVideoPlaying);
          _this.events.sub(_video, Video.PAUSE, handleSharedVideoPause);
        })();
      }
    })();
    this.set("loop", loop => _video.loop = loop);
    this.set("muted", muted => _video.muted = muted);
    this.set("src", src => {
      if (_requestId) {
        _video.element.div.cancelVideoFrameCallback(_requestId);
        _requestId = null;
      }
      _video.src = src.includes("blob") ? src : Assets.getPath(src);
      if (_hasRequestCallback) {
        _requestId = _video.element.div.requestVideoFrameCallback(update);
      }
    });
    this.start = async function () {
      if (!_sharedVideo) {
        if (_video) {
          start();
          await _video.play();
        }
      }
    };
    this.stop = function () {
      if (!_sharedVideo) {
        if (_video) {
          stop();
          _video.pause();
        }
      }
    };
    this.seek = function (time) {
      if (!_sharedVideo) {
        if (_video) {
          _video.seek(time);
        }
      }
    };
    this.onInvisible = function () {
      if (!_sharedVideo) {
        if (_this.active) {
          _video.pause();
        }
        VideoTexture.element().removeChild(_this.video.object, true);
      }
    };
    this.onVisible = function () {
      if (!_sharedVideo) {
        if (_this.active) {
          _video.play();
        }
        VideoTexture.element().add(_this.video.object);
      }
    };
    this.onDestroy = function () {
      _this.texture.destroy();
      if (!_sharedVideo) {
        VideoTexture.element().removeChild(_this.video.object, true);
      }
    };
  }, _ => {
    var $element;
    VideoTexture.element = function () {
      if (!$element) {
        ($element = Stage.create("VideoTextures")).css({
          position: "absolute",
          pointerEvents: "none"
        });
        $element.size(0, 0).setZ(-10);
        Stage.add($element);
      }
      return $element;
    };
  });
  Class(function VideoTextureColorParser(_path, _static) {
    Inherit(this, Component);
    const _this = this;
    var _colorData;
    var _color = new Color();
    this.color = new Color();
    this.lerp = 1;
    (async function () {
      let path = _path.split(".")[0] + ".json";
      _colorData = await get(path);
    })();
    this.update = function (time) {
      if (_colorData) {
        for (let key in _colorData) {
          if (time <= key) {
            _color.set("#" + _colorData[key]);
            _this.color.lerp(_color, _this.lerp);
            break;
          }
        }
      }
    };
  });
  Class(function SocketConnection(_server, _channel) {
    Inherit(this, Component);
    var _socket;
    var _pingPong;
    var _this = this;
    var _fail = 0;
    var _binary = {};
    var _time = Render.TIME;
    function connect() {
      _this.pending = false;
      (_socket = new WebSocket(_server, ["permessage-deflate"])).binaryType = "arraybuffer";
      _socket.onopen = open;
      _socket.onmessage = message;
      _socket.onclose = close;
      _socket.onerror = close;
    }
    function sendPing() {
      if (_socket && _socket.readyState == WebSocket.OPEN) {
        _socket.send("ping");
      }
    }
    function open(e) {
      _fail = 0;
      _this.connected = true;
      _this.events.fire(SocketConnection.OPEN, {
        socket: _this
      }, true);
      if (_channel) {
        _this.send("register", {
          channel: _channel
        });
      }
      _pingPong = setInterval(sendPing, 5000);
    }
    function message(e) {
      if (e.data != "pong" && e.data != "ping") {
        if (typeof e.data == "string") {
          try {
            let data = JSON.parse(e.data);
            let evt = data._evt;
            if (evt) {
              delete data._evt;
              _this.events.fire(evt, data, true);
            } else {
              _binary.data = data;
              _this.events.fire(SocketConnection.BINARY, _binary);
            }
          } catch (er) {}
        } else {
          _binary.data = e.data;
          _this.events.fire(SocketConnection.BINARY, _binary);
        }
      }
    }
    function close(e) {
      if (Render.TIME - _time < 50 && !_this.blocked) {
        _this.blocked = true;
        return _this.events.fire(SocketConnection.BLOCKED);
      }
      if (!_this.pending && !(_fail++ > 250)) {
        _this.connected = false;
        _this.pending = true;
        _this.events.fire(SocketConnection.CLOSE, {
          socket: _this
        }, true);
        _this.timer = _this.delayedCall(connect, 250);
        clearTimeout(_pingPong);
      }
    }
    this.connected = false;
    (async function () {
      try {
        connect();
      } catch (e) {
        await defer();
        _this.events.fire(SocketConnection.ERROR, {
          socket: _this
        });
        _this.timer = _this.delayedCall(connect, 250);
      }
    })();
    this.send = function (evt, data = {}) {
      if (!_this.connected) {
        return _this.delayedCall(_ => _this.send(evt, data), 100);
      }
      data._evt = evt;
      if (_socket && _socket.readyState == WebSocket.OPEN) {
        _socket.send(data.length != null ? data : JSON.stringify(data));
      }
    };
    this.sendBinary = function (data) {
      if (_socket && _socket.readyState == WebSocket.OPEN && _socket.bufferedAmount < 1024) {
        _socket.send("binary:" + (data.length != null ? data : JSON.stringify(data)));
      }
    };
    this.close = function () {
      _socket.onclose = null;
      _socket.onerror = null;
      clearTimeout(_this.timer);
      _socket.close();
    };
  }, _ => {
    SocketConnection.OPEN = "socket_connection_open";
    SocketConnection.CLOSE = "socket_connection_close";
    SocketConnection.ERROR = "socket_connection_error";
    SocketConnection.BINARY = "socket_connection_binary";
    SocketConnection.BLOCKED = "socket_connection_blocked";
  });
  Class(function CameraUtil() {
    Inherit(this, Component);
    const _this = this;
    var _cameras = [];
    function handleResize() {
      _cameras.forEach(camera => camera.applyFOV());
    }
    function handleScrollEvent(e) {
      if (_this.flag("preventScroll")) {
        e.preventDefault?.();
      }
    }
    function touchStart(e) {
      if (_this.flag("hardBlock")) {
        e.preventDefault?.();
      }
    }
    (async function () {
      await Hydra.ready();
      _this.onResize(handleResize);
      Scroll.createUnlimited();
      _this.events.sub(Scroll.EVENT, handleScrollEvent);
      if (Device.mobile) {
        __window.bind("touchstart", touchStart);
      }
    })();
    this.addCamera = function (camera, near = 1, far = 10000) {
      _cameras.push(camera);
      camera.applyFOV = function () {
        camera.fov = function getFOV() {
          return Math.range(Stage.width / Stage.height, 1, 2, 50, 30, true);
        }();
        camera.updateProjectionMatrix();
      };
      camera.near = near;
      camera.far = far;
      camera.applyFOV();
    };
    this.blockScroll = function (bool) {
      _this.flag("preventScroll", bool);
    };
    this.hardBlockScroll = function (bool) {
      _this.flag("hardBlock", bool);
    };
  }, "static");
  Class(function ImageUtil() {
    this.square = async function (src, size = 512) {
      let $canvas = document.createElement("canvas");
      let $ctx = $canvas.getContext("2d");
      $canvas.setAttribute("width", size);
      $canvas.setAttribute("height", size);
      $canvas.width = size;
      $canvas.height = size;
      let loaded = Promise.create();
      let $img = document.createElement("img");
      $img.crossOrigin = "anonymous";
      $img.onload = _ => loaded.resolve();
      $img.src = src;
      await loaded;
      await defer();
      let {
        width: width,
        height: height
      } = $img;
      let mult = size / Math.max(width, height);
      width *= mult;
      height *= mult;
      let x = (size - width) * 0.5;
      let y = (size - height) * 0.5;
      $ctx.drawImage($img, x, y, width, height);
      return {
        width: width,
        height: height,
        canvas: $canvas
      };
    };
  }, "static");
  Class(function Fonts() {
    Inherit(this, Component);
    const _this = this;
    const FONTS = ["FuturaLT-Bold.ttf", "FuturaLT-Book.otf", "FuturaLT-Heavy.ttf", "FuturaLT-Light.otf", "FuturaLT-Medium.ttf", "marscondensed-regular-TRIAL.otf", "marsextended-regular-TRIAL.otf"];
    const SUBSCRIPTMAP = "0123456789".split("");
    const SUBSCRIPT = "".split("");
    const SUPERSCRIPTMAP = "0123456789stndrh".split("");
    const SUPERSCRIPT = "".split("");
    async function applyExtraChars() {
      for (let fontName of FONTS) {
        let path = `assets/fonts/${fontName.split(".")[0]}.json`;
        let font = await get(path);
        SUBSCRIPT.map((char, i) => addScripts(font, char, SUBSCRIPTMAP[i], i));
        SUPERSCRIPT.map((char, i) => addScripts(font, char, SUPERSCRIPTMAP[i], i));
        await Dev.writeFile(path, font);
      }
    }
    function addScripts(font, char, map, i) {
      let id = char.charCodeAt(0);
      let existing = font.chars.find(char => char.id === id);
      if (existing) {
        font.chars.remove(existing);
      }
      let lookup = `${map}`.charCodeAt(0);
      let data = font.chars.find(char => char.id === lookup);
      let yoffset = SUBSCRIPT.includes(char) ? font.common.base * 0.8 : data.yoffset;
      let charData = Object.assign({}, data);
      charData = Object.assign(charData, {
        id: id,
        char: char,
        scale: 0.6,
        yoffset: yoffset
      });
      font.chars.push(charData);
    }
    this.generate = async function () {
      await async function generateFonts() {
        for (let name of FONTS) {
          await window.generateFont(`${name}`, {}, "~!@#$%^&*()-_+=[]{}:;\"'<>?.,W()j$|[]{}QwM@%bdfiCGOS0689&?hklmABDEFHIJKLNPRTUVXYZ123457!#/\\gpqyt;_acenorsu~:<>vxz^+=*\",-'. ");
          await _this.wait(150);
        }
        await _this.wait(5000);
      }();
      await applyExtraChars();
    };
    this.applyExtraChars = async function () {
      await applyExtraChars();
    };
  }, "static");
  Module(function glEaseOptions() {
    let options = ["backInOut", "backIn", "backOut", "bounceOut", "bounceIn", "bounceInOut", "circularInOut", "circularIn", "circularOut", "cubicInOut", "cubicIn", "cubicOut", "elasticInOut", "elasticIn", "elasticOut", "expoInOut", "expoIn", "expoOut", "linear", "quadraticInOut", "quadraticIn", "quadraticOut", "qinticInOut", "qinticIn", "qinticOut", "sineInOut", "sineIn", "sineOut"].map((label, value) => ({
      label: label,
      value: value
    }));
    this.exports = {
      value: 0,
      type: "i",
      options: options
    };
  });
  Class(function Tests() {
    this.getDPR = function () {
      if (GPU.OVERSIZED) {
        return 0.8;
      } else if (GPU.lt(0)) {
        return 1;
      } else if (GPU.lt(1)) {
        return Math.min(Device.pixelRatio, 1);
      } else if (GPU.lt(2)) {
        return Math.min(Device.pixelRatio, 1.1);
      } else if (GPU.lt(3)) {
        return Math.min(Device.pixelRatio, 1.2);
      } else if (GPU.lt(4)) {
        return Math.min(Device.pixelRatio, 1.4);
      } else if (GPU.gt(5)) {
        return Math.max(Device.pixelRatio, 1.5);
      } else if (GPU.mobileLT(0)) {
        return 1;
      } else if (GPU.mobileLT(1)) {
        return Math.min(Device.pixelRatio, 1.1);
      } else if (GPU.mobileLT(2)) {
        return Math.min(Device.pixelRatio, 1.2);
      } else if (GPU.mobileLT(3)) {
        return Math.min(Device.pixelRatio, 1.4);
      } else if (GPU.mobileLT(4)) {
        return Math.min(Device.pixelRatio, 2);
      } else {
        return 1;
      }
    };
    this.hasBirds = function () {
      return true;
    };
    this.getBirdsCount = function () {
      if (GPU.mobileLT(3) || GPU.lt(2)) {
        return 30;
      } else {
        return 100;
      }
    };
    this.lowFPS = function () {
      return !!GPU.lt(1) || !!GPU.mobileLT(2);
    };
    this.renderFXAA = function () {
      return !GPU.mobileLT(2);
    };
    this.useSmoothScroll = function () {
      return !Device.mobile && Device.system.browser !== "safari" && Device.system.browser !== "ie";
    };
    this.bloomEnabled = function () {
      return false;
    };
    this.bloomMips = function () {
      if (GPU.gt(5)) {
        return 5;
      } else {
        return 3;
      }
    };
    this.pingPongSections = function () {
      return !!GPU.lt(0) || !!GPU.mobileLT(2);
    };
    this.optimizeGPUMem = function () {
      return !Global.PLAYGROUND;
    };
    this.generatePreview = function () {
      return Config.ENV !== "production" && !!Utils.query("previewMode");
    };
    this.capFPS = function () {
      if (GPU.lt(0) || GPU.mobileLT(2)) {
        return 30.001;
      } else if (GPU.lt(3)) {
        if (Render.REFRESH_RATE > 60) {
          return 60.001;
        } else {
          return null;
        }
      } else if (Device.mobile && Render.REFRESH_RATE > 100) {
        return 100.001;
      } else {
        return null;
      }
    };
  }, "static");
  Class(function CMS() {
    Inherit(this, Model);
    const _this = this;
    const MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    let _data = null;
    let _rawData = null;
    let _newsPagesCache = {};
    function buildFlexibleSchemaObject(key) {
      var obj = {};
      for (var childKey in _rawData[key]) {
        if (childKey !== "_order" && childKey !== "_temp") {
          let item = _rawData[key][childKey];
          obj[item.key] = item.value;
        }
      }
      return obj;
    }
    function trimStub(stub) {
      let copy = {
        ...stub
      };
      delete copy.perma;
      delete copy._title;
      delete copy._type;
      return copy;
    }
    function slugify(str) {
      str = (str = str.replace(/^\s+|\s+$/g, "")).toLowerCase();
      var from = "/_,:;";
      for (var i = 0, l = from.length; i < l; i++) {
        str = str.replace(new RegExp(from.charAt(i), "g"), "aaaaeeeeiiiioooouuuunc------".charAt(i));
      }
      return str = str.replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
    }
    (async function () {
      await Hydra.ready();
      await async function fetchRoot() {
        if (!_data) {
          _rawData = await get(`${Config.CMS}/index.json?${Date.now()}`);
        }
      }();
      await async function fetchNewsListing() {
        _rawData.news = await get(`${Config.CMS}/news/listing.json?${Date.now()}`);
      }();
      await async function transformData() {
        const home = buildFlexibleSchemaObject("home");
        const about = buildFlexibleSchemaObject("about");
        const general = buildFlexibleSchemaObject("general");
        const chapters = function formatChapters() {
          let obj = {};
          for (var key in _rawData.chapter) {
            var chapter = _rawData.chapter[key];
            var stories = chapter.chapterstorystub.map(storyStub => trimStub(storyStub));
            obj[key] = {
              number: Number(chapter.chapterinfostub.number),
              title: chapter.chapterinfostub.title,
              new: chapter.chapterinfostub.new || false,
              stories: stories
            };
          }
          return obj;
        }();
        const news = function formatNews() {
          _rawData.news = _rawData.news.map(article => {
            article.listingColumnSpan &&= Number(article.listingColumnSpan);
            try {
              let [month, date, year] = article.date.split(" ");
              month = String(MONTHS.indexOf(month) + 1).padStart(2, "0");
              date = String(date.replace(",", "")).padStart(2, "0");
              article._order = new Date(`${year}-${month}-${date}T00:00:00.000Z`);
            } catch {
              article._order = null;
            }
            return article;
          }).sort((a, b) => a._order < b._order ? -1 : a._order > b._order ? 1 : 0).reverse();
          return _rawData.news;
        }();
        const technology = function formatTechnology() {
          let obj = {};
          for (var key in _rawData.technology) {
            let item = _rawData.technology[key];
            let pairedItems = {};
            let textItems = {};
            let longTextItems = {};
            if (item.technologypaireditem) {
              item.technologypaireditem.forEach(pairedItem => {
                pairedItems[slugify(pairedItem._title)] = pairedItem;
              });
            }
            if (item.generaltextstub) {
              item.generaltextstub.forEach(textItem => {
                textItems[slugify(textItem._title)] = textItem;
              });
            }
            if (item.generaltextareastub) {
              item.generaltextareastub.forEach(longTextItem => {
                longTextItems[slugify(longTextItem._title)] = longTextItem;
              });
            }
            obj[key] = {
              title: item.technologyinfostub.title,
              pairedItems: pairedItems,
              textItems: textItems,
              longTextItems: longTextItems
            };
          }
          return obj;
        }();
        const contact = _rawData.contact;
        contact.terms = await RichText.parse(JSON.parse(contact.terms));
        const partners = _rawData.partners.images.sort((a, b) => {
          const altA = a.alt ? a.alt.toUpperCase() : "";
          const altB = b.alt ? b.alt.toUpperCase() : "";
          if (altA < altB) {
            return -1;
          } else if (altA > altB) {
            return 1;
          } else {
            return 0;
          }
        });
        _data = {
          general: general,
          about: about,
          home: home,
          contact: contact,
          navigation: _rawData.navigation,
          chapters: chapters,
          news: news,
          technology: technology,
          partners: partners
        };
      }();
      _this.dataReady = true;
      _this.flag("isReady", true);
    })();
    this.fetchNewsPage = async function (slug) {
      if (_newsPagesCache[slug]) {
        return _newsPagesCache[slug];
      }
      const rawNewsPage = await get(`${Config.CMS}/news/${slug}/index.json?${Date.now()}`);
      const newsPage = await async function formatNewsStory(story) {
        let assets = [];
        let audioPlayers = [];
        let pulledQuotes = [];
        if (story.newsarticleasset) {
          assets = story.newsarticleasset.map(asset => trimStub(asset));
        }
        if (story.newsaudioplayer) {
          audioPlayers = story.newsaudioplayer.map(audioPlayer => trimStub(audioPlayer));
        }
        if (story.newsboldedpullquote) {
          pulledQuotes = story.newsboldedpullquote.map(pullQuote => trimStub(pullQuote));
        }
        let content = trimStub(story.newsarticlemain);
        content.body = await RichText.parse(JSON.parse(content.body));
        return {
          ...content,
          assets: assets,
          pulledQuotes: pulledQuotes,
          audioPlayers: audioPlayers
        };
      }(rawNewsPage);
      _newsPagesCache[slug] = newsPage;
      return newsPage;
    };
    this.get = function (path) {
      return function objectByString(path = "string", obj = {}) {
        return (path = (path = path.replace(/\[(\w+)\]/g, ".$1")).replace(/^\./, "")).split(".").reduce((prev, key) => prev && prev[key] || prev[key] === 0 ? prev[key] : null, obj || {});
      }(path, _data);
    };
    this.ready = async function () {
      await _this.wait("isReady");
    };
  }, "static");
  Class(function Colors() {
    Inherit(this, Component);
    this.value = {
      beige: "#FDF0E1",
      orange: "#E74833",
      darkOrange: "#6e1409",
      orangeYellow: "#FFA300",
      greyishTeal: "#66B4AD",
      teal: "#66B4AD",
      darkBlueGrey: "#122A2B",
      dirtyBlue: "#3BBEA0",
      black: "#161616",
      lime: "#96AF52"
    };
    this.hex = {
      beige: 16642273,
      orange: 15157299,
      black: 1447446
    };
  }, "static");
  Class(function Typography() {
    Inherit(this, Component);
    const _this = this;
    const FONT_FAMILY = {
      title: "Aktifo-B",
      body: "Aktifo-B Book",
      button: "Aktifo-B Bold"
    };
    this.getCSSFont = function (fontName = FONT_FAMILY.body, fontSize, lineHeight = "100%", letterSpacing = "0", fontWeight = "normal") {
      return {
        position: "relative",
        fontFamily: FONT_FAMILY[fontName],
        fontSize: fontSize,
        lineHeight: lineHeight,
        letterSpacing: letterSpacing,
        fontStyle: "normal",
        fontWeight: fontWeight
      };
    };
    Text3D.onCreateShader = (shader, test) => {
      shader.addUniforms({
        uNormalColor: {
          value: new Color(Colors.hex.beige)
        },
        uBoldColor: {
          value: new Color(Colors.hex.orange)
        }
      });
      let shaderClass = _this.initClass(WaveTextShader, null, shader);
      shader.shaderClass = shaderClass;
    };
  }, "static");
  Class(function Container() {
    Inherit(this, Element);
    const _this = this;
    const $this = this.element;
    var _loader;
    (function initHTML() {
      Stage.add($this);
      $this.css({
        position: "static"
      });
    })();
    (async function loadView() {
      let loaderView = _this.initClass(LoaderView);
      await _this.wait(100);
      (_loader = _this.initClass(AssetLoader, Assets.list().filter(["shaders", "uil", "quill"]))).add(3);
      _this.events.sub(_loader, Events.PROGRESS, loaderView.progress);
      _this.events.sub(_loader, Events.COMPLETE, () => {
        (function animateIn() {
          ViewController.instance().isVisible = true;
          PageUIGlobal.instance().animateIn();
        })();
        loaderView.animateOut(() => {
          loaderView = loaderView.destroy();
        });
      });
      _this.events.sub(InteractiveSection.INITIAL_LOADED, () => {
        _loader.trigger(3);
      });
      await CMS.ready();
      await Initializer3D.createWorld();
      await AssetLoader.loadAssets(["~assets/js/lib/video.min.js"]);
      (function initView() {
        World.instance();
        $this.add(World.ELEMENT);
        PageUIGlobal.instance();
        PageUIController.instance();
        ViewController.instance();
        NewsController.instance();
      })();
      await Initializer3D.loaded();
    })();
    _this.triggerLoader = num => {
      _loader.trigger(num);
    };
  }, "singleton");
  Class(function NewsController() {
    Inherit(this, Component);
    const _this = this;
    (async function init() {
      _this.flag("ready", true);
    })();
    _this.ready = async function () {
      await _this.wait("ready");
    };
  }, "singleton", () => {
    NewsController.LOAD_ARTICLE = "load_article";
  });
  Class(function PageUIController() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $container;
    var _state = AppState.createLocal({
      menuOpen: false,
      orientation: Stage.width > Stage.height ? "landscape" : "portrait"
    });
    function resize() {
      _state.orientation = Stage.width > Stage.height ? "landscape" : "portrait";
    }
    (function initHTML() {
      $this.css({
        top: 0,
        left: 0,
        width: "100%",
        height: "100%"
      });
      ($container = $this.create("container")).css({
        width: "100%",
        height: "100%"
      });
      Container.instance().element.add($this);
    })();
    (function addHandlers() {
      _this.onResize(resize);
    })();
    this.get("$container", _ => $container);
    this.get("state", _ => _state);
  }, "singleton");
  Class(function PageUIGlobal() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $right;
    var $top;
    var $bottom;
    var $left;
    var _menuTop;
    const WINDOWS = Device.system.os === "windows";
    function resize() {
      if (WINDOWS) {
        $right.css({
          left: Stage.width - 10
        });
      }
    }
    if (!Tests.generatePreview()) {
      (function initHTML() {
        $this.css({
          position: "fixed",
          top: 0,
          left: 0,
          width: "100vw"
        });
        $this.setZ(10000);
        $this.invisible();
        if (WINDOWS) {
          let style = document.createElement("style");
          style.innerHTML = "\n            body::-webkit-scrollbar {\n                width: 10px;\n                background: #FDF0E1;\n            }\n            body::-webkit-scrollbar-thumb {\n                background: rgba(0, 0, 0, 0.75);\n            }";
          document.body.appendChild(style);
        }
      })();
      (function initHeader() {
        _menuTop = NavigationHeader.instance();
        $this.add(_menuTop.element);
      })();
      (function initBorder() {
        let size = Device.mobile ? 5 : 10;
        ($top = Stage.create(".border")).css({
          width: "100%",
          height: size,
          position: "fixed",
          left: 0,
          top: 0
        }).bg(Colors.value.beige).setZ(100);
        ($bottom = Stage.create(".border")).css({
          width: "100%",
          height: size,
          left: 0,
          bottom: 0,
          position: "fixed"
        }).bg(Colors.value.beige).setZ(100);
        ($left = Stage.create(".border")).css({
          width: size,
          height: "100%",
          top: 0,
          left: 0,
          position: "fixed"
        }).bg(Colors.value.beige).setZ(100);
        ($right = Stage.create(".border")).css({
          width: size,
          height: "100%",
          top: 0,
          position: "fixed"
        }).bg(Colors.value.beige).setZ(100);
        if (!WINDOWS) {
          $right.css({
            right: 0
          });
        }
        Dev.expose("uig", $this);
      })();
      (function addHandlers() {
        _this.onResize(resize);
      })();
      Container.instance().element.add($this);
    }
    this.animateIn = function () {
      if (Tests.generatePreview()) {
        return;
      }
      $this.visible();
      $top.transformPoint("50%", "0%").transform({
        scaleY: 0
      }).tween({
        scaleY: 1
      }, 1000, "easeInOutQuart", 1000);
      $bottom.transformPoint("50%", "100%").transform({
        scaleY: 0
      }).tween({
        scaleY: 1
      }, 1000, "easeInOutQuart", 1000);
      $left.transformPoint("0%", "50%").transform({
        scaleX: 0
      }).tween({
        scaleX: 1
      }, 1000, "easeInOutQuart", 1000);
      $right.transformPoint("100%", "50%").transform({
        scaleX: 0
      }).tween({
        scaleX: 1
      }, 1000, "easeInOutQuart", 1000);
    };
  }, "singleton");
  Class(function Playground() {
    Inherit(this, Component);
    const _this = this;
    let _view;
    function initGLUIView(element) {
      GLUI.Stage.add(element);
    }
    (async function () {
      await UILStorage.ready();
      await Data.ready();
      Global.PLAYGROUND = Utils.query("p");
      (function initThree() {
        World.instance();
        Stage.add(World.ELEMENT);
      })();
      (function initView() {
        let request = Global.PLAYGROUND.split("/")[0];
        let view = window["Playground" + request] || window[request] || null;
        if (!view) {
          throw `No Playground class ${request} found.`;
        }
        _view = view.instance ? view.instance() : _this.initClass(view);
        if (_view.element) {
          if (_view.element.mesh) {
            initGLUIView(_view.element);
          } else {
            Stage.add(_view.element);
          }
        } else if (_view.root && _view.$gluiObject) {
          (function initUI3DView(ui3d) {
            if (Device.mobile) {
              initGLUIView(ui3d.root);
            } else {
              GLUI.Scene.add(ui3d.$gluiObject);
              (function addUIToWorldScene(uiGroup) {
                let group = new Group();
                let v3 = new Vector3();
                let distance = USING_XR ? 1.5 : 2;
                v3.set(0, 0, -distance).applyQuaternion(World.CAMERA.quaternion);
                group.position.copy(World.CAMERA.position).add(v3);
                group.lookAt(World.CAMERA.position);
                group.add(uiGroup);
                World.SCENE.add(group);
                return group;
              })(ui3d.$gluiObject.anchor);
            }
          })(_view);
        }
        if (_view.rt && _view.scene && _view.nuke) {
          if (request.includes("Figma")) {
            let dimensions = _view.dimensions;
            let $obj = $gl(dimensions[0], dimensions[1], _view.rt.texture);
            $obj.x = 40;
            $obj.y = 40;
            if (Utils.query("orientation") === "portrait") {
              $obj.scale = 0.5;
              $obj.y = -300;
            }
            GLUI.Stage.add($obj);
          } else {
            let shader = _this.initClass(Shader, "ScreenQuad", {
              tMap: {
                value: _view
              }
            });
            let mesh = new Mesh(World.QUAD, shader);
            mesh.frustumCulled = false;
            World.SCENE.add(mesh);
          }
        } else {
          World.SCENE.add(_view.group || _view.mesh || _view.object3D || new Group());
        }
        (function initCameraHelper(nuke) {
          let orbitCamera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
          orbitCamera.position.z = 6;
          let lastCamera;
          let timer0;
          let timer1;
          let timer2;
          let wasdCamera = orbitCamera.clone();
          _this.onResize(_ => {
            orbitCamera.aspect = wasdCamera.aspect = Stage.width / Stage.height;
            orbitCamera.updateProjectionMatrix();
            wasdCamera.updateProjectionMatrix();
          });
          let orbit = new DebugControls(orbitCamera, World.ELEMENT.div);
          let wasd = new WASDControls(wasdCamera, World.ELEMENT.div);
          orbit.enabled = false;
          wasd.enabled = false;
          _this.startRender(_ => {
            orbit.update();
            wasd.update();
          });
          _this.orbitControls = orbit;
          _this.wasdControls = wasd;
          const clearTimers = _ => {
            clearTimeout(timer0);
            clearTimeout(timer1);
            clearTimeout(timer2);
          };
          const goToMain = _ => {
            orbit.enabled = false;
            wasd.enabled = false;
            if (lastCamera) {
              nuke.camera = lastCamera;
            }
            AppState.set("playground_camera_active", false);
            clearTimers();
          };
          const goToOrbit = _ => {
            orbit.enabled = true;
            wasd.enabled = false;
            if (nuke.camera != wasdCamera && nuke.camera != orbitCamera) {
              lastCamera = nuke.camera;
            }
            nuke.camera = orbitCamera;
            AppState.set("playground_camera_active", nuke.camera);
            _this.activeControls = orbit;
            clearTimers();
          };
          const goToWASD = _ => {
            wasd.enabled = true;
            orbit.enabled = false;
            if (nuke.camera != wasdCamera && nuke.camera != orbitCamera) {
              lastCamera = nuke.camera;
            }
            nuke.camera = wasdCamera;
            AppState.set("playground_camera_active", nuke.camera);
            _this.activeControls = wasd;
            clearTimers();
          };
          if (Utils.query("orbit")) {
            goToOrbit();
            timer0 = _this.delayedCall(goToOrbit, 500);
            timer1 = _this.delayedCall(goToOrbit, 1000);
            timer2 = _this.delayedCall(goToOrbit, 3000);
          }
          _this.events.sub(Keyboard.DOWN, _ => {
            if (!document.activeElement.tagName.toLowerCase().includes(["textarea", "input"])) {
              if (Keyboard.pressing.includes("!")) {
                goToMain();
              }
              if (Keyboard.pressing.includes("@")) {
                goToOrbit();
              }
              if (Keyboard.pressing.includes("#")) {
                goToWASD();
              }
            }
          });
        })(_view.nuke || World.NUKE);
        Dev.expose("view", _view);
      })();
      defer(window.onresize);
    })();
  }, "singleton");
  Class(function TestParticlePlayground() {
    Inherit(this, Object3D);
    const _this = this;
    _this.layout = _this.initClass(SceneLayout, "test-particles");
  });
  Class(function PlaygroundCar() {
    Inherit(this, Object3D);
    this.initClass(Car, {});
  });
  Class(function PlaygroundStylizedPBR() {
    Inherit(this, Object3D);
    const _this = this;
    _this.layout = _this.initClass(SceneLayout, "playground_stylized_pbr");
  });
  Class(function InstancedCarPart(_input, _group) {
    Inherit(this, Component);
    const _this = this;
    var _batch;
    var _geom;
    var _shader;
    var _mesh;
    (async function () {
      (function initBatch() {
        let geom = _input.get("geometry");
        let key = !!geom && JSON.parse(geom).filename;
        if (!key) {
          return;
        }
        key = `${_this.parent.name}_${key}`;
        if (!InstancedCarPart.PARTS[key]) {
          InstancedCarPart.PARTS[key] = new MeshBatch();
          _this.parent.add(InstancedCarPart.PARTS[key].group);
        }
        _batch = InstancedCarPart.PARTS[key];
      })();
      if (_batch) {
        await async function initGeometry() {
          let settings = _input.get("geometry");
          let src = !!settings && JSON.parse(settings).src;
          _geom = src ? await GeomThread.loadGeometry(src) : World.PLANE;
        }();
        (function initShader() {
          let unique = `${_input.prefix}_shader`;
          _shader = _this.initClass(Shader, "InstancedCarPart", {
            tMap: {
              value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
            },
            unique: unique
          });
          ShaderUIL.add(_shader, _group).setLabel("Shader");
        })();
        (function initMesh() {
          _mesh = new Mesh(_geom, _shader);
          _batch.add(_mesh);
          _this.parent.group.add(_mesh);
        })();
      }
    })();
  }, _ => {
    InstancedCarPart.PARTS = {};
  });
  Class(function PlaygroundInstance() {
    Inherit(this, Object3D);
    const _this = this;
    _this.layout = _this.initClass(SceneLayout, "playground_instance");
  });
  Class(function PlaygroundInstanceCar() {
    Inherit(this, Object3D);
    const _this = this;
    (function () {
      let noGraph = Global.PLAYGROUND !== "InstanceCar";
      _this.layout = _this.initClass(SceneLayout, "playground_instance_car", {
        noGraph: noGraph
      });
    })();
  });
  Class(function CarClip(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config;
    var _shaders = [];
    (async function () {
      let wildcard = _input?.get?.("wildcard");
      if (Global.PLAYGROUND === "CarClip") {
        wildcard = Utils.query("car");
      }
      let suffix = wildcard && wildcard.trim().length > 0 ? `-${wildcard}` : "";
      let noGraph = Global.PLAYGROUND && !Global.PLAYGROUND.includes(["CarClip", "Transition"]);
      _this.layout = _this.initClass(SceneLayout, `carclip${suffix}`, {
        noGraph: noGraph
      });
      (_config = InputUIL.create("carclip_" + _input?.prefix, _group)).setLabel("Car Config");
      _config.addImage("tEnvDiffuse");
      _config.addImage("tEnvSpecular");
      _config.addImage("tLightmap");
      _config.addNumber("uWheelSpeed", 100);
      _config.addNumber("uSide", 1);
      _config.addVector("uScaleOut", [1, 1, 1]);
      _config.addVector("uOffsetOut", [0, 0, 0]);
      _config.addNumber("uSaturation", 1);
      _config.addVector("uEnv", [2, 0]);
      _config.addVector("uLight", [1, 1, 2.5, 1]);
      _config.addVector("uWiggle", [0.002, 0, 0, 0]);
      _config.onUpdate = key => {
        let value = _config.get(key);
        if (value) {
          if (Array.isArray(value)) {
            for (let layer in _this.layout.layers) {
              let mesh = _this.layout.layers[layer];
              if (mesh.shader?.uniforms[key]) {
                mesh.shader.uniforms[key].value.fromArray(value);
              }
            }
          } else if (value.includes("{")) {
            value = JSON.parse(value);
            let src = value.src;
            if (src.includes("?") && !data.hotreload) {
              src.split("?")[0];
            }
            if (src?.length) {
              if (value.compressed) {
                src += "-compressedKtx";
              }
              let texture = Utils3D.getTexture(src);
              if (key.includes("tEnv")) {
                texture.generateMipmaps = false;
                texture.minFilter = Texture.LINEAR;
              }
              for (let layer in _this.layout.layers) {
                let mesh = _this.layout.layers[layer];
                if (mesh.shader?.uniforms[key]) {
                  mesh.shader.set(key, texture);
                }
              }
            }
          } else {
            value = JSON.parse(value);
            for (let layer in _this.layout.layers) {
              if (layer.includes("wheel") || key === "uSide") {
                let mesh = _this.layout.layers[layer];
                if (mesh.shader?.uniforms[key]) {
                  mesh.shader.uniforms[key].value = value;
                }
                if (layer.includes("wheel") && mesh.shader) {
                  mesh.shader.uniforms.uWheel.value = 1;
                }
              }
            }
          }
        }
      };
      let inPlayground = Global.PLAYGROUND && Global.PLAYGROUND.includes(["CarClip", "CarTransition"]);
      _this.startRender(_ => {
        _shaders.map(shader => {
          let p = Math.range(_this.progress, 0, 1, 3, -3, true);
          if (inPlayground) {
            p = Math.range(Mouse.tilt.x, -1, 1, 3, -3, true);
          }
          shader.set("uProgress", p * shader.get("uSide"));
        });
        PBRCarShader.TIME.value += (1 + ViewController.SPEED_MULTI.value * 2) * 0.015 * Render.HZ_MULTIPLIER * _this.wheelSpeed;
      });
      await _this.layout.loadedAllLayers();
      ["tEnvDiffuse", "tEnvSpecular", "tLightmap", "uEnv", "uLight", "uWiggle", "uWheelSpeed", "uSaturation", "uSide"].forEach(_config.onUpdate);
    })();
    this.progress = 0;
    this.wheelSpeed = 1;
    this.register = function (shader) {
      _shaders.push(shader);
    };
  });
  Class(function PBRCarClipShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    (function () {
      _shader.addUniforms({
        uTime: PBRCarClipShader.TIME,
        uProgress: {
          value: 0.5,
          ignoreUIL: true
        },
        uSide: {
          value: 1
        },
        uWheel: {
          value: 0
        },
        uScaleOut: {
          value: new Vector3(1, 1, 1)
        },
        uOffsetOut: {
          value: new Vector3(0, 0, 0)
        },
        uNoiseStrength: {
          value: 0
        },
        uEase: require("glEaseOptions"),
        uWheelSpeed: {
          value: 0
        },
        uClearCoat: {
          value: new Vector3(0.6, 0.7, 0)
        },
        uWiggle: {
          value: new Vector4()
        },
        uSaturation: {
          value: 1
        },
        side: Shader.DOUBLE_SIDE,
        transparent: true
      });
      let parent = _this.findParent("CarClip");
      if (parent) {
        parent.register(_shader);
      }
    })();
  }, _ => {
    PBRCarClipShader.TIME = {
      value: 1
    };
  });
  Class(function PlaygroundTransition() {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "playground_transition");
      let [a, b] = await _this.layout.getLayers("shape-1", "shape-2");
      a.shader.set("uColor", new Color("#ff0000"));
      b.shader.set("uColor", new Color("#0000ff"));
      b.shader.set("uSide", -1);
      _this.startRender(_ => {
        let progress = Math.range(Mouse.tilt.x, -0.5, 0.5, -3, 3, true);
        a.shader.set("uProgress", progress);
        b.shader.set("uProgress", -progress);
      });
    })();
  });
  Class(function pTransition(_mesh, _shader) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color("#fff")
      },
      uProgress: {
        value: 0
      },
      uSide: {
        value: 1
      }
    });
  });
  Class(function ViewCache() {
    Inherit(this, Component);
    this.sceneRepository = {};
  }, "static");
  Class(function ViewController() {
    Inherit(this, Object3D);
    Inherit(this, Router);
    const _this = this;
    const ROUTES = [{
      path: "",
      key: "homePage",
      title: "Home"
    }, {
      path: "chapter1",
      key: "chapter1Page",
      title: "Chapter 1"
    }, {
      path: "chapter2",
      key: "chapter2Page",
      title: "Chapter 2"
    }, {
      path: "chapter3",
      key: "chapter3Page",
      title: "Chapter 3"
    }, {
      path: "test",
      key: "testPage"
    }, {
      path: "news",
      key: "newsPage",
      title: "News"
    }, {
      path: "technology",
      key: "technologyPage",
      title: "Technology"
    }, {
      path: "connect",
      key: "contactPage",
      title: "Contact"
    }, {
      path: "news/:id",
      key: "newsDetailPage"
    }, {
      path: "privacy",
      key: "PrivacyPage",
      title: "Privacy Policy"
    }, {
      path: "404",
      key: "errorPage",
      title: "Error"
    }, {
      path: "faq",
      redirect: "technology"
    }, {
      path: "partners",
      key: "partnersPage",
      title: "Partners"
    }];
    const ROUTELESS = [{
      key: "menu",
      path: "menu"
    }];
    const DIRECTIONS = ["left", "right", "topRight", "bottomLeft"];
    var _composite;
    var _bloom;
    var _audio;
    var _current;
    var _prev;
    var _currentPage;
    var _direction = "left";
    var _skipNextTransition = false;
    var _sceneMap = {};
    var _beige = new Color(Colors.value.black);
    var _orange = new Color(Colors.value.orange);
    function loop() {
      _composite.uniforms.uBloomAdd.value = Math.lerp(ViewController.BLOOM_EXTRA, _composite.uniforms.uBloomAdd.value, 0.1);
    }
    function initRoute({
      key: key,
      path: path,
      children: children,
      redirect: redirect,
      title: title,
      isFirst = false
    }) {
      if (redirect) {
        return;
      }
      let className = key.capitalize();
      if (_sceneMap[className]) {
        return;
      }
      let instance = _this.initClass(InteractivePageWrapper, window[className], isFirst);
      _sceneMap[className] = instance;
      instance.key = className;
      instance.title = title;
      instance.visible = false;
      if (children) {
        children.forEach(child => {
          initRoute({
            key: child.key,
            path: child.path
          });
        });
      }
    }
    function createView(name) {
      return {
        name: name,
        view: name.capitalize()
      };
    }
    function start() {
      startInteracting();
    }
    function end() {
      stopInteracting();
    }
    function press(e) {}
    function down(e) {
      if (e.keyCode == 32) {
        startInteracting();
        if (!Utils.query("uil") && Instruction.CAN_INTERACT) {
          e.preventDefault();
        }
      }
    }
    function up(e) {
      if (e.keyCode == 32) {
        stopInteracting();
      }
    }
    function startInteracting() {
      if (!_this.interacting && (_this.interacting = true, Instruction.CAN_INTERACT)) {
        switch (Instruction.CAN_INTERACT) {
          case "engine":
            _audio.engine.play();
            _audio.engine.volume = 0;
            tween(_audio.engine, {
              volume: 1
            }, 3000, "easeOutSine");
            _audio["engine-fade"].play();
            _audio["engine-fade"].volume = 0;
            tween(_audio["engine-fade"], {
              volume: 0.5
            }, 4000, "easeOutSine");
        }
        _this.events.fire(ViewController.INTERACTION, {
          down: true
        });
        tween(ViewController.SPEED_MULTI, {
          value: 1
        }, 2500, "easeOutCubic");
      }
    }
    function stopInteracting() {
      if (_this.interacting) {
        _this.interacting = false;
        switch (Instruction.CAN_INTERACT) {
          case false:
            tween(_audio.engine, {
              volume: 0
            }, 500, "easeOutSine", _ => {
              _audio.engine.stop();
            });
            tween(_audio["engine-fade"], {
              volume: 0
            }, 500, "easeOutSine", _ => {
              _audio["engine-fade"].stop();
            });
          case "engine":
            tween(_audio.engine, {
              volume: 0
            }, 500, "easeOutSine", _ => {
              _audio.engine.stop();
            });
            tween(_audio["engine-fade"], {
              volume: 0
            }, 500, "easeOutSine", _ => {
              _audio["engine-fade"].stop();
            });
        }
        _this.events.fire(ViewController.INTERACTION, {
          down: false
        });
        tween(ViewController.SPEED_MULTI, {
          value: 0
        }, 1500, "easeOutCubic");
      }
    }
    function onSmoothViewChange(e) {}
    function onSmoothBottom(e) {}
    function onSmoothTop(e) {}
    function onRouteChange(from, to, path, params, route) {
      CameraUtil.blockScroll(false);
      CameraUtil.hardBlockScroll(false);
      Track.event("pageChange", {
        page_path: `/${path}`
      }, `navigateTo:${path}`);
      let next = _sceneMap[to.view];
      next ||= _sceneMap[ErrorPage];
      transition(next);
    }
    async function transition(next) {
      _this.flag("transitioning", true);
      next.visible = true;
      if (_current) {
        _composite.set("tFrom", _current?.view.rt);
      }
      _composite.set("tTo", next.view.rt);
      _composite.set("uTransitionColor", _this.isVisible ? _orange : _beige);
      if (_current) {
        if (_current.key == next.key) {
          await _current.hide();
        } else {
          _current.hide();
        }
      }
      let show = next.show();
      _prev = _current;
      if ((_current = next).key != "Menu") {
        _currentPage = _current;
        if (_current.title) {
          _this.setTitle(`${_current.title}`);
        } else {
          _this.setTitle("Prometheus Fuels");
        }
        _this.events.fire(ViewController.UPDATE, next.key);
      }
      _composite.tween("uVignette", _current.key == "HomePage" ? 1 : 0, 1000, "easeOutSine");
      if (_skipNextTransition) {
        _composite.set("uTransition", 1);
      } else {
        _composite.tween("uTransition0", 1, 750, "easeOutSine", 0).promise();
        let time = _this.isVisible ? 1200 : 2000;
        await _this.wait("isVisible");
        await Promise.all([_composite.tween("uTransition", 1, time, "easeOutSine").promise(), show]);
      }
      _composite.set("uTransition0", 0.01);
      _composite.set("uTransition", 0.03);
      _composite.set("tFrom", _current?.view.rt);
      _composite.set("tTo", _current?.view.rt);
      _skipNextTransition = false;
      _this.flag("transitioning", false);
    }
    async function setDirection(direction = "left") {
      if (!DIRECTIONS.includes(direction)) {
        direction = "left";
      }
      _direction = direction;
      await defer();
    }
    function resize() {
      _composite.set("uStageDimensions", new Vector2(Stage.width, Stage.height));
    }
    (async function () {
      if (!Global.PLAYGROUND) {
        World.SCENE.add(_this.group);
        (function initEager() {
          [...ROUTELESS].forEach(({
            key: key,
            path: path,
            children: children,
            title: title
          }) => {
            initRoute({
              key: key,
              path: path,
              children: children,
              title: title
            });
          });
          let split = _this.getState().split("/");
          let match = ROUTES.find(route => split.length > 1 ? route.path == split[0] + "/:id" : route.path == split[0]);
          if (match && match.redirect) {
            match = ROUTES.find(route => route.path == match.redirect);
          }
          initRoute(match ? {
            key: match.key,
            path: match.key,
            title: match.title,
            isFirst: true
          } : {
            key: "errorPage",
            path: "error",
            title: "Error",
            isFirst: true
          });
        })();
        (function initAudio() {
          (_audio = {}).engine = _this.initClass(Audio3D, {
            src: "assets/audio/engine.mp3",
            loop: false
          });
          _audio["engine-fade"] = _this.initClass(Audio3D, {
            src: "assets/audio/engine-fade.mp3",
            loop: false,
            volume: 0.1
          });
        })();
        (function initRoutes() {
          [...ROUTES].forEach(({
            key: key,
            path: path,
            children: children,
            title: title,
            redirect: redirect
          }) => {
            initRoute({
              key: key,
              path: path,
              children: children,
              title: title,
              redirect: redirect
            });
          });
          _this.registerRoutes(onRouteChange, ROUTES.map(({
            path: path,
            key: key,
            children: children,
            title: title,
            redirect: redirect
          }) => {
            if (redirect) {
              return {
                path: path,
                redirect: redirect,
                updateURL: true
              };
            }
            let data = {
              path: path,
              view: createView(key),
              children: []
            };
            if (children) {
              children.forEach(child => {
                let childData = {
                  path: child.path,
                  view: createView(child.key)
                };
                data.children.push(childData);
              });
            }
            return data;
          }));
        })();
        (async function initCompositor() {
          _bloom = _this.initClass(FX.UnrealBloom, World.NUKE, {
            nMips: Tests.bloomMips(),
            enabled: Tests.bloomEnabled()
          }, "sceneComposite");
          (_composite = _this.initClass(NukePass, "SceneComposite", Utils.mergeObject({
            tTo: {
              value: Utils3D.getTexture("assets/images/_scenelayout/black.jpg"),
              ignoreUIL: true
            },
            tFrom: {
              value: Utils3D.getTexture("assets/images/_scenelayout/black.jpg"),
              ignoreUIL: true
            },
            tNoise: {
              value: Utils3D.getRepeatTexture("assets/images/noise/dirnoise3.jpg"),
              ignoreUIL: true
            },
            tGrunge: {
              value: Utils3D.getRepeatTexture("assets/images/noise/grunge.jpg"),
              ignoreUIL: true
            },
            uTransition0: {
              value: 0.01,
              ignoreUIL: true
            },
            uTransition: {
              value: 0,
              ignoreUIL: true
            },
            uTransitionColor: {
              value: null,
              ignoreUIL: true
            },
            uUVScale: {
              value: 0.8
            },
            uVignette: {
              value: 0
            },
            uSpeed: ViewController.SPEED_MULTI,
            uFlipped: {
              value: 0
            },
            uMobile: {
              value: Device.mobile ? 1 : 0
            },
            uRotation: {
              value: -60
            },
            uRGBShift: {
              value: 1
            },
            uNoise: {
              value: 0
            },
            uGrunge: {
              value: 0
            },
            uBloomAdd: {
              value: 0,
              ignoreUIL: true
            },
            uStageDimensions: {
              value: new Vector2(Stage.width, Stage.height)
            },
            uDimensions: {
              value: new Vector2(1024, 1024)
            }
          }, _bloom.uniforms))).depthWrite = false;
          _composite.depthTest = false;
          _composite.upload();
          ShaderUIL.add(_composite);
          World.NUKE.add(_composite);
          _this.mesh = new Mesh(World.QUAD, _composite.pass);
          _this.mesh.frustumCulled = false;
          _this.add(_this.mesh);
        })();
        (function addHandlers() {
          _this.onResize(resize);
          _this.events.sub(ViewController.SOUNDS_ALL_STOP, stopInteracting);
          _this.events.sub(SmoothRenderManager.VIEW_CHANGE, onSmoothViewChange);
          _this.events.sub(SmoothRenderManager.BOTTOM, onSmoothBottom);
          _this.events.sub(SmoothRenderManager.TOP, onSmoothTop);
          if (Device.mobile) {
            _this.events.sub(Mouse.input, Interaction.START, start);
            _this.events.sub(Mouse.input, Interaction.END, end);
          } else {
            _this.events.sub(Keyboard.DOWN, down);
            _this.events.sub(Keyboard.UP, up);
            _this.events.sub(Keyboard.UP, press);
          }
        })();
        _this.startRender(loop);
      }
    })();
    this.changeRoute = async function (route, direction = "left", skipTransition = false) {
      return !_this.flag("transitioning") && (_skipNextTransition = skipTransition, await setDirection(direction), _this.setState(route), true);
    };
    _this.getCurrentPage = function () {
      return _currentPage;
    };
    this.transition = async function (key, direction = "left") {
      if (_this.flag("transitioning")) {
        return false;
      }
      let next = _sceneMap[key];
      await setDirection(direction);
      transition(next);
      return true;
    };
    _this.transitionBack = async function () {
      if (_this.flag("transitioning")) {
        return false;
      }
      let next = _prev;
      if (next) {
        let direction = "left";
        switch (_direction) {
          case "left":
            direction = "right";
            break;
          case "right":
            direction = "left";
            break;
          case "topRight":
            direction = "bottomLeft";
            break;
          case "bottomLeft":
            direction = "topRight";
            break;
          default:
            direction = "left";
        }
        await setDirection(direction);
        transition(next);
        return true;
      }
    };
    Dev.expose("changeRoute", this.changeRoute);
    Dev.expose("transition", this.transition);
    Dev.expose("transitionBack", this.transitionBack);
  }, "singleton", () => {
    ViewController.UPDATE = "viewcontroller_update";
    ViewController.BLOOM_EXTRA = 0;
    ViewController.SPEED_MULTI = {
      value: 0
    };
    ViewController.INTERACTION = "viewcontroller_interaction";
    ViewController.NEWS_TRANSITION_ANIMATING = "viewcontroller_news_animating";
    ViewController.NEWS_TRANSITION_IDLE = "viewcontroller_news_idle";
    ViewController.SOUNDS_ALL_STOP = "viewcontroller_sounds_all_stop";
  });
  Class(function World() {
    Inherit(this, Component);
    const _this = this;
    let _renderer;
    let _scene;
    let _camera;
    let _nuke;
    let _controls;
    function resize() {
      _renderer.setSize(Stage.width, Stage.height);
      _camera.aspect = Stage.width / Stage.height;
      _camera.updateProjectionMatrix();
      (function updateBreakpoint() {
        if (Stage.width / Stage.height < 1) {
          SceneLayout.setBreakpoint("portrait");
        } else {
          SceneLayout.setBreakpoint("");
        }
      })();
    }
    function loop(t, delta) {
      if (_controls && _controls.enabled) {
        _controls.update();
      }
      RenderManager.render();
    }
    World.DPR = Tests.getDPR();
    (function initWorld() {
      World.PLANE = new PlaneGeometry(1, 1);
      World.QUAD = Utils3D.getQuad();
      World.BOX = new BoxGeometry(1, 1, 1);
      World.SPHERE = new SphereGeometry(1, 16, 16);
      World.HIGH_PLANE = new PlaneGeometry(1, 1, 128, 128);
      RenderManager.initialize(RenderManager.NORMAL, {
        powerPreference: "high-performance"
      });
      _renderer = RenderManager.gl;
      _scene = RenderManager.scene;
      _camera = RenderManager.camera.worldCamera;
      _nuke = RenderManager.nuke;
      World.SCENE = _scene;
      World.RENDERER = _renderer;
      World.ELEMENT = $(_renderer.domElement);
      World.CAMERA = _camera;
      World.NUKE = _nuke;
      if (Tests.renderFXAA()) {
        _nuke.add(new FXAA());
      }
    })();
    if (RenderManager.type == RenderManager.NORMAL) {
      Camera.instance(_camera);
      Render.capFPS = Tests.capFPS();
    }
    (function initControls() {
      if (!window.DebugControls) {
        return;
      }
      const renderTypeNormal = RenderManager.type === RenderManager.NORMAL;
      if (!Utils.query("orbit")) {
        let camera = new BaseCamera();
        camera.group.position.set(0, 0, 6);
        camera.lock();
        return;
      }
      const Controls = Utils.query("wasd") ? WASDControls : DebugControls;
      _controls = new Controls(_camera, World.ELEMENT.div);
      if (renderTypeNormal) {
        _controls.target = new Vector3(0, 0, 0);
      } else {
        _controls.enabled = false;
      }
      World.CONTROLS = _controls;
      World.CAMERA.position.z = 6;
    })();
    (function addHandlers() {
      _this.events.sub(Events.RESIZE, resize);
      SceneLayout.breakpoint = Utils.query("breakpoint");
      resize();
    })();
    if (!Utils.query("uilOnly")) {
      Render.onDrawFrame(loop);
    }
  }, function () {
    var _instance;
    World.instance = function () {
      _instance ||= new World();
      return _instance;
    };
  });
  Class(function ErrorPage(isFirst = false) {
    Inherit(this, InteractivePage, "error", isFirst);
    (async function () {})();
  });
  Class(function ErrorSection(index, parentConfig, isFirst) {
    Inherit(this, InteractiveSection, "errorMain", index, parentConfig, isFirst);
    const _this = this;
    var _text;
    var _text2;
    var _camera;
    var _hitArea;
    function clickHome() {
      ViewController.instance().changeRoute("");
    }
    function resize() {
      let aspect = Stage.width / Stage.height;
      _camera.setFOV(Math.range(aspect, 0.4, 1.6, 55, 30, true));
      _camera.group.position.x = Math.range(aspect, 0.4, 1.6, -1.3, 0);
      _camera.group.position.y = Math.range(aspect, 0.4, 1.6, -0.5, 0);
    }
    (async function () {
      await _this.wait(_this, "isReady");
      await CMS.ready();
      _text = _this.layers.text;
      _text2 = _this.layers.text2;
      _hitArea = _this.layers.hitArea;
      _camera = _this.layers.sceneCamera;
      _this.flag("textReady", true);
      (function addListeners() {
        Interaction3D.find(_camera).add(_hitArea, () => {}, clickHome);
        _this.onResize(resize);
        resize();
      })();
      if (Global.PLAYGROUND) {
        _this.show();
      }
    })();
    _this.show = async function () {
      await _this.wait(_this, "textReady");
      _this._show();
      await _this.wait(_text, "shaderClass");
      await _this.wait(_text2, "shaderClass");
      _text.shaderClass.animateIn();
      _text2.shaderClass.animateIn();
    };
    _this.hide = async function () {
      await _this.wait(_this, "textReady");
      _this._hide();
      _text.shaderClass.animateOut();
      _text2.shaderClass.animateOut();
    };
  });
  Class(function ErrorUI() {
    Inherit(this, InteractiveUI);
    const _this = this;
    const $this = this.element;
    var _social;
    (function initSocial() {
      (_social = _this.initClass(MenuSocialv2, [$this])).element.css({
        position: "absolute",
        bottom: "4rem",
        right: "6rem"
      });
    })();
    _this.animateIn = function (delay = 300) {
      _social.animateIn(delay);
    };
    _this.animateOut = async function () {
      return new Promise(async resolve => {
        _social.animateOut();
        resolve();
      });
    };
  });
  Class(function SceneView() {
    Inherit(this, Object3D);
    const _this = this;
    (function initMesh() {
      let mesh = new Mesh(new BoxGeometry(1, 1, 1), Utils3D.getTestShader());
      _this.add(mesh);
      _this.startRender(t => {
        mesh.position.y = Math.sin(t * 0.002) * 0.3;
        mesh.rotation.y += 0.01;
        mesh.rotation.x += 0.004;
      });
      World.SCENE.add(_this.group);
      let camera = _this.initClass(GazeCamera);
      camera.moveXY.set(8, 4);
      camera.position.set(0, 0, 6);
      camera.lerpSpeed = 0.07;
      camera.lookAt = new Vector3();
      camera.lock();
    })();
  });
  Class(function AboutPage(isFirst = false) {
    Inherit(this, InteractiveScrollPage, "about", isFirst);
    const _this = this;
    var _camera;
    var _topLayer;
    var _topScene;
    var _scrollHint;
    var _space;
    var _section1;
    var _section2;
    var _section3;
    var _section4;
    var _section5;
    var _section6;
    var _section7;
    var _sectionWrapper;
    async function resizeHandler() {
      await _this.wait("isReady");
      let aspect = Stage.width / Stage.height;
      _this.layout.breakpoint = aspect < 1 ? "portrait" : aspect < 1.45 ? "tablet" : "";
      if (_this.layout.breakpoint == "portrait") {
        _scrollHint.visible = false;
        _section1.group.position.y = -1;
        _section2.group.position.y = -3.56;
        _section3.group.position.y = -5.7;
        _section4.group.position.y = -11.7;
        _section5.group.position.y = -13.9;
        _section6.group.position.y = -20.6;
        _section7.group.position.y = -23.6;
        _camera.bottom = -31;
        if (Device.mobile) {
          _section1.group.position.y = -1;
          _section2.group.position.y = -3.56;
          _section3.group.position.y = -5.7;
          _section4.group.position.y = -13.2;
          _section5.group.position.y = -15.4;
          _section6.group.position.y = -23.6;
          _section7.group.position.y = -26.6;
          _camera.bottom = -35;
        }
      } else if (_this.layout.breakpoint == "tablet" && Device.mobile) {
        _scrollHint.visible = false;
        _section1.group.position.y = 0;
        _section2.group.position.y = -2.11;
        _section3.group.position.y = -3.35;
        _section4.group.position.y = -10.1;
        _section5.group.position.y = -11.4;
        _section6.group.position.y = -18.4;
        _section7.group.position.y = -20;
        _camera.bottom = -29;
      } else if (Device.mobile) {
        _this.layout.breakpoint = "portrait";
        _section1.group.position.y = -1;
        _section2.group.position.y = -3.56;
        _section3.group.position.y = -5.7;
        _section4.group.position.y = -11.7;
        _section5.group.position.y = -13.9;
        _section6.group.position.y = -20.6;
        _section7.group.position.y = -23.6;
        _camera.bottom = -31.5;
      } else if (_this.layout.breakpoint == "") {
        _scrollHint.visible = true;
        _section1.group.position.y = 0;
        _section2.group.position.y = -2.11;
        _section3.group.position.y = -3.35;
        _section4.group.position.y = -7.35;
        _section5.group.position.y = -8.8;
        _section6.group.position.y = -13;
        _section7.group.position.y = -14.8;
        _camera.bottom = -20;
      } else if (_this.layout.breakpoint == "tablet") {
        _scrollHint.visible = true;
        _section1.group.position.y = 0;
        _section2.group.position.y = -2.11;
        _section3.group.position.y = -3.35;
        _section4.group.position.y = -9.7;
        _section5.group.position.y = -11;
        _section6.group.position.y = -18;
        _section7.group.position.y = -19.8;
        _camera.bottom = -28;
      }
      if (aspect < 0.6) {
        _camera.group.position.z = Math.range(aspect, 1, 0.4, 7, 8);
        _sectionWrapper.position.y = -3;
        _topLayer.position.z = 1.75;
      } else if (aspect < 1.45) {
        _sectionWrapper.position.y = (_topLayer.scale._y - _topLayer.position._y) * -1;
        _camera.group.position.z = 6;
        _topLayer.position.z = 0;
      } else {
        _camera.group.position.z = 6;
        _sectionWrapper.position.y = -3.5;
        _topLayer.position.z = 0;
      }
      if (aspect < 1) {
        _topLayer.shader.set("uAngle", 0);
      } else {
        _topLayer.shader.set("uAngle", -5);
      }
    }
    (async function () {
      await _this.ready();
      [_camera, _topLayer, _topScene, _scrollHint, _space, _section1, _section2, _section3, _section4, _section5, _section6, _section7, _sectionWrapper] = await _this.layout.getLayers("camera", "topLayer", "topScene", "scrollHint", "space", "section1", "section2", "section3", "section4", "section5", "section6", "section7", "sectionWrapper");
      _topLayer.renderOrder = -1;
      _space.renderOrder = -1;
      (function addListeners() {
        _this.onResize(resizeHandler);
        _this.events.sub(_this, "LayerVisible", e => {
          Track.event("about", {
            items: [{
              item_id: `about_section_scroll_${e.key}`,
              item_name: `about_section_scroll_${e.key}`
            }]
          }, `about:section:${e.key}`);
        });
      })();
      Dev.expose("about", _this);
      _this.flag("isReady", true);
    })();
    this.animateIn = async function () {
      await _this.wait("isReady");
      _topScene.animateIn();
      tween(_scrollHint, {
        alpha: 0
      }, 0, "easeOutCubic");
      tween(_scrollHint, {
        alpha: 1
      }, 600, "easeOutCubic", 1500);
      let z = _camera.group.position.z;
      _camera.group.position.z -= 1.5;
      tween(_camera.group.position, {
        z: z
      }, 3000, "easeOutCubic");
    };
    this.animateOut = async function () {};
    _this.onVisible = function () {
      CameraUtil.hardBlockScroll(true);
    };
  });
  Class(function AboutPageTest() {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      let instance = _this.initClass(AboutSectionType4, {
        text1: "We also know that in order to succeed, our fuels cant just be as good as fossil fuels, they have to be better. Thats why weve designed them to be high-performance and clean-burning. Most importantly, our fuels will cost the same or less than fossil fuels.",
        text2: "Given the magnitude of the crisis, there are some who think that the only way to respond is to fundamentally change who we are. To do and be less.\n\nWe, at Prometheus, think this would be a terrible mistake. We believe we can meet this epic challenge not in spite of, but because of who we are.\n\nThe urge to discover what lies beyond that far horizon, or that ocean, or this planet, is part of what makes us human. We are explorers and adventurers. We search for inspiration, for whats new and whats next. And we yearn to live better, larger lives. Throughout human existence, this restless impulse has led our species to overcome near unfathomable hardships. And its exactly this ability that we need now.\n\nWe shouldnt shrink the scope of human experience. Instead, our goal should be to break the historical link between energy and the dirty fossil fuels that are destroying our world. Instead, we should make energy and the things we do with it in a brand new way.\n\nThis is our mission at Prometheus. We are propelled by the future we imagineone in which everyone who wants to can experience the joy of a road trip, the thrill of flight, and, one day soon, the humbling awe of viewing the Earth from orbit.",
        text3: "We invite you to imagine this future, and if you find it as inspiring as we do, we hope youll join us."
      });
      _this.add(instance.layout.group);
    })();
  });
  Class(function AboutSection(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _instance;
    (async function () {
      let instance;
      let wildcard = _input.get("wildcard");
      let [type, id] = wildcard?.split("|") || [];
      await CMS.ready();
      switch (id) {
        case "1":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text1")
          });
          break;
        case "2":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text2")
          });
          break;
        case "3":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text3"),
            text2: CMS.get("about.text4"),
            text3: CMS.get("about.text5")
          });
          break;
        case "4":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text6")
          });
          break;
        case "5":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text7"),
            text2: CMS.get("about.text8"),
            text3: CMS.get("about.text9")
          });
          break;
        case "6":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text10")
          });
          break;
        case "7":
          instance = _this.initClass(window[type], {
            text1: CMS.get("about.text11"),
            text2: CMS.get("about.text12"),
            text3: CMS.get("about.text13")
          });
      }
      _instance = instance;
    })();
    _this.get("hit", async () => await _instance.hit);
    _this.onVisible = () => {
      _instance.onVisible();
    };
    _this.onInvisible = () => {
      _instance.onInvisible();
    };
    _this.reset = () => {
      _instance.reset();
    };
  });
  Class(function AboutSectionType1(_input) {
    Inherit(this, Object3D);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    async function resize() {
      await _this.wait("textInitialized");
      let aspect = Stage.width / Stage.height;
      _this.layout.breakpoint = aspect < 1 ? "portrait" : aspect < 1.45 ? "tablet" : "";
      if (aspect < 1) {
        Device.mobile;
        _text1.setPropertiesCheck({
          size: 0.5,
          width: 3.4,
          lineHeight: 1
        });
      } else {
        Device.mobile;
        _text1.setPropertiesCheck({
          size: 0.3,
          width: 3.4,
          lineHeight: 1.2
        });
      }
    }
    (async function initScene() {
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType1");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      if (_input) {
        (async function initText() {
          await _text1.ready();
          _text1.setText(_input.text1.toUpperCase());
          _this.flag("textInitialized", true);
        })();
      }
      _this.onResize(resize);
    })();
  });
  Class(function AboutSectionType2(_input) {
    Inherit(this, Object3D);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    var _text3;
    async function resize() {
      await _this.wait("textInitialized");
      let aspect = Stage.width / Stage.height;
      _this.layout.breakpoint = aspect < 1 ? "portrait" : aspect < 1.45 ? "tablet" : "";
      if (aspect < 1.45) {
        _text1.setPropertiesCheck({
          size: 0.15,
          width: 1.75,
          align: "center"
        });
        _text2.setPropertiesCheck({
          size: 0.15,
          width: 1.75,
          align: "center"
        });
        _text3.setPropertiesCheck({
          size: 0.07,
          width: 1.75,
          align: "center"
        });
        let _text1Dimensions = await _text1.getDimensions();
        _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.1;
        let _text2Dimensions = await _text2.getDimensions();
        _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.3;
        if (Device.mobile) {
          _text1.setPropertiesCheck({
            size: 0.15,
            width: 1.4,
            align: "center"
          });
          _text2.setPropertiesCheck({
            size: 0.15,
            width: 1.4,
            align: "center"
          });
          _text3.setPropertiesCheck({
            size: 0.07,
            width: 1.4,
            align: "center"
          });
          let _text1Dimensions = await _text1.getDimensions();
          _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.2;
          let _text2Dimensions = await _text2.getDimensions();
          _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.4;
        }
        _text1.group.position.x = 0;
        _text2.group.position.x = 0;
        _text3.group.position.x = 0;
      } else if (Device.mobile) {
        _text1.setPropertiesCheck({
          size: 0.2,
          width: 5,
          align: "center"
        });
        _text2.setPropertiesCheck({
          size: 0.2,
          width: 5,
          align: "center"
        });
        _text3.setPropertiesCheck({
          size: 0.12,
          width: 5,
          align: "center"
        });
        _text1.group.position.x = 0;
        _text2.group.position.x = 0;
        _text3.group.position.x = 0;
        let _text1Dimensions = await _text1.getDimensions();
        _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.1;
        let _text2Dimensions = await _text2.getDimensions();
        _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.3;
      } else {
        _text1.setPropertiesCheck({
          size: 0.13,
          width: 1.5,
          align: "left"
        });
        _text2.setPropertiesCheck({
          size: 0.13,
          width: 1.5,
          align: "left"
        });
        _text3.setPropertiesCheck({
          size: 0.07,
          width: 2.5,
          align: "left"
        });
        _text1.group.position.x = -2.3;
        _text2.group.position.x = -2.3;
        _text3.group.position.x = -0.291;
        let _text1Dimensions = await _text1.getDimensions();
        _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.2;
        _text3.group.position.y = 0;
      }
    }
    (async function initScene() {
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType2");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      _text3 = _this.layers.text3;
      if (_input) {
        (async function initText() {
          _text1.setText(_input.text1.toUpperCase());
          _text2.setText(_input.text2.toUpperCase());
          _text3.setText(_input.text3);
          await _text1.ready();
          let _text1Dimensions = await _text1.getDimensions();
          _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.2;
          _this.flag("textInitialized", true);
        })();
      }
      _this.onResize(resize);
    })();
  });
  Class(function AboutSectionType3(_input) {
    Inherit(this, Object3D);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    (async function initScene() {
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType3");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      if (_input) {
        (async function initText() {
          await _text1.ready();
          _text1.setText(_input.text1.toUpperCase());
          _text2.setText(_input.text2.toUpperCase());
        })();
      }
    })();
  });
  Class(function AboutSectionType4(_input) {
    Inherit(this, Object3D);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    var _text3;
    async function resize() {
      await _this.wait("textInitialized");
      let aspect = Stage.width / Stage.height;
      _this.layout.breakpoint = aspect < 1 ? "portrait" : aspect < 1.45 ? "tablet" : "";
      if (aspect < 1.45) {
        _text1.setPropertiesCheck({
          size: 0.15,
          width: 1.75,
          align: "center"
        });
        _text2.setPropertiesCheck({
          size: 0.07,
          width: 1.75,
          align: "center"
        });
        _text3.setPropertiesCheck({
          size: 0.07,
          width: 1.75,
          align: "center"
        });
        let _text1Dimensions = await _text1.getDimensions();
        _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.3;
        let _text2Dimensions = await _text2.getDimensions();
        _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.2;
        if (Device.mobile) {
          _text1.setPropertiesCheck({
            size: 0.15,
            width: 1.4,
            align: "center"
          });
          _text2.setPropertiesCheck({
            size: 0.07,
            width: 1.4,
            align: "center"
          });
          _text3.setPropertiesCheck({
            size: 0.07,
            width: 1.4,
            align: "center"
          });
          let _text1Dimensions = await _text1.getDimensions();
          _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.3;
          let _text2Dimensions = await _text2.getDimensions();
          _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.4;
        }
        _text1.group.position.x = 0;
        _text2.group.position.x = 0;
        _text3.group.position.x = 0;
      } else if (Device.mobile) {
        _text1.setPropertiesCheck({
          size: 0.2,
          width: 5,
          align: "center"
        });
        _text2.setPropertiesCheck({
          size: 0.12,
          width: 5,
          align: "center"
        });
        _text3.setPropertiesCheck({
          size: 0.12,
          width: 5,
          align: "center"
        });
        _text1.group.position.x = 0;
        _text2.group.position.x = 0;
        _text3.group.position.x = 0;
        let _text1Dimensions = await _text1.getDimensions();
        _text2.group.position.y = _text1.group.position.y - _text1Dimensions.height - 0.3;
        let _text2Dimensions = await _text2.getDimensions();
        _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.4;
      } else {
        _text1.setPropertiesCheck({
          size: 0.13,
          width: 1.5,
          align: "left"
        });
        _text2.setPropertiesCheck({
          size: 0.07,
          width: 2.5,
          align: "left"
        });
        _text3.setPropertiesCheck({
          size: 0.07,
          width: 2.5,
          align: "left"
        });
        _text1.group.position.x = -2.3;
        _text2.group.position.x = -0.291;
        _text3.group.position.x = -0.291;
        _text2.group.position.y = 0;
        let _text2Dimensions = await _text2.getDimensions();
        _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.2;
      }
    }
    (async function initScene() {
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType4");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      _text3 = _this.layers.text3;
      if (_input) {
        (async function initText() {
          _text1.setText(_input.text1.toUpperCase());
          _text2.setText(_input.text2);
          _text3.setText(_input.text3);
          await _text2.ready();
          await _text3.ready();
          let _text2Dimensions = await _text2.getDimensions();
          _text3.group.position.y = _text2.group.position.y - _text2Dimensions.height - 0.2;
          _this.flag("textInitialized", true);
        })();
      }
      _this.onResize(resize);
    })();
  });
  Class(function AboutSectionType5(textCopy1, textCopy2, textCopy3) {
    Inherit(this, FXScene);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    var _text3;
    (async function initScene() {
      _this.create();
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType5");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      _text3 = _this.layers.text3;
      _this.scene.add(_this.layout.group);
      (function initText() {
        _text1.setText(textCopy1.toUpperCase());
        _text2.setText(textCopy2.toUpperCase());
        _text3.setText(textCopy3);
      })();
    })();
  });
  Class(function AboutSectionType6() {
    Inherit(this, FXScene);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    (async function initScene() {
      _this.create();
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType6");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      _this.scene.add(_this.layout.group);
      (function initText() {
        let textCopy1 = "We know we have to move fast, maybe scaling faster than any industry has moved before.";
        _text1.setText(textCopy1.toUpperCase());
        let textCopy2 = "But we believe its possible and we have a plan to do it.";
        _text2.setText(textCopy2.toUpperCase());
      })();
    })();
  });
  Class(function AboutSectionType7(textCopy1, textCopy2, textCopy3) {
    Inherit(this, FXScene);
    Inherit(this, AbstractAboutSectionType);
    const _this = this;
    var _text1;
    var _text2;
    var _text3;
    (async function initScene() {
      _this.create();
      _this.layout = _this.initClass(SceneLayout, "AboutSectionType7");
      _this.layers = await _this.layout.getAllLayers();
      _text1 = _this.layers.text1;
      _text2 = _this.layers.text2;
      _text3 = _this.layers.text3;
      _this.scene.add(_this.layout.group);
      (function initText() {
        _text1.setText(textCopy1.toUpperCase());
        _text2.setText(textCopy1);
        _text3.setText(textCopy1);
      })();
    })();
    initCamera();
  });
  Class(function AboutSpaceBG(_mesh, _shader) {
    function getTexture(src) {
      let texture = Utils3D.getTexture(src);
      texture.wrapS = texture.wrapT = Texture.MIRROR_REPEAT;
      return texture;
    }
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: getTexture
      },
      tStars: {
        value: null,
        getTexture: getTexture
      },
      uScale2: {
        value: new Vector2(1, 1)
      },
      uNoiseScale2: {
        value: new Vector2(1, 1)
      },
      uTimeScale: {
        value: 1
      },
      uMap: {
        value: new Vector2(0, 1)
      }
    });
  });
  Class(function AboutTopLayer(_mesh, _shader) {
    Inherit(this, Component);
    const _this = this;
    function resizeHandler() {
      let aspect = Stage.width / Stage.height;
      _mesh.scale.x = aspect * _mesh.scale.y;
    }
    (async function () {
      let scene = await _this.parent.getLayer("topScene");
      _mesh.scale.x;
      _mesh.scale.y;
      _shader.set("tMap", scene);
      _this.onResize(resizeHandler);
    })();
  });
  Class(function AboutTopLayerShader(_mesh, _shader) {
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uAngle: {
        value: 0
      }
    });
    _mesh.renderOrder = 999;
  });
  Class(function AboutTopScene() {
    Inherit(this, FXScene);
    const _this = this;
    var _text;
    var _people;
    var _space;
    async function resizeHandler() {
      let aspect = Stage.width / Stage.height;
      _this.layout.breakpoint = aspect < 1 ? "portrait" : aspect < 1.45 ? "tablet" : "";
      _space.scale.x = aspect * _space.scale.y;
      _people.scale.x = aspect * 4.1;
      _people.scale.y = aspect * 2.5625;
      _people.position.y = Math.range(aspect, 0, 2, -2, 0.5);
      if (Stage.width < Stage.height) {
        _text.setText("OUR\nMISSION");
      } else {
        _text.setText("MISSION");
      }
    }
    (async function () {
      _this.create(_this.parent?.parent?.nuke);
      _this.layout = _this.initClass(SceneLayout, "AboutTopScene");
      _space = await _this.layout.getLayer("space");
      await _this.layout.getLayer("earth");
      _text = await _this.layout.getLayer("text");
      _people = await _this.layout.getLayer("people");
      _text.renderOrder += 100;
      let camera = await _this.layout.getLayer("camera");
      _this.useCamera(camera);
      _this.scene.add(_this.layout.group);
      if (_this.parent.getLayer) {
        let parentCamera = await _this.parent.getLayer("camera");
        _this.startRender(_ => {
          camera.group.position.y = parentCamera.group.position.y * -0.2;
          camera.group.position.z = parentCamera.group.position.y * -0.4;
          camera.lookAt.y = -parentCamera.group.position.y * 0.7;
        });
      }
      (async function initText() {
        await _text.ready();
        _this.flag("textInitialized", true);
      })();
      _this.onResize(resizeHandler);
      if (_this.isPlayground()) {
        defer(() => {
          _this.animateIn();
        });
      }
    })();
    _this.animateIn = async function () {
      await _text.ready();
      if (_text.shaderClass && _text.shaderClass.animateIn) {
        _text.shaderClass.reset();
        _text.shaderClass.animateIn(ViewController.instance().isVisible ? 800 : 1500);
      } else if (_text.shader.shaderClass && _text.shader.shaderClass.animateIn) {
        _text.shader.shaderClass.reset();
        _text.shader.shaderClass.animateIn(ViewController.instance().isVisible ? 800 : 1500);
      } else {
        console.warn("Text missing WaveTextShader shader class");
      }
    };
    _this.animateOut = async function () {
      await _text.ready();
    };
  });
  Class(function AbstractAboutSectionType() {
    Inherit(this, Component);
    const _this = this;
    var _texts;
    var _hit;
    (async function () {
      await _this.wait(_this, "layers");
      (_texts = await _this.layout.getAllMatching("text")).forEach(async text => {
        await text.ready();
        text.shader.transparent = true;
        text.shader.set("uBoundingMin", text.shader.get("uBoundingMin").copy(text.text.dimensions.min));
        text.shader.set("uBoundingMax", text.shader.get("uBoundingMax").copy(text.text.dimensions.max));
        text.shader.set("uTransition0", 0);
      });
      (function initHit() {
        let shader = _this.initClass(Shader, "InteractiveScrollSectionHitShader");
        (_hit = new Mesh(World.PLANE, shader)).scale.setScalar(0.001);
        _hit.position.y = 1;
        _hit.shader.transparent = true;
        _hit.renderOrder = -1000;
        _this.add(_hit);
        _this.flag("hitReady", true);
      })();
    })();
    _this.get("hit", async () => {
      await _this.wait(_this, "hitReady");
      return _hit;
    });
    _this.onInvisible = () => {
      _this.shown &&= false;
    };
    _this.onVisible = () => {
      if (!_this.shown) {
        _this.shown = true;
        if (_this.animateIn) {
          _this.animateIn();
        }
        if (!_this.animatedIn) {
          (function animateIn() {
            _texts.forEach((text, index) => {
              if (text.shaderClass && text.shaderClass.animateIn) {
                text.shaderClass.animateIn(index * 300);
              } else if (text.shader.shaderClass && text.shader.shaderClass.animateIn) {
                text.shader.shaderClass.animateIn(index * 300);
              } else {
                console.warn("Text missing WaveTextShader shader class");
              }
            });
          })();
        }
      }
    };
    _this.hide = () => {
      if (_this.animateOut) {
        _this.animateOut();
      }
      (function animateOut() {
        _texts.forEach((text, index) => {
          if (text.shaderClass && text.shaderClass.animateOut) {
            text.shaderClass.animateOut(0);
          } else {
            console.warn("Text missing WaveTextShader shader class");
          }
        });
      })();
      _this.animatedIn = false;
      _this.shown = false;
    };
    _this.reset = () => {
      _this.shown = false;
      _this.animatedIn = false;
      _texts.forEach(async text => {
        await text.ready();
        if (text.shaderClass && text.shaderClass.animateIn) {
          text.shaderClass.reset();
        } else if (text.shader.shaderClass && text.shader.shaderClass.reset) {
          text.shader.shaderClass.reset();
        } else {
          console.warn("Text missing WaveTextShader shader class");
        }
      });
    };
  });
  Class(function CustomText3D(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    (async function () {})();
  });
  Class(function SolidColorShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color("#000000")
      },
      uAlpha: {
        value: 0.5
      }
    });
  });
  Class(function Chapter1Page(isFirst = false) {
    Inherit(this, InteractivePage, "chapter1", isFirst);
    const _this = this;
    function onViewChange(e) {
      if (e && e.view && e.view.parent === _this) {
        Track.event("chapter1", {
          items: [{
            item_id: `chapter1_screen_${e.index}`,
            item_name: `chapter1_screen_${e.index}`
          }]
        }, `chapter1:section:${e.index}`);
      }
    }
    (async function () {
      await _this.ready();
      (function addListeners() {
        _this.events.sub(SmoothRenderManager.VIEW_CHANGE, onViewChange);
      })();
    })();
  });
  Class(function Chapter2Page(isFirst = false) {
    Inherit(this, InteractivePage, "chapter2", isFirst);
    const _this = this;
    function onViewChange(e) {
      if (e && e.view && e.view.parent === _this) {
        Track.event("chapter2", {
          items: [{
            item_id: `chapter2_screen_${e.index}`,
            item_name: `chapter2_screen_${e.index}`
          }]
        }, `chapter2:section:${e.index}`);
      }
    }
    (async function () {
      await _this.ready();
      (function addListeners() {
        _this.events.sub(SmoothRenderManager.VIEW_CHANGE, onViewChange);
      })();
    })();
  });
  Class(function Chapter3Page(isFirst = false) {
    Inherit(this, InteractivePage, "chapter3", isFirst);
    const _this = this;
    function onViewChange(e) {
      if (e && e.view && e.view.parent === _this) {
        Track.event("chapter3", {
          items: [{
            item_id: `chapter3_screen_${e.index}`,
            item_name: `chapter3_screen_${e.index}`
          }]
        }, `chapter3:section:${e.index}`);
      }
    }
    (async function () {
      await _this.ready();
      (function addListeners() {
        _this.events.sub(SmoothRenderManager.VIEW_CHANGE, onViewChange);
      })();
    })();
  });
  Class(function ChapterCopy(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $translate;
    var $text;
    var $sub;
    var _cta;
    async function resize() {
      let width = Stage.width > Stage.height || !Device.mobile.phone ? Math.min(Stage.width - 100, Device.mobile ? 300 : 600) : Stage.width - 80;
      if (Device.mobile.phone) {
        width = Math.min(310, Stage.width - 70);
      }
      if ($text) {
        $text.resize({
          width: width
        });
      }
      if ($sub) {
        $sub.resize({
          width: width
        });
      }
      await defer();
      let height = 0;
      let textHeight = $text?.dimensions?.height || 0;
      let subHeight = $sub?.dimensions?.height || 0;
      if ($text) {
        height += textHeight;
      }
      if ($sub) {
        height += subHeight + 30;
      }
      if (_cta) {
        height += 30;
      }
      $wrapper.x = Math.max(40, Stage.width * 0.06);
      $wrapper.y = Stage.height - Math.max(40, Stage.width * 0.06) - height;
      if (Device.mobile.phone && Stage.width < Stage.height) {
        $wrapper.x = Math.max(35, Stage.width * 0.06);
        $wrapper.y -= _config.dashboard ? 50 : 30;
      }
      if (_config.top) {
        $wrapper.y = Math.max(40, Stage.width * 0.06) + 300;
      }
      if (_config.right) {
        $wrapper.x = Math.min(Stage.width - 40, Stage.width * 0.94);
        if (Device.mobile.phone && Stage.width < Stage.height) {
          $wrapper.x = Math.min(Stage.width - 35, Stage.width * 0.94);
        }
      }
      if ($sub && $text) {
        $sub.y = textHeight + 30;
      }
      if (_cta && _cta.element) {
        _cta.element.y = 0;
        if ($text) {
          _cta.element.y += textHeight + 50;
        }
        if ($sub) {
          _cta.element.y += subHeight + 10;
        }
      }
    }
    _this.progress = 0;
    (async function () {
      (function init() {
        ($wrapper = $gl()).hide();
        _this.element.add($wrapper);
        ($translate = $gl()).alpha = 0;
        $wrapper.add($translate);
      })();
      if (_config.copy) {
        await async function initText() {
          let size = Math.range(_config.copy.length, 10, 120, 28, 16, true);
          if (Device.mobile.phone) {
            size *= Stage.width > Stage.height ? 0.6 : 0.7;
          }
          let text = _config.copy;
          if (Device.mobile) {
            text = text.replace(/\n/g, " ");
          }
          $text = $glText(text.toString().toUpperCase(), "FuturaLT-Bold", size, {
            width: 450,
            align: _config.right ? "right" : "left",
            lineHeight: Math.range(size, 28, 16, 1.45, 1.6),
            letterSpacing: 0,
            color: _config.color || Colors.value.beige
          });
          $translate.add($text);
          $text.textContent = text;
          let shader = _this.initClass(Shader, "ChapterCopyShader", {
            tNoise: {
              value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
              ignoreUIL: true
            },
            uTimeScale: {
              value: 0.39
            },
            uUVScale: {
              value: 1.78
            },
            uRotation: {
              value: -180
            },
            uTransition0: {
              value: 1.01
            },
            uBoundingMin: {
              value: new Vector3()
            },
            uBoundingMax: {
              value: new Vector3()
            },
            blending: _config.additive ? Shader.ADDITIVE_BLENDING : Shader.NORMAL_BLENDING
          });
          $text.shader = shader;
          $text.useShader(shader);
          await $text.text.ready();
          $text.text.shader.set("uBoundingMin", new Vector3().copy($text.dimensions.min));
          $text.text.shader.set("uBoundingMax", new Vector3().copy($text.dimensions.max));
        }();
      }
      if (_config.sub) {
        (function initSub() {
          let text = _config.sub;
          if (Device.mobile) {
            text = text.replace(/\n/g, " ");
          }
          $sub = $glText(text.toString(), "FuturaLT-Medium", Device.mobile.phone ? 14 : 16, {
            width: 320,
            align: "left",
            lineHeight: 1.6,
            letterSpacing: 0,
            color: _config.color || Colors.value.beige
          });
          $translate.add($sub);
        })();
      }
      if (_config.cta) {
        (function initCTA() {
          _cta = _this.initClass(CopyButton, {
            width: 170,
            height: 40,
            text: _config.cta,
            bg: _config.color || Colors.value.beige,
            color: _config.color == Colors.value.black ? Colors.value.beige : Colors.value.black
          });
          $translate.add(_cta.element);
          _this.events.sub(_cta, Events.CLICK, _ => {
            ViewController.instance().changeRoute("news/prometheus-metaforge");
          });
        })();
      }
      await _this.wait(100);
      (function addHandlers() {
        _this.onResize(resize);
      })();
    })();
    this.setCopy = async function (text) {
      if ($text) {
        $text.setText(text);
      }
      $wrapper.hide();
    };
    this.update = function (progress) {
      if (!$translate) {
        return;
      }
      let offset = _config.start * _config.height * 200;
      $translate.y = offset - progress * _config.height * 200 + 80;
      let pos = Math.range(progress, _config.start, _config.end, -1, 1);
      $translate.alpha = Math.smoothStep(1, 0.3, Math.abs(pos));
      $text.shader.set("uRotation", pos > 0 ? -180 : 0);
      $text.shader.set("uTransition0", Math.smoothStep(1, 0.3, Math.abs(pos)));
      if (_cta) {
        _cta.element.alpha = Math.smoothStep(-0.4, 0.1, pos) * Math.smoothStep(0.8, 0.5, pos);
      }
      if ($translate.alpha > 0) {
        $wrapper.show();
      } else {
        $wrapper.hide();
      }
    };
    this.animateIn = async function () {
      _this.isVisible ||= true;
    };
    this.animateOut = async function () {
      _this.isVisible &&= false;
    };
  });
  Class(function ChapterOverlay(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $image;
    function resize() {
      $image.x = Stage.width * 0.9 - 100;
      $image.y = Stage.height * 0.85 - 100;
    }
    _this.progress = 0;
    (async function () {
      (function initText() {
        ($image = $gl(200, 200, _config.src)).shader.transparent = true;
        $image.alpha = 0;
        _this.element.add($image);
      })();
      (function addHandlers() {
        _this.onResize(resize);
      })();
    })();
    this.setImage = async function (image) {
      $image.shader.set("tMap", Utils3D.getTexture(image));
    };
    this.update = function (progress) {
      let movement = Math.range(progress, _config.start, _config.end, 1, -1);
      $image.alpha = Math.smoothStep(1, 0.5, Math.abs(movement));
    };
    this.animateIn = async function () {
      if (!_this.isVisible) {
        _this.isVisible = true;
        $image.show();
        $image.alpha = 0;
        $image.y = 10;
        $image.tween({
          alpha: 1,
          y: 0
        }, 1500, "easeOutQuart");
      }
    };
    this.animateOut = async function () {
      if (_this.isVisible) {
        _this.isVisible = false;
        $image.tween({
          alpha: 0,
          y: -10
        }, 600, "easeInSine", _ => {
          $image.hide();
        });
      }
    };
  });
  Class(function CopyButton(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $text;
    var $bg;
    var $hit;
    function hover(e) {
      switch (e.action) {
        case "over":
          $bg.tween({
            alpha: 0.5
          }, 300, "easeOutSine");
          break;
        case "out":
          $bg.tween({
            alpha: 1
          }, 500, "easeOutSine");
      }
    }
    function click() {
      _this.events.fire(Events.CLICK, _config);
    }
    (async function () {
      (function initText() {
        $wrapper = $gl();
        _this.element.add($wrapper);
        $bg = $wrapper.create(_config.width || 200, _config.height || 50, _config.bg || "#ff0000");
        ($text = $glText(_config.text.toString().toUpperCase(), "FuturaLT-Bold", 10, {
          width: _config.width || 200,
          align: "center",
          lineHeight: 1.5,
          letterSpacing: 0,
          color: _config.color || Colors.value.beige
        })).x = _config.width / 2;
        $text.y = _config.height / 2 - 5;
        $text.z += 0.001;
        $wrapper.add($text);
        ($hit = $gl(_config.width || 200, _config.height || 50, "empty")).shader.neverRender = true;
        $wrapper.add($hit);
      })();
      (function addHandlers() {
        $hit.mesh.interactionScene = GLUI.Stage.scene;
        $hit.interact(hover, click);
      })();
    })();
    this.animateIn = async function (delay = 0) {
      $wrapper.alpha = 0;
      $wrapper.y = 10;
      $wrapper.tween({
        alpha: 1,
        y: 0
      }, 1000, "easeOutQuart", delay + 200);
    };
    this.animateOut = async function () {};
  });
  Class(function CoverTest() {
    Inherit(this, Object3D);
    const _this = this;
    (function () {
      let mesh = new Mesh(World.QUAD, _this.initClass(Shader, "ScreenQuad", {
        tMap: {
          value: LoaderCoverView.instance().rt
        }
      }));
      _this.add(mesh);
    })();
  });
  Class(function Instruction(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $translate;
    var $text;
    async function resize() {
      $wrapper.x = Stage.width / 2;
      $wrapper.y = Stage.height - Math.max(40, Stage.height * 0.06) - (Device.mobile.phone ? 10 : 35);
    }
    _this.progress = 0;
    (async function () {
      (function init() {
        ($wrapper = $gl()).hide();
        _this.element.add($wrapper);
        ($translate = $gl()).alpha = 0;
        $wrapper.add($translate);
      })();
      if (_config.copy) {
        await async function initText() {
          let text = (Device.mobile ? "TAP AND HOLD TO\n" : "HOLD SPACEBAR TO\n") + _config.copy;
          $text = $glText(text.toString().toUpperCase(), "FuturaLT-Bold", Device.mobile ? 10 : 12, {
            width: 450,
            align: "center",
            lineHeight: 1.5,
            letterSpacing: 0,
            color: _config.color || Colors.value.orange
          });
          $translate.add($text);
          $text.textContent = text;
          let shader = _this.initClass(Shader, "ChapterCopyShader", {
            tNoise: {
              value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
              ignoreUIL: true
            },
            uTimeScale: {
              value: 0.39
            },
            uUVScale: {
              value: 1.78
            },
            uRotation: {
              value: -180
            },
            uTransition0: {
              value: 1.01
            },
            uBoundingMin: {
              value: new Vector3()
            },
            uBoundingMax: {
              value: new Vector3()
            },
            blending: Shader.ADDITIVE_BLENDING
          });
          $text.shader = shader;
          $text.useShader(shader);
          await $text.text.ready();
          $text.text.shader.set("uBoundingMin", new Vector3().copy($text.dimensions.min));
          $text.text.shader.set("uBoundingMax", new Vector3().copy($text.dimensions.max));
        }();
      }
      (function addHandlers() {
        _this.onResize(resize);
      })();
    })();
    this.setCopy = async function (text) {
      if ($text) {
        $text.setText(text);
      }
      $wrapper.hide();
    };
    this.update = function (progress) {
      if (!$translate) {
        return;
      }
      _config.start;
      _config.height;
      let pos = Math.range(progress, _config.start, _config.end, -1, 1);
      $translate.alpha = Math.smoothStep(1, 0.3, Math.abs(pos));
      $translate.alpha *= 0.9 + Math.sin(Render.TIME * 0.01) * 0.1;
      $text.shader.set("uRotation", pos < 0 ? -180 : 0);
      $text.shader.set("uTransition0", Math.smoothStep(1, 0.3, Math.abs(pos)));
      $wrapper.alpha = Math.smoothStep(0.8, 0, ViewController.SPEED_MULTI.value);
      if ($translate.alpha > 0) {
        $wrapper.show();
      } else {
        $wrapper.hide();
      }
    };
    this.animateIn = async function () {
      if (!_this.isVisible) {
        _this.isVisible = true;
        resize();
        Instruction.CAN_INTERACT = _config.type || true;
      }
    };
    this.animateOut = async function () {
      if (_this.isVisible) {
        _this.isVisible = false;
        Instruction.CAN_INTERACT = false;
        _this.events.fire(ViewController.SOUNDS_ALL_STOP);
      }
    };
  }, _ => {
    Instruction.CAN_INTERACT = false;
  });
  Class(function LandingCopy(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $translate;
    var $title;
    var $text;
    var _button;
    function click() {
      ViewController.instance().changeRoute("mission");
    }
    function resize() {
      let offset = Device.mobile.phone ? 30 : 60;
      $wrapper.scale = 1;
      $wrapper.x = Stage.width - offset - Config.SCROLL_PAGE_OFFSET;
      $wrapper.y = Stage.height - 180;
      if (Device.mobile && Stage.width > Stage.height) {
        $wrapper.scale = 0.7;
        $wrapper.y = Stage.height - $wrapper.scale * 170;
      }
    }
    (async function () {
      (function initText() {
        ($wrapper = $gl()).hide();
        _this.element.add($wrapper);
        $translate = $gl();
        $wrapper.add($translate);
        $title = $glText(_config.title.toString().toUpperCase(), "FuturaLT-Bold", 17, {
          width: 400,
          align: "right",
          lineHeight: 1.4,
          letterSpacing: 0,
          color: _config.color || Colors.value.beige
        });
        $translate.add($title);
        ($text = $glText(_config.copy.toString(), "FuturaLT-Book", 14, {
          width: 260,
          align: "right",
          lineHeight: 1.5,
          letterSpacing: 0,
          color: _config.color || Colors.value.beige
        })).y = 30;
        $translate.add($text);
      })();
      (function initButton() {
        if (!_config.cta) {
          return;
        }
        (_button = _this.initClass(CopyButton, {
          width: 120,
          height: 36,
          text: _config.cta,
          bg: Colors.value.beige,
          color: Colors.value.black
        })).element.y = 90;
        _button.element.x = -120;
        _button.animateIn();
        $translate.add(_button.element);
      })();
      (function addHandlers() {
        _this.onResize(resize);
        if (_config.cta) {
          _this.events.sub(_button, Events.CLICK, click);
        }
      })();
    })();
    this.setCopy = async function (text) {
      $text.setText(text);
      $wrapper.hide();
    };
    this.update = function (progress) {
      let movement = Math.range(progress, _config.start, _config.end, 1, -1);
      $translate.alpha = Math.smoothStep(1, 0.3, -movement);
      if ($translate.alpha > 0) {
        $wrapper.show();
      } else {
        $wrapper.hide();
      }
    };
    this.animateIn = async function () {
      _this.isVisible ||= true;
    };
    this.animateOut = async function () {
      _this.isVisible &&= false;
    };
  });
  Class(function LoaderCoverView() {
    Inherit(this, Component);
    const _this = this;
    var _capture;
    var $container;
    var $spinner;
    function resize() {
      $container.width = Stage.width;
      $container.height = Stage.height;
      $spinner.x = Stage.width / 2 - 90;
      $spinner.y = Stage.height / 2 - 90;
    }
    _capture = _this.initClass(StageLayoutCapture, Stage.width, Stage.height);
    _this.rt = _capture.rt;
    (function initSpinner() {
      $container = $gl(Stage.width, Stage.height, Colors.value.black);
      let shader = _this.initClass(Shader, "LoaderCoverShader");
      ($spinner = $gl(180, 180, "#000000")).useShader(shader);
      $spinner.x = Stage.width / 2 - 90;
      $spinner.y = Stage.height / 2 - 90;
      _capture.root.add($spinner);
      _capture.root.add($container);
    })();
    (function addListeners() {
      _this.onResize(resize);
    })();
  }, "singleton");
  Class(function PrometheusInput({
    label: label,
    type: type,
    maxLength: maxLength,
    validator: validator
  }) {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $label;
    var $input;
    var $inputWrapper;
    var $underline;
    function handleFocus() {
      if (Stage.width <= 600) {
        $label.css({
          fontSize: "1.6rem",
          transform: "translateY(0rem) scale(0.7)"
        });
        $input.css({
          fontSize: "1.6rem",
          padding: "1.3rem 0 0"
        });
      } else {
        $label.css({
          fontSize: "1rem",
          transform: "translateY(1rem) scale(0.7)"
        });
        $input.css({
          fontSize: "1.6rem",
          padding: "1.4rem 0 0"
        });
      }
    }
    function handleFocusLoss() {
      if (!_this.value) {
        if (Stage.width <= 600) {
          $label.css({
            fontSize: "1.6rem",
            transform: "translateY(1rem) scale(1)"
          });
          $input.css({
            fontSize: "2.6rem",
            padding: "0rem 0 0"
          });
        } else {
          $label.css({
            fontSize: "1rem",
            transform: "translateY(2rem) scale(1)"
          });
          $input.css({
            fontSize: "2.8rem",
            padding: "0rem 0 0"
          });
        }
      }
    }
    function handleValueChange(e) {
      _this.value = $input.div.value;
    }
    function resize() {
      if (Stage.width <= 600) {
        $label.css({
          fontSize: "1.6rem",
          transform: "translateY(1rem) scale(1)"
        });
        $input.css({
          fontSize: "2.6rem",
          padding: "0rem 0 0"
        });
      } else {
        $label.css({
          fontSize: "1rem",
          transform: "translateY(2rem) scale(1)"
        });
        $input.css({
          fontSize: "2.8rem",
          padding: "0rem 0 0"
        });
      }
    }
    (function initHTML() {
      $label = $this.create("label");
      $inputWrapper = $this.create("input_wrapper");
      $input = $inputWrapper.create("input", "input");
      if (type === "password") {
        $input.attr("type", "password");
      }
      if (type === "email") {
        $input.attr("type", "email");
      }
      if (type === "file") {
        $input.attr("type", "file");
      }
      $input.attr("tabindex", "0");
      if (label) {
        let stripped = label.replace(" ", "");
        $input.attr("name", stripped);
        $input.attr("aria-labeledby", stripped + "_label");
        $label.attr("for", stripped);
        $label.attr("id", stripped + "_label");
        $label.text(label);
      }
      if (maxLength) {
        $input.attr("maxlength", maxLength);
      }
      $underline = $this.create("underline");
    })();
    (function initStyles() {
      $this.css({
        position: "relative",
        display: "flex",
        flexDirection: "column"
      });
      $this.css({
        opacity: 0
      }).transform({
        y: 10
      });
      $label.css({
        fontSize: "1rem",
        position: "relative",
        fontFamily: "'FuturaLT-Bold', sans-serif",
        textTransform: "uppercase",
        transformOrigin: "0% 50%",
        transform: "translateY(4rem) scale(1)",
        WebkitTransition: "all 100ms cubic-bezier(0.33, 1, 0.68, 1)"
      });
      $inputWrapper.css({
        position: "relative",
        fontSize: "1.6rem"
      });
      $input.css({
        position: "relative",
        fontSize: "5.6rem",
        width: "100%",
        WebkitTransition: "all 100ms cubic-bezier(0.33, 1, 0.68, 1)"
      });
      $underline.css({
        position: "relative",
        width: "100%",
        height: "1px",
        background: Colors.value.beige
      });
    })();
    (function addListeners() {
      $input.bind("focusin", handleFocus);
      $input.bind("focusout", handleFocusLoss);
      $input.bind("change", handleValueChange);
      $input.bind("input", handleValueChange);
      _this.onResize(resize);
    })();
    _this.animateIn = function (delay = 0) {
      $this.tween({
        opacity: 1,
        y: 0
      }, 400, "easeInOut", delay);
    };
    _this.animateOut = async function (delay = 0) {
      await $this.tween({
        opacity: 0
      }, 400, "easeInOut", delay).promise();
      $this.transform({
        y: 10
      });
    };
    _this.getValue = function () {
      let valid = true;
      if (validator) {
        valid = validator(_this.value);
      }
      return {
        valid: valid,
        value: _this.value
      };
    };
  });
  Class(function ScrollPrompt(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $translate;
    var $circle;
    var $arrow;
    function resize() {
      $wrapper.x = Stage.width * 0.62 - _this.size * 0.5;
      $wrapper.y = Stage.height - _this.size * 1.18;
      if (Device.mobile.phone && Stage.width < Stage.height) {
        $wrapper.x = Stage.width * 0.3 - _this.size * 0.5;
        $wrapper.y = Stage.height - _this.size * 1.25;
      }
    }
    _this.progress = 0;
    _this.size = Device.mobile.phone ? 150 : 220;
    (async function () {
      (function init() {
        ($wrapper = $gl(_this.size, _this.size)).hide();
        _this.element.add($wrapper);
        ($translate = $gl(_this.size, _this.size)).alpha = 0;
        $wrapper.add($translate);
      })();
      (function initText() {
        ($circle = $gl(_this.size, _this.size)).x = _this.size * 0.5;
        $circle.y = _this.size * 0.5;
        $translate.add($circle);
        let $inside = $gl(_this.size, _this.size, "assets/images/ui/star-circle.png");
        $inside.x = -_this.size * 0.5;
        $inside.y = -_this.size * 0.5;
        $inside.textureShader.blending = Shader.ADDITIVE_BLENDING;
        $inside.shader.blending = Shader.ADDITIVE_BLENDING;
        $circle.add($inside);
        ($arrow = $gl(_this.size * 0.4, _this.size * 0.4, "assets/images/ui/down-arrow.png")).x = _this.size * 0.3;
        $arrow.y = _this.size * 0.3;
        $arrow.textureShader.blending = Shader.ADDITIVE_BLENDING;
        $arrow.shader.blending = Shader.ADDITIVE_BLENDING;
        $translate.add($arrow);
      })();
      (function addHandlers() {
        _this.onResize(resize);
      })();
    })();
    this.setImage = async function (image) {
      $image.shader.set("tMap", Utils3D.getTexture(image));
    };
    this.update = function (progress) {
      let offset = _config.start * _config.height * -100;
      $translate.y = offset - progress * _config.height * -100 - 40;
      $circle.rotation -= Render.HZ_MULTIPLIER * 0.3;
      let pos = Math.range(progress, _config.start, _config.end, -1, 1);
      $translate.alpha = Math.smoothStep(1, 0.3, Math.abs(pos)) * 0.8;
      if ($translate.alpha > 0) {
        $wrapper.show();
      } else {
        $wrapper.hide();
      }
    };
    this.animateIn = async function () {
      _this.isVisible ||= true;
    };
    this.animateOut = async function () {
      _this.isVisible &&= false;
    };
  });
  Class(function DashboardGraph(_config) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $topLabel;
    var $destination;
    var $topLabelSub;
    var $bottomlabel;
    var $bottomlabelSub;
    var $number;
    var $numberLabel;
    var $icon;
    var $iconLabel;
    var $iconSub;
    var _boxes;
    var $boxes;
    _this.width = 110;
    _this.height = 200;
    var _extra = _config.negative ? 5 : 0;
    var _color = new Color(_config?.color || Colors.value.teal);
    var _positive = new Color(_config?.color || Colors.value.teal);
    var _negative = new Color("#1c87ff");
    async function addText(text = "text", size = "12", align = "left", link = false) {
      let $text = $glText(text.toString().toUpperCase(), "FuturaLT-Bold", size, {
        width: 450,
        align: align,
        lineHeight: Math.range(size, 28, 16, 1.45, 1.6),
        letterSpacing: 0,
        color: _config?.color || Colors.value.teal
      });
      $wrapper.add($text);
      await $text.text.ready();
      $text.text.shader.blending = Shader.ADDITIVE_BLENDING;
      if (link) {
        $text.text.shader.uniforms.uColor.value = _color;
      }
      return $text;
    }
    (async function () {
      if (_this.isPlayground()) {
        _this.element.x = 200;
        _this.element.y = 200;
        _this.startRender(_ => {
          _this.update(0.5 - Math.sin(Render.TIME * 0.001) * 0.5);
        });
      }
      (function init() {
        $wrapper = $gl();
        _this.element.add($wrapper);
      })();
      await async function initText() {
        ($topLabel = await addText(_config?.top || "", _config?.topSub ? 16 : 18, "right")).x = -9;
        $topLabel.y = 5;
        ($topLabelSub = await addText(_config?.topSub || "", 9, "right")).x = -9;
        $topLabelSub.y = _config?.top ? 30 : 5;
        ($bottomlabel = await addText(_config?.bottom || "", _config?.bottomSub ? 16 : 18, "right")).x = -9;
        $bottomlabel.y = _config?.bottomSub ? _this.height - 30 : _this.height - 13;
        ($bottomlabelSub = await addText(_config?.bottomSub || "", 9, "right")).x = -9;
        $bottomlabelSub.y = _config?.bottom ? _this.height - 5 : _this.height - 20;
        ($number = await addText(_config?.number || "", 21, "left", true)).x = _this.width + 6;
        $number.y = _this.height / 2 - 9;
        ($numberLabel = await addText(_config?.numberLabel || "", 10, "left", true)).x = _this.width + 6;
        $numberLabel.y = _this.height / 2 + 20;
        ($icon = $wrapper.create(35, 35, "assets/images/ui/" + (_config?.icon || "molecule") + ".png")).x = -4;
        $icon.y = _this.height + 12;
        $icon.textureShader.blending = Shader.ADDITIVE_BLENDING;
        $icon.shader.blending = Shader.ADDITIVE_BLENDING;
        ($iconLabel = await addText(_config?.iconLabel || "", 17, "left", false)).x = 38;
        $iconLabel.y = _this.height + 20;
        ($iconSub = await addText(_config?.iconSub || "", 8, "left", false)).x = 0;
        $iconSub.y = _this.height + 52;
        ($destination = await addText(_config?.destination || "", 13, "right", false)).y = -90;
        $destination.x = _this.width + 45;
      }();
      (function initBars() {
        let padding = 4;
        let width = _this.width - padding;
        let height = (_this.height - padding * 9) / 10;
        let y = padding;
        $boxes = $gl();
        $wrapper.add($boxes);
        _boxes = [];
        for (var i = 0; i < 10 + _extra; i++) {
          let $box = $boxes.create(width, height, _config?.color || Colors.value.teal);
          $box.textureShader.blending = Shader.ADDITIVE_BLENDING;
          $box.shader.blending = Shader.ADDITIVE_BLENDING;
          if (i > 9) {
            $box.shader.uniforms.uColor.value = _color;
          }
          $box.y = y;
          _boxes.push($box);
          y += height + padding;
        }
      })();
    })();
    this.update = function (p) {
      if (!_boxes) {
        return;
      }
      let progress = _config.negative ? Math.range(p, 1, 0.5, 1, 0, true) + Math.range(p, 0.5, 0, 0, -1, true) : p;
      let negative = !!_config.negative && !!(p < 0.5);
      _color.lerp(negative ? _negative : _positive, 0.12);
      _boxes.forEach(($box, i) => {
        let index = 10 - i - 1;
        let start = index * 0.1;
        let end = (index + 1) * 0.1;
        $box.alpha = 0.15 + Math.smoothStep(0, 0.8, Math.range(progress, start, end, 0, 1, true)) * 0.85;
        if (i > 9) {
          $box.alpha = Math.range($box.alpha, 0.15, 1, 0.5, 0);
        }
      });
      if (!isNaN(_config?.number)) {
        let number = _config?.number * progress;
        let fixed = _config?.number < 100 ? 1 : 0;
        $number.setText(number.toFixed(fixed));
      }
    };
    this.animateIn = async function () {
      _this.isVisible ||= true;
    };
    this.animateOut = async function () {
      _this.isVisible &&= false;
    };
  });
  Class(function DashboardOverlay({
    type = "fillup",
    start = 0.2,
    end = 1,
    height = 2,
    left: left
  }) {
    Inherit(this, GLUIElement);
    const _this = this;
    var $wrapper;
    var $bg;
    var $translate;
    var _left;
    var _right;
    var _config;
    _this.progress = 0;
    _this.interact = type == "fillup";
    _this.bg = 0;
    switch (type) {
      case "fillup":
        _config = [{
          top: "F",
          bottom: "E",
          number: 16,
          numberLabel: "GAL",
          icon: "gas",
          iconLabel: "GAS",
          iconSub: "Zero Net Carbon"
        }, {
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          number: 314,
          numberLabel: "LBS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
        break;
      case "truck":
        _config = [{
          top: 2137,
          topSub: "MILES",
          bottom: "0",
          bottomSub: "MILES",
          number: 356,
          numberLabel: "GAL",
          icon: "gas",
          iconLabel: "DIESEL",
          iconSub: "Zero Net Carbon"
        }, {
          destination: "Origin: Port of Los Angeles\nDestination: Chicago",
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          number: 4,
          numberLabel: "TONS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
        break;
      case "plane":
        _config = [{
          top: 2475,
          topSub: "MILES",
          bottom: "0",
          bottomSub: "MILES",
          color: "#38807a",
          number: 5325,
          numberLabel: "GAL",
          icon: "gas",
          iconLabel: "JETFUEL",
          iconSub: "Zero Net Carbon"
        }, {
          destination: "Origin: JFK\nDestination: LAX",
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          color: "#38807a",
          number: 56,
          numberLabel: "TONS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
        break;
      case "spirits":
        _config = [{
          topSub: "PARTY",
          bottomSub: "NIP",
          number: 750,
          numberLabel: "ML",
          icon: "whiskey",
          iconLabel: "SPIRITS",
          iconSub: "Zero Net Carbon"
        }, {
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          number: 383,
          numberLabel: "GRAMS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
        break;
      case "store":
        _config = [{
          top: "100%",
          topSub: "INVENTORY",
          bottomSub: "INVENTORY",
          bottom: "0%",
          number: 1159,
          numberLabel: "LBS",
          icon: "camping",
          iconLabel: "GOODS",
          iconSub: "banked-carbon"
        }, {
          negative: true,
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          number: 1.8,
          numberLabel: "TONS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
        break;
      case "camp":
        _config = [{
          top: 216,
          topSub: "MILES",
          bottomSub: "MILES",
          bottom: "0",
          number: 13.5,
          numberLabel: "GAL",
          icon: "gas",
          iconLabel: "GAS",
          iconSub: "Zero Net Carbon"
        }, {
          destination: "Origin: Los Angeles city limits\nDestination: Mojave Desert",
          direction: 1,
          topSub: "Polluted\nPast",
          bottomSub: "Net Zero\nFuture",
          number: 265,
          numberLabel: "LBS",
          icon: "molecule",
          iconLabel: "CO2",
          iconSub: "Emissions"
        }];
    }
    function resize() {
      let scale = Math.range(Stage.width, 0, 1800, 0, 1, true);
      $wrapper.scaleX = scale;
      $wrapper.scaleY = scale;
      Device.mobile.phone;
      let offset = 15;
      let scroll = Device.mobile ? 0 : 15;
      $wrapper.x = Stage.width - offset - scroll - $wrapper.width * scale;
      $wrapper.y = Stage.height - offset - $wrapper.height * scale;
      if (left) {
        $wrapper.x = 40;
      }
      if (Device.mobile.phone && Stage.width < Stage.height) {
        let scale = Math.range(Stage.width - 40, 0, $wrapper.width, 0, 1, true);
        $wrapper.scaleX = scale;
        $wrapper.scaleY = scale;
        $wrapper.x = Stage.width - 20 - $wrapper.width * scale;
        $wrapper.y = Stage.height - 5 - $wrapper.height * scale;
        if (type == "fillup") {
          $wrapper.y -= 50;
        }
      }
    }
    (async function () {
      if (_this.isPlayground()) {
        _this.element.x = 150;
        _this.element.y = 100;
      }
      (function init() {
        ($wrapper = $gl()).width = 540;
        $wrapper.height = 350;
        _this.element.add($wrapper);
        ($translate = $gl()).alpha = 1;
        $wrapper.add($translate);
        ($bg = $translate.create($wrapper.width, $wrapper.height, "#000000")).x = 0;
        $bg.y = 0;
        $bg.alpha = 0.4;
        $bg.z = -0.01;
        $bg.textureShader.blending = Shader.SUBTRACTIVE_BLENDING;
        $bg.shader.blending = Shader.SUBTRACTIVE_BLENDING;
      })();
      (function initGraphs() {
        (_left = _this.initClass(DashboardGraph, _config[0])).element.x = $wrapper.width / 2 - _left.width - 52;
        _left.element.y = 45;
        $translate.add(_left.element);
        (_right = _this.initClass(DashboardGraph, _config[1])).element.x = $wrapper.width / 2 + 55;
        _right.element.y = 45;
        $translate.add(_right.element);
      })();
      (function addHandlers() {
        _this.onResize(resize);
      })();
    })();
    this.setCopy = async function (text) {
      $wrapper.hide();
    };
    this.update = function (progress) {
      if (!$translate) {
        return;
      }
      let pos = Math.range(progress, start, end, -1, 1, true);
      $translate.alpha = Math.smoothStep(-1, -0.6, pos);
      $wrapper.alpha = 0.98 + Math.sin(Render.TIME * 0.017) * 0.01 + Math.sin(Render.TIME * 0.028) * 0.01;
      if (_this.interact) {
        _left.update(ViewController.SPEED_MULTI.value);
        _right.update(1 - ViewController.SPEED_MULTI.value);
      } else {
        _left.update(Math.smoothStep(-0.9, 0.2, pos));
        _right.update(1 - Math.smoothStep(-0.9, 0.2, pos));
      }
      $bg.alpha = Math.smoothStep(-1, 0, pos) * _this.bg;
    };
    this.animateIn = async function () {
      _this.isVisible ||= true;
    };
    this.animateOut = async function () {
      _this.isVisible &&= false;
    };
  });
  Class(function ContactPage(isFirst = false) {
    Inherit(this, InteractivePage, "contact", isFirst);
    const _this = this;
    (async function () {
      await _this.ready();
    })();
  });
  Class(function ContactSection(index, parentConfig, isFirst) {
    Inherit(this, InteractiveSection, "contactMain", index, parentConfig, isFirst);
    const _this = this;
    var _text;
    var _camera;
    function resize() {
      let aspect = Stage.width / Stage.height;
      _camera.setFOV(Math.range(aspect, 1, 1.6, 95, 30, true));
      _text.group.position.y = aspect < 1 ? -20 : 0;
    }
    (async function () {
      await _this.wait(_this, "isReady");
      await CMS.ready();
      (_text = _this.layers.text).setText(CMS.get("contact.title").replace(/<br>/g, "\n"));
      _camera = _this.layers.sceneCamera;
      _this.flag("textReady", true);
      (function addListeners() {
        _this.onResize(resize);
        resize();
      })();
    })();
    _this.show = async function () {
      await _this.wait(_this, "textReady");
      _this._show();
      _text.shaderClass.animateIn();
    };
    _this.hide = async function () {
      await _this.wait(_this, "textReady");
      _this._hide();
      _text.shaderClass.animateOut();
    };
  });
  Class(function ContactUI() {
    Inherit(this, InteractiveUI);
    const _this = this;
    const $this = _this.element;
    const FIELDS = [{
      key: "firstName",
      label: "First Name"
    }, {
      key: "lastName",
      label: "Last Name"
    }, {
      key: "email",
      label: "Email Address",
      type: "email",
      validator: email => /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(String(email).toLowerCase())
    }];
    var $container;
    var $header;
    var $form;
    var $error;
    var $bottom;
    var $desc;
    var $button;
    var $containerTitle;
    var $title;
    var _social;
    var _inputs = [];
    var _formFields = {};
    function showError(type) {
      if (type == "email") {
        $error.text(_this.config.emailError);
      } else {
        $error.text(_this.config.generalError);
      }
      $error.css({
        display: "initial"
      });
      $error.transform({
        y: 10
      }).tween({
        y: 0,
        opacity: 1
      }, 400, "easeOutCubic");
    }
    function resize() {
      if (Stage.width <= 600) {
        if (Device.mobile) {
          $this.css({
            height: "fit-content"
          });
          $container.css({
            width: "90%",
            position: "relative",
            top: "initial",
            left: "initial",
            transform: "initial",
            padding: "2rem 0 5rem",
            margin: "auto"
          });
          $containerTitle.css({
            width: "90%",
            bottom: "initial",
            position: "relative",
            left: "initial",
            top: "initial",
            margin: "auto",
            padding: "12rem 0 0rem"
          });
          $header.css({
            fontSize: "1.6rem",
            paddingBottom: "2rem",
            width: "100%"
          });
          $title.css({
            fontSize: "7rem",
            textAlign: "left"
          });
          _social.element.css({
            position: "relative",
            bottom: "initial",
            right: "initial",
            padding: "0 5% 5rem"
          });
        } else {
          $this.css({
            height: "fit-content"
          });
          $container.css({
            width: "90%",
            position: "relative",
            top: "initial",
            left: "initial",
            transform: "initial",
            padding: "2rem 0 5rem",
            margin: "auto"
          });
          $containerTitle.css({
            width: "90%",
            bottom: "initial",
            position: "relative",
            left: "0",
            top: "15%",
            margin: "auto",
            padding: "12rem 0rem 0rem"
          });
          $header.css({
            fontSize: "1.6rem",
            marginBottom: "0",
            paddingBottom: "2rem",
            width: "100%"
          });
          $title.css({
            fontSize: "7rem",
            textAlign: "left"
          });
          _social.element.css({
            position: "relative",
            bottom: "initial",
            right: "initial",
            padding: "0 5% 5rem"
          });
        }
      } else if (Stage.width <= 960) {
        if (Device.mobile) {
          $this.css({
            height: "fit-content"
          });
          $container.css({
            width: "90%",
            position: "relative",
            top: "initial",
            left: "initial",
            transform: "initial",
            padding: "2rem 0 5rem",
            margin: "auto"
          });
          $containerTitle.css({
            width: "90%",
            bottom: "initial",
            position: "relative",
            left: "0",
            top: "15%",
            margin: "auto",
            padding: "10rem 0px 10rem"
          });
          $header.css({
            fontSize: "1.6rem",
            marginBottom: "0",
            paddingBottom: "2rem",
            width: "100%"
          });
          $title.css({
            fontSize: "9rem",
            textAlign: "center"
          });
          _social.element.css({
            position: "relative",
            bottom: "initial",
            right: "initial",
            padding: "0 5% 5rem"
          });
        } else {
          $this.css({
            height: "fit-content"
          });
          $container.css({
            width: "90%",
            position: "relative",
            top: "initial",
            left: "initial",
            transform: "initial",
            padding: "2rem 0 5rem",
            margin: "auto"
          });
          $containerTitle.css({
            width: "90%",
            bottom: "initial",
            position: "relative",
            left: "0",
            top: "15%",
            margin: "auto",
            padding: "14rem 0px 5rem"
          });
          $header.css({
            fontSize: "1.6rem",
            marginBottom: "0",
            paddingBottom: "2rem",
            width: "100%"
          });
          $title.css({
            fontSize: "9rem",
            textAlign: "center"
          });
          _social.element.css({
            position: "relative",
            bottom: "initial",
            right: "initial",
            padding: "0 5% 5rem"
          });
        }
      } else {
        $this.css({
          height: "100vh"
        });
        $container.css({
          width: "30vw",
          top: "50%",
          left: "75%",
          transform: "translate(-50%, -50%)",
          padding: "initial",
          margin: "initial"
        });
        $containerTitle.css({
          position: "absolute",
          left: "50%",
          width: "35vw",
          bottom: "8rem",
          left: "8rem",
          top: "initial",
          padding: "10rem 0rem 0rem",
          transform: "translateX(0%)"
        });
        $header.css({
          fontSize: "2.6rem",
          paddingBottom: "initial",
          width: "87%",
          margin: "revert"
        });
        $title.css({
          fontSize: "16rem",
          textAlign: "left"
        });
        _social.element.css({
          position: "absolute",
          bottom: "4rem",
          right: "4rem"
        });
      }
    }
    function onButtonHover(e) {
      if (e.action == "over") {
        $button.tween({
          scale: 0.9
        }, 300, "easeOutCubic");
      } else {
        $button.tween({
          scale: 1
        }, 300, "easeOutCubic");
      }
    }
    async function onButtonClick(e) {
      $error.css({
        display: "none"
      });
      let formData = {};
      let errors = {};
      Object.keys(_formFields).forEach(key => {
        let input = _formFields[key];
        let {
          value: value,
          valid: valid
        } = input.getValue();
        if (!valid) {
          errors[key] = true;
        }
        formData[key] = value;
      });
      if (Object.keys(errors).length == 0) {
        Track.event("sign_up", {
          method: "Newsletter"
        }, "newsletter");
        try {
          const result = await post(Config.NEWSLETTER_URL, formData);
          if (result && result.success) {
            _this.animateSuccess();
          } else {
            showError();
          }
        } catch (e) {
          showError();
        }
      } else if (Object.keys(errors).length == 1 && errors.email) {
        showError("email");
      } else {
        showError();
      }
    }
    _this.config = Config.CONTACT;
    (function initHTML() {
      $containerTitle = $this.create("container_title");
      ($title = $containerTitle.create("header", "h1")).text(_this.config.title);
      $container = $this.create("container");
      ($header = $container.create("header", "h5")).text(_this.config.header);
      $form = $container.create("form");
      FIELDS.forEach(({
        key: key,
        label: label,
        type: type,
        validator: validator
      }) => {
        let $input = _this.initClass(PrometheusInput, {
          key: key,
          label: label,
          type: type,
          validator: validator
        }, [$form]);
        _inputs.push($input);
        _formFields[key] = $input;
      });
      ($error = $form.create("error")).text("error");
      $bottom = $container.create("bottom");
      ($desc = $bottom.create("desc")).text(_this.config.description);
      ($button = $bottom.create("button")).bg("assets/images/ui/right-arrow.png");
      $button.interact(onButtonHover, onButtonClick, "#", "submit button");
    })();
    (function initStyles() {
      $this.css({
        position: "relative",
        height: "fit-content",
        width: "100vw"
      });
      $containerTitle.css({
        position: "absolute",
        width: "35vw",
        height: "fit-content",
        color: Colors.value.black,
        bottom: "8rem",
        left: "8rem",
        opacity: "0",
        padding: "10rem 0 0"
      });
      $title.css({
        fontFamily: "marscondensed-regular-TRIAL, sans-serif",
        fontSize: "16rem",
        lineHeight: "0.8",
        position: "relative",
        textTransform: "uppercase",
        textAlign: "left",
        backgroundSize: "cover",
        webkitBackgroundClip: "text",
        backgroundClip: "text",
        color: "transparent",
        display: "block",
        margin: "auto"
      });
      $title.bg("assets/images/textures/grains_3.jpg");
      $container.css({
        position: "absolute",
        width: "30vw",
        height: "fit-content",
        color: Colors.value.beige,
        top: "50%",
        left: "75%",
        transform: "translate(-50%, -50%)",
        padding: "2rem 0 5rem",
        display: "block",
        margin: "auto"
      });
      $header.css({
        fontFamily: "'Futura', sans-serif",
        fontWeight: 700,
        fontSize: "2.6rem",
        position: "relative",
        lineHeight: "1",
        width: "87%"
      });
      $header.css({
        opacity: 0
      }).transform({
        y: 10
      });
      $form.css({
        display: "grid",
        gridGap: "1rem",
        position: "relative",
        paddingBottom: "6rem"
      });
      $error.css({
        fontFamily: "'Futura', sans-serif",
        fontWeight: 500,
        color: Colors.value.black,
        opacity: 0,
        fontSize: "1.1rem",
        lineHeight: "1.3",
        display: "none",
        zIndex: -1,
        bottom: "2rem",
        textTransform: "uppercase",
        fontWeight: "700"
      });
      $bottom.css({
        position: "relative",
        display: "flex",
        justifyContent: "spaceBetween"
      });
      $bottom.css({
        opacity: 0
      }).transform({
        y: 10
      });
      $desc.css({
        fontFamily: "'Futura', sans-serif",
        fontWeight: 500,
        fontSize: "1.1rem",
        lineHeight: "1.3",
        position: "relative"
      });
      $button.css({
        width: "20rem",
        height: "5rem",
        paddingLeft: "4rem",
        backgroundSize: "contain",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        position: "relative"
      });
    })();
    (function initSocial() {
      (_social = _this.initClass(MenuSocialv2, [$this])).element.css({
        position: "absolute",
        bottom: "4rem",
        right: "4rem",
        display: "flex"
      });
    })();
    (function addListeners() {
      _this.onResize(resize);
    })();
    if (_this.isPlayground()) {
      Container.instance().element.add($this);
    }
    _this.animateIn = function (delay = 300) {
      $containerTitle.tween({
        opacity: 1
      }, 200, "easeInOut", delay);
      $header.tween({
        opacity: 1,
        y: 0
      }, 400, "easeInOut", delay);
      _inputs.forEach((input, index) => {
        input.animateIn(delay + index * 200 + 1);
      });
      $bottom.css({
        opacity: 0,
        y: 10
      });
      $bottom.tween({
        opacity: 1,
        y: 0
      }, 400, "easeInOut", delay + _inputs.length * 200);
      _social.animateIn(_inputs.length * 200 + 200);
    };
    _this.animateOut = async function () {
      return new Promise(async resolve => {
        _inputs.forEach((input, index) => {
          input.animateOut();
        });
        $containerTitle.tween({
          opacity: 0
        }, 200, "easeInOut").promise();
        $header.tween({
          opacity: 0
        }, 200, "easeInOut");
        _social.animateOut();
        await $bottom.tween({
          opacity: 0
        }, 200, "easeInOut").promise();
        $header.transform({
          y: 10
        });
        $bottom.transform({
          y: 10
        });
        resolve();
      });
    };
    _this.animateSuccess = async function () {
      return new Promise(async resolve => {
        _inputs.forEach((input, index) => {
          input.animateOut();
        });
        await $containerTitle.tween({
          opacity: 0
        }, 200, "easeInOut").promise();
        $title.text(_this.config.success);
        await $containerTitle.tween({
          opacity: 1
        }, 200, "easeInOut").promise();
        console.log("asdasd");
        await $header.tween({
          opacity: 0
        }, 200, "easeInOut").promise();
        await $bottom.tween({
          opacity: 0
        }, 200, "easeInOut").promise();
        _social.animateOut();
        $header.transform({
          y: 10
        });
        $bottom.transform({
          y: 10
        });
        resolve();
      });
    };
  });
  Class(function HomePage(isFirst = false) {
    Inherit(this, InteractivePage, "home", isFirst);
    const _this = this;
    function onViewChange(e) {
      if (e && e.view && e.view.parent === _this) {
        Track.event("homepage", {
          items: [{
            item_id: `homepage_screen_${e.index}`,
            item_name: `homepage_screen_${e.index}`
          }]
        }, `homepage:section:${e.index}`);
      }
    }
    (async function () {
      await _this.ready();
      (function addListeners() {
        _this.events.sub(SmoothRenderManager.VIEW_CHANGE, onViewChange);
      })();
    })();
    this.animateIn = function () {};
    this.animateOut = function () {};
  });
  Class(function HomeTestSection() {
    Inherit(this, InteractiveSection, "homeTestSection");
    const _this = this;
    (async function () {
      await _this.ready();
    })();
  });
  Class(function TestHomeUI() {
    Inherit(this, Element);
    const $this = this.element;
    (function initHTML() {
      $this.size("100%", "100vh");
      $this.css({});
    })();
  });
  Class(function LoaderView() {
    Inherit(this, Element);
    const _this = this;
    const $this = this.element;
    let $logo;
    let $bg;
    let $wrapper;
    let $rings;
    let $rings2;
    let $colorbg;
    (function initHTML() {
      $this.size("100%").setZ(100);
      $this.css({
        top: 0,
        left: 0,
        position: "fixed",
        backgroundSize: "cover",
        backgroundPosition: "center",
        zIndex: 999999
      });
      $colorbg = $this.create(".colorbg");
      $colorbg.size("100%").bg(Colors.value.black);
      $bg = $this.create(".bg");
      $bg.size("100%").bg("assets/images/about/stars-repeat.jpg").css({
        backgroundSize: "512px 512px",
        backgroundRepeat: "repeat",
        opacity: 0
      });
      $bg.tween({
        opacity: 0.2
      }, 1000, "easeInOutSine", 100);
    })();
    (function initLogo() {
      $logo = $this.create("logo");
      $logo.size(80, 80).center().bg("assets/images/ui/prometheus-logo.png");
      $logo.css({
        opacity: 0
      }).transform({
        scale: 0.85,
        rotation: 0
      });
      $wrapper = $this.create(".wrapper");
      $wrapper.size("100%");
      $wrapper.css({
        opacity: 0
      }).transform({
        scale: 1.05,
        rotation: 0
      });
      $wrapper.inner = $wrapper.create(".wrapper-rotate");
      $wrapper.inner.size("100%");
      _this.delayedCall(_ => {
        $logo.tween({
          opacity: 1,
          scale: 1,
          y: 0,
          rotation: 0
        }, 1000, "easeOutBack");
        $wrapper.tween({
          opacity: 1,
          scale: 1,
          y: 0,
          rotation: 0
        }, 1000, "easeOutBack");
      }, 200);
      $rings2 = $wrapper.inner.create("rings2");
      $rings2.svg("assets/images/ui/rings.svg");
      $rings2.css({
        width: "100%",
        height: "100%"
      });
      $rings = $wrapper.inner.create("rings");
      $rings.svg("assets/images/ui/rings.svg");
      $rings.css({
        width: "100%",
        height: "100%"
      });
    })();
    this.progress = function (e) {};
    this.animateOut = async function (callback) {
      $colorbg.tween({
        opacity: 0
      }, 1000, "easeOutSine");
      $wrapper.tween({
        opacity: 0,
        scale: 0.95
      }, 600, "easeOutCubic");
      $logo.tween({
        opacity: 0,
        scale: 0.95
      }, 800, "easeOutCubic", 100);
      $this.tween({
        opacity: 0
      }, 1500, "easeInOutSine", 500).onComplete(() => callback && callback());
    };
  });
  Class(function Menu() {
    Inherit(this, InteractivePage, "menu");
    const _this = this;
    const $this = _this.element;
    (async function () {
      (async function init() {
        await _this.ready();
        $this.css({
          overflow: "",
          height: "100%"
        });
      })();
      if (_this.isPlayground()) {
        _this.delayedCall(() => {
          _this.show();
        }, 100);
      }
    })();
    _this.onVisible = function () {
      CameraUtil.hardBlockScroll(true);
    };
  });
  Class(function ColorBlockShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color("#000000")
      }
    });
  });
  Class(function MenuNavigation($parent) {
    Inherit(this, Component);
    const _this = this;
    var $container;
    var _totalHeight = 0;
    var _currRoute = "";
    const NAV_ITEMS = [{
      text: "HOME",
      path: "",
      order: 1
    }, {
      text: "TECHNOLOGY",
      path: "technology",
      order: 2
    }, {
      text: "NEWS",
      path: "news",
      order: 3
    }, {
      text: "PARTNERS",
      path: "partners",
      order: 4
    }, {
      text: "CONNECT",
      path: "connect",
      order: 5
    }];
    var $navItems = [];
    function onItemHover(e) {
      let $el;
      $el = e?.mesh ? e.mesh.glui : e.object;
      if (!_this.flag("isAnimating") && !$el.active) {
        switch (e.action) {
          case "over":
            $el.tween({
              x: 10
            }, 600, "easeOutQuart");
            $el.shader.set("uRotation", 80);
            $el.shader.tween("uTransition0", 1, 600, "easeOutQuart");
            break;
          case "out":
            $el.tween({
              x: 0
            }, 1000, "easeOutQuart");
            $el.shader.set("uRotation", -80);
            $el.shader.tween("uTransition0", 0, 1000, "easeOutQuart");
        }
      }
    }
    function onItemClick(e) {
      if (_this.flag("isAnimating")) {
        return;
      }
      let $el;
      $el = e?.mesh ? e.mesh.glui : e.object;
      if ($el.path == ViewController.instance().currentRoute.path) {
        ViewController.instance().transitionBack();
      } else {
        ViewController.instance().changeRoute($el.path);
      }
    }
    async function resize() {
      await _this.wait(_this, "contentReady");
      let scaleLimit = Stage.width > 1440 ? 0.9 : 0.8;
      $container.scale = Math.range(Stage.height, 0, 750, 0, 1, true);
      $container.scale *= Math.range(Stage.width, 400, 1440, 0.45, scaleLimit, true);
      if (Stage.width < 800) {
        $container.x = 25;
        $container.y = 95;
      } else if (Device.mobile.phone && Stage.width > Stage.height) {
        $container.x = Stage.width / 2 - 300;
        $container.y = 70;
      } else {
        $container.x = Math.range(Stage.width, 400, 1440, 0.1, 1, true) * 150;
        $container.y = Stage.height / 2 - _totalHeight * $container.scale / 2;
      }
      $container.y;
      _totalHeight * $container.scale;
    }
    (async function () {
      (function init() {
        ($container = $gl()).y = 0;
        $parent.add($container);
        _currRoute = ViewController.instance().currentRoute?.path;
      })();
      (async function initNavItems() {
        let promises = NAV_ITEMS.map(async (item, index) => new Promise(async resolve => {
          let $item = await async function createText({
            text: text,
            path: path,
            order: order
          }) {
            return new Promise(async resolve => {
              let $item = $glText(text, "marscondensed-regular-TRIAL", 120, {
                width: "Infinity",
                align: "left",
                letterSpacing: -0.03,
                color: path === _currRoute ? Colors.value.orange : Colors.value.beige
              });
              $item.visible = true;
              $item.textContent = text;
              $item.order = order;
              let shader = _this.initClass(Shader, "MenuItemShader", {
                tNoise: {
                  value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
                  ignoreUIL: true
                },
                uTimeScale: {
                  value: 0.39
                },
                uHoverColor: {
                  value: new Color("#9f9992")
                },
                uUVScale: {
                  value: 0.8
                },
                uRotation: {
                  value: 180
                },
                uTransition0: {
                  value: 0
                },
                uBoundingMin: {
                  value: new Vector3()
                },
                uBoundingMax: {
                  value: new Vector3()
                }
              });
              $item.shader = shader;
              $item.useShader(shader);
              await $item.text.ready();
              $item.mesh.tag = "menunav";
              $item.text.shader.set("uBoundingMin", new Vector3().copy($item.dimensions.min));
              $item.text.shader.set("uBoundingMax", new Vector3().copy($item.dimensions.max));
              $item.path = path;
              $item.mesh.interactionScene = GLUI.Stage.scene;
              $item.interact(onItemHover, onItemClick, "#", text);
              resolve($item);
            });
          }(item);
          if (index > 0) {
            $item.y = $item.dimensions.height * index;
          }
          _totalHeight += $item.dimensions.height;
          $item.targetY = $item.y + 50;
          $item.index = index;
          $container.add($item);
          $navItems.push($item);
          resolve();
        }));
        await Promise.all(promises);
        let _seo = {
          root: _this.findParent("MenuSection").scene,
          seo: NAV_ITEMS.map(item => ({
            url: item.path,
            label: item.text
          }))
        };
        let _meshes = $navItems.sort((a, b) => a.order - b.order).map(item => item.mesh);
        Interaction3D.find(World.CAMERA).add(_meshes, onItemHover, onItemClick, _seo);
        if (Stage.width > 600) {
          $container.y = Stage.height / 2 - _totalHeight / 2;
        } else {
          $container.y = 0;
        }
        _this.flag("contentReady", true);
      })();
      (function addListeners() {
        _this.onResize(resize);
      })();
      if (_this.isPlayground()) {
        _this.animateIn();
      }
      resize();
    })();
    _this.show = async function () {
      await _this.wait(_this, "contentReady");
      _currRoute = ViewController.instance().currentRoute?.path;
      $navItems.forEach($item => {
        if ($item.path == _currRoute) {
          $item.setColor(Colors.value.orange);
          $item.active = true;
        } else {
          $item.setColor(Colors.value.beige);
          $item.active = false;
        }
        $item.tween({
          alpha: 1
        }, 400, "easeOutCubic");
        $item.tween({
          x: 0
        }, 10, "easeOutQuart");
        $item.shader.set("uRotation", -80);
        $item.shader.tween("uTransition0", 0, 10, "easeOutQuart");
      });
    };
    _this.hide = function () {};
    _this.getDimensions = async function () {
      let scale = Math.range(Stage.height, 0, 750, 0, 1, true);
      scale *= Math.range(Stage.width, 600, 1440, 0.45, 1, true);
      return {
        y: $container.y,
        height: _totalHeight * scale
      };
    };
  });
  Class(function MenuSection() {
    Inherit(this, InteractiveSection, "menu");
    const _this = this;
    var _mobileCarousel;
    var _menuNavigation;
    var _stack;
    async function resize() {
      await defer();
      doCarousel();
    }
    async function doCarousel() {
      let h = Stage.height;
      let w = Stage.width;
      if (Stage.width <= 600 || Device.mobile && !(Stage.width > Stage.height)) {
        _mobileCarousel ||= _this.initClass(MobileCarousel, {
          parent: _this.glui,
          hit: _this.ui.element
        });
        let {
          height: height,
          y: y
        } = await _menuNavigation.getDimensions();
        if (h !== Stage.height || w !== Stage.width) {
          resize();
        }
        _mobileCarousel.resize(height + y);
        if (_this.visible) {
          _mobileCarousel.show();
        }
        if (_stack) {
          _stack.animateOut();
        }
      } else {
        if (_mobileCarousel) {
          _mobileCarousel.hide();
        }
        if (_this.visible) {
          _stack.show();
        }
      }
    }
    (async function () {
      await _this.wait(_this, "isReady");
      _menuNavigation = _this.initClass(MenuNavigation, _this.glui);
      _stack = _this.initClass(MenuStack, _this.glui);
      _this.flag("sectionReady", true);
      (function addListeners() {
        _this.onResize(resize);
        resize();
      })();
      if (_this.parent.isPlayground()) {
        await defer();
        _this.show();
      }
    })();
    _this.animateIn = async function () {
      await _this.wait(_this, "sectionReady");
      _menuNavigation.show();
      await doCarousel();
      resize();
    };
    _this.animateOut = function () {
      if (_menuNavigation) {
        _menuNavigation.hide();
      }
      if (_stack) {
        _stack.hide();
      }
    };
  });
  Class(function MenuSignup() {
    Inherit(this, DOMTemplate);
    const _this = this;
    var $this;
    var _elements = [];
    (async function () {
      $this = _this.element;
    })();
    this.visible = function () {
      $this.visible();
    };
    this.style = function () {
      return "\n        @font-face {\n            font-family: 'FuturaLT-Bold';\n            src: url('../fonts/FuturaLT-Bold.ttf') format('truetype');\n            font-weight: 400;\n            font-style: normal;\n        }\n\n        #Stage, #Stage * {\n            // * {\n            //     position: relative;\n            // }\n            .MenuSignup, {\n                width: 100%;\n                position: fixed;\n                bottom: 30%;\n                left: 100px;\n                width: 31%;\n            }\n            .Signup {\n                position: relative;\n                width: 100%;\n                opacity: 0;\n            }\n            .Signup_Title_Wrapper {\n                position: relative;\n                width: 100%;\n            }\n            .Signup_Title {\n                position: absolute;\n                top: 0%;\n                left: 0%;\n                font-family: 'FuturaLT-Bold', sans-serif;\n                font-size: 2rem;\n                color: #E74833;\n                width: 100%;\n            }\n            .CTA {\n                position: absolute;\n                top: 4rem;\n                left: 0%;\n                font-family: 'Futura LT Medium', sans-serif;\n                font-size: 1.0rem;\n                line-height: 1.6rem;\n                color: #D8D8D8;\n                width: 30%;\n            }\n            .Data {\n                position: absolute;\n                top: 4rem;\n                left: 40%;\n                font-family: 'Futura LT Medium', sans-serif;\n                font-size: 0.8rem;\n                line-height: 1.15rem;\n                color: #D8D8D8;\n                width: 60%;\n            }\n            .CheckboxLabel {\n                position: absolute;\n                top: 13rem;\n                left: 0%;\n                font-family: 'FuturaLT-Bold', sans-serif;\n                font-size: 1.1rem;\n                color: #D8D8D8;\n                // width: 40%;\n            }\n            .Checkbox {\n                position: absolute;\n                top: 11.9rem;\n                left: 26%;\n                width: 3.5rem;\n                height: 3.5rem;\n                border: 0.15rem solid #D8D8D8;\n                border-radius: 0.7rem;\n            }\n            .EmailInput_Placehoder {\n                position: absolute;\n                top: 11.8rem;\n                left: 40%;\n                width: 40%;\n                height: 3.5rem;\n                font-family: 'FuturaLT-Bold', sans-serif;\n                font-size: 1.1rem;\n                color: #D8D8D8;\n                display: flex;\n                align-items: center;\n            }\n            .EmailInput {\n                position: absolute;\n                top: 11.8rem;\n                left: 40%;\n                width: 40%;\n                height: 3.5rem;\n                font-family: 'FuturaLT-Bold', sans-serif;\n                font-size: 1.1rem;\n                color: #D8D8D8;\n            }\n            .EmailUnderline {\n                position: absolute;\n                top: 15.2rem;\n                left: 40%;\n                width: 45%;\n                height: 0.15rem;\n                background-color: #D8D8D8;\n            }\n            .EmailArrow_Wrapper {\n                position: absolute;\n                top: 11.8rem;\n                right: 0%;\n            }\n            .EmailArrow {\n                position: relative;\n                width: 3.5rem;\n                height: 3.5rem;\n            }\n            .EmailArrowL1 {\n                position: absolute;\n                top: 50%;\n                right: 0;\n                width: 2.3rem;\n                height: 0.15rem;\n                background-color: #D8D8D8;\n                transform-origin: top right;\n                transform: rotate(45deg)\n            }\n            .EmailArrowL2 {\n                position: absolute;\n                top: 50%;\n                right: 0;\n                width: 2.3rem;\n                height: 0.15rem;\n                background-color: #D8D8D8;\n                transform-origin: top right;\n                transform: rotate(-45deg)\n            }\n            .EmailArrowL3 {\n                position: absolute;\n                top: 50%;\n                right: 0;\n                width: 3.5rem;\n                height: 0.15rem;\n                background-color: #D8D8D8;\n            }\n        }        \n        ";
    };
    this.render = function (html) {
      return html`
              <div class="Signup">
                  <div class="Signup_Title">
                      JOIN THE REVOLUTION
                  </div>
                  <div class="CTA">
                      Enter your email to receive updates on what we\'re doing and how you can support us.
                  </div>
                  <div class="Data">
                      We are collecting this information so that we can contact you in the future with updates about our product. We will never share it with any third party companies and you may unsubscribe at any time by following the instructions in the emails you receive.
                  </div>
                  <div class="CheckboxLabel">
                      I UNDERSTAND
                  </div>
                  <div class="Checkbox"></div>
                  <div class="EmailInput_Placehoder">
                      ENTER EMAIL ADDRESS
                  </div>
                  <input class="EmailInput" />
                  <div class="EmailUnderline"></div>
                  <div class="EmailArrow_Wrapper">
                      <div class="EmailArrow">
                          <div class="EmailArrowL1"></div>
                          <div class="EmailArrowL2"></div>
                          <div class="EmailArrowL3"></div>
                      </div>
                  </div>
              </div>
          `;
    };
    this.postRender = async function () {
      let $signup = await _this.querySelector(".Signup");
      _elements.push($signup);
      _this.flag("hasElements", true);
    };
    _this.animateIn = async function (delay = 0) {
      await _this.wait("hasElements");
      _elements[0].css({
        opacity: 0
      });
      return _elements[0].tween({
        opacity: 1
      }, 500, "easeInOutQuad", delay).promise();
    };
    _this.animateOut = async function (delay = 0) {
      await _this.wait("hasElements");
      return _elements[0].tween({
        opacity: 0
      }, 500, "easeInOutQuad", delay).promise();
    };
    this.getElements = async function () {
      await _this.wait("hasElements");
      return _elements;
    };
  });
  Class(function MenuSocial($parent) {
    Inherit(this, DOMTemplate);
    const _this = this;
    var $this;
    var _elements = [];
    (async function () {
      $this = _this.element;
      if ($parent[0].div.classList.contains("MenuSection")) {
        $this.div.classList.add("isMenu");
      }
    })();
    this.visible = function () {
      $this.visible();
    };
    this.style = function () {
      return "\n\n        #Stage, #Stage * {\n            \n            .MenuSocial {\n                position: fixed;\n                bottom: 4rem;\n                right: 5%;\n                width: 13rem;\n                height: 5rem;\n                &.isMenu {\n                    position: absolute !important;\n                    .Social {\n                        transition: opacity 500ms cubic-bezier(0.455, 0.03, 0.515, 0.955) 500ms !important;\n                    }\n                }\n                @media screen and (max-width: 600px) {\n                    bottom: 3rem;\n                    right: 0; \n                    width: 13rem;\n                    height: 5rem;\n                    left: 20px;\n                    transform: initial;\n                }\n            }\n\n            .Social {\n                position: relative;\n                width: 100%;\n                height: 100%;\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                opacity:0;\n            }\n            .Social_Link {\n                display: flex;\n                width: 100%;\n                height: 100%;\n                z-index: 1;\n                justify-content: center;\n                align-items: center;\n            }\n            .Social_Facebook_Wrapper {\n                position: relative;\n                width: 4rem;\n                height: 4rem;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                cursor: pointer;\n                &:hover {\n                    .Social_Facebook_Border {\n                        width: 90%;\n                        height: 90%;\n                    }\n                    .Social_Facebook_Img {\n                        width: 50%;\n                        height: 50%;\n                    }\n                }\n            }\n            .Social_Facebook_Img {\n                width: 40%;\n                height: 40%;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .Social_Facebook_Border {\n                width: 100%;\n                height: 100%;\n                border: 2px solid #D8D8D8;\n                border-radius: 3.5rem;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .Social_Instagram_Wrapper {\n                position: relative;\n                width: 4rem;\n                height: 4rem;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                cursor: pointer;\n                &:hover {\n                    .Social_Instagram_Border {\n                        width: 90%;\n                        height: 90%;\n                    }\n                    .Social_Instagram_Img {\n                        width: 50%;\n                        height: 50%;\n                    }\n                }\n            }\n            .Social_Instagram_Img {\n                width: 40%;\n                height: 40%;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .Social_Instagram_Border {\n                width: 100%;\n                height: 100%;\n                border: 2px solid #D8D8D8;\n                border-radius: 3.5rem;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .Social_Twitter_Wrapper {\n                position: relative;\n                width: 4rem;\n                height: 4rem;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                cursor: pointer;\n                &:hover {\n                    .Social_Twitter_Border {\n                        width: 90%;\n                        height: 90%;\n                    }\n                    .Social_Twitter_Img {\n                        width: 50%;\n                        height: 50%;\n                    }\n                }\n            }\n            .Social_Twitter_Img {\n                width: 40%;\n                height: 40%;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .Social_Twitter_Border {\n                width: 100%;\n                height: 100%;\n                border: 2px solid #D8D8D8;\n                border-radius: 3.5rem;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n\n        \n        }        \n        ";
    };
    this.render = function (html) {
      return html`
              <div class="Social">
                  <div class="Social_Facebook_Wrapper">
                      <a href="https://www.facebook.com/prometheusfuels/" target="blank" title="Prometheus Facebook" class="Social_Link">
                          <img src="assets/images/icons/facebook.png" alt="Prometheus Facebook" class="Social_Facebook_Img"/>
                      </a>
                      <div class="Social_Facebook_Border"></div>
                  </div>
                  <div class="Social_Instagram_Wrapper">
                      <a href="https://www.instagram.com/prometheusfuels/" target="blank" title="Prometheus Instagram" class="Social_Link">
                          <img src="assets/images/icons/instagram.png" alt="Prometheus Instagram" class="Social_Instagram_Img"/>
                      </a>
                      <div class="Social_Instagram_Border"></div>
                  </div>
                  <div class="Social_Twitter_Wrapper">
                      <a href="https://twitter.com/prometheusfuels/" target="blank" title="Prometheus Twitter" class="Social_Link">
                          <img src="assets/images/icons/twitter.png" alt="Prometheus Twitter" class="Social_Twitter_Img" />
                      </a>
                      <div class="Social_Twitter_Border"></div>
                  </div>
              </div>
          `;
    };
    this.postRender = async function () {
      let $social = await _this.querySelector(".Social");
      _elements.push($social);
      _this.flag("hasElements", true);
    };
    this.animateIn = async function (delay = 0) {
      await _this.wait("hasElements");
      _elements[0].css({
        opacity: 0
      });
      return _elements[0].tween({
        opacity: 1
      }, 500, "easeInOutQuad", delay).promise();
    };
    _this.animateOut = async function (delay = 0) {
      await _this.wait("hasElements");
      return _elements[0].tween({
        opacity: 0
      }, 500, "easeInOutQuad", delay).promise();
    };
    this.getElements = async function () {
      await _this.wait("hasElements");
      return _elements;
    };
  });
  Class(function MenuSocialv2() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $container;
    const SOCIAL_ITEMS = [{
      image: "assets/images/icons/twitter.png",
      path: "https://twitter.com/prometheusfuels/",
      label: "Twitter"
    }, {
      image: "assets/images/icons/linkedin.png",
      path: "https://www.linkedin.com/company/prometheusfuels/",
      label: "LinkedIn"
    }, {
      image: "assets/images/icons/instagram.png",
      path: "https://www.instagram.com/prometheusfuels/",
      label: "Instagram"
    }, {
      image: "assets/images/icons/facebook.png",
      path: "https://www.facebook.com/prometheusfuels/",
      label: "Facebook"
    }];
    var $socialItems = [];
    function hover(e) {
      switch (e.action) {
        case "over":
          e.object.tween({
            scale: 0.9,
            opacity: 0.8
          }, 200, "easeOutCubic");
          break;
        case "out":
          e.object.tween({
            scale: 1,
            opacity: 1
          }, 400, "easeOutCubic");
      }
    }
    function click(e) {
      Track.event("share", {
        method: e.object.networkName
      }, e.object.networkName);
      window.open(e.object.path, "_blank");
    }
    (async function () {
      (async function init() {
        $container = $this.create("social_container");
        $this.css({
          position: "relative"
        });
        $container.css({
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          flexWrap: "wrap",
          gap: "1rem"
        });
        SOCIAL_ITEMS.forEach(async (item, index) => {
          let $icon = $container.create("social_icon");
          if (index) {
            $icon.css({
              marginLeft: item.label.match("Facebook") ? 5 : 10
            });
          }
          $icon.css({
            height: "23px",
            width: "23px",
            position: "relative",
            opacity: 0,
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          });
          let $iconImage = $icon.create("social_image");
          $iconImage.css({
            height: "100%",
            width: "100%",
            backgroundSize: "contain",
            backgroundPosition: "center",
            backgroundRepeat: "no-repeat"
          }).bg(item.image);
          $icon.networkName = item.label;
          $icon.path = item.path;
          $icon.index = index;
          $icon.interact(hover, click, item.path, item.label);
          let $socialItem = {
            icon: $icon,
            iconImage: $iconImage
          };
          $socialItems.push($socialItem);
        });
      })();
      if (_this.isPlayground()) {
        _this.animateIn();
      }
    })();
    this.animateIn = async function (delay = 1000) {
      return new Promise(async resolve => {
        if (_this.flag("isShowing")) {
          resolve();
        } else {
          _this.flag("isShowing", true);
          let anims = $socialItems.map(async ($item, index) => $item.icon.tween({
            opacity: 1
          }, 800, "easeOutCubic", delay + index * 100).promise());
          await Promise.all(anims);
          resolve();
        }
      });
    };
    this.animateOut = async function (delay = 0) {
      return new Promise(async resolve => {
        if (_this.flag("isShowing")) {
          _this.flag("isShowing", false);
          let anims = $socialItems.map(async $item => $item.icon.tween({
            opacity: 0
          }, 400, "easeOutCubic").promise());
          await Promise.all(anims);
          resolve();
        } else {
          resolve();
        }
      });
    };
  });
  Class(function MenuTop() {
    Inherit(this, DOMTemplate);
    const _this = this;
    var _elements = [];
    function close() {
      _this.flag("isOpen", false);
      _elements[0]?.tween({
        scale: 1
      }, 600, "easeOutCubic");
      _elements[1]?.tween({
        rotation: 0,
        y: 0
      }, 600, "easeOutCubic");
      _elements[2]?.tween({
        scale: 1,
        y: 8,
        x: 0
      }, 600, "easeOutCubic");
      _elements[3]?.tween({
        rotation: 0,
        y: 16
      }, 600, "easeOutCubic");
      _elements[4]?.tween({
        x: 0,
        opacity: 0
      }, 600, "easeOutCubic");
    }
    async function onLogoClick() {
      if (_this.flag("isOpen") && ViewController.instance().getCurrentPage().key == "HomePage") {
        if (await ViewController.instance().transitionBack()) {
          close();
        }
      } else if (await ViewController.instance().changeRoute("", "right")) {
        close();
      }
    }
    async function onMenuClick() {
      if (_this.flag("isOpen")) {
        if (await ViewController.instance().transitionBack()) {
          close();
        }
      } else if (await ViewController.instance().transition("Menu", "topRight")) {
        (function open() {
          _this.flag("isOpen", true);
          _elements[0]?.tween({
            scale: 0.7,
            scaleX: 1
          }, 600, "easeOutCubic");
          _elements[1]?.tween({
            rotation: 45,
            y: 10,
            scaleX: 1
          }, 600, "easeOutCubic");
          _elements[2]?.tween({
            scale: 0,
            x: -100,
            y: 10,
            scaleX: 1
          }, 600, "easeOutCubic");
          _elements[3]?.tween({
            rotation: -45,
            y: 8,
            scaleX: 1
          }, 600, "easeOutCubic");
          _elements[4]?.tween({
            x: -100,
            opacity: 1,
            scaleX: 1
          }, 600, "easeOutCubic");
        })();
      }
    }
    function onMenuEnter() {
      if (!_this.flag("isOpen")) {
        _elements[1]?.tween({
          y: 0,
          scaleX: 0.8
        }, 300, "easeOutCubic");
        _elements[3]?.tween({
          y: 16,
          scaleX: 0.8
        }, 300, "easeOutCubic");
      }
    }
    function onMenuLeave() {
      if (!_this.flag("isOpen")) {
        _elements[1]?.tween({
          y: 0,
          x: 0,
          scaleX: 1
        }, 500, "easeOutCubic");
        _elements[3]?.tween({
          y: 16,
          x: 0,
          scaleX: 1
        }, 500, "easeOutCubic");
      }
    }
    function onRouteChange() {
      close();
    }
    (async function () {
      (function initHTML() {
        _this.element.attr("aria-label", "menu-top");
      })();
      (function addListeners() {
        _this.events.sub(ViewController.UPDATE, onRouteChange);
      })();
    })();
    this.style = function () {
      return "\n        @font-face {\n            // font-family: 'FuturaLT-Bold';\n            // src: url('../fonts/FuturaLT-Bold.ttf') format('truetype');\n            font-family: 'marscondensed-regular-TRIAL';\n            src: url('../fonts/marscondensed-regular-TRIAL.otf') format('opentype');\n            font-weight: 400;\n            font-style: normal;\n        }\n\n        #Stage, #Stage * {\n            .Menu {\n                position: absolute;\n                z-index: 9999;\n            }\n            .MenuTop, {\n                position: fixed;\n                top: 3rem;\n                height: 7rem;\n                left: 50%;\n                width: 100%;\n                transform: translateX(-50%);\n                display: contents;\n            }\n            .Top {\n                position: relative;\n                width: 100%;\n                height: 100%;\n                display: contents;\n            }\n            .Logo {\n                position: absolute;\n                left: 40px;\n                top: 40px;\n                width: 6rem;\n                height: 6rem;\n                transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                img {\n                    height: 100%;\n                }\n                &:hover {\n                    cursor: pointer;\n                    opacity: 0.5;\n                    transform: scale(0.8) !important;\n                }\n            }\n            .TopBuger_Wrapper {\n                position: absolute;\n                right: 40px;\n                top: 50px;\n                width: 100px;\n                height: 80px;\n            }\n            .TopBuger {\n                position: relative;\n                width: 100%;\n                height: 100%;\n                display: flex;\n                justify-content: center;\n                cursor: pointer;\n                transform-origin: 50% 50%;\n\n                &__close {\n                    opacity: 0;\n                    position:absolute;\n                    font-family:Futura, sans-serif;\n                    color: #D8D8D8;\n                    font-weight:700;\n                    fontSize: 1.6rem;\n                    text-transform:uppercase;\n                }\n\n                .TopBurgerL1 {\n                    position: absolute;\n                    transform: translateY(0px);\n                    width: 100%;\n                    height: 2px;\n                    background-color: #ee2f22;\n                }\n                .TopBurgerL2 {\n                    position: absolute;\n                    transform: translateY(8px);\n                    width: 100%;\n                    height: 2px;\n                    background-color: #ee2f22;\n                }\n                .TopBurgerL3 {\n                    position: absolute;\n                    transform: translateY(16px);\n                    width: 100%;\n                    height: 2px;\n                    background-color: #ee2f22;\n                }\n            }\n            \n        }        \n        ";
    };
    this.render = function (html) {
      return html`
              <div class="Top">
                  <div class="Logo">
                      <img src="assets/images/test/prometheus-logo.png" @click="${onLogoClick}"/>
                  </div>
                  <div class="TopBuger_Wrapper" @click="${onMenuClick}" @mouseenter="${onMenuEnter}" @mouseleave="${onMenuLeave}">
  <!--                    <div class="TopBuger__close">Close</div>-->
                      <div class="TopBuger">
                          <div class="TopBurgerL1"></div>
                          <div class="TopBurgerL2"></div>
                          <div class="TopBurgerL3"></div>
                      </div>
                  </div>
              </div>
          `;
    };
    this.postRender = async function () {
      let $logo = await _this.querySelector(".Logo");
      _elements.push($logo);
      let $topBurgerL1 = await _this.querySelector(".TopBurgerL1");
      _elements.push($topBurgerL1);
      let $topBurgerL2 = await _this.querySelector(".TopBurgerL2");
      _elements.push($topBurgerL2);
      let $topBurgerL3 = await _this.querySelector(".TopBurgerL3");
      _elements.push($topBurgerL3);
      let $close = await _this.querySelector(".TopBuger__close");
      _elements.push($close);
      _this.flag("hasElements", true);
    };
    _this.animateIn = async function () {
      await _this.wait("hasElements");
      _elements.forEach((el, index) => {
        if (index == 0) {
          el.css({
            opacity: 0
          }).tween({
            opacity: 1
          }, 3000, "easeOutCubic");
        } else {
          el.css({
            opacity: 0
          }).transform({
            scaleX: 0
          }).tween({
            opacity: 1,
            scaleX: 1
          }, index - 250, "easeOutCubic");
        }
      });
    };
    this.getElements = async function () {
      await _this.wait("hasElements");
      return _elements;
    };
  });
  Class(function MenuUI() {
    Inherit(this, InteractiveUI);
    const _this = this;
    const $this = _this.element;
    var $content;
    var $link;
    var _social;
    function resize() {
      if (Stage.width < 600) {
        $content.css({
          alignItems: "flex-start",
          justifyContent: "center",
          bottom: "2rem",
          right: "unset",
          left: "1rem"
        }).transform({
          scale: 0.8
        });
        $link.css({
          fontSize: "1.2rem"
        });
      } else if (Device.mobile && Stage.width > Stage.height) {
        _social.element.css({
          display: "block"
        });
        $content.css({
          alignItems: "flex-start",
          justifyContent: "unset",
          bottom: "1rem",
          right: "unset",
          left: "7.5rem"
        }).transform({
          x: "0",
          scale: 0.6
        });
        $link.css({
          fontSize: "1.4rem"
        });
      } else {
        _social.element.css({
          display: "block"
        });
        $content.css({
          alignItems: "flex-end",
          justifyContent: "unset",
          bottom: "4rem",
          right: "4rem",
          marginRight: Config.SCROLL_PAGE_OFFSET,
          left: "unset"
        }).transform({
          x: "0",
          scale: 1
        });
        $link.css({
          fontSize: "1.2rem"
        });
      }
      if (Device.mobile && Stage.width < Stage.height) {
        $this.css({
          height: window.innerHeight
        });
      } else {
        $this.css({
          height: "100%"
        });
      }
    }
    function onLinkHover(e) {
      if (e.action == "over") {
        $link.tween({
          opacity: 0.5
        }, 200, "easeOutCubic");
      } else {
        $link.tween({
          opacity: 1
        }, 400, "easeOutCubic");
      }
    }
    function onLinkClick(e) {
      ViewController.instance().changeRoute("privacy");
    }
    $this.css({
      width: "100vw",
      height: "100%"
    });
    ($content = $this.create("content")).css({
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-end",
      bottom: "4rem",
      right: "4rem"
    });
    ($link = $content.create("link")).text("Privacy Policy");
    $link.css({
      position: "relative",
      fontWeight: "500",
      color: "#FDF0E1",
      textDecoration: "underline",
      fontFamily: "Futura, sans-serif",
      fontSize: "1.2rem",
      paddingBottom: "1rem",
      lineHeight: "2.4rem",
      whiteSpace: "nowrap",
      opacity: 0
    });
    $link.interact(onLinkHover, onLinkClick, "privacy", "privacy");
    _social = _this.initClass(MenuSocialv2, [$content]);
    _this.onResize(resize);
    _this.onVisible = function () {};
    _this.onInvisible = function () {};
    _this.animateIn = function () {
      $link.tween({
        opacity: 1
      }, 300, "easeOutCubic", 1200);
      return _social.animateIn();
    };
    _this.animateOut = async function () {
      $link.tween({
        opacity: 0
      }, 300, "easeOutCubic");
      return _social.animateOut();
    };
  });
  Class(function MobileMenuNavigation($parent) {
    Inherit(this, Object3D);
    const _this = this;
    var $container;
    var _totalHeight = 0;
    var _currRoute = "";
    const NAV_ITEMS = [{
      text: "HOME",
      path: ""
    }, {
      text: "ABOUT",
      path: "about"
    }, {
      text: "TECHNOLOGY",
      path: "technology"
    }, {
      text: "NEWS",
      path: "news"
    }, {
      text: "CONNECT",
      path: "connect"
    }];
    var $navItems = [];
    function onItemHover(e) {
      if (!_this.flag("isAnimating")) {
        switch (e.action) {
          case "over":
            e.object.tween({
              alpha: 0.33
            }, 200, "easeOutCubic");
            break;
          case "out":
            e.object.tween({
              alpha: 1
            }, 400, "easeOutCubic");
        }
      }
    }
    function onItemClick(e) {
      if (!_this.flag("isAnimating")) {
        if (e.object.path == ViewController.instance().currentRoute.path) {
          ViewController.instance().transitionBack();
        } else {
          ViewController.instance().changeRoute(e.object.path);
        }
      }
    }
    async function resize() {
      await _this.wait(_this, "contentReady");
      $container.scale = Math.range(Stage.height, 0, 750, 0, 1, true);
      $container.scale *= Math.range(Stage.width, 400, 1440, 0.5, 1, true);
      if (SceneLayout.breakpoint != "") {
        $container.x = 25;
        $container.y = 75;
      } else {
        $container.x = 150;
        $container.y = Stage.height / 2 - _totalHeight / 2 * 1.2 * $container.scale;
      }
      _this.animateIn();
    }
    (async function () {
      (function init() {
        ($container = $gl()).y = 0;
        $parent.add($container);
        _currRoute = ViewController.instance().currentRoute?.path;
      })();
      (function initNavItems() {
        NAV_ITEMS.forEach(async (item, index) => {
          let $item = await async function createText({
            text: text,
            path: path,
            offset: offset
          }) {
            return new Promise(async resolve => {
              let $item = $glText(text, "marscondensed-regular-TRIAL", 70, {
                width: 120,
                align: "left",
                letterSpacing: -0.03,
                color: path === _currRoute ? Colors.value.orange : Colors.value.beige
              });
              let shader = _this.initClass(Shader, "MenuItemShader", {
                tNoise: {
                  value: Utils3D.getTexture("assets/images/noise/dirnoise_basecolor.png"),
                  ignoreUIL: true
                },
                uTimeScale: {
                  value: 0.39
                },
                uUVScale: {
                  value: 1.78
                },
                uRotation: {
                  value: -180
                },
                uTransition0: {
                  value: 0.01
                },
                uBoundingMin: {
                  value: new Vector3()
                },
                uBoundingMax: {
                  value: new Vector3()
                }
              });
              $item.shader = shader;
              $item.useShader(shader);
              await $item.text.ready();
              $item.text.shader.set("uBoundingMin", new Vector3().copy($item.dimensions.min));
              $item.text.shader.set("uBoundingMax", new Vector3().copy($item.dimensions.max));
              $item.path = path;
              $item.interact(onItemHover, onItemClick);
              resolve($item);
            });
          }(item);
          if (index > 0) {
            $item.y = $item.dimensions.height * index;
          }
          _totalHeight += $item.dimensions.height;
          $item.targetY = $item.y + 50;
          $item.index = index;
          $container.add($item);
          $navItems.push($item);
          if (index == NAV_ITEMS.length - 1) {
            if (Stage.width > 600) {
              $container.y = Stage.height / 2 - _totalHeight / 2 - $item.dimensions.height / 2;
            } else {
              $container.y = 0;
            }
            _this.flag("contentReady", true);
          }
        });
      })();
      (function addListeners() {
        _this.onResize(resize);
      })();
      if (_this.isPlayground()) {
        _this.animateIn();
      }
      resize();
    })();
    this.animateIn = async function (delay = 0) {
      return new Promise(async (resolve, reject) => {
        await _this.wait(_this, "contentReady");
        _this.flag("isAnimating", true);
        let anims = $navItems.map(async $item => {
          await $item.text.ready();
          $item.shader.tween("uTransition0", 1, 800, "easeIn", delay + $item.index * 100).promise();
          return $item.tween({
            y: $item.targetY
          }, 400, "easeOutCubic", delay + $item.index * 150).promise();
        });
        await Promise.all(anims);
        _this.flag("isAnimating", false);
        resolve();
      });
    };
    this.animateOut = async function (delay = 0) {
      return new Promise(resolve => {
        $navItems.forEach($item => {
          $item.shader.tween("uAlpha", 0, 500, "easeOutSine", delay + $item.index * 50);
          $item.shader.tween("uTransition0", 0, 500, "easeIn", delay + $item.index * 50).promise();
          $item.clearInteract();
        });
        $navItems = [];
        resolve();
      });
    };
  });
  Class(function NavigationHeader() {
    Inherit(this, Element);
    const _this = this;
    const $this = _this.element;
    var $wordmark;
    var $menu;
    var $logo;
    var $logoContainer;
    var $closeContainer;
    var $closeWrapper;
    _this.state = "";
    var $lines = [];
    var _gap = Device.mobile ? 4 : 6;
    async function close() {
      _this.flag("isOpen", false);
      PageUIController.instance().state.set("menuOpen", false);
      $lines[0].tween({
        rotation: 0,
        y: 0
      }, 600, "easeOutCubic");
      $lines[1].tween({
        scale: 1,
        y: _gap,
        x: 0
      }, 600, "easeOutCubic");
      $lines[2].tween({
        rotation: 0,
        y: _gap * 2
      }, 600, "easeOutCubic");
      $menu.hit.size(56, 24).center();
    }
    function resize() {
      if (Device.mobile && Stage.width > Stage.height && Stage.height < 500) {
        $this.transform({
          scale: 0.7
        });
      } else {
        $this.transform({
          scale: 1
        });
      }
    }
    async function onMenuClick() {
      if (_this.flag("isOpen")) {
        if (await ViewController.instance().transitionBack()) {
          close();
        }
      } else if (await ViewController.instance().transition("Menu", "topRight")) {
        _this.switchToLogo();
        _this.changeColor(Colors.value.beige);
        (async function open() {
          _this.flag("isOpen", true);
          PageUIController.instance().state.set("menuOpen", true);
          $lines[0].tween({
            rotation: 45,
            y: 10,
            scaleX: 1
          }, 600, "easeOutCubic");
          $lines[1].tween({
            scale: 0,
            x: -100,
            y: 10,
            scaleX: 1
          }, 600, "easeOutCubic");
          $lines[2].tween({
            rotation: -45,
            y: 6,
            scaleX: 1
          }, 600, "easeOutCubic");
          $menu.hit.size(56, 56).center();
        })();
      }
    }
    function onMenuHover(e) {
      if (!_this.flag("isOpen")) {
        if (e.action == "over") {
          $lines[0]?.tween({
            y: 0,
            scaleX: 0.8,
            rotation: 0
          }, 300, "easeOutCubic");
          $lines[2]?.tween({
            y: _gap * 2,
            scaleX: 0.8,
            rotation: 0
          }, 300, "easeOutCubic");
        } else {
          $lines[0]?.tween({
            y: 0,
            x: 0,
            scaleX: 1,
            rotation: 0
          }, 500, "easeOutCubic");
          $lines[2]?.tween({
            y: _gap * 2,
            x: 0,
            scaleX: 1,
            rotation: 0
          }, 500, "easeOutCubic");
        }
      }
    }
    async function onLogoClick() {
      if (ViewController.instance().currentRoute.path != "" || _this.flag("isOpen")) {
        if (_this.flag("isOpen") && ViewController.instance().getCurrentPage().key == "HomePage") {
          if (await ViewController.instance().transitionBack()) {
            close();
          }
        } else if (await ViewController.instance().changeRoute("", "right")) {
          close();
        }
      } else {
        _this.events.fire(NavigationHeader.LOGO_CLICK);
      }
    }
    function onLogoHover(e) {
      if (!Device.mobile) {
        if (e.action == "over") {
          if (_this.state == "logo") {
            $logo.tween({
              opacity: 0.6
            }, 200, "easeOutCubic");
          } else {
            $wordmark.tween({
              opacity: 0.6
            }, 200, "easeOutCubic");
          }
        } else if (_this.state == "logo") {
          $logo.tween({
            opacity: 1
          }, 400, "easeOutCubic");
        } else {
          $wordmark.tween({
            opacity: 1
          }, 400, "easeOutCubic");
        }
      }
    }
    async function onCloseClick() {
      if (ViewController.instance().currentRoute.path != "news") {
        ViewController.instance().changeRoute("news");
      }
    }
    async function onCloseHover(e) {
      if (ViewController.instance().currentRoute.path.split("/")[1] != null) {
        if (_this.flag("closeHoverable")) {
          if (e.action == "over") {
            $closeWrapper.tween({
              opacity: 0.5,
              scale: 0.8
            }, 300, "easeOutCubic");
          } else {
            $closeWrapper.tween({
              opacity: 1,
              scale: 1
            }, 300, "easeOutCubic");
          }
        }
      } else {
        if (_this.flag("closeHoverable") || _this.flag("closeActive")) {
          return;
        }
        await closeHide();
      }
    }
    async function onRouteChange(e) {
      close();
      await defer();
      switch (ViewController.instance().currentRoute?.path) {
        case "":
        case "chapter1":
        case "chapter2":
          _this.switchToWordmark();
          $logoContainer.css({
            backgroundColor: "transparent"
          });
          break;
        case "connect":
          _this.switchToLogo();
          $logoContainer.css({
            backgroundColor: Colors.value.beige
          });
          break;
        case "mission":
        default:
          _this.switchToLogo();
          $logoContainer.css({
            backgroundColor: Colors.value.orange
          });
      }
    }
    async function closeShow() {
      if (!_this.flag("closeActive")) {
        $closeWrapper.transform({
          y: -20
        });
        $closeWrapper.css({
          opacity: 0
        });
        $closeContainer.css({
          display: "initial"
        });
        await $closeWrapper.tween({
          opacity: 1,
          y: 0
        }, 300, "easeInOut", 300).promise();
        _this.flag("closeActive", true);
        await _this.wait(1000);
        _this.flag("closeHoverable", true);
      }
    }
    async function closeHide() {
      if (_this.flag("closeActive")) {
        await $closeWrapper.tween({
          opacity: 0,
          scale: 1
        }, 300, "easeInOut").promise();
        _this.flag("closeHoverable", false);
        $closeContainer.css({
          display: "none"
        });
        _this.flag("closeActive", false);
      }
    }
    (async function initHTML() {
      $this.css({
        display: "contents"
      });
      let offset = Device.mobile.phone ? 40 : 60;
      ($logoContainer = $this.create("logo-container")).css({
        position: "relative",
        top: offset * 0.7,
        left: offset * 0.7,
        backgroundColor: Colors.value.orange
      });
      let size = Device.mobile.phone ? {
        width: 250,
        height: 45
      } : {
        width: 300,
        height: 60
      };
      let logoSize = Device.mobile.phone ? 36 : 44;
      let logoCSS = {
        backgroundSize: "contain",
        backgroundPosition: "center",
        display: "inline-block",
        marginLeft: 5,
        backgroundColor: "inherit",
        maskSize: "contain",
        opacity: 0
      };
      ($wordmark = $logoContainer.create("wordmark")).size(size.width, size.height).css(logoCSS);
      $wordmark.css({
        top: Device.mobile.phone ? -9 : -10,
        left: 5,
        backgroundImage: "url(assets/images/ui/prometheus_wordmark.png)",
        backgroundRepeat: "no-repeat"
      });
      $wordmark.interact(onLogoHover, onLogoClick, "#", "Prometheus logo home button");
      $wordmark.multiTween = true;
      if (Device.mobile) {
        $wordmark.hit.div.setAttribute("role", "button");
      }
      ($logo = $logoContainer.create("logo")).size(logoSize, logoSize).css(logoCSS);
      $logo.css({
        "-webkit-mask": "url(assets/images/ui/logo.svg) no-repeat center",
        mask: "url(assets/images/ui/logo.svg) no-repeat center contain",
        maskSize: "contain"
      });
      $logo.interact(onLogoHover, onLogoClick, "#", "Prometheus logo home button");
      $logo.multiTween = true;
      if (Device.mobile) {
        $logo.hit.div.setAttribute("role", "button");
      }
      ($closeContainer = $this.create("close-container")).css({
        position: "absolute",
        top: offset * 0.7,
        left: "50%",
        width: "4rem",
        height: "4rem",
        transform: "translateX(-50%)",
        display: "none"
      });
      $closeContainer.interact(onCloseHover, onCloseClick, "#", "Close button");
      ($closeWrapper = $closeContainer.create("close-wrapper")).css({
        position: "relative",
        width: "100%",
        height: "100%",
        opacity: 0
      });
      $closeWrapper.create("closeLine1").css({
        position: "absolute",
        top: "50%",
        left: "50%",
        width: "100%",
        height: "2px",
        background: Colors.value.beige,
        transformOrigin: "left",
        transform: "rotate(45deg) translate(-50%, -50%)"
      });
      $closeWrapper.create("closeLine2").css({
        position: "absolute",
        top: "50%",
        left: "50%",
        width: "100%",
        height: "2px",
        background: Colors.value.beige,
        transformOrigin: "left",
        transform: "rotate(-45deg) translate(-50%, -50%)"
      });
      ($menu = $this.create("menu")).css({
        position: "relative",
        height: "24px",
        float: "right",
        top: offset - 3,
        right: offset
      });
      $menu.interact(onMenuHover, onMenuClick, "#", "Menu button");
      $menu.hit.size(56, 24).center();
      if (Device.mobile) {
        $menu.hit.div.setAttribute("role", "button");
      }
      for (let i = 0; i < 3; i++) {
        let $line = $menu.create("line");
        $line.css({
          position: "relative",
          width: Device.mobile.phone ? 40 : 56,
          height: "2px",
          background: Colors.value.beige
        }).transform({
          y: _gap * i
        });
        $lines.push($line);
      }
    })();
    (function addListeners() {
      _this.events.sub(ViewController.UPDATE, onRouteChange);
      _this.events.sub(NavigationHeader.CLOSE_SHOW, closeShow);
      _this.events.sub(NavigationHeader.CLOSE_HIDE, closeHide);
      _this.onResize(resize);
    })();
    _this.changeColor = function (color) {
      $lines.forEach($line => {
        $line.css({
          background: color
        });
      });
    };
    _this.switchToLogo = async function () {
      if (_this.state != "logo") {
        _this.state = "logo";
        $wordmark.css({
          opacity: 0
        }).hide();
        await $logoContainer.tween({
          opacity: 0
        }, 300, "easeOutCubic").promise();
        $logo.show().css({
          opacity: 1
        });
        $logoContainer.tween({
          opacity: 1
        }, 300, "easeOutCubic").promise();
      }
    };
    _this.switchToWordmark = async function () {
      if (_this.state != "wordmark") {
        _this.state = "wordmark";
        await $logoContainer.tween({
          opacity: 0
        }, 300, "easeOutCubic").promise();
        $logo.css({
          opacity: 0
        }).hide();
        $wordmark.css({
          opacity: 1
        }).show();
        $logoContainer.tween({
          opacity: 1
        }, 300, "easeOutCubic").promise();
      }
    };
  }, "singleton", () => {
    NavigationHeader.LOGO_CLICK = "NavigationHeader_logo_click";
    NavigationHeader.CLOSE_SHOW = "NavigationHeader_close_anim_show";
    NavigationHeader.CLOSE_HIDE = "NavigationHeader_close_anim_hide";
    NavigationHeader.CLOSE_CLICK = "NavigationHeader_close_click";
  });
  Class(function MenuCarousel() {
    Inherit(this, Object3D);
    const _this = this;
    const DATA = [{
      image: "assets/images/ui/chapter1.jpg",
      subtitle: "CHAPTER 1",
      title: CMS.get("chapters.chapter-1.title"),
      path: "chapter1"
    }, {
      image: "assets/images/ui/chapter2.jpg",
      subtitle: "CHAPTER 2",
      title: CMS.get("chapters.chapter-2.title"),
      path: "chapter2"
    }, {
      image: "assets/images/ui/chapter3.jpg",
      subtitle: "CHAPTER 3",
      title: CMS.get("chapters.chapter-3.title"),
      path: "chapter3"
    }];
    var $stack;
    var $container;
    var _objects = [];
    var $dots = [];
    var _active = 0;
    function generateObjects() {
      DATA.forEach(async ({
        image: image,
        subtitle: subtitle,
        title: title,
        path: path
      }, index) => {
        let item = _this.initClass(MenuCarouselItem, {
          image: image,
          subtitle: subtitle,
          title: title,
          index: index % DATA.length,
          path: path
        });
        _objects.push(item.$container);
      });
    }
    function loop() {}
    function addListeners() {
      _this.events.sub(Stack3D.UPDATE, onUpdate);
    }
    function onUpdate(e) {
      _objects.forEach((obj, index) => {
        if (e.sign == -1) {
          if (index == 0) {
            obj.shader.set("uAlpha2", 1);
            obj.title.text.shader?.tween("uTransition0", 1, 400, "easeIn");
            obj.subtitle.text.shader?.tween("uTransition0", 1, 400, "easeIn");
            _active = obj.index;
            $dots[_active]?.tween({
              alpha: 1
            }, 300, "easeOutCubic");
          } else {
            obj.title.text.shader?.set("uTransition0", 0);
            obj.subtitle.text.shader?.set("uTransition0", 0);
            if (obj.index != _active) {
              $dots[obj.index]?.tween({
                alpha: 0.5
              }, 300, "easeOutCubic");
            }
          }
        } else if (index == 1) {
          obj.shader.set("uAlpha2", 1);
          obj.title.text.shader?.tween("uTransition0", 1, 400, "easeIn");
          obj.subtitle.text.shader?.tween("uTransition0", 1, 400, "easeIn");
          _active = obj.index;
          $dots[_active]?.tween({
            alpha: 1
          }, 300, "easeOutCubic");
        } else {
          obj.title.text.shader?.set("uTransition0", 0);
          obj.subtitle.text.shader?.set("uTransition0", 0);
          if (obj.index != _active) {
            $dots[obj.index]?.tween({
              alpha: 0.5
            }, 300, "easeOutCubic");
          }
        }
      });
    }
    (async function () {
      (async function initObjects() {
        generateObjects();
        generateObjects();
        (function createStack(mode) {
          if ($stack) {
            $stack.destroy();
          }
          let offset = new Vector3(0, 0, 0);
          if (mode == "desktop") {
            offset.set(-0.2, 0.2, 1);
          } else {
            offset.set(Stage.width <= 500 ? -1.25 : -1.5, 0.001, 0.001);
          }
          $stack = _this.initClass(Stack3D, _objects, {
            offset: offset,
            visible: 2,
            easeTime: 800,
            ease: "easeOutQuart"
          });
        })("desktop");
        await defer();
        addListeners();
        await _objects[0].title.text.ready();
        await _objects[0].subtitle.text.ready();
        _objects[0].title.text.shader?.set("uTransition0", 1);
        _objects[0].subtitle.text.shader?.set("uTransition0", 1);
      })();
      addListeners();
    })();
    this.animateIn = async function (delay = 0) {
      _this.visible = true;
      _this.startRender(loop);
      return Promise.all([$stack.wrapper.tween({
        alpha: 1
      }, 400, "easeOutCubic", delay).promise(), $container?.tween({
        alpha: 1
      }, 400, "easeOutCubic", delay).promise()]);
    };
    this.animateOut = async function (delay = 0) {
      _this.stopRender(loop);
      return Promise.all([$stack.wrapper.tween({
        alpha: 0
      }, 400, "easeOutCubic", delay).promise(), $container?.tween({
        alpha: 0
      }, 400, "easeOutCubic", delay).promise()]);
    };
    this.hide = async () => {
      await $stack.wrapper.tween({
        alpha: 0
      }, 300, "easeOutCubic").promise();
      _this.stopRender(loop);
      _this.visible = false;
    };
    this.initControls = function () {
      if (!$container) {
        ($container = $gl()).alpha = 0.01;
        DATA.forEach((data, index) => {
          let $dot = $gl(0.04, 0.04, Colors.value.beige);
          let shader = _this.initClass(Shader, "MenuCarouselIndicatorShader", {
            uColor: {
              value: new Color()
            },
            transparent: true
          });
          $dot.useShader(shader);
          $dot.alpha = index == 0 ? 1 : 0.5;
          $dot.y = index * 0.075;
          $dot.index = index;
          $container.add($dot);
          $dots.push($dot);
        });
        $container.x = 1.5;
        $container.y = -(DATA.length * 0.04 + (DATA.length - 1) * 0.075) / 2;
        $stack.wrapper.add($container);
      }
    };
    _this.get("stack", () => $stack);
  });
  Class(function MenuCarouselItem({
    image: image,
    subtitle: subtitle,
    title: title,
    index: index,
    path: path
  } = {}) {
    Inherit(this, Component);
    const _this = this;
    function initText({
      text: text,
      size: size,
      color: color
    }) {
      let shader = _this.initClass(Shader, "MenuItemShader", {
        tNoise: {
          value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
          ignoreUIL: true
        },
        uTimeScale: {
          value: 0.39
        },
        uUVScale: {
          value: 1.78
        },
        uRotation: {
          value: -60
        },
        uTransition0: {
          value: 0.01
        },
        uBoundingMin: {
          value: new Vector3()
        },
        uBoundingMax: {
          value: new Vector3()
        }
      });
      let $text = $glText(text, "marscondensed-regular-TRIAL", size, {
        align: "center",
        color: color,
        letterSpacing: -0.03
      });
      $text.useShader(shader);
      $text.shader = shader;
      return $text;
    }
    async function resize() {
      await _this.wait(_this, "isReady");
    }
    function onHover(e) {}
    function onClick(e) {
      if (_this.$container.z >= -0.5 && path) {
        ViewController.instance().changeRoute(path);
      }
    }
    _this.$container;
    (async function init() {
      let shader = _this.initClass(Shader, "MenuCarouselItemShader", {
        uSize: {
          value: new Vector2(2.7, 1.8)
        },
        uAlpha2: {
          value: 1
        }
      });
      _this.$container = $gl(2.7, 1.8, image);
      _this.$container.index = index;
      _this.$container.useShader(shader);
      _this.$container.enable3D();
      _this.$container.interact(onHover, onClick);
      let $subtitle = initText({
        text: subtitle,
        size: 0.08,
        color: Colors.value.orange
      });
      $subtitle.y = 0.33;
      $subtitle.enable3D();
      _this.$container.group.add($subtitle.anchor);
      _this.$container.subtitle = $subtitle;
      let $title = initText({
        text: title,
        size: 0.2,
        color: Colors.value.beige
      });
      $title.y = 0.1;
      $title.enable3D();
      _this.$container.group.add($title.anchor);
      _this.$container.title = $title;
      await $subtitle.text.ready();
      $subtitle.shader.set("uBoundingMin", new Vector3().copy($subtitle.dimensions.min));
      $subtitle.shader.set("uBoundingMax", new Vector3().copy($subtitle.dimensions.max));
      await $title.text.ready();
      $title.shader.set("uBoundingMin", new Vector3().copy($title.dimensions.min));
      $title.shader.set("uBoundingMax", new Vector3().copy($title.dimensions.max));
      _this.flag("isReady", true);
    })();
    (function addListeners() {
      _this.onResize(resize);
    })();
  });
  Class(function MobileCarousel({
    parent: parent,
    hit: hit
  } = {}) {
    Inherit(this, Component);
    const _this = this;
    const DATA = [{
      image: "assets/images/ui/chapter1.jpg",
      subtitle: "CHAPTER 1",
      title: CMS.get("chapters.chapter-1.title"),
      path: "chapter1",
      badge: CMS.get("chapters.chapter-1.new")
    }, {
      image: "assets/images/ui/chapter2.jpg",
      subtitle: "CHAPTER 2",
      title: CMS.get("chapters.chapter-2.title"),
      path: "chapter2",
      badge: CMS.get("chapters.chapter-2.new")
    }, {
      image: "assets/images/ui/chapter3.jpg",
      subtitle: "CHAPTER 3",
      title: CMS.get("chapters.chapter-3.title"),
      path: "chapter3",
      badge: CMS.get("chapters.chapter-3.new")
    }];
    var $wrap;
    var $carousel;
    var _slider;
    var _feathering;
    var _items = [];
    var _objects = [];
    (function initFeathering() {
      _feathering = _this.initClass(UIFeathering, {
        bounds: new Vector2(0.35, 1),
        direction: new Vector2(1, 0),
        width: 50
      });
    })();
    (function generateObjects() {
      DATA.forEach(async (obj, index) => {
        let item = _this.initClass(MobileCarouselItem, {
          ...obj,
          index: index % DATA.length
        });
        item.useFeathering(_feathering);
        _items.push(item);
        _objects.push(item.$container);
      });
    })();
    (async function initSlider() {
      ($wrap = $gl()).alpha = 0;
      parent.add($wrap);
      $carousel = $gl();
      $wrap.add($carousel);
      let size = await _items[0].getSize();
      let itemWidth = size.width;
      let itemHeight = size.height;
      let width = itemWidth + 10;
      (_slider = _this.initClass(Interaction.Slider, $carousel, {
        x: 1
      }, {
        hit: Stage,
        slides: _objects.length,
        width: width,
        repeatable: true,
        desktopDrag: true
      })).repeatable = true;
      _slider.views = _objects;
      _objects.forEach((obj, index) => {
        obj.x = width * index;
        $carousel.add(obj);
      });
      $wrap.x = Stage.width / 2 - itemWidth / 2;
      $wrap.y = Stage.height - 200 - itemHeight / 2;
    })();
    _this.hide = async function () {
      await $wrap.tween({
        alpha: 0
      }, 300, "easeOutCubic").promise();
      $wrap.visible = false;
    };
    _this.show = async function () {
      await $wrap.tween({
        alpha: 1
      }, 300, "easeOutCubic", 300).promise();
      $wrap.visible = true;
    };
    _this.resize = async function (y) {
      if (Stage.width > Stage.height) {
        _feathering.bounds = new Vector2(0.35, 1);
      } else {
        _feathering.bounds = new Vector2(0, 1);
      }
      let size = await _items[0].getSize();
      let itemWidth = size.width;
      let itemHeight = size.height;
      if (Stage.width < 600) {
        $wrap.x = Stage.width / 2 - itemWidth / 2 - 25;
      } else {
        $wrap.x = Stage.width / 2 - itemWidth / 2 + 100;
      }
      $wrap.y = Stage.width > Stage.height ? Stage.height - 170 - itemHeight / 2 : y + 30;
      _objects.forEach((obj, index) => {
        obj.x = (itemWidth + 10) * index;
      });
      _slider.width = itemWidth + 10;
    };
  });
  Class(function MobileCarouselItem({
    image: image,
    subtitle: subtitle,
    title: title,
    index: index,
    path: path,
    badge: badge
  } = {}) {
    Inherit(this, Component);
    const _this = this;
    var $image;
    var $badge;
    _this.$container = $gl();
    var _width = Math.max(Stage.width / 2, 275);
    var _height = _width / 1.5;
    var _lastX = 0;
    var _layoutAspect = 0;
    function initText({
      text: text,
      size: size,
      color: color
    }) {
      let textShader = _this.initClass(Shader, "MenuCarouselItemTextShader", {
        uAlpha2: {
          value: 1
        },
        transparent: true
      });
      let $text = $glText(text, "marscondensed-regular-TRIAL", size, {
        align: "center",
        color: color,
        letterSpacing: -0.03
      });
      $text.useShader(textShader);
      return $text;
    }
    async function resize() {
      _this.flag("isResized", false);
      await _this.wait(_this, "isReady");
      _width = Stage.width / 1.5;
      _height = _width / _layoutAspect;
      $image.height = _height;
      $image.width = _width;
      _this.$container.title.x = _width / 2;
      _this.$container.subtitle.x = _width / 2;
      await _this.$container.title.text.ready();
      _this.$container.title.text.shader.set("uAlpha2", 1);
      _this.flag("isResized", true);
      if ($badge) {
        $badge.element.x = _width - $badge.width * 1.5 - 10;
        $badge.element.y = _height - $badge.height * 1.5 - 10;
        $badge.element.scale = 1.5;
      }
    }
    function onHover(e) {
      if (e.action == "over") {
        _lastX = Mouse.x;
        0;
        _this.flag("canClick", false);
      } else {
        Math.abs(Mouse.x - _lastX);
        _this.flag("canClick", true);
      }
    }
    async function onClick(e) {
      if (path && Mouse.delta.length() < 3) {
        if (ViewController.instance().currentRoute.path != path) {
          ViewController.instance().changeRoute(path);
        } else {
          ViewController.instance().transitionBack();
        }
      }
    }
    _layoutAspect = 281 / 184;
    (function init() {
      let shader = _this.initClass(Shader, "MenuCarouselItemShader", {
        uSize: {
          value: new Vector2(1.5, 1)
        },
        uAlpha2: {
          value: 1
        },
        transparent: true
      });
      _this.$container.index = index;
      ($image = $gl(_width, _height, image)).useShader(shader);
      $image.z = -1;
      _this.$container.add($image);
      $image.interact(onHover, onClick);
      let $subtitle = initText({
        text: subtitle,
        size: 20,
        color: Colors.value.orange
      });
      $subtitle.y = 25;
      $subtitle.x = _width / 2;
      _this.$container.add($subtitle);
      _this.$container.subtitle = $subtitle;
      let $title = initText({
        text: title,
        size: 30,
        color: Colors.value.beige
      });
      $title.y = 50;
      $title.x = _width / 2;
      _this.$container.add($title);
      _this.$container.title = $title;
      _this.flag("isReady", true);
    })();
    (function initBadge() {
      if (badge) {
        $badge = _this.initClass(MenuBadge);
        _this.$container.add($badge.element);
      }
    })();
    (function addListeners() {
      _this.onResize(resize);
    })();
    console.log($image);
    _this.getSize = async function () {
      return new Promise(async resolve => {
        await _this.wait(_this, "isResized");
        resolve({
          width: _width,
          height: _height
        });
      });
    };
    _this.useFeathering = async function (feathering) {
      await _this.wait(_this, "isReady");
      await _this.$container.subtitle.text.ready();
      await _this.$container.title.text.ready();
    };
  });
  Class(function UIFeathering(_config = {}) {
    Inherit(this, Component);
    const _this = this;
    var _bounds = new Vector2(0, 1);
    var _width = {
      value: Device.mobile ? 30 : 80
    };
    var _direction = new Vector2(0, 0);
    if (_config.bounds) {
      _bounds.copy(_config.bounds);
    }
    if (_config.width) {
      _width.value = _config.width;
    }
    if (_config.direction) {
      _direction.copy(_config.direction);
    }
    _this.get("width", () => _width.value);
    _this.set("width", width => _width.value = width);
    _this.get("bounds", () => _bounds);
    _this.set("bounds", bounds => _this.bounds.copy(bounds));
    _this.get("direction", () => _direction);
    _this.set("direction", direction => _this.direction.copy(direction));
    _this.get("uniforms", () => ({
      uFeatherBounds: {
        value: _this.bounds
      },
      uFeatherWidth: _width,
      uFeatherDirection: {
        value: _this.direction
      }
    }));
    _this.copyUniformsTo = function (...shaders) {
      shaders.forEach(shader => {
        if (shader) {
          if (!(shader instanceof Shader)) {
            shader = shader.shader;
          }
          Object.assign(shader.uniforms, _this.uniforms);
        }
      });
    };
  });
  Class(function MenuBadge() {
    Inherit(this, GLUIElement);
    const _this = this;
    const $this = _this.element;
    var $bg;
    var $title;
    function loop() {
      $bg.rotation.z -= Render.HZ_MULTIPLIER * 0.012;
    }
    _this.width = 42;
    _this.height = 42;
    (function initGL() {
      ($bg = $gl(42, 42, Utils3D.getTexture("/assets/images/ui/badge-star-texture.png"))).enable3D();
      $bg.setZ(2);
      $bg.x = 21;
      $bg.y = -21;
      $this.add($bg);
      ($title = $glText("NEW", "marscondensed-regular-TRIAL", 12.5, {
        align: "center",
        color: Colors.value.beige,
        letterSpacing: 0
      })).x = 21;
      $title.y = 14.5;
      $this.add($title);
      $title.setZ(3);
    })();
    _this.startRender(loop);
  });
  Class(function MenuStack($parent) {
    Inherit(this, Component);
    const _this = this;
    var $this;
    var $items = [];
    var _totalHeight = 0;
    const DATA = [{
      image: "assets/images/ui/chapter1.jpg",
      subtitle: "CHAPTER   1",
      title: CMS.get("chapters.chapter-1.title"),
      path: "chapter1",
      badge: CMS.get("chapters.chapter-1.new")
    }, {
      image: "assets/images/ui/chapter2.jpg",
      subtitle: "CHAPTER   2",
      title: CMS.get("chapters.chapter-2.title"),
      path: "chapter2",
      badge: CMS.get("chapters.chapter-2.new")
    }, {
      image: "assets/images/ui/chapter3.jpg",
      subtitle: "CHAPTER   3",
      title: CMS.get("chapters.chapter-3.title"),
      path: "chapter3",
      badge: CMS.get("chapters.chapter-3.new")
    }];
    function resizeHandler() {
      $this.scale = Math.range(Stage.width, 600, 1400, 0.7, 1.4, true);
      $this.scale *= Math.range(Stage.height, 600, 1100, 0.7, 1.1, true);
      $this.scale *= Math.range(Stage.height, 500, 300, 1, 0.7, true);
      $this.y = Stage.height / 2 - _totalHeight / 2;
      if (Device.mobile && Stage.width > Stage.height) {
        $this.x = Stage.width / 2 - 50;
        if (Stage.height < 375) {
          $this.scale *= Math.range(Stage.height, 0, 375, 0, 0.9, true);
        }
      } else {
        $this.x = Stage.width / 2 + 75;
      }
    }
    ($this = $gl(366, 490)).alpha = 0.001;
    $this.topLeftAnchor = true;
    $parent.add($this);
    DATA.forEach((obj, i) => {
      obj.video = "ch" + (i + 1);
      let item = _this.initClass(MenuStackItem, obj);
      $this.add(item.element);
      if (Device.mobile && Stage.width > Stage.height) {
        item.element.y = i * 190;
      } else {
        item.element.y = i * 180;
      }
      $items.push(item);
      _totalHeight += item.element.y;
    });
    if (Device.mobile && Stage.width > Stage.height) {
      _totalHeight -= 35;
    } else {
      _totalHeight += 0;
    }
    _this.onResize(resizeHandler);
    _this.show = function () {
      $items.forEach($item => {
        $item.show();
      });
      $this.tween({
        alpha: 1
      }, 300, "easeInCubic", 200);
    };
    _this.hide = function () {
      $items.forEach($item => {
        $item.hide();
      });
    };
    _this.animateOut = function () {
      $this.tween({
        alpha: 0
      }, 300, "easeOutCubic");
    };
  });
  Class(function MenuStackItem(_data) {
    Inherit(this, GLUIElement);
    const _this = this;
    const $this = _this.element;
    var _shader;
    var _videoTexture;
    var $wrapper;
    var $bg;
    var $title;
    var $subtitle;
    var $badge;
    var _color;
    var _width;
    var _height;
    var _mouse = new Vector2();
    function hover(e) {
      if (e.action == "over") {
        if ($badge) {
          $badge.element.tween({
            scale: 1.1
          }, 800, "easeOutQuart");
        }
        $wrapper.tween({
          scale: 1.04
        }, 800, "easeOutQuart");
        tween($subtitle, {
          scale: 1
        }, 800, "easeOutQuart");
        tween($title, {
          scale: 1.02
        }, 800, "easeOutQuart");
        _shader.tween("uHover", 1, 2000, "easeOutQuart");
        _videoTexture.start();
      } else {
        if ($badge) {
          $badge.element.tween({
            scale: 1
          }, 800, "easeOutQuart");
        }
        _videoTexture.saveTime = _videoTexture.video.time;
        $wrapper.tween({
          scale: 1
        }, 800, "easeOutQuart");
        tween($subtitle, {
          scale: 1
        }, 800, "easeOutQuart");
        tween($title, {
          scale: 1
        }, 800, "easeOutQuart");
        _shader.tween("uHover", 0, 2000, "easeOutQuart");
        _videoTexture.stop();
      }
    }
    function click(e) {
      if (ViewController.instance().currentRoute.path != _data.path) {
        ViewController.instance().changeRoute(_data.path);
      } else {
        ViewController.instance().transitionBack();
      }
    }
    if (Device.mobile && Stage.width > Stage.height) {
      _width = 325;
      _height = 185;
    } else {
      _width = 325;
      _height = 165;
    }
    (function initGL() {
      _videoTexture = _this.initClass(VideoTexture, `assets/videos/${_data.video}.mp4`, {
        firstFrame: `assets/videos/${_data.video}.jpg`,
        autoplay: false
      });
      $wrapper = $gl(_width, _height);
      $this.add($wrapper);
      $bg = $gl(_width, _height, _videoTexture);
      $wrapper.add($bg);
      switch (_data.video) {
        case "ch1":
          _color = Colors.value.orangeYellow;
          break;
        case "ch2":
          _color = Colors.value.greyishTeal;
          break;
        case "ch3":
          _color = Colors.value.lime;
      }
      _shader = _this.initClass(Shader, "MenuStackBackground", {
        uAlpha: {
          value: 1
        },
        uTreatment: {
          value: 1
        },
        uHover: {
          value: 0
        },
        uMouse: {
          value: _mouse
        },
        uColor: {
          value: new Color(_color)
        },
        uBorder: {
          value: new Color(Colors.value.beige)
        },
        uSize: {
          value: new Vector2(2, 1)
        },
        uSize2: {
          value: new Vector2(2, 1)
        },
        tNoise: {
          value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg")
        }
      });
      $bg.useShader(_shader);
      $bg.mesh.interactionScene = GLUI.Stage.scene;
      $bg.interact(hover, click, "#", _data.title);
      ($title = $glText(_data.title, "marscondensed-regular-TRIAL", 32, {
        align: "center",
        color: Colors.value.beige,
        letterSpacing: -0.03
      })).x = _width / 2;
      $title.y = _height / 2 - 16;
      $wrapper.add($title);
      $title.setZ(2);
      ($subtitle = $glText(_data.subtitle, "marscondensed-regular-TRIAL", 11, {
        align: "center",
        color: Colors.value.beige,
        letterSpacing: 0.3
      })).x = _width / 2;
      $subtitle.y = _height / 2 - 32;
      $wrapper.add($subtitle);
      $subtitle.setZ(2);
    })();
    (function initBadge() {
      if (_data.badge) {
        ($badge = _this.initClass(MenuBadge)).element.x = 12;
        $badge.element.y = 12;
        $this.add($badge);
      }
    })();
    (function initSEO() {
      let _seo = {
        root: _this.findParent("MenuSection").scene,
        seo: {
          url: _data.path,
          label: `${_data.subtitle} ${_data.title}`.toLowerCase()
        }
      };
      Interaction3D.find(World.CAMERA).add($bg.mesh, hover, click, _seo);
    })();
    _this.show = async function () {
      $wrapper.tween({
        scale: 1
      }, 10, "easeOutQuart");
      tween($subtitle, {
        scale: 1
      }, 10, "easeOutQuart");
      tween($title, {
        scale: 1
      }, 10, "easeOutQuart");
      _shader.tween("uHover", 0, 10, "easeOutQuart");
      _videoTexture.stop();
    };
    _this.hide = function () {
      _videoTexture.stop();
    };
  });
  Class(function NewsArticleItem(_data, _index) {
    Inherit(this, Element);
    const $this = this.element;
    var $container;
    var $title;
    (async function () {
      (function initHTML() {
        $container = $this.create("NewsArticleItem_Container");
        $title = $container.create("NewsArticleItem_Header", "h5");
        _data.bind("title", $title);
      })();
      (function initStyles() {
        $this.css({
          position: "relative",
          display: "flex",
          flexDirection: "column"
        });
        $container.css({
          width: "calc(((100vw / 3) * 2) / 2)",
          height: "calc((20rem + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem))",
          marginBottom: "6rem",
          background: "gray",
          position: "relative"
        });
        $title.css({
          fontFamily: "'marscondensed-regular-TRIAL', sans-serif",
          fontSize: "4rem",
          lineHeight: "3.4rem",
          color: "#d8d8d8",
          textAlign: "left",
          textTransform: "uppercase",
          marginBottom: "3rem"
        });
      })();
    })();
    this.animateIn = function (delay = 0) {};
    this.animateOut = async function (delay = 0) {};
  });
  Class(function NewsPage(isFirst = false) {
    Inherit(this, InteractivePage, "news", isFirst);
    const _this = this;
    (async function () {
      (async function init() {
        await _this.ready();
      })();
    })();
    this.animateIn = function () {};
    this.animateOut = function () {};
    this.hide = async function () {
      await defer();
      _this._hide();
    };
  });
  Class(function NewsPageUI() {
    Inherit(this, InteractiveUI);
    Inherit(this, DOMTemplate);
    const _this = this;
    var $newsPageUIWrapper;
    var $newsArticleCloneWrapper;
    var $newsArticleImgWrapper;
    var $newsArticleTitleHeader;
    var $newsArticleHTML;
    var $newsArticleDateClone;
    var _articleId;
    var $clickedArticle;
    var _activeArticle;
    var $clonedArticle;
    var $clone;
    var $this = _this.element;
    var $newsArticles = [];
    var _scrollY = 0;
    async function openArticle(item, ev) {
      if (_this.flag("newsArticleIsOpened")) {
        return;
      }
      CameraUtil.blockScroll(true);
      _this.events.fire(ViewController.NEWS_TRANSITION_ANIMATING);
      _this.flag("newsArticleIsOpened", true);
      _this.events.fire(NewsController.LOAD_ARTICLE, {
        item: item
      });
      _scrollY = window.scrollY;
      _articleId = item.slug;
      _activeArticle = await CMS.fetchNewsPage(item.slug);
      $clickedArticle = ev.target.closest(".News_Article_Wrapper");
      $newsPageUIWrapper.div.classList.add("NewsPageUI_Wrapper_ACTIVE");
      $newsArticles.forEach(async $article => {
        $article.div.classList.add("News_Article_HIDE");
      });
      document.querySelector(".NewsPage").classList.add("NewsPage_ACTIVE");
      $clone = $clickedArticle.querySelector(".News_Article_Img").cloneNode(true);
      if ($clickedArticle.classList.contains("News_Article_Featured")) {
        $newsPageUIWrapper.div.classList.add("News_Article_Clone_ACTIVE_V2");
      } else {
        $newsPageUIWrapper.div.classList.add("News_Article_Clone_ACTIVE");
      }
      $clonedArticle = $clickedArticle;
      $newsArticleTitleHeader.div.innerHTML = _activeArticle.title;
      $newsArticleHTML.div.innerHTML = _activeArticle.body;
      $newsArticleDateClone.div.innerHTML = _activeArticle.date;
      $newsArticleCloneWrapper.div.style.top = window.scrollY + "px";
      $clone.style.top = $clonedArticle.getBoundingClientRect().top - $newsArticleImgWrapper.div.getBoundingClientRect().top + "px";
      $clone.style.left = $clonedArticle.getBoundingClientRect().left + "px";
      $clone.style.width = $clonedArticle.getBoundingClientRect().width + "px";
      $newsArticleImgWrapper.div.appendChild($clone);
      await _this.wait(1);
      if ($clickedArticle.classList.contains("News_Article_Featured") || window.innerWidth <= 600) {
        $clone.classList.add("News_Article_Clone_ANIMATE_ACTIVE_V2");
      } else {
        $clone.classList.add("News_Article_Clone_ANIMATE_ACTIVE");
      }
      await _this.wait(1000);
      CameraUtil.blockScroll(false);
      Stage.div.scrollTop = 0;
      (function changeRoute() {
        ViewController.instance().changeRoute("news/" + _articleId);
      })();
    }
    (async function () {
      (async function init() {
        $this.css({
          opacity: 0
        });
        if (_this.isPlayground()) {
          defer(() => {
            _this.animateIn();
          });
        }
      })();
    })();
    this.animateIn = async function (delay = 600) {
      return new Promise(async resolve => {
        if (_scrollY != 0) {
          await _this.wait(delay);
          window.scrollTo(0, _scrollY);
        }
        $this.css({
          opacity: 0
        });
        await $this.tween({
          opacity: 1
        }, 1000, "easeOutCubic", delay).promise();
        resolve();
      });
    };
    this.animateOut = async function (delay = 1000) {
      return new Promise(async resolve => {
        await defer();
        $this.css({
          opacity: 0
        });
        (async function closeArticle() {
          _this.flag("newsArticleIsOpened", false);
          document.querySelector(".NewsPage").classList.remove("NewsPage_ACTIVE");
          $newsPageUIWrapper.div.classList.remove("News_Article_Clone_ACTIVE");
          $newsPageUIWrapper.div.classList.remove("News_Article_Clone_ACTIVE_V2");
          if ($clone) {
            $clone.classList.remove("News_Article_Clone_ANIMATE_ACTIVE");
            $clone.classList.remove("News_Article_Clone_ANIMATE_ACTIVE_V2");
            if ($newsArticleImgWrapper.div.contains($clone)) {
              $newsArticleImgWrapper.div.removeChild($clone);
            }
          }
          $newsPageUIWrapper.div.classList.remove("NewsPageUI_Wrapper_ACTIVE");
          $newsPageUIWrapper.div.classList.remove("News_PageUI_ACTIVE");
          $newsArticles.forEach(async _article => {
            _article.div.classList.remove("News_Article_ACTIVE");
            _article.div.classList.remove("News_Article_HIDE");
          });
          $newsArticleTitleHeader.div.innerHTML = "";
          $newsArticleHTML.div.innerHTML = "";
          $newsArticleDateClone.div.innerHTML = "";
        })();
        _this.events.fire(ViewController.NEWS_TRANSITION_IDLE);
        resolve();
      });
    };
    this.style = function () {
      return "\n        @font-face {\n            font-family: 'marscondensed-regular-TRIAL';\n            src: url('../fonts/marscondensed-regular-TRIAL.otf') format('opentype');\n            font-weight: 400;\n            font-style: bold;\n        }\n        @font-face {\n            font-family: 'FuturaLT-Bold';\n            src: url('../fonts/FuturaLT-Bold.ttf') format('truetype');\n            font-weight: 600;\n            font-style: normal;\n        }\n        @font-face {\n            font-family: 'FuturaLT-Medium';\n            src: url('../fonts/FuturaLT-Medium.ttf') format('truetype');\n            font-weight: 400;\n            font-style: normal;\n        }\n\n        #Stage, #Stage * {\n            .NewsPage {\n                overflow: hidden;\n            }\n            .NewsPageUI, {\n                width: 100%;\n                position: relative;\n                display: inline-block;\n                * {\n                    position: relative;\n                }\n            }\n            .NewsPageUI_Wrapper {\n                display: inline-block;\n                position: relative;\n                background-color: #161616;\n                &:before {\n                    content: '';\n                    position: absolute;\n                    top: 0;\n                    left: 0;\n                    width: 100%;\n                    height: 100%;\n                    background-image: url('../assets/images/textures/grains.png');\n                    background-size: contain;\n                    filter: brightness(4.75);\n                    transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 150ms;\n                }\n            }\n            .News {\n                position: relative;\n                width: 100%;\n            }\n            .News_Header {\n                font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                font-size: 12rem;\n                color: #E74833;\n                text-align: center;\n                margin: 5rem auto;\n                position: relative;\n                z-index: 0;\n                width: calc(66% + 20rem);\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 150ms;\n            }\n            .News_Article_Title_Header {\n                font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                font-size: 12rem;\n                color: #FDF0E1;\n                text-align: center;\n                text-transform: uppercase;\n                line-height: 10rem;\n                z-index: 2;\n                opacity: 0;\n                width: 80vw;\n                transform: translateY(-200%);\n                // margin: calc(2.5% + 1.25rem) auto 0;\n                // padding: calc(2.5% + 1.25rem) 0 0;\n                padding: 150px 0 0;\n                margin: 0 auto 4.5rem auto;\n                // background: url('../images/textures/grains_2.jpg');\n                background: url('../assets/images/textures/grains_2.jpg');\n                background-size: cover;\n                -webkit-background-clip: text;\n                background-clip: text;\n                color: transparent;\n                top: 0;\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            \n            .News_Article_Date_Header {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                text-align: center;\n                font-size: 1.4rem;\n                color: #FDF0E1;\n                text-transform: uppercase;\n                z-index: 2;\n                opacity: 0;\n                width: calc((100vw / 3) * 2 + 8rem);\n                transform: translateY(-200%);\n                margin: calc(2.5% + 2rem) auto 2rem;\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .News_Articles {\n                width: calc((100% / 3) * 2 + 10rem);\n                margin: auto;\n                position: relative;\n                display: flex;\n                flex-wrap: wrap;\n                justify-content: space-between;\n            }\n            .News_Article_Wrapper {\n                position: relative;\n                z-index: 0;\n                width: calc(((100vw / 3) * 2) / 2);\n                height: calc(((((100vw / 3) * 2) / 2 + 3rem) * 0.627) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                // height: calc((30rem + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                margin-bottom: 6rem;\n                transition: opacity 500ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 100ms;\n            }\n            .News_Article_Wrapper.News_Article_Featured {\n                // height: calc((60rem + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                height: calc(((((100vw / 3) * 2 + 10rem) * 0.627) + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                margin-bottom: 2.5rem;\n            }\n            .News_Article_Featured {\n                width: 100%;\n                .News_Article {\n                    width: 100%;\n                }\n                .News_Article_Content {\n                    width: 100%;\n                }\n                .News_Article_Img {\n                    // width: 100%;\n                    // height: 60rem;\n                    height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                    width: calc((100vw / 3) * 2 + 10rem);\n                    border-radius: 1.5rem;\n                }\n                .News_Article_Content_Wrapper {\n                    // top: 63rem;\n                    top: calc((((100vw / 3) * 2 + 10rem) * 0.627) + 3rem);\n                }\n            }\n            .News_Article {\n                position: relative;\n                display: flex;\n                flex-direction: column;\n                width: calc(((100vw / 3) * 2) / 2);\n                height: 100%;\n                cursor: pointer;\n                text-decoration: none;\n                &:hover {\n                    .News_Article_Img {\n                        // border: 2px solid #E74833;\n                        box-shadow: 0px 0px 0px 2px #E74833;\n                        filter: brightness(1) sepia(0) grayscale(0) contrast(1.0);\n                    }\n                    // .News_Article_Img_Thumb {\n                    //     opacity: 0;\n                    // }\n                }\n                &:focus {\n                    outline: auto;\n                    .News_Article_Img {\n                        filter: brightness(1.0) sepia(0.0) grayscale(0) contrast(1.0);\n                    }\n                }\n            }\n\n            .News_Article_Featured .News_Article_Img {\n                filter: brightness(0.85) sepia(0) grayscale(0) contrast(1.02);\n            }\n\n            \n            \n            .News_Article_Img {\n                position: absolute;\n                background-size: cover;\n                background-position: center;\n                background-repeat: no-repeat;\n                overflow: hidden;\n                // width: calc(((100vw / 3) * 2) / 2);\n                // height: 30rem;\n                width: calc(((100vw / 3) * 2) / 2);\n                height: calc((((100vw / 3) * 2) / 2) * 0.627);\n                // height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                // width: calc((100vw / 3) * 2 + 10rem);\n                border-radius: 1.2rem;\n                margin-bottom: 3rem;\n                // border: 2px solid #FDF0E1;\n                box-shadow: 0px 0px 0px 2px #FDF0E1;\n                filter: brightness(0.5) sepia(1.0) grayscale(0.30) contrast(1.25);\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000), filter 150ms ease-out;\n            }\n            .News_Article_Img_Thumb {\n                background-position: center;\n                background-size: cover;\n                background-repeat: no-repeat;\n                width: 100%;\n                height: 100%;\n                border-radius: 1.2rem;\n                display: flex;\n                opacity: 1;\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                // transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            } \n            .News_Article_Content_Wrapper {\n                width: 100%;\n                position: relative;\n                // top: 33rem;\n                top: calc(((((100vw / 3) * 2) / 2 + 3rem) * 0.627));\n            }\n            .News_Article_Content {\n                position: absolute;\n                width: calc(((100vw / 3) * 2) / 2);\n                opacity: 1;\n                transition: opacity 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            }\n            .News_Article_Title {\n                font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                font-size: 4rem;\n                line-height: 3.4rem;\n                color: #FDF0E1;\n                text-align: left;\n                text-transform: uppercase;\n                margin-bottom: 3rem;\n                display: -webkit-box;\n                -webkit-line-clamp: 3;\n                -webkit-box-orient: vertical;\n                overflow: hidden;\n                margin-top: 0;\n                text-overflow: ellipsis;\n                width: 100%;\n\n                @media screen and (max-width: 800px) {\n                    -webkit-line-clamp: 2;\n                }\n            }\n            .News_Article_Title.minHeight {\n                min-height: 10rem;\n            }\n            .News_Article_Date {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                font-size: 1.4rem;\n                color: #FDF0E1;\n                text-align: left;\n                // text-align: center;\n                width: 100%;\n                text-transform: uppercase;\n                height: 1.7rem;\n                margin-bottom: 2rem;\n                // opacity: 0;\n                // top: 66rem;\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000)\n            }\n            .News_Article_Date_Clone {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                font-size: 1.4rem;\n                color: #FDF0E1;\n                text-align: left;\n                text-align: center;\n                width: 100%;\n                text-transform: uppercase;\n                height: 1.7rem;\n                margin-bottom: 2rem;\n                opacity: 0;\n                top: 66rem;\n                transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000)\n            }\n            .News_Article_Line {\n                width: 100%;\n                height: 1px;\n                background-color: #E74833;\n            }\n            .News_Article_Line.fixedHeight {\n                position: absolute;\n                top: 17rem;\n            }\n            .News_Article_HTML {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                font-size: 1.8rem;\n                line-height: 2.4rem;\n                // font-size: 1.4rem;\n                // line-height: 2rem;\n                color: #FDF0E1;\n                position: relative;\n                top: 60rem;\n                left: 50%;\n                z-index: 2;\n                opacity: 0;\n                width: 50vw;\n                transform: translateX(-50%);\n                transition: all 500ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                iframe {\n                    padding: 5rem 0;\n                    margin: 0 auto;\n                    width: 100%;\n                }\n                ul {\n                    padding: 0 4rem;\n                }\n                blockquote {\n                    font-size: 4rem;\n                    font-family: \"marscondensed-regular-TRIAL\", sans-serif;\n                    line-height: 3.5rem;\n                    text-transform: uppercase;\n                    padding: 4rem 0;\n                    border-top: 1px #FDF0E1 solid;\n                    border-bottom: 1px #FDF0E1 solid;\n                    padding: 4rem 0;\n                    margin: 0 auto;\n                }\n                a {\n                    font-weight: bold;\n                    color: #FDF0E1 !important;\n                    text-decoration: none;\n                    border-bottom: 1px #E74833 solid;\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &:hover {\n                        opacity: 0.5;\n                    }\n                }\n                img {\n                    max-height: 40rem;\n                    max-width: 100%;\n                    padding: 4rem 0;\n                    margin: 0 auto;\n                    text-align: center;\n                    display: flex;\n                }\n            }\n            // .News_Article_Clone_Close {\n            //     width: 5rem;\n            //     height: 5rem;\n            //     margin: 0 auto;\n            //     display: flex;\n            //     justify-content: center;\n            //     align-items: center;\n            //     position: relative;\n            //     padding: calc(2.5% + 5rem) 0 0;\n            //     // padding: calc(2.5% + 10rem) 0 0;\n            //     opacity: 0;\n            //     transform: translateY(-10rem);\n            //     transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 100ms;\n            //     &__L1 {\n            //         height: 2px;\n            //         background-color: #FDF0E1;\n            //         width: 100%;\n            //         position: absolute;\n            //         top: 50%;\n            //         left: 50%;\n            //         transform-origin: left;\n            //         transform: rotate(45deg) translate(-50%, -50%);\n            //     }\n            //     &__L2 {\n            //         height: 2px;\n            //         background-color: #FDF0E1;\n            //         width: 100%;\n            //         position: absolute;\n            //         top: 50%;\n            //         left: 50%;\n            //         transform-origin: left;\n            //         transform: rotate(-45deg) translate(-50%, -50%);\n            //     }\n            // }\n            .NewsPageUI_Wrapper_ACTIVE {\n                &:before {\n                    opacity: 0;\n                }\n                // .News_Article_Clone_Close {\n                //     opacity: 1;\n                //     transform: translateY(0);\n                // }\n                .News_Header {\n                    opacity: 0;\n                    transform: translateY(125%);\n                    transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                }\n                .News_Article_ACTIVE {\n                    .News_Article_Img {\n                        visibility: hidden;\n                    }\n                }\n                .News_Article_Clone_Wrapper {\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    width: 100%;\n                    height: 100vh;\n                    .News_Article_Img {\n                        visibility: initial;\n                        transform: translateX(0%);\n                    }\n                }\n                .News_Article_Date_Header {\n                    opacity: 1;\n                    margin: calc(2.5% + 10rem) auto 2rem;\n                    transform: translateY(0%);\n                }\n                .News_Article_Title_Header {\n                    opacity: 1;\n                    transform: translateY(0%);\n                }\n                .News_Article_Img {\n                    // border: 2px solid #E74833 !important;\n                    box-shadow: 0px 0px 0px 2px #E74833 !important;;\n                    filter: brightness(1) sepia(0) grayscale(0) contrast(1.0) !important;\n                }\n                .News_Article_Img_Thumb {\n                    opacity: 0;\n                    // transition: initial;\n                }\n                // .News_Article_Date {\n                //     opacity: 1;\n                // }\n                .News_Article_Date_Clone {\n                    opacity: 1;\n                }\n                .News_Article_HTML {\n                    opacity: 1;\n                    top: 70.8rem;\n                    transition: all 1000ms cubic-bezier(0.455, 0.030, 0.515, 0.955);\n                }\n                // .News_Article_Icon_Wrapper {\n                //     visibility: initial;\n                // }\n                // .News_Article_Icon {\n                //     opacity: 1;\n                // }\n            }\n            .News_Article_HIDE {\n                opacity: 0;\n                transition: opacity 500ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 0ms;\n            }\n            .News_Article_Clone {\n                position: relative;\n                // top: 150px;\n                width: 100%;\n            }\n            .News_Article_Clone_ACTIVE {\n                .News_Article_Img {\n                    transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000), width 1000ms cubic-bezier(0.455, 0.030, 0.515, 0.955);\n                }\n            }\n            .News_Article_Clone_ACTIVE_V2 {\n                .News_Article_Img {\n                    // height: 60rem;\n                    height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                    // width: calc((100vw / 3) * 2 + 10rem);\n                    width: calc((100vw / 3) * 2 + 10rem) !important;\n                    left: calc(50% - ((100vw / 3) * 2 + 10rem) / 2) !important;\n                    transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000), width 1000ms cubic-bezier(0.455, 0.030, 0.515, 0.955), height 0ms;\n                }\n            }\n            .News_Article_Clone_ANIMATE_ACTIVE {\n                // height: 60rem !important;\n                height: calc(((100vw / 3) * 2 + 10rem) * 0.627) !important;\n                top: 0 !important;\n                left: 50% !important;\n                width: calc((100% / 3) * 2 + 10rem) !important;\n                margin: -2rem auto 10rem;\n                transform: translateX(-50%) !important;\n            }\n            .News_Article_Clone_ANIMATE_ACTIVE_V2 {\n                top: 0 !important;\n                margin: -2rem auto 10rem;\n            }\n            // .News_Article_Icon_Wrapper {\n            //     width: calc((100% / 3) * 2 + 10rem);\n            //     margin: 0 auto;\n            //     visibility: hidden;\n            //     z-index: 1;\n            // }\n            // .News_Article_Icon {\n            //     opacity: 0;\n            //     width: 20rem;\n            //     height: 20rem;\n            //     background-image: url('../images/icons/cta-scroll.svg');\n            //     position: absolute;\n            //     right: -17rem;\n            //     top: 42rem;\n            //     transition: all 700ms cubic-bezier(0.455, 0.03, 0.515, 0.955) 300ms;\n            // }\n\n            .NewsPage_ACTIVE {\n                overflow: initial !important;\n                .News_Article_Clone {\n                    background-color: #161616;\n                }\n            }\n            \n            @media screen and (max-width: 960px) {\n                .News_Article_Title_Header {\n                    font-size: 8rem;\n                    line-height: 7rem;\n                }\n            }\n\n            @media screen and (max-width: 600px) {\n                .News_Article_Clone {\n                    top: 100px;\n                }\n                .News_Header {\n                    font-size: 6rem;\n                    width: 100%;\n                    margin: 10rem 0 5rem;\n                }\n                .NewsPageUI_Wrapper {\n                    width: 100%;\n                }\n                .News_Articles {\n                    width: calc(100% - 5rem);\n                }\n                .News_Article_Wrapper {\n                    width: 100%;\n                    height: calc((20rem + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                }\n                .News_Article {\n                    width: 100%;\n                }\n                .News_Article_Wrapper.News_Article_Featured {\n                    height: calc((20rem + 3rem) + (10.3rem + 3rem) + (1.7rem + 2rem) + (1.4rem + 1rem));\n                }\n                .News_Article_Featured {\n                    .News_Article_Img {\n                        // height: 20rem;\n                        width: calc(100vw - 5rem);\n                        height: calc((100vw - 5rem) * 0.627);\n                    }\n                    .News_Article_Content_Wrapper {\n                        top: 23rem;\n                    }\n                }\n                .News_Article_Content_Wrapper {\n                    top: 23rem;\n                }\n                .News_Article_Img {\n                    // width: 100%;\n                    // height: 20rem;\n                    // width: calc(100vw - 5rem);\n                    height: calc((100vw - 5rem) * 0.627);\n                    width: calc(100vw - 5rem) !important;\n                    left: calc(50% - (100vw - 5rem) / 2) !important;\n                }\n                .News_Article_Content {\n                    width: 100%;\n                }\n                .News_Article_Title_Header {\n                    font-size: 6rem;\n                    line-height: 5rem;\n                    padding: 0;\n                }\n                // .News_Article_Clone_Close {\n                //     visibility: hidden;\n                // }\n                .News_Article_Clone_ANIMATE_ACTIVE_V2.News_Article_Img {\n                    // height: 20rem ;\n                    // height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                    height: calc((100vw - 5rem)*.627);\n                    // width: calc((100vw / 3) * 2 + 10rem);\n                    // width: calc(100% - 5rem)!important;\n                    width: calc(100vw - 5rem) !important;\n                    left: calc(50% - (100vw - 5rem) / 2) !important;\n                    transition: all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000), width 0ms, height 0ms, left 0ms,;\n                }\n                .News_Article_Clone_ANIMATE_ACTIVE {\n                    height: 20rem !important;\n                    top: 0 !important;\n                    left: 50% !important;\n                    width: calc(100% - 5rem)!important;\n                    transform: translateX(-50%) !important;\n                }\n                // .News_Article_Date {\n                //     top: 35rem;\n                // }\n                .News_Article_HTML {\n                    // top: 5rem;\n                    top: 40rem;\n                }\n                .NewsPageUI_Wrapper_ACTIVE {\n                    // .News_Article_Date {\n                    //     // top: 25rem;\n                    //     top: calc(((100vw / 3) * 2 + 10rem) * 0.627 + 5rem);\n                    // }\n                    .News_Article_Date_Clone {\n                        // top: 25rem;\n                        top: calc(((100vw / 3) * 2 + 10rem) * 0.627 + 5rem);\n                    }\n                    .News_Article_HTML {\n                        position: relative;\n                        // top: 0rem;\n                        // top: 30rem;\n                        top: calc(((100vw / 3) * 2 + 10rem) * 0.627 + 10rem);\n                        // padding: 25rem 0 20rem;\n                        width: calc(100% - 5rem);\n                        transition: all 1000ms cubic-bezier(0.455, 0.03, 0.515, 0.955), width 0ms;\n                    }\n                    .News_Article_Clone_Wrapper {\n                        top: 0 !important;\n                    }\n                    // .News_Article_Icon_Wrapper {\n                    //     visibility: hidden;\n                    // }\n                }\n            }            \n        }        \n        ";
    };
    this.render = function (html) {
      return html`
              <div class="NewsPageUI_Wrapper">
                  <h1 class="News_Header">NEWS</h1>
                  <div class="News_Articles">
                      ${CMS.get("news").sort((a, b) => b._order - a._order).map((item, index) => html`
                      <div id="${item.slug}" class="News_Article_Wrapper ${index == 0 ? "News_Article_Featured" : ""}" @click="${openArticle.bind(_this, item)}">
                          <a href="javascript:;" title="${item.title}" class="News_Article" >
                              <div class="News_Article_Img" style="background-image: url(${item.heroImage})">
                                  <div class="News_Article_Img_Thumb" style="display: ${item.thumbnailImage ? index == 0 ? "none" : "flex" : "none"}; background-image: url(${item.thumbnailImage ? index == 0 ? "" : item.thumbnailImage : ""})"></div>
                              </div>
                              <div class="News_Article_Content_Wrapper">
                                  <div class="News_Article_Content">
                                      <h2 class="News_Article_Title minHeight">${item.title}</h2>
                                      <div class="News_Article_Date">${item.date}</div>
                                      <div class="News_Article_Line"></div>
                                  </div>
                              </div>
                          </a>
                      </div>
                      `)}
                  </div>
                  
                  <div class="News_Article_Clone_Wrapper">
                      <div class="News_Article_Clone">
                          <!-- <div class="News_Article_Clone_Close">
                              <div class="News_Article_Clone_Close__L1"></div>
                              <div class="News_Article_Clone_Close__L2"></div>
                          </div> -->
                          <h1 class="News_Article_Title_Header"></h1>
                          <!-- <div class="News_Article_Icon_Wrapper">
                              <div class="News_Article_Icon"></div>
                          </div> -->
                          <div class="News_Article_Img_Wrapper"></div>
                          <div class="News_Article_Date_Clone"></div>
                          <div class="News_Article_HTML"></div>
                      </div>
                  </div>                
                  
              </div>
          `;
    };
    this.postRender = async function () {
      await _this.querySelector(".NewsPage");
      $newsPageUIWrapper = await _this.querySelector(".NewsPageUI_Wrapper");
      $newsArticleCloneWrapper = await _this.querySelector(".News_Article_Clone_Wrapper");
      await _this.querySelector(".News_Article_Clone");
      $newsArticleImgWrapper = await _this.querySelector(".News_Article_Img_Wrapper");
      $newsArticleTitleHeader = await _this.querySelector(".News_Article_Title_Header");
      await _this.querySelector(".News_Article_Date");
      $newsArticleDateClone = await _this.querySelector(".News_Article_Date_Clone");
      $newsArticleHTML = await _this.querySelector(".News_Article_HTML");
      $newsArticles = await _this.querySelectorAll(".News_Article_Wrapper");
      _this.flag("postRendered", true);
    };
  });
  Class(function NewsPageUIv2() {
    Inherit(this, InteractiveUI);
    Inherit(this, ViewState, NewsArticleItem);
    const _this = this;
    const $this = _this.element;
    var $container;
    var $header;
    _this.config = Config.NEWS;
    (async function initHTML() {
      $container = $this.create("NewsPageUIv2_Container");
      ($header = $container.create("NewsPageUIv2_Header", "h6")).text(_this.config.header);
      await CMS.ready();
      let cmsNews = CMS.get("news");
      console.log(cmsNews);
      let data = new StateArray(cmsNews);
      _this.setSourceData(data);
      Dev.expose("data", data);
    })();
    (function initStyles() {
      $this.css({
        position: "relative",
        height: "100vh",
        width: "100vw"
      });
      $container.css({
        position: "absolute",
        width: "100vw",
        height: "fit-content"
      });
      $header.css({
        fontFamily: "'marscondensed-regular-TRIAL', sans-serif",
        fontSize: "12rem",
        color: "#66B4AD",
        textAlign: "center",
        textTransform: "uppercase",
        margin: "5rem auto",
        position: "relative",
        zIndex: "0",
        width: "calc(66% + 20rem)",
        transition: "all 1000ms cubic-bezier(0.190, 1.000, 0.220, 1.000) 150ms"
      });
    })();
    if (_this.isPlayground()) {
      Container.instance().element.add($this);
    }
    _this.animateIn = function (delay = 300) {
      console.log("NewsPageUIv2 animateIn");
    };
    _this.animateOut = async function () {
      console.log("NewsPageUIv2 animateOut");
    };
    this.onAddView = function (instance, index) {
      _this.element.add(instance);
    };
    this.onRemoveView = function (instance, index) {
      instance.element.remove();
    };
  });
  Class(function TestPageUI() {
    Inherit(this, InteractiveUI);
    const $this = this.element;
    (function initHTML() {
      $this.size("100%", "100vh");
      $this.css({});
    })();
  });
  Class(function NewsDetailPage(isFirst = false) {
    Inherit(this, InteractivePage, "newsDetail", isFirst);
    const _this = this;
    (async function () {
      await _this.ready();
    })();
    _this.hide = function () {
      return new Promise(async resolve => {
        this.views.forEach(async view => {
          await view.hide();
        });
        _this._hide();
        resolve();
      });
    };
  });
  Class(function NewsDetailUI() {
    Inherit(this, InteractiveUI);
    Inherit(this, DOMTemplate);
    const _this = this;
    const $this = _this.element;
    var _hash;
    var _activeArticle;
    var $newsDetailTitle;
    var $newsDetailDate;
    var $newsDetailImg;
    var $newsDetailHTML;
    var _news;
    var _currentNewsIndex;
    async function loadArticle({
      item: item
    }) {
      _this.flag("fromNewsPageIU", true);
      _hash = item.slug;
      _activeArticle = await CMS.fetchNewsPage(_hash);
      _news.forEach(async (article, index) => {
        if (article.date == _activeArticle.date) {
          _currentNewsIndex = index;
        }
      });
      $this.css({
        opacity: 0
      });
      $newsDetailTitle.div.innerHTML = _activeArticle.title;
      $newsDetailDate.div.innerHTML = _activeArticle.date;
      $newsDetailImg.div.style.backgroundImage = "url('" + _activeArticle.heroImage + "')";
      $newsDetailHTML.div.innerHTML = _activeArticle.body;
      _this.events.fire(NavigationHeader.CLOSE_SHOW);
      _this.flag("closeActive", true);
    }
    async function onPrevClick() {
      _this.flag("fromNewsPageIU", false);
      await _this.wait("postRendered");
      _this.flag("fromNewsNav", true);
      await _this.preAnimateOut();
      if (_currentNewsIndex == 0) {
        ViewController.instance().changeRoute("news/" + _news[_news.length - 1].slug);
      } else {
        ViewController.instance().changeRoute("news/" + _news[_currentNewsIndex - 1].slug);
      }
    }
    async function onNextClick() {
      _this.flag("fromNewsPageIU", false);
      await _this.wait("postRendered");
      _this.flag("fromNewsNav", true);
      await _this.preAnimateOut();
      if (_currentNewsIndex == _news.length - 1) {
        ViewController.instance().changeRoute("news/" + _news[0].slug);
      } else {
        ViewController.instance().changeRoute("news/" + _news[_currentNewsIndex + 1].slug);
      }
    }
    (async function () {
      _this.flag("animateIn", false);
      (async function init() {
        _news = await CMS.get("news");
        _this.flag("isIdle", true);
      })();
      (function addHandlers() {
        _this.events.sub(NewsController.LOAD_ARTICLE, loadArticle);
      })();
    })();
    _this.animateIn = async function (delay = 300) {
      return new Promise(async resolve => {
        await _this.wait("postRendered");
        if (_this.flag("fromNewsPageIU")) {
          $this.css({
            opacity: 1
          });
          if (!_this.flag("closeActive")) {
            if (_hash != null) {
              _this.events.fire(NavigationHeader.CLOSE_SHOW);
            }
            _this.flag("closeActive", true);
          }
        } else {
          await _this.wait("isIdle");
          _this.flag("isIdle", false);
          $this.css({
            opacity: 0
          });
          _hash = ViewController.instance().currentRoute.params.id;
          _activeArticle = await CMS.fetchNewsPage(_hash);
          _news.forEach(async (article, index) => {
            if (article.date == _activeArticle.date) {
              _currentNewsIndex = index;
            }
          });
          $newsDetailTitle.div.innerHTML = _activeArticle.title;
          $newsDetailDate.div.innerHTML = _activeArticle.date;
          $newsDetailImg.div.style.backgroundImage = "url('" + _activeArticle.heroImage + "')";
          $newsDetailHTML.div.innerHTML = _activeArticle.body;
          if (_this.flag("fromNewsNav")) {
            _this.flag("fromNewsNav", false);
          } else {
            if (_hash != null) {
              _this.events.fire(NavigationHeader.CLOSE_SHOW);
            }
            _this.flag("closeActive", true);
          }
          await $this.tween({
            opacity: 1
          }, 1000, "easeOutCubic").promise();
        }
        await defer();
        (function wrapIframes() {
          let iframes = $newsDetailHTML.div.querySelectorAll("iframe");
          for (let i = 0; i < iframes.length; i++) {
            const el = iframes[i];
            let wrapper = document.createElement("div");
            wrapper.className = "iframe-wrapper";
            el.parentNode.style.padding = 0;
            el.parentNode.insertBefore(wrapper, el);
            wrapper.appendChild(el);
          }
        })();
        if (Device.mobile) {
          Stage.div.scrollTop = 0;
        }
        if (_activeArticle) {
          ViewController.instance().setTitle("Prometheus Fuels - " + _activeArticle.title);
        }
        _this.parent?.smooth.resize();
        _this.flag("isIdle", true);
        resolve();
      });
    };
    this.animateOut = async function () {
      return new Promise(async resolve => {
        if (!_this.flag("fromNewsNav")) {
          $this.tween({
            opacity: 0
          }, 300, "easeOutCubic");
          _this.events.fire(NavigationHeader.CLOSE_HIDE);
          _this.flag("closeActive", false);
        }
        resolve();
      });
    };
    _this.preAnimateOut = async function (delay = 1000) {
      _this.flag("isIdle", false);
      return new Promise(async resolve => {
        await $this.tween({
          opacity: 0
        }, 400, "easeOutCubic", 0).promise();
        _this.flag("isIdle", true);
        resolve();
      });
    };
    this.style = function () {
      return "\n        @font-face {\n            font-family: 'marscondensed-regular-TRIAL';\n            src: url('../fonts/marscondensed-regular-TRIAL.otf') format('opentype');\n            font-weight: 400;\n            font-style: bold;\n        }\n        @font-face {\n            font-family: 'FuturaLT-Bold';\n            src: url('../fonts/FuturaLT-Bold.ttf') format('truetype');\n            font-weight: 600;\n            font-style: normal;\n        }\n        @font-face {\n            font-family: 'FuturaLT-Medium';\n            src: url('../fonts/FuturaLT-Medium.ttf') format('truetype');\n            font-weight: 400;\n            font-style: normal;\n        }\n\n        #Stage, #Stage * {\n            .NewsDetailUI, {\n                width: 100%;\n                position: relative;\n                background-color: #161616;\n                * {\n                    position: relative;\n                    user-select: text;\n                }\n            }\n            .NewsDetailUI {\n                display: block;\n            }\n            .NewsDetailUI_Wrapper {\n                width: 100%;\n                display: block;\n                &:before {\n                    content: '';\n                    position: absolute;\n                    top: 0;\n                    left: 0;\n                    width: 100%;\n                    height: 100%;\n                    background-image: url('../assets/images/textures/grains.png');\n                    background-repeat-y: repeat;\n                    filter: brightness(2.75);\n                    opacity: 0;\n                    animation: GRAINS 1s linear 1 normal forwards;\n                }\n            }\n            @keyframes GRAINS {\n                0%   {opacity: 0}\n                50% {opacity: 1}\n                100% {opacity: 1}\n            }\n            // .News_Detail_Close_Wrapper {\n            //     padding: calc(2.5% + 0.7rem) 0 4.3rem;\n            //     margin: 0 auto;\n            //     display: flex;\n            //     justify-content: center;\n            //     align-items: center;\n            //     width: 5rem;\n            // }\n            // .News_Detail_Close {\n            //     width: 5rem;\n            //     height: 5rem;\n            //     position: relative;\n            //     transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            //     text-decoration: none;\n            //     &__L1 {\n            //         height: 2px;\n            //         background-color: #FDF0E1;\n            //         width: 100%;\n            //         position: absolute;\n            //         top: 50%;\n            //         left: 50%;\n            //         transform-origin: left;\n            //         transform: rotate(45deg) translate(-50%, -50%);\n            //         transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            //     }\n            //     &__L2 {\n            //         height: 2px;\n            //         background-color: #FDF0E1;\n            //         width: 100%;\n            //         position: absolute;\n            //         top: 50%;\n            //         left: 50%;\n            //         transform-origin: left;\n            //         transform: rotate(-45deg) translate(-50%, -50%);\n            //         transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n            //     }\n            //     &:hover {\n            //         cursor: pointer;\n            //         opacity: 0.5;\n            //         transform: scale(0.8);\n            //     }\n            //     &:focus {\n            //         cursor: pointer;\n            //         opacity: 0.5;\n            //         transform: scale(0.8);\n            //         outline: auto;\n            //     }\n                \n            // }\n            .News_Detail_Title {\n                font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                font-size: 12rem;\n                color: transparent;\n                text-align: center;\n                text-transform: uppercase;\n                line-height: 10rem;\n                // padding: calc(2.5% + 1.25rem) 0 0;\n                padding: 150px 0 0;\n                // padding: 9.6% 0 0;\n                margin: 0 auto 0;\n                z-index: 1;\n                width: 80vw;\n                // background: url('../images/textures/grains_2.jpg');\n                background: url('../assets/images/textures/grains_2.jpg');\n                background-size: cover;\n                -webkit-background-clip: text;\n                background-clip: text;\n            }\n            .News_Detail_Img {\n                background-size: cover;\n                background-position: center;\n                background-repeat: no-repeat;\n                height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                width: calc((100vw / 3) * 2 + 10rem);\n                // height: 60rem;\n                // width: calc((100% / 3) * 2 + 10rem);\n                margin: 0 auto;\n                border-radius: 1.2rem;\n                // border: 2px solid #E74833;\n                box-shadow: 0px 0px 0px 2px #E74833;\n                position: relative;\n                margin-top: 3rem;\n            }\n            // .News_Detail_Icon {\n            //     width: 20rem;\n            //     height: 20rem;\n            //     background-image: url('../images/icons/cta-scroll.svg');\n            //     position: absolute;\n            //     right: -17rem;\n            //     bottom: -4rem;\n            // }\n            .News_Detail_Date {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                text-align: center;\n                font-size: 1.4rem;\n                color: #FDF0E1;\n                text-transform: uppercase;\n                position: relative;\n                padding: 6rem 0 3rem;\n                width: 100%;\n            }\n            .News_Detail_HTML {\n                font-family: 'FuturaLT-Medium', sans-serif;\n                // font-size: 1.4rem;\n                // line-height: 2rem;\n                font-size: 1.8rem;\n                line-height: 2.4rem;\n                color: #FDF0E1;\n                width: 50vw;\n                padding: 0 0 20rem;\n                margin: 0 auto 0;\n                .iframe-wrapper{\n                    width: 100%;\n                    padding-bottom: 56.25%;\n                    margin: 5rem 0;\n                }\n                iframe {\n                    position: absolute;\n                    padding: 0;\n                    margin: 0 auto;\n                    width: 100%;\n                    height: 100%;\n                }\n                ul {\n                    padding: 0 4rem;\n                    margin: 0;\n                }\n                blockquote {\n                    font-size: 4rem;\n                    font-family: \"marscondensed-regular-TRIAL\", sans-serif;\n                    line-height: 3.5rem;\n                    text-transform: uppercase;\n                    padding: 4rem 0;\n                    border-top: 1px #FDF0E1 solid;\n                    border-bottom: 1px #FDF0E1 solid;\n                    padding: 4rem 0;\n                    margin: 0 auto;\n                }\n                a {\n                    font-weight: bold;\n                    color: #FDF0E1 !important;\n                    text-decoration: none;\n                    border-bottom: 1px #E74833 solid;\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &:hover {\n                        opacity: 0.5;\n                    }\n                    &:focus {\n                        outline: auto;\n                    }\n                }\n                img {\n                    // max-height: 40rem;\n                    // max-width: 100%;\n                    width: 100%;\n                    padding: 0;\n                    margin: 0 auto;\n                    text-align: center;\n                    display: flex;\n                }\n                p {\n                    padding: 0;\n                    margin: 0;\n                }\n                .ql-size-small {\n                    font-size: 1.2rem !important;\n                    line-height: 1.6rem !important;\n                }\n            }\n            .News_Detail_Nav {\n                display: flex;\n                justify-content: space-between;\n                width: 80vw;\n                margin: auto;\n                padding-bottom: 5rem;\n            }\n            .News_Detail_Nav_Prev {\n                cursor: pointer;\n                display: flex;\n                align-items: center;\n                justify-content: flex-start;\n                width: 18rem;\n                text-decoration: none;\n                &__Arrow {\n                    width: 3rem;\n                    height: 3rem;\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &__L1 {\n                        transform-origin: left;\n                        position: absolute;\n                        transform: rotate(-45deg);\n                        top: 50%;\n                        width: 2rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                    &__L2 {\n                        position: absolute;\n                        top: 50%;\n                        width: 3rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                    &__L3 {\n                        position: absolute;\n                        top: 50%;\n                        transform-origin: left;\n                        transform: rotate(45deg);\n                        width: 2rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                }\n                &__Text {\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &:after {\n                        content: 'PREV ARTICLE';\n                        font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                        font-size: 3rem;\n                        color: #E74833;\n                        margin-left: 2rem;\n                    }\n                }\n                &:hover {\n                    .News_Detail_Nav_Prev__Arrow {\n                        transform: translateX(-50%);\n                    }\n                    .News_Detail_Nav_Prev__Text {\n                        opacity: 0.5;\n                        transform: translateX(-20%);\n                    }\n                }\n                &:focus {\n                    .News_Detail_Nav_Prev__Arrow {\n                        transform: translateX(-50%);\n                    }\n                    .News_Detail_Nav_Prev__Text {\n                        opacity: 0.5;\n                        transform: translateX(-20%);\n                    }\n                }\n            }\n            .News_Detail_Nav_Next {\n                cursor: pointer;\n                display: flex;\n                align-items: center;\n                justify-content: flex-end;\n                width: 18rem;\n                text-decoration: none;\n                &__Arrow {\n                    width: 3rem;\n                    height: 3rem;\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &__L1 {\n                        transform-origin: right;\n                        position: absolute;\n                        transform: rotate(-45deg);\n                        top: 50%;\n                        right: 0;\n                        width: 2rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                    &__L2 {\n                        position: absolute;\n                        top: 50%;\n                        width: 3rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                    &__L3 {\n                        position: absolute;\n                        top: 50%;\n                        right: 0;\n                        transform-origin: right;\n                        transform: rotate(45deg);\n                        width: 2rem;\n                        height: 1px;\n                        background: #E74833;\n                    }\n                }\n                &__Text {\n                    transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                    &:after {\n                        content: 'NEXT ARTICLE';\n                        font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                        font-size: 3rem;\n                        color: #E74833;\n                        margin-right: 2rem;\n                    }\n                }\n                &:hover {\n                    .News_Detail_Nav_Next__Text {\n                        opacity: 0.5;\n                        transform: translateX(20%);\n                    }\n                    .News_Detail_Nav_Next__Arrow {\n                        transform: translateX(50%);\n                    }\n                }\n                &:focus {\n                    .News_Detail_Nav_Next__Text {\n                        opacity: 0.5;\n                        transform: translateX(20%);\n                    }\n                    .News_Detail_Nav_Next__Arrow {\n                        transform: translateX(50%);\n                    }\n                }\n            }\n            @media screen and (max-width: 960px) {\n                .News_Detail_Title {\n                    font-size: 8rem;\n                    line-height: 7rem;\n                }\n            }\n            @media screen and (max-width: 600px) {\n                .NewsDetailUI_Wrapper {\n                    width: calc(100% - 5rem);\n                    margin: auto;\n                }\n                .News_Detail_Title {\n                    font-size: 6rem;\n                    line-height: 5rem;\n                    // padding: calc(2.5% + 2rem) 0 0;\n                    padding: 100px 0 0;\n                }\n                .News_Detail_Date {\n                    width: 100%;\n                    // padding: 5rem 0 0;\n                    // padding: 4.6rem 0 0;\n                    padding: 6.5rem 0 0;\n                }\n                .News_Detail_Img {\n                    // height: 20rem;\n                    // height: calc(((100vw / 3) * 2 + 10rem) * 0.627);\n                    height: calc((100vw - 5rem)*.627);\n                    width: 100%;\n                }\n                .News_Detail_HTML {\n                    width: 100%;\n                    // padding: 5rem 0 20rem;\n                    padding: 5.3rem 0 20rem;\n                    // padding: 5.1rem 0 20rem; \n                }\n                // .News_Detail_Icon {\n                //     display: none;\n                // }\n                // .News_Detail_Close_Wrapper {\n                //     padding: 0;\n                // }\n                // .News_Detail_Close {\n                //     visibility: hidden;\n                //     padding: calc(2.5% + 10.2rem) 0 0;\n                // }\n                .News_Detail_Nav_Prev {\n                    &__Text {\n                        &:after {\n                            content: 'PREV';\n                        }\n                    }\n                }\n                .News_Detail_Nav_Next {\n                    &__Text {\n                        &:after {\n                            content: 'NEXT';\n                        }\n                    }\n                }\n            }\n        }        \n        ";
    };
    this.render = function (html) {
      return html`
              <div class="NewsDetailUI_Wrapper">
                  <h1 class="News_Detail_Title"></h1>
                  <div class="News_Detail_Img">
                      <!-- <div class="News_Detail_Icon"></div> -->
                  </div>
                  <div class="News_Detail_Date"></div>
                  <div class="News_Detail_HTML"></div>    
                  <div class="News_Detail_Nav">
                      <a href="javascript:;" title="Previous article" class="News_Detail_Nav_Prev" @click="${onPrevClick}">
                          <div class="News_Detail_Nav_Prev__Arrow">
                              <div class="News_Detail_Nav_Prev__Arrow__L1"></div>
                              <div class="News_Detail_Nav_Prev__Arrow__L2"></div>
                              <div class="News_Detail_Nav_Prev__Arrow__L3"></div>
                          </div>
                          <div class="News_Detail_Nav_Prev__Text"></div>
                      </a>
                      <a href="javascript:;" title="Next article" class="News_Detail_Nav_Next" @click="${onNextClick}">
                          <div class="News_Detail_Nav_Next__Text"></div>
                          <div class="News_Detail_Nav_Next__Arrow">
                              <div class="News_Detail_Nav_Next__Arrow__L1"></div>
                              <div class="News_Detail_Nav_Next__Arrow__L2"></div>
                              <div class="News_Detail_Nav_Next__Arrow__L3"></div>
                          </div>
                      </a>
                  </div>
              </div>
          `;
    };
    this.postRender = async function () {
      await _this.querySelector(".NewsDetailUI_Wrapper");
      $newsDetailDate = await _this.querySelector(".News_Detail_Date");
      $newsDetailTitle = await _this.querySelector(".News_Detail_Title");
      $newsDetailImg = await _this.querySelector(".News_Detail_Img");
      $newsDetailHTML = await _this.querySelector(".News_Detail_HTML");
      _this.flag("postRendered", true);
    };
  });
  Class(function SceneParticles() {
    Inherit(this, Object3D);
    const _this = this;
    var _particles;
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "scene-particles");
      _particles = await _this.layout.getLayer("particles");
      await _particles.ready();
      _this.flag("isReady", true);
    })();
    _this.set("previousFrame", async frame => {
      await _this.wait("isReady");
      _particles.shader.set("uPrevFrame", frame);
    });
  });
  Class(function PartnersHero() {
    Inherit(this, FXScene);
    const _this = this;
    var _resizeDebounced;
    var _imgTexturePortrait;
    var _imgTextureLandscape;
    function resizeHandler() {
      clearTimeout(_resizeDebounced);
      _resizeDebounced = _this.delayedCall(() => {
        (async function resize() {
          let image = _this.layers.image;
          let camera = _this.layers.camera;
          if (Stage.width < Stage.height) {
            _this.layers.text.setPropertiesCheck({
              size: 0.5
            });
            _this.layers.text.group.position.x = 0;
            _this.layers.text.group.position.y = -0.3;
            image.shader.addUniforms({
              tMap: {
                value: _imgTexturePortrait
              },
              uScale2: {
                value: new Vector2(1.03, 1.03)
              },
              uTranslate: {
                value: new Vector2(0, -0.06)
              }
            });
          } else {
            _this.layers.text.setPropertiesCheck({
              size: 1.2
            });
            _this.layers.text.group.position.x = -0.25;
            _this.layers.text.group.position.y = 1.103;
            image.shader.addUniforms({
              tMap: {
                value: _imgTextureLandscape
              },
              uScale2: {
                value: new Vector2(1, 1)
              },
              uTranslate: {
                value: new Vector2(0, 0)
              }
            });
          }
          await image.shader.uniforms.tMap.value.promise;
          let imageDimensions = image.shader.uniforms.tMap.value.dimensions;
          let imageRatio = imageDimensions.width / imageDimensions.height;
          let screenHeight = Utils3D.getHeightFromCamera(camera, camera.position.z - image.position.z);
          let screenWidth = Utils3D.getWidthFromCamera(camera, camera.position.z - image.position.z);
          let scale = screenWidth / screenHeight < imageRatio ? screenHeight : screenWidth * (1 / imageRatio);
          image.scale.x = imageRatio;
          image.scale.y = 1;
          image.scale.z = 1;
          image.scale.multiplyScalar(scale);
        })();
      }, 300);
    }
    (async function () {
      _this.create(_this.parent?.parent?.nuke);
      _this.layout = _this.initClass(SceneLayout, "PartnersHero");
      _this.layers = await _this.layout.getAllLayers();
      _imgTextureLandscape = Utils3D.getTexture("assets/images/partners/partners-hero.jpg");
      _imgTexturePortrait = Utils3D.getTexture("assets/images/partners/partners-hero-mobile.jpg");
      _this.layers.text.renderOrder += 100;
      _this.layers.image.renderOrder = -1;
      (async function initCamera() {
        let camera = _this.layers.camera;
        _this.useCamera(camera);
        if (_this.parent.getLayer) {
          let parentCamera = await _this.parent.getLayer("camera");
          _this.startRender(_ => {
            camera.group.position.y = parentCamera.group.position.y * -0.2;
            camera.group.position.z = parentCamera.group.position.y * -0.4;
            camera.lookAt.y = -parentCamera.group.position.y * 0.7;
          });
        }
      })();
      (function addHandlers() {
        _this.onResize(resizeHandler);
      })();
      _this.scene.add(_this.layout.group);
      _this.animateIn();
    })();
    _this.animateIn = async function () {
      await _this.layers.text.ready();
      if (_this.layers.text.shaderClass && _this.layers.text.shaderClass.animateIn) {
        _this.layers.text.shaderClass.reset();
        _this.layers.text.shaderClass.animateIn(ViewController.instance().isVisible ? 800 : 1500);
      } else if (_this.layers.text.shader.shaderClass && _this.layers.text.shader.shaderClass.animateIn) {
        _this.layers.text.shader.shaderClass.reset();
        _this.layers.text.shader.shaderClass.animateIn(ViewController.instance().isVisible ? 800 : 1500);
      } else {
        console.warn("Text missing WaveTextShader shader class");
      }
      let z = _this.layers.camera.position.z;
      _this.layers.camera.position.z += 2.5;
      tween(_this.layers.camera.position, {
        z: z
      }, 3000, "easeOutCubic");
    };
    _this.animateOut = async function () {
      await _this.layers.text.ready();
    };
  });
  Class(function PartnersHeroBGShader(_mesh, _shader) {
    Inherit(this, Component);
    (async function () {
      _shader.addUniforms({
        tMap: {
          value: null
        },
        uScale2: {
          value: new Vector2(1, 1)
        },
        uTranslate: {
          value: new Vector2(0, 0)
        }
      });
    })();
  });
  Class(function PartnersHeroLayer(_mesh, _shader) {
    Inherit(this, Component);
    const _this = this;
    var _heroScene;
    function resizeHandler() {
      let aspect = Stage.width / Stage.height;
      _mesh.scale.x = aspect * _mesh.scale.y;
      if (Stage.width < Stage.height) {
        _mesh.position.y = 1;
      } else {
        _mesh.position.y = 0;
      }
    }
    (async function () {
      _heroScene = await _this.parent.getLayer("heroSection");
      (function initShaderRT() {
        _shader.set("tMap", _heroScene);
      })();
      (function addHandlers() {
        _mesh.scale.x;
        _mesh.scale.y;
        _this.onResize(resizeHandler);
      })();
    })();
  });
  Class(function PartnersHeroLayerShader(_mesh, _shader) {
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uAngle: {
        value: 0
      }
    });
    _mesh.renderOrder = 999;
  });
  Class(function PartnersLine(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    async function resize() {
      let image = _mesh;
      let camera = _this.parent.layers.camera.baseCamera.camera;
      let screenHeight = Utils3D.getHeightFromCamera(camera, camera.position.z - image.position.z);
      let screenWidth = Utils3D.getWidthFromCamera(camera, camera.position.z - image.position.z);
      image.scale.x = 0.2;
      image.scale.y = screenHeight * 3;
      image.scale.z = 1;
      let pos = _input.get("wildcard");
      let x = Math.range(["left", "center", "right"].indexOf(pos), 0, 2, -screenWidth * 1.15, screenWidth * 1.15);
      image.position.x = x;
    }
    _shader.addUniforms({
      tMap: {
        value: Utils3D.getTexture("assets/images/partners/lines.png")
      },
      uScale: {
        value: new Vector2(1, 1)
      },
      transparent: true
    });
    _this.onResize(resize);
  });
  Class(function PartnersLogoSection() {
    Inherit(this, Object3D);
    const _this = this;
    var _cameraUnits;
    var _resizeDebounced;
    var _hit;
    var _parent;
    var _size = Device.mobile ? 2 : 2.25;
    var _gridColumns = Device.mobile ? 2 : 4;
    var _group = $gl();
    var _logoOffsetX = Device.mobile ? 0.1 : 0.5;
    var _data = [];
    var _gridPos = [];
    function resizeHandler() {
      _cameraUnits = Utils3D.getHeightFromCamera(_this.parent.layers.camera.baseCamera, _this.parent.layers.camera.group.position.length());
      _gridColumns = Math.round(Math.range(Stage.width, 800, 1200, 2, 4, true));
      _size = Math.range(Stage.width, 800, 1200, 2, 3, true);
      let _cameraBottomPortrait = Math.range(Stage.width, 375, 800, 3.9, 4.4, true);
      if (Stage.width <= 800 && Stage.height > 500) {
        _group.x = -(_size + _logoOffsetX - 0.1) * _gridColumns / 2 / _cameraUnits;
        _group.y = -0.8;
        _this.parent.layers.camera.bottom = -_cameraBottomPortrait;
      } else if (Device.mobile && Stage.width > Stage.height) {
        _size = Math.range(Stage.width, 500, 800, 3, 4, true);
        _gridColumns = 4;
        _group.x = -(_size + _logoOffsetX) * _gridColumns / 2 / _cameraUnits;
        _group.y = -1.8;
        _this.parent.layers.camera.bottom = -4;
      } else {
        _group.x = -(_size + _logoOffsetX) * _gridColumns / 2 / _cameraUnits;
        _group.y = -2;
        _this.parent.layers.camera.bottom = -3.8;
      }
      clearTimeout(_resizeDebounced);
      _resizeDebounced = _this.delayedCall(() => {
        (function initGridPos() {
          let x = 0;
          let y = 0;
          let row = 0;
          _gridPos = [];
          _data.forEach((item, i) => {
            if (i % _gridColumns) {
              x += (_size + _logoOffsetX) / _cameraUnits;
            } else {
              row += 1;
              let rowItems = _data.slice(i - _gridColumns, i);
              if (i === 0) {
                rowItems = _data.slice(0, _gridColumns);
              }
              x = 0;
              y += (_size + 0.5) / _cameraUnits;
              y;
            }
            if (row === 1) {
              y = 0;
            }
            let size = _size / _cameraUnits;
            _gridPos.push({
              x: x,
              y: y,
              size: size
            });
            _group.children[i].x = x;
            _group.children[i].y = -y;
            _group.children[i].width = size;
            _group.children[i].height = size;
          });
        })();
      }, 300);
    }
    function onLogoHover(e) {
      let $el;
      $el = e?.mesh ? e.mesh.glui : e.object;
      if ($el.link) {
        if (e.action == "over") {
          $el.tween({
            scale: 1.2
          }, 600, "easeOutCubic");
        } else {
          $el.tween({
            scale: 1
          }, 300, "easeOutCubic");
        }
      }
    }
    function onLogoClick(data) {
      if (data.link) {
        window.open(data.link, "_blank");
        Track.event("partners", {
          items: [{
            item_id: `partners_logo_${data.alt}`,
            item_name: `partners_logo_${data.alt}`
          }]
        }, `click:${data.alt}`);
      }
    }
    (async function () {
      _parent = _this.findParent("PartnersPage");
      _group.enable3D(true);
      _group.hide();
      _this.layout = _this.initClass(SceneLayout, "PartnersLogoSection");
      _this.layers = await _this.layout.getAllLayers();
      _cameraUnits = Utils3D.getHeightFromCamera(_this.parent.layers.camera.baseCamera, _this.parent.layers.camera.group.position.length());
      await async function initData() {
        _data = [];
        let res = await CMS.get("partners");
        await Promise.all(res.map(async item => {
          let obj = item;
          let asset = await ImageUtil.square(item.asset);
          let texture = new Texture(asset.canvas);
          obj.width = asset.width;
          obj.height = asset.height;
          obj.canvas = asset.canvas;
          obj.texture = texture;
          _data.push(obj);
        }));
        _data = _data.sort((a, b) => a.alt < b.alt ? -1 : a.alt > b.alt ? 1 : 0);
      }();
      (function initHit() {
        let shader = _this.initClass(Shader, "InteractiveScrollSectionHitShader");
        (_hit = new Mesh(World.PLANE, shader)).position.y = 1;
        _this.group.position.y = -4;
        _hit.shader.transparent = true;
        _hit.renderOrder = -1;
        _this.add(_hit);
        _this.flag("hitReady", true);
      })();
      (function initLogos() {
        _data.forEach((item, i) => {
          let size = _size / _cameraUnits;
          let shader = _this.initClass(Shader, "PartnersLogoShader", {
            tNoise: {
              value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
              ignoreUIL: true
            },
            uTimeScale: {
              value: 0.15
            },
            uUVScale: {
              value: 1.78
            },
            uRotation: {
              value: 90
            },
            uTransition0: {
              value: 0
            },
            uBoundingMin: {
              value: new Vector3()
            },
            uBoundingMax: {
              value: new Vector3()
            },
            transparent: true,
            blending: Shader.ADDITIVE_BLENDING
          });
          let $logo = $gl(size, size, item.texture);
          $logo.enable3D(true);
          $logo.useShader(shader);
          $logo.delay = i * 100;
          $logo.shader.set("uBoundingMax", new Vector3(2, -5, 1));
          if (item.link && item.link.length) {
            if (!Global.PLAYGROUND) {
              $logo.interact(onLogoHover, onLogoClick.bind($logo, item), item.link, `Go to ${item.alt} website`);
            }
            $logo.link = item.link;
          }
          _group.add($logo);
        });
      })();
      (function addHandlers() {
        _this.onResize(resizeHandler);
      })();
      _parent.glScene.add(_group);
      await async function initSEO() {
        await _this.wait(250);
        await _this.wait(_ => _parent.camera);
        GLSEO.registerPage(_group, "partners_logos_glui");
        let _seo = {
          root: _group,
          seo: _data.map(item => ({
            url: item.link ? item.link : "",
            label: item.alt
          }))
        };
        let _meshes = _group.children.map(item => item.mesh);
        Interaction3D.find(_parent.camera.baseCamera).add(_meshes, onLogoHover, onLogoClick, _seo);
      }();
    })();
    _this.get("hit", async () => {
      await _this.wait(_this, "hitReady");
      return _hit;
    });
    _this.onInvisible = () => {
      _group.hide();
      _group.children.forEach(el => {
        el.shader.set("uTransition0", 0);
      });
    };
    _this.onVisible = () => {
      _group.show();
      _group.children.forEach(el => {
        el.shader.tween("uTransition0", 1, 4000, "easeOutQuart", el.delay);
      });
    };
    _this.hide = function () {
      _group.hide();
    };
  });
  Class(function PartnersPage(isFirst = false) {
    Inherit(this, InteractiveScrollPage, "partners", isFirst);
    const _this = this;
    function resizeHandler() {
      if (Stage.width < Stage.height) {
        _this.layers.bg.position.y = -3.23;
        _this.layers.scrollHint.group.scale.set(0.3, 0.3, 1);
        _this.layers.scrollHint.group.position.x = 0;
        _this.layers.scrollHint.group.position.y = 0.55;
        _this.layers.scrollHint.group.position.z = -1;
      } else {
        _this.layers.bg.position.y = -3.35;
        _this.layers.scrollHint.group.scale.set(0.7, 0.7, 1);
        _this.layers.scrollHint.group.position.x = -1.015;
        _this.layers.scrollHint.group.position.y = -1.514;
        _this.layers.scrollHint.group.position.z = -1;
      }
    }
    (async function () {
      await _this.ready();
      await _this.wait(_this, "cameraReady");
      _this.layers = await _this.layout.getAllLayers();
      _this.layers.camera.baseCamera.lock();
      _this.layers.heroRTLayer.renderOrder = -1;
      _this.layers.bg.renderOrder = -3;
      _this.layers.left.renderOrder = -2;
      _this.layers.center.renderOrder = -2;
      _this.layers.right.renderOrder = -2;
      _this.layers.scrollHint.alpha = 1;
      (function addHandlers() {
        _this.onResize(resizeHandler);
        _this.events.sub(_this, "LayerVisible", e => {
          Track.event("partners", {
            items: [{
              item_id: `partners_section_scroll_${e.key}`,
              item_name: `partners_section_scroll_${e.key}`
            }]
          }, `partners:section:${e.key}`);
        });
      })();
      _this.flag("layersReady", true);
    })();
    this.animateIn = async function () {
      await _this.wait("layersReady");
      _this.layers.heroSection.animateIn();
      tween(_this.layers.scrollHint, {
        alpha: 0
      }, 0, "easeOutCubic");
      tween(_this.layers.scrollHint, {
        alpha: 1
      }, 600, "easeOutCubic", 1500);
    };
    this.animateOut = async function () {};
    _this.onVisible = function () {
      CameraUtil.hardBlockScroll(true);
    };
  });
  Class(function PartnersSpaceBG(_mesh, _shader) {
    Inherit(this, Component);
    const _this = this;
    async function resize() {
      let image = _mesh;
      let camera = _this.parent.layers.camera.baseCamera.camera;
      await _shader.uniforms.tMap.value.promise;
      let imageDimensions = _shader.uniforms.tMap.value.dimensions;
      let imageRatio = imageDimensions.width / imageDimensions.height;
      let screenHeight = Utils3D.getHeightFromCamera(camera, camera.position.z - image.position.z);
      let screenWidth = Utils3D.getWidthFromCamera(camera, camera.position.z - image.position.z);
      let scale = screenWidth / screenHeight < imageRatio ? screenHeight : screenWidth * (1 / imageRatio);
      image.scale.x = imageRatio;
      image.scale.y = 1;
      image.scale.z = 1;
      image.scale.multiplyScalar(scale * Math.range(Stage.width / Stage.height, 1.5, 0.5, 2.6, 4, true));
    }
    (async function () {
      _shader.addUniforms({
        tMap: {
          value: null
        },
        tLines: {
          value: null
        },
        uScale2: {
          value: new Vector2(1, 1)
        }
      });
      await _this.parent.getAllLayers();
      _this.onResize(resize);
    })();
  });
  Class(function PrivacyPage() {
    Inherit(this, InteractivePage, "privacy");
    const _this = this;
    (async function () {
      await _this.ready();
      _this.element.css({
        opacity: "0"
      });
    })();
    this.animateIn = function () {
      _this.element.tween({
        opacity: 1
      }, 600, "easeOutCubic", 600);
      _this.element.css({
        position: "relative !important"
      });
    };
    this.animateOut = function () {
      _this.element.tween({
        opacity: 0
      }, 300, "easeOutCubic");
    };
  });
  Class(function PrivacyUI() {
    Inherit(this, InteractiveUI);
    Inherit(this, DOMTemplate);
    const _this = this;
    _this.element;
    var _content;
    var $body;
    (async function () {
      _this.flag("animateIn", false);
      (async function init() {
        await CMS.ready();
        _content = await CMS.get("contact.terms");
        await _this.wait("postRendered");
        $body.div.innerHTML = _content;
      })();
    })();
    this.style = function () {
      return "\n            $small: 500px;\n            $medium: 900px;\n            @font-face {\n                font-family: 'marscondensed-regular-TRIAL';\n                src: url('../fonts/marscondensed-regular-TRIAL.otf') format('opentype');\n                font-weight: 400;\n                font-style: bold;\n            }\n            @font-face {\n                font-family: 'FuturaLT-Bold';\n                src: url('../fonts/FuturaLT-Bold.ttf') format('truetype');\n                font-weight: 600;\n                font-style: normal;\n            }\n            @font-face {\n                font-family: 'FuturaLT-Medium';\n                src: url('../fonts/FuturaLT-Medium.ttf') format('truetype');\n                font-weight: 400;\n                font-style: normal;\n            }\n\n            .PrivacyUI {\n                display: block;\n                position: relative !important;\n                width: 100vw;\n\n                & > * {\n                    position:relative !important;\n                }\n\n                &__title {\n                    font-family: 'marscondensed-regular-TRIAL', sans-serif;\n                    font-size: 12rem;\n                    color: #FDF0E1;\n                    text-align: center;\n                    text-transform: uppercase;\n                    line-height: 10rem;\n                    padding: calc(2.5% + 1.25rem) 0 0;              \n                    margin: 0 auto 0;\n                    z-index: 1;\n                    width: 80vw;\n                    background: url('../images/textures/grains-2.jpg');\n                    background-size: cover;\n                    -webkit-background-clip: text;\n                    background-clip: text;\n                    color: transparent;\n                }\n\n                &__content {\n                    & > * {\n                        position:relative !important;\n                    }\n\n                    font-family: 'FuturaLT-Medium', sans-serif;\n                    font-size: 1.8rem;\n                    line-height: 2.4rem;\n                    color: #FDF0E1;\n                 \n                    margin: 0 auto 0;\n\n\n                    @media screen and (max-width: $small) {\n                        width: initial;\n                        padding: 40px;\n                        padding-top: 80px;\n                        font-size: 1.4rem;\n                        line-height: 1.4;\n                    }\n                    @media screen and (min-width: $small) {\n                        width: 50vw;\n                        padding: 10rem 0 20rem;\n                    }\n\n                    iframe {\n                        padding: 5rem 0;\n                        margin: 0 auto;\n                        width: 100%;\n                    }\n                    ul {\n                        padding: 0 4rem;\n\n                        & > * {\n                            position:relative !important;\n                        }\n                    }\n\n                    p {\n                        margin: 0;\n                        padding: 0;\n                        & > * {\n                            position:relative !important;\n                        }\n                    }\n\n                    blockquote {\n                        font-size: 4rem;\n                        font-family: \"marscondensed-regular-TRIAL\", sans-serif;\n                        line-height: 3.5rem;\n                        text-transform: uppercase;\n                        padding: 4rem 0;\n                        border-top: 1px #FDF0E1 solid;\n                        border-bottom: 1px #FDF0E1 solid;\n                        padding: 4rem 0;\n                        margin: 0 auto;\n                    }\n                    a {\n                        font-weight: bold;\n                        color: #FDF0E1;\n                        text-decoration: none;\n                        border-bottom: 1px #E74833 solid;\n                        transition: all 300ms cubic-bezier(0.190, 1.000, 0.220, 1.000);\n                        &:hover {\n                            opacity: 0.5;\n                        }\n                        &:focus {\n                            outline: auto;\n                        }\n                    }\n                    img {\n                        // max-height: 40rem;\n                        // max-width: 100%;\n                        width: 100%;\n                        padding: 4rem 0;\n                        margin: 0 auto;\n                        text-align: center;\n                        display: flex;\n                    }\n                }\n            }\n        ";
    };
    this.render = function (html) {
      return html`
              <div class="PrivacyUI">
                  <h1 class="PrivacyUI__title"></h1>
                  <div class="PrivacyUI__content"></div>    
              </div>
          `;
    };
    this.postRender = async function () {
      $body = await _this.querySelector(".PrivacyUI__content");
      _this.flag("postRendered", true);
    };
  });
  Class(function ScrollHint(_input) {
    Inherit(this, Object3D);
    const _this = this;
    var $wrapper;
    var $circleWrap;
    var $circle;
    var $arrow;
    var _color = new Color();
    async function arrowOut() {
      await $arrow.tween({
        y: 0.4,
        alpha: 0,
        scale: 0.95
      }, 1000, "easeInCubic", 400).promise();
      (async function arrowIn() {
        $arrow.y = 0.1;
        await $arrow.tween({
          y: 0.3,
          alpha: 1,
          scale: 1
        }, 1400, "easeOutQuart").promise();
        await _this.wait(1500);
        arrowOut();
      })();
    }
    function loop() {
      $circleWrap.rotation -= 0.1;
    }
    (function () {
      _this.renderOrder = 9999;
      if (_input && _input instanceof InputUILConfig) {
        let color = _input.get("wildcard");
        if (color) {
          _color.setHex(color);
        } else {
          _color.setHex(Colors.hex.orange);
        }
      }
      (function initWrapper() {
        ($wrapper = $gl()).alpha = 0;
        $wrapper.x = -0.5;
        $wrapper.y = -0.5;
        _this.add($wrapper.group);
      })();
      (function initCircle() {
        ($circleWrap = $gl()).x = 0.5;
        $circleWrap.y = 0.5;
        let shader = _this.initClass(Shader, "ScrollHintItemShader", {
          uColor: {
            value: _color
          }
        });
        ($circle = $gl(1, 1, "assets/images/ui/star-circle.png")).useShader(shader);
        $circle.x = -0.5;
        $circle.y = -0.5;
        $circleWrap.add($circle);
        $wrapper.add($circleWrap);
      })();
      (function initArrow() {
        let shader = _this.initClass(Shader, "ScrollHintItemShader", {
          uColor: {
            value: _color
          }
        });
        ($arrow = $gl(0.4, 0.4, "assets/images/ui/down-arrow.png")).useShader(shader);
        $arrow.x = 0.3;
        $arrow.y = 0.3;
        $wrapper.add($arrow);
      })();
      _this.delayedCall(() => {
        _this.start();
      }, 500);
      _this.startRender(loop);
    })();
    _this.set("rotation", v => {});
    _this.set("alpha", v => {
      $wrapper.alpha = v;
    });
    _this.get("alpha", () => $wrapper.alpha);
    _this.start = function () {
      arrowOut();
    };
  });
  Class(function ScrollProgress({
    $parent: $parent,
    views: views
  } = {}) {
    Inherit(this, Component);
    const _this = this;
    var $container;
    var _shader;
    var _color = new Color();
    (async function () {
      _color.setHex(Colors.hex.beige);
      $container = $gl(3, Stage.height * 0.65, "#FFFFFF");
      _shader = _this.initClass(Shader, "ScrollProgressShader", {
        uIndex: {
          value: 1
        },
        uColor: {
          value: _color
        },
        uSectionAmount: {
          value: views.length
        },
        uAlpha0: {
          value: 0
        },
        transparent: true
      });
      $container.useShader(_shader);
      $container.x = Stage.width * 0.95;
      $container.y = Stage.height * 0.55 - $container.height / 2;
    })();
    _this.setIndex = function (index) {
      index;
      _shader.tween("uIndex", index, 400, "easeOutCubic");
    };
    _this.animateOut = function (delay = 0) {
      _shader.tween("uAlpha0", 0, 400, "easeOutCubic", delay);
    };
    _this.animateIn = function (delay = 0) {
      _shader.tween("uAlpha0", 1, 400, "easeOutCubic", delay);
    };
  });
  Class(function TechnologyBGShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    function resize() {
      if (SceneLayout.breakpoint == "portrait" || Device.mobile) {
        _shader.set("uApplyTilt", 0);
      } else {
        _shader.set("uApplyTilt", 1);
      }
    }
    _shader.addUniforms({
      uColor: {
        value: new Color()
      },
      uApplyTilt: {
        value: 1
      }
    });
    _this.onResize(resize);
  });
  Class(function TechnologyGraphicShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      tNoise: {
        value: Utils3D.getTexture("assets/images/noise/dirnoise_basecolor.png"),
        ignoreUIL: true
      },
      uTimeScale: {
        value: 0.39
      },
      uUVScale: {
        value: 1.78
      },
      uRotation: {
        value: 90
      },
      uTransition0: {
        value: 0
      }
    });
    this.animateIn = async function (delay = 0) {
      await _shader.tween("uTransition0", 1, 2000, "easeOutCubic", delay).promise();
    };
    this.animateOut = async function (delay = 0) {
      await _shader.tween("uTransition0", 0, 300, "easeOutCubic", delay).promise();
    };
  });
  Class(function TechnologyPage(isFirst = false) {
    Inherit(this, InteractiveScrollPage, "technology", isFirst);
    const _this = this;
    const $this = _this.element;
    var _element;
    var _video;
    var $modal;
    var $vidContainer;
    var $closeContainer;
    var $closeWrapper;
    function hideModal() {
      _this.flag("videoModalOpen", false);
      _video.pause();
      $modal.tween({
        x: "100%"
      }, 300, "easeOutCubic");
    }
    function fixPauseSafari() {
      if (_this.flag("forcedReflowForVideoFix")) {
        _element.classList.remove("forceReflow");
        _this.flag("forcedReflowForVideoFix", false);
      } else {
        _element.classList.add("forceReflow");
        _this.flag("forcedReflowForVideoFix", true);
      }
    }
    function hideCloseModalBtn() {
      $closeContainer.tween({
        opacity: 0
      }, 1000, "easeOutCubic").onComplete(_ => {
        $closeContainer.hide();
      });
    }
    function showCloseModalBtn() {
      $closeContainer.show();
      $closeContainer.tween({
        opacity: 1
      }, 300, "easeOutCubic");
    }
    function handleOrientation(orientation) {
      if (orientation == "landscape" && _this.flag("videoModalOpen") && _video) {
        _video.requestFullscreen();
      }
    }
    function resize() {
      if (_this.flag("videoIsPlaying") && Device.mobile) {
        if (Stage.height > Stage.width) {
          hideCloseModalBtn();
        } else {
          showCloseModalBtn();
        }
      }
      if (_this.camera) {
        if (SceneLayout.breakpoint == "portrait" && Stage.width < 600) {
          _this.camera.baseCamera.setFOV(30);
          _this.camera.bottom = 0;
        } else if (Device.mobile?.phone && Stage.width > Stage.height) {
          _this.camera.baseCamera.setFOV(22.5);
          _this.camera.bottom = 0;
        } else if (Device.mobile?.tablet && Stage.width > Stage.height) {
          _this.camera.baseCamera.setFOV(35);
          _this.camera.bottom = 0;
        } else {
          _this.camera.baseCamera.setFOV(30);
          _this.camera.bottom = 0;
        }
      }
    }
    function handleHoverCloseBtn(e) {
      e.action;
    }
    function handleClickCloseBtn() {
      (function closeModal() {
        _this.events.fire(TechnologyPage.CLOSE_MODAL);
        PageUIController.instance().$container.css({
          zIndex: "unset"
        });
        hideModal();
      })();
    }
    function openModal() {
      PageUIController.instance().$container.css({
        zIndex: 999999
      });
      (function showModal() {
        _this.flag("videoModalOpen", true);
        showCloseModalBtn();
        $modal.tween({
          x: "0%"
        }, 800, "easeOutQuint").onComplete(_ => {
          _video.play();
          if (PageUIController.instance().state.orientation == "landscape" && Device.mobile) {
            _video.requestFullscreen();
          }
        });
      })();
    }
    (async function () {
      await async function initHTML() {
        (function initStyles() {
          $this.goob(`\n            width: 100%;\n            height: 100%;\n\n            .videoModal {\n                z-index: 99999;\n                position: fixed !important;\n                width: 100%;\n                height: 100%;\n                top: 0;\n                left: 0;\n                background: rgba(255,255,255, 0.75);\n            }\n\n            .vidContainer {\n                top: 0;\n                bottom: 0;\n                left: 0;\n                right: 0;\n                margin: auto;\n                width: 100%;\n                height: 100%;\n                background: rgba(50,50,50, 0.75);\n\n                video {\n                    pointer-events: ${Device.mobile ? "auto" : "none"};\n                    width: 100%;\n                    height: 100%;\n                    top: 0;\n                    left: 0;\n\n                    &.forceReflow {\n                        position: absolute !important;\n                    }\n                }\n            }\n\n            .close-container {\n                position: absolute;\n                top: 47px;\n                right: 25px;\n                width: 4rem;\n                height: 4rem;\n                transform: translateX(-50%);\n\n                @media (max-width: 767px) {\n                    top: 27px;\n                    right: 16px;\n                }\n\n                @media (max-width: 600px) {\n                    top: 27px;\n                    right: 8px;\n                }\n            }\n\n            .closeButton {\n                position: absolute;\n                top: 50px;\n                right: 50px;\n                width: 50px;\n                height: 50px;\n                background: #ff0000;\n            }\n\n            .vjs-control-bar {\n                position: absolute !important;\n                bottom: 42px;\n\n                @media (max-width: 767px) {\n                    bottom: 20px;\n                }\n            }\n\n            #custom-player .vjs-play-control .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-play.png")});\n            }\n\n            #custom-player .vjs-play-control.vjs-playing .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-pause.png")});\n            }\n\n            #custom-player .vjs-mute-control .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-volume.png")});\n            }\n\n            #custom-player .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-volume-low.png")});\n            }\n\n            #custom-player .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder:before, \n            #custom-player .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-volume-none.png")});\n            }\n            \n            #custom-player .vjs-fullscreen-control .vjs-icon-placeholder:before {\n                background-image: url(${Assets.getPath("assets/images/technology/player-ui/icon-fullscreen.png")});\n            }\n        `);
        })();
        (function initModal() {
          $modal = $this.create("videoModal");
          ($vidContainer = $modal.create("vidContainer")).div.setAttribute("id", "custom-player");
          (function initCloseButton() {
            ($closeContainer = $modal.create("close-container")).interact(handleHoverCloseBtn, handleClickCloseBtn, "#", "Close video button");
            $closeContainer.div.setAttribute("title", "Close video button");
            $closeContainer.hit.div.setAttribute("role", "button");
            ($closeWrapper = $closeContainer.create("close-wrapper")).css({
              position: "relative",
              width: "100%",
              height: "100%"
            });
            $closeWrapper.create("closeLine1").css({
              position: "absolute",
              top: "50%",
              left: "50%",
              width: "100%",
              height: "2px",
              background: Colors.value.beige,
              transformOrigin: "left",
              transform: "rotate(45deg) translate(-50%, -50%)"
            });
            $closeWrapper.create("closeLine2").css({
              position: "absolute",
              top: "50%",
              left: "50%",
              width: "100%",
              height: "2px",
              background: Colors.value.beige,
              transformOrigin: "left",
              transform: "rotate(-45deg) translate(-50%, -50%)"
            });
          })();
        })();
        await async function initVideo() {
          (_element = document.createElement("video")).crossOrigin = "anonymous";
          _element.setAttribute("crossorigin", "anonymous");
          _element.setAttribute("playsinline", "");
          _element.setAttribute("webkit-playsinline", "");
          _element.setAttribute("id", "tech-video");
          _element.setAttribute("preload", "auto");
          _element.style.width = "100%";
          _element.style.height = "100%";
          _element.style.padding = "0";
          _element.style.maxWidth = "100%";
          _element.style.background = "#000000";
          _element.src = Assets.getPath("assets/images/technology/Prometheus_Tech_Film_1080_v4.mp4");
          $vidContainer.div.appendChild(_element);
          if (Global.PLAYGROUND) {
            await AssetLoader.loadAssets(["~assets/js/lib/video.min.js"]);
          }
          (_video = videojs(_element, {
            controls: true,
            autoplay: false,
            preload: true,
            fluid: true,
            controlBar: {
              children: ["playToggle", "progressControl", "volumePanel", "fullscreenToggle"]
            }
          }, async function onPlayerReady() {
            if (Device.mobile) {
              this.play();
              await defer();
              this.pause();
            }
            this.on("playing", function (e) {
              _this.flag("videoIsPlaying", true);
              $vidContainer.div.classList.remove("loadingVideo");
              if (_this.flag("userInactive") && Device.mobile && Stage.height > Stage.width) {
                hideCloseModalBtn();
              }
              if (!Device.mobile && Device.system.browser == "safari") {
                _this.stopRender(fixPauseSafari);
              }
            });
            this.on("pause", function (e) {
              _this.flag("videoIsPlaying", false);
              if (Device.mobile) {
                showCloseModalBtn();
              }
              if (!Device.mobile && Device.system.browser == "safari") {
                let pausedAtTime = _video.currentTime();
                fixPauseSafari();
                _this.startRender(fixPauseSafari, 2);
                _this.delayedCall(_ => {
                  if (!_this.flag("videoIsPlaying")) {
                    _video.currentTime(pausedAtTime);
                  }
                }, 500);
              }
            });
            this.on("useractive", function () {
              _this.flag("userInactive", false);
              showCloseModalBtn();
            });
            this.on("userinactive", function () {
              _this.flag("userInactive", true);
              if (_this.flag("videoIsPlaying") && Device.mobile && Stage.height > Stage.width) {
                hideCloseModalBtn();
              }
            });
            this.on("waiting", function (e) {
              $vidContainer.div.classList.add("loadingVideo");
            });
            this.on("canplaythrough", function (e) {
              $vidContainer.div.classList.remove("loadingVideo");
            });
            this.on("canplay", function (e) {
              $vidContainer.div.classList.remove("loadingVideo");
            });
            this.on("ended", function (e) {
              $vidContainer.div.classList.remove("loadingVideo");
            });
          })).src({
            src: Assets.getPath("assets/images/technology/Prometheus_Tech_Film_1080_v4.mp4"),
            type: "video/mp4"
          });
          _video.addClass("video-js");
          _video.addClass("vjs-hydra");
        }();
        hideModal();
      }();
      await _this.ready();
      await _this.wait(_this, "cameraReady");
      (function addListeners() {
        _this.onResize(resize);
        _this.events.sub(_this, "LayerVisible", e => {
          Track.event("technology", {
            items: [{
              item_id: `technology_section_scroll_${e.key}`,
              item_name: `technology_section_scroll_${e.key}`
            }]
          }, `technology:section:${e.key}`);
        });
        _this.events.sub(TechnologyPage.OPEN_MODAL, openModal);
        if (Device.mobile) {
          _this.bindState(PageUIController.instance().state, "orientation", handleOrientation);
        }
      })();
    })();
    this.animateIn = function () {
      _this.views[0]?.parentRef?.onVisible();
      let z = _this.camera.group.position.z;
      _this.camera.group.position.z -= 1.5;
      tween(_this.camera.group.position, {
        z: z
      }, 3000, "easeOutCubic");
    };
    this.animateOut = function () {};
    _this.onVisible = function () {
      CameraUtil.hardBlockScroll(true);
    };
    _this.onInvisible = function () {
      PageUIController.instance().$container.css({
        zIndex: "unset"
      });
      hideModal();
    };
  }, () => {
    TechnologyPage.OPEN_MODAL = "TechnologyPage.OPEN_MODAL";
    TechnologyPage.CLOSE_MODAL = "TechnologyPage.CLOSE_MODAL";
  });
  Class(function TechnologyPlayBtnScriptClass(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    (function () {
      let btnTexture = Utils3D.getTexture(Assets.getPath("assets/images/technology/play_btn.png"));
      let playShader = _this.initClass(Shader, "TechnologyPlayBtnScriptClass", {
        tMap: {
          value: btnTexture
        },
        uColor: {
          value: new Color("#FDF0E1")
        },
        uBgColor: {
          value: new Color("#E84733")
        },
        uIsText: {
          value: 0
        },
        tNoise: {
          value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
          ignoreUIL: true
        },
        uTimeScale: {
          value: 0.39
        },
        uUVScale: {
          value: 1.78
        },
        uRotation: {
          value: 0
        },
        uTransition0: {
          value: 0
        },
        depthTest: false,
        transparent: true
      });
      _mesh.shader = playShader;
      (function initDebug() {
        if (!Global.PLAYGROUND) {
          return;
        }
        _mesh.shader.uniforms.uTransition0.value = 1;
      })();
    })();
  });
  Class(function TechnologyPlayButtonShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uColor: {
        value: new Vector3()
      },
      uBgColor: {
        value: new Vector3()
      },
      uIsText: {
        value: 0
      },
      tNoise: {
        value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
        ignoreUIL: true
      },
      uTimeScale: {
        value: 0.39
      },
      uUVScale: {
        value: 1.78
      },
      uRotation: {
        value: 0
      },
      uTransition0: {
        value: 0
      }
    });
    this.animateIn = async function (delay = 0) {
      _shader.set("uTransition0", 0);
      await _shader.tween("uTransition0", 1, 900, "easeIn", delay).promise();
    };
    this.animateOut = async function (delay = 0) {
      await _shader.tween("uTransition0", 0, 400, "easeIn", delay).promise();
    };
  });
  Class(function TechnologySectionOne() {
    Inherit(this, InteractiveScrollSection, "section1");
    Inherit(this, Element);
    const _this = this;
    _this.element;
    var _scrollHint;
    var _text;
    var $playBtn;
    var $playIcon;
    var $playTextLabel;
    var $playHitMobile;
    var $logoExceptionHit;
    var $burgerExceptionHit;
    var _enabledPlayFollow = false;
    var _enabledModalClick = true;
    var _modalOpened = false;
    function playBtnLoop() {
      $playBtn.x += (Mouse.x - $playBtn.x) * 0.15;
      $playBtn.y += (Mouse.y - $playBtn.y) * 0.15;
    }
    async function addExceptionsHitAreas() {
      if (_enabledPlayFollow && !_this.flag("exceptionsEnabled")) {
        _this.flag("exceptionsEnabled", true);
        ($logoExceptionHit = $gl(125, 120, "#ff6600")).alpha = 0;
        GLUI.Stage.add($logoExceptionHit);
        ($burgerExceptionHit = $gl(130, 110, "#ff6600")).alpha = 0;
        $burgerExceptionHit.x = Stage.width - 150;
        GLUI.Stage.add($burgerExceptionHit);
        $logoExceptionHit.interact(handleHitExceptionHover, _ => {});
        $burgerExceptionHit.interact(handleHitExceptionHover, _ => {});
      }
    }
    function clearExceptionsHitAreas() {
      if (_enabledPlayFollow) {
        _this.flag("exceptionsEnabled", false);
        $logoExceptionHit.remove();
        $burgerExceptionHit.remove();
      }
    }
    function handleHoverModalA11y(e) {
      if (e.action == "over") {
        $playIcon.tween({
          scale: 1.2
        }, 500, "easeOutCubic");
      } else {
        $playIcon.tween({
          scale: 1
        }, 150, "easeOutCubic");
      }
    }
    function onRouteChange(e) {
      let route = e.toLowerCase();
      _modalOpened = false;
      if (route == "technologypage") {
        if (_enabledPlayFollow) {
          Mouse.x = Stage.width / 2;
          Mouse.y = Stage.height / 2 + 180;
        }
        toggleModalClick(true, 700);
        addExceptionsHitAreas();
      } else {
        toggleModalClick(false);
        clearExceptionsHitAreas();
      }
    }
    async function handleHitExceptionHover(e) {
      if (!_modalOpened) {
        if (e.action == "over") {
          _this.flag("hoveringExceptionHit", true);
          toggleModalClick(false);
          await defer();
          Stage.cursor("auto");
        } else {
          _this.flag("hoveringExceptionHit", false);
          toggleModalClick(true);
        }
      }
    }
    function toggleModalClick(enable, playBtnDelay = 0) {
      if (enable && function canEnableClick() {
        return !PageUIController.instance().state.menuOpen && ViewController.instance().getState() == "technology" && !_this.flag("hoveringExceptionHit") && !_modalOpened;
      }()) {
        _enabledModalClick = true;
        (function animateInPlayBtn(delay = 0) {
          $playIcon.shader.set("uTransition0", 0);
          $playTextLabel.shader.set("uTransition0", 0);
          $playIcon.shader.tween("uTransition0", 1, 900, "easeIn", delay);
          $playTextLabel.shader.tween("uTransition0", 1, 700, "easeIn", delay);
        })(playBtnDelay);
      } else {
        _enabledModalClick = false;
        (function animateOutPlayBtn(delay = 0) {
          $playTextLabel.shader.tween("uTransition0", 0, 400, "easeIn", delay);
          $playIcon.shader.tween("uTransition0", 0, 400, "easeIn", delay);
        })(playBtnDelay);
      }
    }
    function handleWindowClick() {
      if (_enabledModalClick) {
        openModal();
      }
    }
    function handlePlayClickMobile() {
      if (ViewController.instance().getState() == "technology") {
        openModal();
      }
    }
    function resize() {
      if (_enabledPlayFollow) {
        $burgerExceptionHit.x = Stage.width - 150;
      } else {
        let topOffset = Stage.width > Stage.height ? Stage.height < 450 ? 40 : 120 : 65;
        $playBtn.x = Stage.width / 2;
        $playBtn.y = Stage.height / 2 + topOffset;
      }
      if (Stage.height < 450) {
        $playBtn.scale = 0.85;
      } else {
        $playBtn.scale = 1;
      }
    }
    function handleMenuOpen(isOpen) {
      if (isOpen) {
        toggleModalClick(false);
      }
    }
    function openModal() {
      _modalOpened = true;
      toggleModalClick(false);
      clearExceptionsHitAreas();
      _this.events.fire(TechnologyPage.OPEN_MODAL);
    }
    function closeModal() {
      _modalOpened = false;
      addExceptionsHitAreas();
      if (!_enabledPlayFollow) {
        toggleModalClick(true);
      }
    }
    function loop() {
      Math.range(_this.progress, 0, 0.25, 1, 0);
    }
    (async function () {
      await _this.wait(_this, "isReady");
      _scrollHint = _this.layers.scrollHint;
      _text = _this.layers.text1;
      GLSEO.setPageH1(_this.findParent("TechnologyPage"), _text.text.text.string);
      (function initPlayVideoButton() {
        ($playBtn = $gl()).x = Stage.width / 2;
        $playBtn.y = Stage.height / 2 + 180;
        GLUI.Stage.add($playBtn);
        let btnTexture = Utils3D.getTexture(Assets.getPath("assets/images/technology/play_btn.png"));
        ($playIcon = $gl(64, 64, Assets.getPath("assets/images/technology/play_btn.png"))).x = -32;
        $playIcon.y = -32;
        let playShader = _this.initClass(Shader, "TechnologyPlayButtonShader", {
          tMap: {
            value: btnTexture
          },
          uColor: {
            value: new Color("#FDF0E1")
          },
          uBgColor: {
            value: new Color("#E84733")
          },
          uIsText: {
            value: 0
          },
          tNoise: {
            value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
            ignoreUIL: true
          },
          uTimeScale: {
            value: 0.39
          },
          uUVScale: {
            value: 1.78
          },
          uRotation: {
            value: 0
          },
          uTransition0: {
            value: 0
          }
        });
        $playIcon.useShader(playShader);
        $playBtn.add($playIcon);
        ($playTextLabel = $gl(80.15, 12.49, Assets.getPath("assets/images/technology/play_btn.png"))).x = -41;
        $playTextLabel.y = Device.mobile ? 49 : 43;
        let textShader = _this.initClass(Shader, "TechnologyPlayButtonShader", {
          tMap: {
            value: btnTexture
          },
          uColor: {
            value: new Color("#FDF0E1")
          },
          uIsText: {
            value: 1
          },
          tNoise: {
            value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
            ignoreUIL: true
          },
          uTimeScale: {
            value: 0.39
          },
          uUVScale: {
            value: 1.78
          },
          uRotation: {
            value: 0
          },
          uTransition0: {
            value: 0
          }
        });
        $playTextLabel.useShader(textShader);
        $playBtn.add($playTextLabel);
        if (!Device.mobile) {
          _enabledPlayFollow = true;
          Mouse.x = $playBtn.x;
          Mouse.y = $playBtn.y;
        }
      })();
      await async function addListeners() {
        if (_enabledPlayFollow) {
          _this.startRender(playBtnLoop);
          await _text.ready();
          addExceptionsHitAreas();
          _this.events.sub(Mouse.input, Interaction.START, handleWindowClick);
          (function addModalA11y() {
            let modalA11y = $gl(0, 0, "#ff0000");
            modalA11y.parentSeo = _this.findParent("TechnologyPage");
            GLUI.Stage.add(modalA11y);
            modalA11y.interact(handleHoverModalA11y, handleWindowClick, "#", "Play Video button: Open Prometheus technology video");
          })();
        } else {
          (function addMobilePlayBtnInteract() {
            ($playHitMobile = $gl(92, 103, "#0000ff")).x = -48;
            $playHitMobile.y = -36;
            $playHitMobile.alpha = 0;
            $playBtn.add($playHitMobile);
            $playHitMobile.parentSeo = _this.findParent("TechnologyPage");
            $playHitMobile.interact(handleHoverModalA11y, handlePlayClickMobile, "#", "Play Video button: Open Prometheus technology video");
          })();
        }
        _this.onResize(resize);
        _this.events.sub(ViewController.UPDATE, onRouteChange);
        _this.events.sub(TechnologyPage.CLOSE_MODAL, closeModal);
        _this.bindState(PageUIController.instance().state, "menuOpen", handleMenuOpen);
        if (ViewController.instance().getState() == "technology") {
          toggleModalClick(true, 1000);
        } else {
          toggleModalClick(false);
        }
      }();
      _this.flag("hintReady", true);
    })();
    _this.animateIn = async () => {
      await _this.wait(_this, "hintReady");
      tween(_scrollHint, {
        alpha: 1
      }, 600, "easeOutCubic", 1500);
      _this.startRender(loop);
    };
    _this.animateOut = async () => {
      await _this.wait(_this, "hintReady");
      tween(_scrollHint, {
        alpha: 0
      }, 300, "easeOutCubic", 0);
      _this.stopRender(loop);
    };
  });
  Class(function TechnologyVideoBGShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _videoTexture;
    function handleResize() {
      _shader.uniforms.uWindowSize.value.set(Stage.width, Stage.height);
    }
    _shader.addUniforms({
      tMap: {
        value: null
      },
      tDimensions: {
        value: new Vector2(1280, 720)
      },
      uWindowSize: {
        value: new Vector2()
      },
      uAlpha: {
        value: 0
      },
      tNoise: {
        value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
        ignoreUIL: true
      },
      uTimeScale: {
        value: 0.39
      },
      uUVScale: {
        value: 1.78
      },
      uRotation: {
        value: 0
      },
      uTransition0: {
        value: 0
      }
    });
    (_videoTexture = _this.initClass(VideoTexture, Assets.getPath("assets/images/technology/0_Landing.mp4"), {
      autoplay: true,
      muted: true,
      loop: true
    })).start();
    _shader.set("tMap", _videoTexture.uniform.value);
    (function addHandlers() {
      _this.onResize(handleResize);
    })();
  });
  Class(function ColorBlockShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color(Math.random(), Math.random(), Math.random())
      },
      uRange: {
        value: new Vector2(-1.3, 1.4)
      },
      uSubtract: {
        value: 1
      },
      uDustTexture: {
        value: Utils3D.getRepeatTexture("assets/images/test/dust.jpg"),
        ignoreUIL: true
      }
    });
  });
  Class(function ColorShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color(Math.random(), Math.random(), Math.random())
      }
    });
  });
  Class(function ScrollTest() {
    Inherit(this, FXScene);
    const _this = this;
    var _particles;
    function loop() {
      _this.render();
      _particles.previousFrame = World.NUKE.prevFrameRT;
    }
    (async function () {
      _this.create();
      let layout = _this.initClass(SceneLayout, "scrolltest");
      _this.scene.add(layout.group);
      let scrollCamera = await layout.getLayer("camera");
      scrollCamera.baseCamera.lock();
      let b = await layout.getLayer("b");
      scrollCamera.observe(b, visible => {
        console.log(visible);
      });
      (_particles = await layout.getLayer("particles")).previousFrame = World.NUKE.prevFrameRT;
      _this.startRender(loop, World.NUKE);
      World.NUKE.add(new BlitPass());
    })();
  });
  Class(function TestPage() {
    Inherit(this, InteractivePage, "test");
    const _this = this;
    (async function () {
      await _this.ready();
    })();
    this.animateIn = function () {
      console.log("show test page");
    };
    this.animateOut = function () {
      console.log("hide test page");
    };
  });
  Class(function TestPageUI() {
    Inherit(this, Element);
    const $this = this.element;
    (function initHTML() {
      $this.size("100%", "100vh");
      $this.css({});
    })();
  });
  Class(function TestSection() {
    Inherit(this, InteractiveSection, "test-section");
    const _this = this;
    (async function () {
      await _this.ready();
      _this.initClass(TimelineLayoutLink, _this.layout);
    })();
  });
  Class(function TestTextView() {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "text_text_view");
    })();
  });
  Class(function TestView() {
    Inherit(this, Object3D);
    const _this = this;
    var _playback;
    function loop() {
      _playback.seek(_this.progress);
    }
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "testlayout_osctest");
      _this.initClass(TimelineLayoutLink, _this.layout);
      await _this.layout.getLayer("camera");
      _playback = await _this.initClass(TimelinePlayback, "timeline_animation");
      _this.startRender(loop);
    })();
  });
  Class(function TransitionTest() {
    Inherit(this, Object3D);
    this.initClass(SceneLayout, "transition_test");
  });
  Class(function TransitionTestShader(_mesh, _shader) {
    Inherit(this, Component);
    const _this = this;
    var _dimensions = new Vector2();
    function resize() {
      if (_shader) {
        _dimensions.x = Stage.width;
        _dimensions.y = Stage.height;
        _shader.set("uStageDimensions", _dimensions);
      }
    }
    (async function () {
      let texture = Utils3D.getRepeatTexture("assets/images/noise/grunge.jpg");
      _shader.addUniforms({
        tTo: {
          value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg"),
          ignoreUIL: true
        },
        tFrom: {
          value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg"),
          ignoreUIL: true
        },
        tNoise: {
          value: Utils3D.getRepeatTexture("assets/images/noise/dirnoise3.jpg"),
          ignoreUIL: true
        },
        tGrunge: {
          value: texture,
          ignoreUIL: true
        },
        uTransition0: {
          value: 0.01,
          ignoreUIL: false
        },
        uTransition: {
          value: 0,
          ignoreUIL: false
        },
        uTransitionColor: {
          value: new Color()
        },
        uUVScale: {
          value: 0.8
        },
        uVignette: {
          value: 0
        },
        uSpeed: ViewController.SPEED_MULTI,
        uFlipped: {
          value: 0
        },
        uMobile: {
          value: Device.mobile ? 1 : 0
        },
        uRotation: {
          value: -60
        },
        uRGBShift: {
          value: 1
        },
        uNoise: {
          value: 0
        },
        uGrunge: {
          value: 0
        },
        uBloomAdd: {
          value: 0,
          ignoreUIL: true
        },
        uStageDimensions: {
          value: _dimensions
        },
        uDimensions: {
          value: new Vector2()
        }
      });
      await texture.promise;
      _shader.set("uDimensions", new Vector2(texture.dimensions.width, texture.dimensions.height));
      _this.onResize(resize);
    })();
  });
  Class(function WaveTextShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    _shader.addUniforms({
      tNoise: {
        value: Utils3D.getTexture("assets/images/noise/dirnoise18.jpg"),
        ignoreUIL: true
      },
      uTimeScale: {
        value: 0
      },
      uUVScale: {
        value: 4
      },
      uRotation: {
        value: 20
      },
      uTransition0: {
        value: 0
      }
    });
    _this.animateIn = async function (delay = 0) {
      if (!_this.flag("visible")) {
        _this.flag("visible", true);
        _shader.set("uTransition0", 0);
        await _shader.tween("uTransition0", 1, 2000, "easeOutQuart", delay).promise();
      }
    };
    _this.animateOut = async function (delay = 0) {
      if (_this.flag("visible")) {
        _this.flag("visible", false);
        await _shader.tween("uTransition0", 0, 300, "easeOutCubic", delay).promise();
      }
    };
    _this.reset = function () {
      _this.flag("visible", false);
      _shader.set("uTransition0", 0);
    };
  });
  Class(function AnimatedFuelForgeShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uDirection: {
        value: new Vector3()
      },
      uOffset: {
        value: new Vector3()
      },
      uDistance: {
        value: 10
      },
      uPosterizeTime: {
        value: 12
      },
      uParams: {
        value: new Vector4()
      },
      uColor: {
        value: new Color("#526163")
      },
      uGrain: {
        value: 0.9
      },
      uFlip: {
        value: 0
      },
      uSomething: {
        value: 0
      },
      tMatcap: {
        value: null
      },
      tAo: {
        value: null
      },
      tLightmap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tMask: {
        value: null
      },
      uLightmapPower: {
        value: 1
      },
      uNoiseStrength: {
        value: 0
      },
      uBrightness: {
        value: 1
      },
      uColor0: {
        value: new Color("#ffee66")
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#ffffff")
      },
      uColor3: {
        value: new Color("#ffffff")
      },
      uPosterizeNoise: {
        value: 12
      },
      uFanSpeed: {
        value: 12
      },
      uAxis: {
        value: new Vector3(0, 1, 0)
      },
      uOrientation: {
        value: new Vector4(0, 0, 0, 0)
      }
    });
  });
  Class(function AnimatedInstanceShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uDirection: {
        value: new Vector3()
      },
      uOffset: {
        value: new Vector3()
      },
      uDistance: {
        value: 10
      },
      uPosterizeTime: {
        value: 12
      },
      uParams: {
        value: new Vector4()
      },
      uKeyLightDir: {
        value: new Vector3(0, 4, 0)
      },
      uBounceLightDir: {
        value: new Vector3(-0.1, -1.5, 0)
      },
      uRimLightDir: {
        value: new Vector3(0, 1, -1)
      },
      uKeyLightStep: {
        value: 0.8
      },
      uBounceStep: {
        value: 1.1
      },
      uRimStep: {
        value: 0.8
      },
      uColor: {
        value: new Color("#526163")
      },
      uBounceColor: {
        value: new Color("0c0c0c")
      },
      uRimColor: {
        value: new Color("#ffffff")
      },
      uShadowColor: {
        value: new Color("#1f1f1f")
      },
      uGrain: {
        value: 0.9
      },
      uFlip: {
        value: 0
      }
    });
  });
  Class(function BonfireShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap0: {
        value: null
      },
      tMap1: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uGrain: {
        value: 0.5
      },
      uDiscard: {
        value: 0.5
      },
      uDirection: {
        value: new Vector2()
      },
      uParams: {
        value: new Vector4()
      },
      uColor0: {
        value: new Color("FFFFFF")
      },
      uColor1: {
        value: new Color("000000")
      }
    });
  });
  Class(function CloudDistanceShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    _shader.addUniforms({
      tStaticTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tAnimatedTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 0.1)
      },
      uTime: {
        value: 0
      },
      uDirection: {
        value: new Vector2(0, 0.1)
      },
      uGrain: {
        value: 0.15
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#000000")
      },
      uColor3: {
        value: new Color("#e6e6e6")
      },
      uColor4: {
        value: new Color("#b6b6b6")
      },
      uGradient1: {
        value: new Vector3()
      },
      uGradient2: {
        value: new Vector3()
      },
      uGradientRotation: {
        value: 0
      },
      uDiscard: {
        value: 0.5
      },
      uPosterizeTime: {
        value: 12
      },
      uPosterizeTimeNoise: {
        value: 12
      },
      uAlpha: {
        value: 1
      },
      uOther: {
        value: 1
      }
    });
    _this.startRender(_ => {
      _shader.uniforms.uTime.value += (1 + ViewController.SPEED_MULTI.value * 3) * 0.015 * Render.HZ_MULTIPLIER;
    });
  });
  Class(function CutoutShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    (async function () {
      _shader.addUniforms({
        tMap: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tBrush: {
          value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
          ignoreUIL: true
        },
        uBrushBlend: {
          value: 0
        },
        uBrushScale: {
          value: new Vector2(1, 1)
        },
        uBrushRotate: {
          value: 0
        },
        uDirection: {
          value: new Vector2()
        },
        uTile: {
          value: new Vector2(1, 1)
        },
        uOffset: {
          value: new Vector2()
        },
        uColor: {
          value: new Color()
        },
        uColor1: {
          value: new Color()
        },
        uMix: {
          value: 0
        },
        uNoiseStrength: {
          value: 0
        },
        uPosterizeTime: {
          value: 12
        },
        uHueAdjust: {
          value: 0
        },
        uFogParams: {
          value: new Vector2(-10, -200)
        },
        uFogColor: {
          value: new Color("#FFFFFF")
        },
        uFogMix: {
          value: 0
        },
        uWiggle: {
          value: new Vector3()
        },
        uWiggleSpeed: {
          value: 0.1
        },
        uBrightness: {
          value: 1
        },
        uBillboard: {
          value: 0
        }
      });
      if (Renderer.type == Renderer.WEBGL1) {
        await defer();
        let tile = _shader.get("uTile");
        if (tile.x == 1 && tile.y == 1) {
          let texture = _shader.get("tMap");
          if (texture) {
            texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE;
          }
        }
      }
    })();
  });
  Class(function FlatColorShader(_mesh, _shader) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color()
      }
    });
  });
  Class(function GreyboxShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uFresnelParams: {
        value: new Vector4(0.1, 0.5, 0.5, 0)
      }
    });
  });
  Class(function HueShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uHueAdjust: {
        value: 0
      },
      uAlpha: {
        value: 1
      }
    });
  });
  Class(function MatcapShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMatcap: {
        value: null
      },
      tAo: {
        value: null
      },
      tLightmap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tMask: {
        value: null
      },
      uLightmapPower: {
        value: 1
      },
      uNoiseStrength: {
        value: 0
      },
      uBrightness: {
        value: 1
      },
      uColor0: {
        value: new Color("#ffee66")
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#ffffff")
      },
      uColor3: {
        value: new Color("#ffffff")
      },
      uPosterizeTime: {
        value: 12
      },
      uPosterizeNoise: {
        value: 12
      },
      uFanSpeed: {
        value: 12
      },
      uAxis: {
        value: new Vector3(0, 1, 0)
      },
      uOffset: {
        value: new Vector3()
      },
      uLightDir: {
        value: new Vector4()
      }
    });
  });
  Class(function ModifiedGlassShader(_mesh, _shader) {
    _shader ||= _mesh;
    _shader.addUniforms({
      tEnv: {
        value: null
      },
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uRefractionRatio: {
        value: 1
      },
      uReflectScale: {
        value: 1
      },
      uEnvBlend: {
        value: 1
      },
      uRatio: {
        value: 0.5
      },
      uAttenuation: {
        value: 0.5
      },
      uAlpha: {
        value: 1
      },
      uShininess: {
        value: 1
      },
      uFresnelPow: {
        value: 1
      },
      uFresnelAlpha: {
        value: 1
      },
      uDistortStrength: {
        value: 1
      },
      uSpecAdd: {
        value: new Vector2(1, 0)
      },
      uPhongColor: {
        value: new Color()
      },
      uFresnelColor: {
        value: new Color()
      },
      uLightDir: {
        value: new Vector3(0, 0, 1)
      },
      uTransparent: {
        value: 1
      },
      uAlphaRange: {
        value: new Vector4(0, 1, 0, 1)
      },
      uColor0: {
        value: new Color()
      },
      uColor1: {
        value: new Color()
      },
      uColorParams: {
        value: new Vector4()
      }
    });
  });
  Class(function ShadowShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uColor: {
        value: new Color()
      },
      uColor1: {
        value: new Color()
      },
      uStep: {
        value: 0.5
      },
      uMaskStep: {
        value: 0.5
      },
      uNoise: {
        value: 0
      },
      uNoiseReduce: {
        value: 0
      },
      uMaskNoise: {
        value: 0
      },
      uPosterizeTime: {
        value: 12
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      }
    });
  });
  Class(function SkyGradientShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uDirection: {
        value: new Vector2()
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uOffset: {
        value: new Vector2()
      },
      uColor: {
        value: new Color()
      },
      uColor1: {
        value: new Color()
      },
      uMix: {
        value: 0
      },
      uNoiseStrength: {
        value: 0
      },
      uPosterizeTime: {
        value: 12
      },
      uHueAdjust: {
        value: 0
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uBrightness: {
        value: 1
      }
    });
  });
  Class(function SpeedlineShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uParams: {
        value: new Vector4()
      },
      uPosterizeTime: {
        value: 6
      }
    });
  });
  Class(function SpinningFanShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uKeyLightDir: {
        value: new Vector3(0, 4, 0)
      },
      uBounceLightDir: {
        value: new Vector3(-0.1, -1.5, 0)
      },
      uRimLightDir: {
        value: new Vector3(0, 1, -1)
      },
      uKeyLightStep: {
        value: 0.8
      },
      uBounceStep: {
        value: 1.1
      },
      uRimStep: {
        value: 0.8
      },
      uColor: {
        value: new Color("#526163")
      },
      uBounceColor: {
        value: new Color("0c0c0c")
      },
      uRimColor: {
        value: new Color("#ffffff")
      },
      uShadowColor: {
        value: new Color("#1f1f1f")
      },
      uGrain: {
        value: 0.9
      },
      uWobble: {
        value: new Vector2()
      },
      uWobbleSpeed: {
        value: 8
      },
      uSpeed: {
        value: 1
      },
      uPosterizeTime: {
        value: 12
      },
      uAxis: {
        value: new Vector3(0, 0, 1)
      }
    });
  });
  Class(function StylizedBuildingShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tLightMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.4
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2(0, 0)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#573331")
      },
      uColor2: {
        value: new Color("#1F1611")
      },
      uColor3: {
        value: new Color("#193347")
      },
      uShadowColor: {
        value: new Color("#69008D")
      },
      uPosterizeTime: {
        value: 12
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uLightMix: {
        value: 0
      },
      uLightColor: {
        value: new Color("#FFFFFF")
      }
    });
  });
  Class(function StylizedCloudShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    _shader.addUniforms({
      tStaticTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tAnimatedTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 0.1)
      },
      uTime: {
        value: 0
      },
      uDirection: {
        value: new Vector2(0, 0.1)
      },
      uGrain: {
        value: 0.15
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#000000")
      },
      uColor3: {
        value: new Color("#e6e6e6")
      },
      uColor4: {
        value: new Color("#b6b6b6")
      },
      uGradient1: {
        value: new Vector3()
      },
      uGradient2: {
        value: new Vector3()
      },
      uGradientRotation: {
        value: 0
      },
      uDiscard: {
        value: 0.5
      },
      uPosterizeTime: {
        value: 12
      },
      uPosterizeTimeNoise: {
        value: 12
      },
      uAlpha: {
        value: 1
      }
    });
    _this.startRender(_ => {
      _shader.uniforms.uTime.value += (1 + ViewController.SPEED_MULTI.value * 3) * 0.015 * Render.HZ_MULTIPLIER;
    });
  });
  Class(function StylizedDiffuseShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uKeyLightDir: {
        value: new Vector3(0, 4, 0)
      },
      uBounceLightDir: {
        value: new Vector3(-0.1, -1.5, 0)
      },
      uRimLightDir: {
        value: new Vector3(0, 1, -1)
      },
      uKeyLightStep: {
        value: 0.8
      },
      uBounceStep: {
        value: 1.1
      },
      uRimStep: {
        value: 0.8
      },
      uHueAdjust: {
        value: 0
      },
      uColor: {
        value: new Color("#526163")
      },
      uBounceColor: {
        value: new Color("0c0c0c")
      },
      uRimColor: {
        value: new Color("#ffffff")
      },
      uShadowColor: {
        value: new Color("#1f1f1f")
      },
      uGrain: {
        value: 0.9
      },
      uGrainReduce: {
        value: 0
      },
      uWobble: {
        value: new Vector2()
      },
      uWobbleSpeed: {
        value: 8
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedFieldShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tAnimatedTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tLightmap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 0.1)
      },
      uDirection: {
        value: new Vector2(0, 0.1)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#000000")
      },
      uColor3: {
        value: new Color("#e6e6e6")
      },
      uColor4: {
        value: new Color("#b6b6b6")
      },
      uPosterizeTime: {
        value: 12
      },
      uGradient1: {
        value: new Vector3()
      },
      uGradient2: {
        value: new Vector3()
      },
      uGradientRotation: {
        value: 0
      },
      uGradientApply: {
        value: 0
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedGrassShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uWind: {
        value: new Vector4(0.5, 0.1, 0.1, 0)
      },
      uGrassColor1: {
        value: new Color("#578443")
      },
      uGrassColor2: {
        value: new Color("#80b74e")
      },
      uCutoff: {
        value: 0.1,
        ignoreUIL: true
      },
      uGrassColor1: {
        value: new Color()
      },
      uGrassColor2: {
        value: new Color()
      },
      uFogColor: {
        value: new Color()
      },
      uFogDepth: {
        value: new Vector2(4, 40)
      },
      uEnv: {
        value: new Color()
      }
    });
  });
  Class(function StylizedPBRTextureShader(_mesh, _shader) {
    Inherit(this, Component);
    _shader.addUniforms({
      tBaseColor: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tMRO: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tNormal: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      tEnvDiffuse: {
        value: null,
        premultiplyAlpha: false
      },
      tEnvSpecular: {
        value: null,
        premultiplyAlpha: false
      },
      tLightmap: {
        value: null,
        premultiplyAlpha: false
      },
      uClearCoat: {
        value: new Vector3(0.6, 0.7, 0)
      },
      uNoiseStrength: {
        value: 0
      },
      uSaturation: {
        value: 1
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2(0, 0)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#FFFFFF")
      },
      uColor2: {
        value: new Color("#39404B")
      },
      uColor3: {
        value: new Color("#B34E3C")
      },
      uColor4: {
        value: new Color("#FFFFFF")
      },
      uApplyPBR: {
        value: 0
      },
      uShadowColor: {
        value: new Color("#727C8B")
      },
      uPosterizeTime: {
        value: 12
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedRoadShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    _shader.addUniforms({
      tAnimatedTexture: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 0.1)
      },
      uDirection: {
        value: new Vector2(0, 0.1)
      },
      uGrain: {
        value: 0.15
      },
      uTime: {
        value: 0
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#ffffff")
      },
      uColor2: {
        value: new Color("#000000")
      },
      uColor3: {
        value: new Color("#e6e6e6")
      },
      uColor4: {
        value: new Color("#b6b6b6")
      },
      uGradient1: {
        value: new Vector3()
      },
      uGradient2: {
        value: new Vector3()
      },
      uGradientRotation: {
        value: 0
      },
      uPosterizeTime: {
        value: 12
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
    _this.startRender(_ => {
      _shader.uniforms.uTime.value += (1 + ViewController.SPEED_MULTI.value * 3) * 0.015 * Render.HZ_MULTIPLIER;
    });
  });
  Class(function StylizedSmokeShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    _shader.addUniforms({
      uTime: {
        value: 0
      },
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uColor: {
        value: new Color("#FBF2D1")
      },
      uColor2: {
        value: new Color("#C9C9AB")
      },
      uStep: {
        value: 0.2
      },
      uTile: {
        value: new Vector2(1, 0.1)
      },
      uSpeed: {
        value: 0.5
      },
      uHeight: {
        value: 3
      },
      uGrain: {
        value: 0.1
      },
      uGradientStep: {
        value: 0.817
      },
      uGradientRange: {
        value: new Vector2(0.27, 1)
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      },
      uFade: {
        value: new Vector2(0.7, 0.2)
      }
    });
    _this.startRender(_ => {
      _shader.uniforms.uTime.value += (1 + ViewController.SPEED_MULTI.value * 2) * 0.015 * Render.HZ_MULTIPLIER;
    });
  });
  Class(function StylizedTextureShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2(0, 0)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#FFFFFF")
      },
      uColor2: {
        value: new Color("#39404B")
      },
      uColor3: {
        value: new Color("#B34E3C")
      },
      uShadowColor: {
        value: new Color("#727C8B")
      },
      uPosterizeTime: {
        value: 12
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedTextureShaderExtra(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2(0, 0)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#FFFFFF")
      },
      uColor2: {
        value: new Color("#39404B")
      },
      uColor3: {
        value: new Color("#B34E3C")
      },
      uColor4: {
        value: new Color("#FFFFFF")
      },
      uShadowColor: {
        value: new Color("#727C8B")
      },
      uPosterizeTime: {
        value: 12
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedWaterShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _clearColor = new Color("#000");
    (async function () {
      _shader.addUniforms({
        uColor1: {
          value: new Color("#2e668c")
        },
        uColor2: {
          value: new Color("#67f1ff")
        },
        uColor3: {
          value: new Color("#c1ffd9")
        },
        tData: {
          value: Utils3D.getTexture("assets/images/shipping/water.png")
        },
        uMirrorDiffuse: {
          value: new Vector3(1, 1, 1)
        },
        uClearColor: {
          value: _clearColor
        },
        uWave: {
          value: new Vector3(1, 1, 1)
        },
        uDirection: {
          value: 0
        },
        uScale: {
          value: 1
        },
        uStep: {
          value: 1
        },
        uGrain: {
          value: 0.35
        },
        uGrainReduce: {
          value: 0.5
        },
        uTime: {
          value: 0
        },
        uPosterizeTime: {
          value: 12
        }
      });
      _this.startRender(_ => {
        _shader.uniforms.uTime.value += (1 + ViewController.SPEED_MULTI.value * 3) * 0.015 * Render.HZ_MULTIPLIER;
        let camera = _this.parent.parent.nuke.camera;
        if (_this.mirror) {
          _this.mirror.useCamera(camera);
        }
      });
      let camera = _this.parent.parent.nuke.camera;
      let nuke = _this.parent.parent.nuke;
      _this.mirror = _this.initClass(FX.Mirror, _mesh, {
        nuke: nuke,
        camera: camera,
        size: 1024,
        enabled: true
      });
      _this.mirror.clearColor = _clearColor;
      _shader.uniforms.tMirrorReflection.ignoreUIL = true;
      let layers = await _this.parent.getAllLayers();
      let exclude = (_input.get("wildcard") || "").split(",").map(name => name.trim());
      for (let id in layers) {
        if (!id.trim().includes(exclude) && !layers[id].isGroup && !layers[id].isTweenAnchor) {
          let layer = layers[id];
          if (layer.instanceMeshReady) {
            layer.instanceMeshReady.then(_ => {
              _this.mirror.add(layer.instanceMesh);
            });
          } else if (layer.clone) {
            _this.mirror.add(layer);
          }
        }
      }
      _this.mirror.start();
    })();
  });
  Class(function TextureShader(_mesh, _shader) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uAlpha: {
        value: 1
      },
      transparent: true
    });
  });
  Class(function TilingSkyShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uTile: {
        value: new Vector4()
      }
    });
  });
  Class(function WaterShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2()
      },
      uColor0: {
        value: new Color()
      },
      uColor1: {
        value: new Color()
      },
      uParams: {
        value: new Vector4()
      },
      uStep: {
        value: 0.5
      }
    });
  });
  Class(function AnimatedBird(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tAnimation: {
        value: null
      }
    });
  });
  Class(function Bird(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      (async function initScene() {
        _this.layout = _this.initClass(SceneLayout, "birdlayout");
      })();
    })();
  });
  Class(function BirdFlockLayout() {
    Inherit(this, Object3D);
    const _this = this;
    var _flock1;
    var _flock2;
    var _flock3;
    var _flock4;
    (async function () {
      if (Tests.hasBirds()) {
        await async function initScene() {
          if (!_this) {
            return;
          }
          _this.layout = _this.initClass(SceneLayout, "birdflocklayout_flocking");
          await _this.layout.getAllLayers();
          _flock1 = _this.layout.layers.flock_1;
          _flock2 = _this.layout.layers.flock_2;
          _flock3 = _this.layout.layers.flock_3;
          _flock4 = _this.layout.layers.flock_4;
          _flock1.shader.visible = false;
          _flock2.shader.visible = false;
          _flock3.shader.visible = false;
          _flock4.shader.visible = false;
          let proton = _this.layout.layers.particles;
          await proton.ready();
          proton.behavior.shader.addUniforms({
            uFlock1: {
              value: new Vector3()
            },
            uFlock2: {
              value: new Vector3()
            },
            uFlock3: {
              value: new Vector3()
            },
            uFlock4: {
              value: new Vector3()
            }
          });
          _this.proton = proton;
          proton.behavior.shader.uniforms.uFlock1.value = _flock1.position;
          proton.behavior.shader.uniforms.uFlock2.value = _flock2.position;
          proton.behavior.shader.uniforms.uFlock3.value = _flock3.position;
          proton.behavior.shader.uniforms.uFlock4.value = _flock4.position;
        }();
        _this.startRender(_ => {
          _flock1.position.z = Math.sin(Render.TIME * -0.00015 + 0.5) * 20;
          _flock1.position.x = Math.cos(Render.TIME * -0.00015 + 0.5) * 28;
          _flock2.position.z = Math.sin(Render.TIME * -0.00015 + 1) * 22;
          _flock2.position.x = Math.cos(Render.TIME * -0.00015 + 1) * 25;
          _flock3.position.z = Math.sin(Render.TIME * 0.00015 + 1.5) * 22;
          _flock3.position.x = Math.cos(Render.TIME * 0.00015 + 1.5) * 28;
          _flock4.position.z = Math.sin(Render.TIME * 0.00015 + 0.75) * 25;
          _flock4.position.x = Math.cos(Render.TIME * 0.00015 + 0.75) * 25;
        });
      }
    })();
  });
  Class(function InstancedBirds(_proton, _group) {
    Inherit(this, Object3D);
    const _this = this;
    (async function initMesh() {
      _proton.antimatter.storeVelocity = true;
      let birdGeometry = await GeomThread.loadGeometry("assets/geometry/birds/simplebird2.json");
      let geom = new Geometry().instanceFrom(birdGeometry);
      _proton.applyToInstancedGeometry(geom);
      let shader = _this.initClass(Shader, "InstancedBirdParticles", {
        tAnimation: {
          value: Utils3D.getLookupTexture("assets/images/birds/birdanimation.jpg")
        },
        uColor1: {
          value: new Color()
        },
        uColor2: {
          value: new Color()
        },
        uAltColor1: {
          value: new Color()
        },
        uAltColor2: {
          value: new Color()
        },
        uEnabled: {
          value: 0
        }
      });
      _this.shader = shader;
      ShaderUIL.add(shader, _group).setLabel("Shader");
      _proton.applyToShader(shader);
      let mesh = new Mesh(geom, shader);
      mesh.frustumCulled = false;
      _this.add(mesh);
    })();
  });
  Class(function InteractivePage(_name = Utils.query("name"), isFirst = false) {
    Inherit(this, Element);
    Inherit(this, FXScene);
    Inherit(this, GLUIToRT);
    const _this = this;
    const $this = _this.element;
    var _transitionShader;
    var _config = Config.PAGE[_name];
    var _views = [];
    var _hideCall = null;
    function loop() {
      if (_this.smooth) {
        let delta = _this.smooth.smooth.progress - _this.previous;
        delta = Math.clamp(-0.2, 0.2, delta * 10);
        _transitionShader.uniforms.uScrollDelta.value = 1 + delta;
        _this.previous = _this.smooth.smooth.progress;
      }
    }
    function onLogoClick() {
      if (_this.smooth) {
        _this.smooth.smooth.scroll = 0;
      }
    }
    _this.hasScene = true;
    _this.name = _name;
    _this.promise = Promise.create();
    _this.previous = 0;
    (async function () {
      if (_name == "home") {
        _config = [...Config.PAGE.chapter1, ...Config.PAGE.chapter2, ...Config.PAGE.chapter3];
      }
      (function initHTML() {
        $this.css({
          width: "100vw",
          overflow: "hidden"
        });
      })();
      (function initScene() {
        _this.create(RTPool.instance().getRT());
      })();
      await function initViews() {
        if (!_config) {
          return;
        }
        _config.forEach((section, index) => {
          let view;
          if (section.layout) {
            view = _this.initClass(section.layout, index, section, isFirst);
          } else {
            let existing = ViewCache[section.layoutName];
            if (existing) {
              view = existing;
            } else {
              view = _this.initClass(InteractiveSection, section.layoutName, index, section, isFirst);
              ViewCache[section.layoutName] = view;
            }
          }
          if (!view.ui) {
            if (section.ui) {
              view.ui = _this.initClass(section.ui, [$this]);
              view.ui.parent = _this;
            } else {
              view.ui = _this.initClass(InteractiveUI, {
                height: section.height || 1
              }, [$this]);
              view.ui.parent = _this;
            }
          }
          _views.push(view);
        });
        return Promise.all(_views.map(view => view.ready));
      }();
      (function addListeners() {
        _this.events.sub(NavigationHeader.LOGO_CLICK, onLogoClick);
      })();
      _this.promise.resolve();
      _this.startRender(loop);
    })();
    _this.get("views", _ => _views);
    _this.show = async function () {
      return new Promise(async resolve => {
        if (_hideCall) {
          clearTimeout(_hideCall);
          _hideCall = null;
        }
        if (!Global.PLAYGROUND) {
          PageUIController.instance().$container.add($this);
        }
        _views.forEach(view => {
          view.parent = _this;
          if (view.ui) {
            $this.add(view.ui);
            view.ui.parent = _this;
          }
        });
        if (!_this.smooth) {
          (function initSmooth() {
            if (_config) {
              _this.smooth = SmoothRenderManager.createLocal();
              _transitionShader = _this.initClass(Shader, "ViewControllerTransition", {
                tMap1: {
                  value: null
                },
                tMap2: {
                  value: null
                },
                uRatio: {
                  value: Stage.width / Stage.height
                },
                uScrollDelta: {
                  value: 1
                },
                uTransition: {
                  value: 0
                }
              });
              _this.smooth.initialize(_this, _transitionShader, {
                container: PageUIController.instance().$container,
                smoothScroll: Tests.useSmoothScroll(),
                pingPong: Tests.pingPongSections()
              });
            }
          })();
        }
        _this.smooth?.show(_this);
        if (_this.animateIn) {
          await _this.animateIn();
        }
        resolve();
      });
    };
    _this.hide = async function () {
      return new Promise(async resolve => {
        if (_this.animateOut) {
          await _this.animateOut();
        }
        _views.forEach(view => {
          view.hide(true);
        });
        if (_this.smooth) {
          _this.smooth.hide();
        }
        _hideCall = _this.delayedCall(() => {
          _this.visible = false;
          PageUIController.instance().$container.removeChild($this);
          _hideCall = null;
        }, 600);
        resolve();
      });
    };
    _this.ready = function () {
      return _this.promise;
    };
  });
  Class(function InteractivePageWrapper(_clazz = "", isFirst = false) {
    Inherit(this, Object3D);
    const _this = this;
    var _view;
    _view = _this.initClass(_clazz, isFirst);
    _this.show = function () {
      if (_view) {
        _view.show();
      }
    };
    _this.hide = function () {
      if (_view) {
        _view.hide();
      }
    };
    _this.get("view", () => _view);
    _this.set("visible", v => {
      _this.group.visible = v;
      if (_view) {
        _view.visible = v;
      }
    });
  });
  Class(function InteractiveScrollPage(_name = Utils.query("name"), isFirst = false) {
    Inherit(this, Element);
    Inherit(this, FXScene);
    Inherit(this, GLUIToRT);
    const _this = this;
    const $this = _this.element;
    const EXCLUDED = ["camera", "bg"];
    var _views = [];
    _this.glSceneEnabled = true;
    _this.hasScene = true;
    _this.name = _name;
    _this.promise = Promise.create();
    (async function () {
      GLSEO.registerPage(_this, _this.name);
      (function initHTML() {
        $this.css({
          width: "100%"
        });
      })();
      (async function initScene() {
        _this.create();
        _this.layout = _this.initClass(SceneLayout, _name);
        _this.scene.add(_this.layout.group);
        _this.layers = await _this.layout.getAllLayers();
        (function setupBg() {
          _this.bg = _this.layers.bg;
          if (_this.bg) {
            _this.bg.frustumCulled = false;
          }
        })();
        (function setupCamera() {
          if (_this.layers.camera) {
            _this.camera = _this.layers.camera;
            _this.camera.lerp = Device.mobile ? 0.5 : 0.2;
            Object.keys(_this.layers).forEach(async (key, index) => {
              if (!EXCLUDED.includes(key)) {
                let hit = await _this.layers[key].hit;
                if (!hit) {
                  return;
                }
                hit.color = _this.layers[key].color;
                hit.parentRef = _this.layers[key];
                _views.push(hit);
                _this.camera.observe(hit, async visible => {
                  await _this.wait(100);
                  if (visible) {
                    _this.events.fire("LayerVisible", {
                      key: key
                    });
                    _this.layers[key].onVisible();
                  } else {
                    _this.layers[key].onInvisible();
                  }
                });
                let colorHit = await _this.layers[key].colorHit;
                if (!colorHit) {
                  return;
                }
                colorHit.parentRef = _this.layers[key];
                _this.camera.observe(colorHit, async visible => {
                  await _this.wait(100);
                  if (visible) {
                    _this.layers[key].onColorHitVisible();
                  }
                });
              }
            });
            if (_this.isPlayground()) {
              _this.show();
            }
          }
          _this.flag("cameraReady", true);
        })();
        _this.promise.resolve();
        if (isFirst) {
          await Initializer3D.uploadAll(_this.layout);
          _this.events.fire(InteractiveSection.INITIAL_LOADED);
        }
      })();
      _this.displayGLUI(true);
    })();
    _this.onVisible = () => {
      GLUI.Scene.camera = _this.nuke.camera;
    };
    _this.onInvisible = () => {};
    _this.get("views", _ => _views);
    _this.show = async function () {
      await _this.promise;
      if (!Global.PLAYGROUND) {
        PageUIController.instance().$container.add($this);
      }
      _this.gluiToScreen();
      if (_this.animateIn) {
        await _this.animateIn();
      }
      if (_this.camera) {
        _this.useCamera(_this.camera.baseCamera);
      }
      _this.onVisible();
    };
    _this.hide = async function () {
      _this.gluiToRT();
      _this.delayedCall(() => {
        _views.forEach(view => {
          if (view.parentRef && view.parentRef.hide) {
            view.parentRef?.hide();
          }
        });
        _this.visible = false;
        _this.camera.reset();
        _views.forEach(view => {
          if (view.parentRef && view.parentRef.reset) {
            view.parentRef.reset();
          }
        });
      }, 600);
      PageUIController.instance().$container.removeChild($this);
    };
    _this.ready = function () {
      return _this.promise;
    };
  });
  Class(function InteractiveScrollSection(_input) {
    Inherit(this, Object3D);
    const _this = this;
    const OPTION_MAP = {
      title: {
        width: 2,
        size: 0.28,
        position: new Vector3(0, 0.2, 0)
      },
      paragraph: {
        width: 1.3
      },
      landscapeMobile: {
        title: {
          width: 2,
          size: 0.4,
          position: new Vector3(0, 0.35, 0)
        }
      }
    };
    var _name;
    var _hit;
    var _colorHit;
    var _video;
    var _texts = [];
    var _others = [];
    async function resize() {
      await _this.wait(_this, "isReady");
      if (SceneLayout.breakpoint == "portrait" || Device.mobile.phone && Stage.height > Stage.width) {
        _texts.forEach(async text => {
          let props = {
            align: "center"
          };
          let settings = OPTION_MAP[text.type];
          if (settings) {
            props = {
              ...props,
              ...settings
            };
          }
          await text.text.loaded();
          await text.text.text.ready();
          text.setPropertiesCheck(props, true);
        });
        _this.layers.text1.group.position.copy(OPTION_MAP.title.position);
      } else if (Stage.height < 450 && Stage.width >= Stage.height) {
        _texts.forEach(async text => {
          let props = {
            align: "center"
          };
          let settings = OPTION_MAP.landscapeMobile[text.type];
          if (settings) {
            props = {
              ...props,
              ...settings
            };
          }
          await text.text.loaded();
          await text.text.text.ready();
          text.setPropertiesCheck(props, true);
        });
        _this.layers.text1.group.position.copy(OPTION_MAP.landscapeMobile.title.position);
      } else {
        _texts.forEach(text => {
          let props = text.originalSettings;
          text.setPropertiesCheck(props, true);
        });
        _this.layers.text1.group.position.set(0, 0, 0);
      }
    }
    (async function () {
      await async function init() {
        _name = _input && _input instanceof InputUILConfig ? _input.get("wildcard") : _input || Utils.query("name");
        if (_name != "section1") {
          return;
        }
        _this.config = Config.TECHNOLOGY[_name];
        _this.layout = _this.initClass(SceneLayout, _name);
        _this.layers = await _this.layout.getAllLayers();
        _this.color = new Color();
        _this.color.setHex(Colors.hex[_this.config?.bg] || Colors.hex.black);
        _this.colorValue = Colors.value[_this.config?.bg] || Colors.hex.black;
        Object.keys(_this.layers).forEach(async key => {
          let curr = _this.layers[key];
          if (key.includes("text")) {
            if (_this.config.data[key]) {
              _this.flag("shouldWaitForTexts", true);
              await curr.ready();
              curr.setText(_this.config.data[key]);
              curr.shader.set("uTransition0", 0);
            }
            curr.originalSettings = {
              ...curr.fontObject
            };
            curr.type = curr.wildcard;
            _texts.push(curr);
          } else {
            _others.push(curr);
          }
        });
        if (_this.layout.exists("video")) {
          let videoLayer = await _this.layout.getLayer("video");
          _video = videoLayer.scriptClass;
        }
        (function initHits() {
          let shader = _this.initClass(Shader, "InteractiveScrollSectionHitShader");
          shader.depthWrite = false;
          shader.depthTest = false;
          shader.transparent = true;
          shader.blending = Shader.ADDITIVE_BLENDING;
          (_hit = new Mesh(World.PLANE, shader)).scale.setScalar(2);
          _hit.shader.transparent = true;
          _hit.renderOrder = -9999;
          _hit.position.y = 0;
          _this.add(_hit);
          (_colorHit = new Mesh(World.PLANE, shader)).scale.setScalar(0.001);
          _colorHit.shader.transparent = true;
          _colorHit.renderOrder = -1000;
          _colorHit.position.y = -1;
          _this.add(_colorHit);
        })();
        await defer();
        if (_this.flag("shouldWaitForTexts")) {
          await _this.wait(_ => _texts.length > 0);
        }
        _this.flag("isReady", true);
        if (_this.isPlayground()) {
          await defer();
          _this.onVisible();
        }
      }();
      if (_name == "section1") {
        await defer();
        (function addListeners() {
          _this.onResize(resize);
        })();
      }
    })();
    _this.get("hit", async () => {
      await _this.wait(_this, "isReady");
      return _hit;
    });
    _this.get("colorHit", () => _colorHit);
    _this.onInvisible = () => {
      if (_this.shown) {
        _this.shown = false;
        if (_video) {
          _video.stop();
        }
      }
    };
    _this.onVisible = () => {
      if (!_this.shown) {
        _this.shown = true;
        if (_video) {
          if (!_this.animatedIn) {
            _video.show();
          }
          _video.start();
        }
        if (_this.animateIn) {
          _this.animateIn();
        }
        if (!_this.animatedIn) {
          (async function animateIn() {
            await _this.wait(_this, "isReady");
            _texts.forEach((text, index) => {
              if (text.shaderClass && text.shaderClass.animateIn) {
                text.shaderClass.animateIn(index * 300);
              } else {
                console.warn("Text missing WaveTextShader shader class");
              }
            });
            _others.forEach((layer, index) => {
              if (layer.shaderClass?.animateIn) {
                layer.shaderClass.animateIn(index * 300);
              }
            });
          })();
          _this.animatedIn = true;
        }
      }
    };
    _this.hide = () => {
      if (_this.animateOut) {
        _this.animateOut();
      }
      _this.delayedCall(() => {
        (function animateOut() {
          _texts.forEach((text, index) => {
            if (text.shaderClass && text.shaderClass.animateOut) {
              text.shaderClass.animateOut(0);
            } else {
              console.warn("Text missing WaveTextShader shader class");
            }
          });
        })();
      }, 600);
      if (_video) {
        _video.hide();
      }
      _this.animatedIn = false;
      _this.shown = false;
    };
    this.onColorHitVisible = function () {
      if (this.colorValue == Colors.value.beige) {
        NavigationHeader.instance().changeColor(Colors.value.black);
      } else {
        NavigationHeader.instance().changeColor(Colors.value.beige);
      }
    };
    _this.reset = function () {
      _texts.forEach(text => {
        text.shader.set("uTransition0", 0);
      });
    };
  });
  Class(function InteractiveSection(name = Utils.query("name"), index = -1, parentConfig, isParentFirst) {
    Inherit(this, FXScene);
    Inherit(this, GLUIToRT);
    const _this = this;
    var _layers;
    var _cover;
    var _camera;
    var _startCamera;
    var _endCamera;
    var _controller;
    var _desktopStartCamera;
    var _desktopEndCamera;
    var _cameraTransition;
    var _scroll;
    var _cameraWrap;
    var _camGroup;
    var _config;
    var _original;
    var _dashboard;
    var _instruction;
    var _direction = 1;
    var _progress = 0;
    var _animLerp = 0.07;
    var _lerp = 0.07;
    var _texts = [];
    var _isFirstFrame = true;
    Utils.query("lerpTheatre");
    _this.start = 0;
    _this.height = 0;
    _this.progress = 0;
    _this.name = name;
    _this.direction = 1;
    _this.promise = Promise.create();
    _this.bloom = parentConfig?.bloom || 0;
    var _gluiScene = new Scene();
    function drawGLUI() {
      GLUI.Stage.renderToRT(_gluiScene, _this.rt);
    }
    function getCameraSuffix() {
      let aspect = Stage.width < Stage.height ? "portrait" : "landscape";
      if (Device.mobile.phone && parentConfig?.mobileCameras && aspect === "portrait" || Hydra.LOCAL && Utils.query("isMobile")) {
        return "Mobile";
      } else {
        return "";
      }
    }
    function reset() {
      if (_cameraWrap && _original) {
        _cameraWrap.position.lerp(_original.position, 1, false);
        _cameraWrap.quaternion.slerp(_original.quaternion, 1, false);
      }
      _this.progress = 0;
      _this.direction = 1;
      _progress = 0;
      _direction = 1;
      if (_this.layout) {
        _this.layout.timeline.elapsed = 0;
      }
      if (_cameraTransition) {
        _controller.destroy();
        (_controller = Camera.instance().createLocal()).name = name;
        ({
          ..._startCamera
        }).lock(_controller);
        _controller.worldCamera.fov = {
          ..._endCamera
        }.getFOV();
        if (!Utils.query("orbit")) {
          _this.useCamera(_controller.worldCamera);
        }
        (_cameraTransition = {
          ..._endCamera
        }.manualTransition(_controller)).value = 0;
        _cameraTransition.direction = "end";
        let near = parentConfig?.near ? parentConfig.near : 1;
        CameraUtil.addCamera(_controller.worldCamera, near);
      }
    }
    async function resize() {
      if (Utils.query("cameraMode") || _this.flag("isResizing")) {
        return;
      }
      await _this.wait(_this, "cameraSet");
      _this.flag("isResizing", true);
      let mode = "";
      mode = SceneLayout.breakpoint == "portrait" && Device.mobile ? "mobile" : "desktop";
      mode;
      if (_cameraTransition) {
        let aspect = Stage.width < Stage.height ? "portrait" : "landscape";
        if (aspect !== _this.flag("aspect")) {
          let isMobile = getCameraSuffix();
          _desktopStartCamera.prefix = `${name}_startCamera${isMobile}`;
          _desktopEndCamera.prefix = `${name}_endCamera${isMobile}`;
          _this.flag("aspect", aspect);
        }
        CameraUIL.add(_desktopStartCamera, null);
        CameraUIL.add(_desktopEndCamera, null);
        let progress = _progress;
        await defer();
        await defer();
        _startCamera = _desktopStartCamera;
        _endCamera = _desktopEndCamera;
        reset();
        _progress = progress;
        _this.progress = progress;
      }
      _this.flag("needsCameraUpdate", true);
      _this.flag("isResizing", false);
    }
    function loop() {
      let last = _progress;
      if (Global.PLAYGROUND) {
        _this.progress = _this.layout.timeline.elapsed;
      }
      _progress = index == 0 || index == 15 ? Math.range(_this.progress, 0.1, 1, 0, 1, true) : Math.clamp(_this.progress, 0, 1);
      _this.direction = _progress < last ? -1 : 1;
      if (_cameraTransition) {
        if (_direction != _this.direction || _this.flag("needsCameraUpdate")) {
          let direction = _this.direction == 0 || _this.direction == 1 ? "end" : "start";
          if (_cameraTransition.direction != direction) {
            if (_this.direction >= 0) {
              (_cameraTransition = {
                ..._endCamera
              }.manualTransition(_controller)).value = 0;
              _cameraTransition.direction = "end";
            } else {
              (_cameraTransition = {
                ..._startCamera
              }.manualTransition(_controller)).value = 0;
              _cameraTransition.direction = "start";
            }
            _endCamera.camera.applyFOV();
            _startCamera.camera.applyFOV();
          }
          _direction = _this.direction;
          _this.flag("needsCameraUpdate", false);
        }
        _cameraTransition.value = _direction >= 0 ? _progress : 1 - _progress;
      }
      if (_camGroup && _cameraWrap) {
        _lerp = _isFirstFrame ? 1 : _animLerp;
        _cameraWrap.position.lerp(_camGroup.position, _lerp, false);
        _cameraWrap.quaternion.slerp(_camGroup.quaternion, _lerp, false);
        _isFirstFrame = false;
      }
      _texts.forEach(text => {
        text.update(_progress);
        if (_progress >= text.start && _progress <= text.end) {
          text.animateIn();
        } else {
          text.animateOut();
        }
      });
      if (_dashboard) {
        _dashboard.update(_progress);
        if (_progress >= _dashboard.start && _progress <= _dashboard.end) {
          _dashboard.animateIn();
        } else {
          _dashboard.animateOut();
        }
      }
      if (_scroll) {
        _scroll.update(_progress);
        if (_progress >= _scroll.start && _progress <= _scroll.end) {
          _scroll.animateIn();
        } else {
          _scroll.animateOut();
        }
      }
      if (_instruction) {
        _instruction.update(_progress);
        if (_progress >= _instruction.start && _progress <= _instruction.end) {
          _instruction.animateIn();
        } else {
          _instruction.animateOut();
        }
      }
      if (_layers.title && _layers.title.text && name == "carflyaround") {
        _layers.title.text.alpha = Math.smoothStep(0.3, 0.2, _progress);
      }
      if (_layers.chapter && _layers.chapter.text && name == "carflyaround") {
        _layers.chapter.text.alpha = Math.smoothStep(0.3, 0.2, _progress);
      }
      if (name == "ch3newlanding") {
        let layers = ["car", "cargroup", "carshadow"];
        layers.forEach(l => {
          let layer = _layers[l];
          if (layer) {
            let move = layer.position || layer.group.position;
            layer.oPos ||= new Vector3().copy(move);
            move.z = Math.range(_progress, 0, 1, layer.oPos.z - 0.5, layer.oPos.z + 28.5);
          }
        });
        layers = ["trail1", "trail2", "trail3"];
        layers.forEach(l => {
          let layer = _layers[l];
          layer.shader.set("uHeight", Math.range(_progress, 0.1, 0.4, 4, 1.5, true));
          layer.oScale ||= layer.scale.y;
          layer.scale.y = Math.range(_progress, 0.1, 0.4, layer.oScale, layer.oScale * 2, true);
        });
      }
      if (_layers.price && _layers.price.text && name == "gasstation3") {
        let number = Math.range(ViewController.SPEED_MULTI.value, 0, 1, 0, 16).toFixed(1);
        _layers.price.text.setText(number);
      }
      _this.layout.timeline.elapsed = _progress;
      _this.layout.timeline.update();
      if (_this.theatre) {
        _this.theatre.seek(_progress);
      }
    }
    _this.$glWrapper = $gl();
    _gluiScene.add(_this.$glWrapper.group);
    (async function () {
      GLSEO.registerPage(_this, name);
      if (!name.match("menu")) {
        GLSEO.registerPage(_this.$glWrapper, `${name}__glui`);
      }
      _this.visible = false;
      _this.glui.group.visible = false;
      _this.$glWrapper.group.visible = false;
      _this.create(RTPool.instance().getRT());
      await async function initLayout() {
        _cover = new Mesh(World.QUAD, _this.initClass(Shader, "InteractiveSectionCover", {
          tMap: {
            value: LoaderCoverView.instance().rt
          },
          uAlpha: {
            value: 1
          },
          transparent: true,
          depthWrite: false
        }));
        _this.scene.add(_cover);
        let immediate = index == 0;
        let resolveQueue = Global.PLAYGROUND ? null : await Initializer3D.queue(immediate);
        let perFrame = resolveQueue && !immediate ? 2 : undefined;
        _this.layout = _this.initClass(SceneLayout, name, {
          timeline: new TweenTimeline(),
          perFrame: perFrame
        });
        _this.scene.add(_this.layout.group);
        _layers = await _this.layout.getAllLayers();
        _camera = _layers.cinemaCamera || _layers.sceneCamera;
        _this.layers = _layers;
        (function initText() {
          _texts = [];
          if (parentConfig) {
            if (parentConfig.text) {
              parentConfig.text.forEach(config => {
                config.height = parentConfig.height;
                if (parentConfig.dashboard && Device.mobile.phone) {
                  config.top = true;
                }
                let text = _this.initClass(ChapterCopy, config);
                _this.$glWrapper.add(text.element);
                text.start = config.start;
                text.end = config.end;
                _texts.push(text);
                if (config.isA11Y) {
                  text.element.alpha = 0.001;
                }
              });
            }
            if (parentConfig.landingCopy) {
              parentConfig.landingCopy.forEach(config => {
                config.height = parentConfig.height;
                config.dashboard = parentConfig.dashboard;
                let text = _this.initClass(LandingCopy, config);
                _this.$glWrapper.add(text.element);
                text.start = config.start;
                text.end = config.end;
                _texts.push(text);
              });
            }
            if (parentConfig.instruction) {
              parentConfig.instruction.height = parentConfig.height;
              (_instruction = _this.initClass(Instruction, parentConfig.instruction)).start = parentConfig.instruction.start;
              _instruction.end = parentConfig.instruction.end;
              _this.$glWrapper.add(_instruction.element);
            }
            if (parentConfig.scroll) {
              parentConfig.scroll.height = parentConfig.height;
              (_scroll = _this.initClass(ScrollPrompt, parentConfig.scroll)).start = parentConfig.scroll.start;
              _scroll.end = parentConfig.scroll.end;
              _this.$glWrapper.add(_scroll.element);
            }
            if (parentConfig.dashboard) {
              parentConfig.dashboard.height = parentConfig.height;
              (_dashboard = _this.initClass(DashboardOverlay, parentConfig.dashboard)).start = parentConfig.dashboard.start;
              _dashboard.end = parentConfig.dashboard.end;
              _this.$glWrapper.add(_dashboard.element);
            }
          }
        })();
        if (_camera && !Utils.query("orbit")) {
          (function initCameraWrap() {
            _camGroup = _camera.group._parent;
            _original = _camGroup.clone();
            (_cameraWrap = new Group()).add(_camera.group);
            _this.layout.add(_cameraWrap);
            _this.useCamera(_camera);
            let near = parentConfig?.near ? parentConfig.near : 1;
            CameraUtil.addCamera(_camera.camera, near);
            (_config = InputUIL.create(name + "_scroll")).setLabel("Animation Lerp");
            _config.add("lerp", 0.07);
            _animLerp = _config.getNumber("lerp") || 0.07;
            _this.flag("cameraSet", true);
          })();
        }
        if (!Global.PLAYGROUND) {
          await Initializer3D.detectUploadAll(_this.layout, immediate, resolveQueue);
        }
        _cover.shader.tween("uAlpha", 0, 300, "easeOutCubic");
        _this.theatre = TweenUIL.create(`${name}_theatre`, _this.layout);
        if (_this.layers.tween_anchor) {
          await _this.theatre.preload();
        }
        if (isParentFirst && index == 0) {
          _this.events.fire(InteractiveSection.INITIAL_LOADED);
        }
        _this.flag("isReady", true);
      }();
      if (!_camera) {
        (async function createCameras() {
          await _this.wait(_this, "isReady");
          if (!Utils.query("cameraMode")) {
            "desktop";
          }
          _desktopStartCamera = _this.initClass(GazeCamera);
          _desktopEndCamera = _this.initClass(GazeCamera);
          let isMobile = getCameraSuffix();
          _desktopStartCamera.prefix = `${name}_startCamera${isMobile}`;
          _desktopEndCamera.prefix = `${name}_endCamera${isMobile}`;
          CameraUIL.add(_desktopStartCamera);
          CameraUIL.add(_desktopEndCamera);
          await defer();
          _startCamera = _desktopStartCamera;
          _endCamera = _desktopEndCamera;
          (_controller = Camera.instance().createLocal()).name = name;
          ({
            ..._startCamera
          }).lock(_controller);
          let near = parentConfig?.near ? parentConfig.near : 1;
          CameraUtil.addCamera(_controller.worldCamera, near);
          CameraUtil.addCamera(_startCamera.camera, near);
          CameraUtil.addCamera(_endCamera.camera, near);
          if (!Utils.query("orbit")) {
            _this.useCamera(_controller.worldCamera);
          }
          (_cameraTransition = {
            ..._endCamera
          }.manualTransition(_controller)).direction = "end";
          _this.flag("cameraSet", true);
        })();
      }
      if (Global.PLAYGROUND) {
        _this.startRender(loop);
        _this.visible = true;
      }
      (function addListeners() {
        _this.onResize(resize);
      })();
      if (!Tests.generatePreview()) {
        _this.startRender(drawGLUI, _this);
      }
      _this.promise.resolve();
    })();
    _this.onVisible = function () {};
    _this.onInvisible = function () {};
    _this.update = function () {
      loop();
    };
    _this.show = async function () {
      if (!_this.isVisible) {
        _this.isVisible = true;
        if (Device.mobile) {
          (function extraReset() {
            if (_cameraTransition) {
              _controller.destroy();
              (_controller = Camera.instance().createLocal()).name = name;
              if (_this.direction >= 0) {
                ({
                  ..._startCamera
                }).lock(_controller);
                if (!Utils.query("orbit")) {
                  _this.useCamera(_controller.worldCamera);
                }
                (_cameraTransition = {
                  ..._endCamera
                }.manualTransition(_controller)).value = 0;
                _cameraTransition.direction = "end";
              } else {
                ({
                  ..._endCamera
                }).lock(_controller);
                if (!Utils.query("orbit")) {
                  _this.useCamera(_controller.worldCamera);
                }
                (_cameraTransition = {
                  ..._startCamera
                }.manualTransition(_controller)).value = 0;
                _cameraTransition.direction = "start";
              }
              _endCamera.camera.applyFOV();
              _startCamera.camera.applyFOV();
              let near = parentConfig?.near ? parentConfig.near : 1;
              CameraUtil.addCamera(_controller.worldCamera, near);
            }
          })();
        }
        _this.visible = true;
        _this.glui.group.visible = true;
        _this.glui.alpha = 1;
        _this.$glWrapper.group.visible = true;
        _this.$glWrapper.alpha = 1;
        if (_camera) {
          _camera.visible = true;
        }
        _this.gluiToRT();
        await defer();
        _this.delayedCall(() => {
          _this.gluiToScreen();
        }, 800);
        await _this.wait(_this, "isReady");
        if (_this.ui && _this.ui.setVisibility) {
          _this.ui.setVisibility(true);
        }
        if (_this.ui && _this.ui.animateIn) {
          _this.ui.animateIn();
        }
        if (_this.animateIn) {
          _this.animateIn();
        }
        _this.startRender(loop);
        ViewController.BLOOM_EXTRA = _this.bloom;
      }
    };
    _this.hide = async function (invokedByParent) {
      if (_this.isVisible) {
        _this.isVisible = false;
        _this.stopRender(loop);
        if (_camera) {
          _camera.visible = false;
        }
        _this.gluiToRT();
        if (_this.ui && _this.ui.animateOut) {
          await _this.ui.animateOut();
        }
        if (_this.animateOut) {
          _this.animateOut();
        }
        if (invokedByParent) {
          _this.delayedCall(() => {
            reset();
            _this.visible = false;
            _this.glui.group.visible = false;
            _this.$glWrapper.group.visible = false;
          }, 600);
        } else {
          _this.visible = false;
          _this.glui.group.visible = false;
          _this.$glWrapper.group.visible = false;
        }
        if (_this.ui && _this.ui.setVisibility) {
          _this.ui.setVisibility(false);
        }
      } else if (invokedByParent) {
        reset();
      }
    };
    _this.ready = function () {
      return _this.promise;
    };
    _this.get("layers", () => _layers);
  }, () => {
    InteractiveSection.INITIAL_LOADED = "InteractiveSection_initial_loaded";
  });
  Class(function InteractiveUI({
    height = 1
  } = {}) {
    Inherit(this, Element);
    const $this = this.element;
    (function initHTML() {
      $this.css({
        height: `${height}00vh`,
        width: "100%"
      });
    })();
  });
  Class(function InteractiveScrollPageBgShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uRange: {
        value: new Vector2(0.35, 0.5)
      },
      uColor1: {
        value: new Color()
      },
      uColor2: {
        value: new Color()
      },
      uTransition: {
        value: 0
      },
      uNoiseScale: {
        value: 0
      },
      uNoiseSpeed: {
        value: 0
      },
      uVelocity: {
        value: 0
      },
      uVelocityMultiplier: {
        value: 3
      },
      uAliasFactor: {
        value: 0.0025
      },
      uBias: {
        value: 0
      },
      uDirection: {
        value: -1
      }
    });
  });
  Class(function InteractiveScrollSectionVideo(_mesh, _shader, _group, _input) {
    Inherit(this, Object3D);
    const _this = this;
    var _videoTexture;
    function handleVideoStart() {
      _this.flag("isInteracted", true);
      _this.events.unsub(Mouse.input, Interaction.START, handleVideoStart);
    }
    (async function () {
      let path = await _input.get("wildcard");
      _videoTexture = _this.initClass(VideoTexture, path, {
        autoplay: false,
        muted: true,
        loop: true
      });
      _shader.set("tMap", _videoTexture);
      (function addListeners() {
        _this.events.sub(Mouse.input, Interaction.START, handleVideoStart);
      })();
    })();
    _this.show = async function (delay = 0) {
      await _shader.tween("uTransition0", 1, 2000, "easeIn", delay).promise();
    };
    _this.hide = async function (delay = 0) {
      await _shader.tween("uTransition0", 0, 300, "easeIn", delay).promise();
    };
    _this.start = async function () {
      if (Device.mobile) {
        await _this.wait("isInteracted");
      }
      _videoTexture.start();
      _videoTexture.video.play();
    };
    _this.stop = function () {
      _videoTexture.video.pause();
    };
  });
  Class(function InteractiveScrollSectionVideoShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      tDimensions: {
        value: new Vector2()
      },
      uAlpha: {
        value: 0
      },
      tNoise: {
        value: Utils3D.getTexture("assets/images/noise/dirnoise3.jpg"),
        ignoreUIL: true
      },
      uTimeScale: {
        value: 0.39
      },
      uUVScale: {
        value: 1.78
      },
      uRotation: {
        value: 0
      },
      uTransition0: {
        value: 0
      }
    });
    this.animateIn = async function (delay = 0) {
      _shader.set("uTransition0", 0);
      await _shader.tween("uTransition0", 1, 2000, "easeIn", delay).promise();
    };
    this.animateOut = async function (delay = 0) {
      await _shader.tween("uTransition0", 0, 300, "easeIn", delay).promise();
    };
  });
  Class(function TestLayout(_name = Utils.query("name")) {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      (async function initScene() {
        _this.layout = _this.initClass(SceneLayout, `testlayout_${_name}`);
        Utils.query("name");
      })();
    })();
  });
  Class(function Campfire() {
    Inherit(this, InteractiveSection, "campfire");
    (async function () {})();
  });
  Class(function Tents() {
    Inherit(this, InteractiveSection, "tents");
    (async function () {})();
  });
  Class(function CampShopSmall() {
    Inherit(this, InteractiveSection, "campshopsmall");
    (async function () {})();
  });
  Class(function Car(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config;
    (async function () {
      let playground = Global.PLAYGROUND === "Car";
      let type = playground ? Utils.query("car") : _input.get("wildcard");
      let noGraph = !!type && !playground;
      type = type ? `car_${type}` : "car";
      _this.layout = _this.initClass(SceneLayout, type, {
        noGraph: noGraph
      });
      (_config = InputUIL.create("car_" + _input.prefix, _group)).setLabel("Car Config");
      _config.addImage("tEnvDiffuse");
      _config.addImage("tEnvSpecular");
      _config.addImage("tLightmap");
      _config.addNumber("uWheelSpeed", 100);
      _config.addNumber("uSaturation", 1);
      _config.addVector("uEnv", [2, 0]);
      _config.addVector("uLight", [1, 1, 2.5, 1]);
      _config.addVector("uWiggle", [0.002, 0, 0, 0]);
      _config.onUpdate = key => {
        let value = _config.get(key);
        if (value) {
          if (Array.isArray(value)) {
            for (let layer in _this.layout.layers) {
              let mesh = _this.layout.layers[layer];
              if (mesh.shader?.uniforms[key]) {
                mesh.shader.uniforms[key].value.fromArray(value);
              }
            }
          } else if (value.includes("{")) {
            value = JSON.parse(value);
            let src = value.src;
            if (src.includes("?") && !data.hotreload) {
              src.split("?")[0];
            }
            if (src?.length) {
              if (value.compressed) {
                src += "-compressedKtx";
              }
              let texture = Utils3D.getTexture(src);
              if (key.includes("tEnv")) {
                texture.generateMipmaps = false;
                texture.minFilter = Texture.LINEAR;
              }
              for (let layer in _this.layout.layers) {
                let mesh = _this.layout.layers[layer];
                if (mesh.shader?.uniforms[key]) {
                  mesh.shader.set(key, texture);
                }
              }
            }
          } else {
            value = JSON.parse(value);
            for (let layer in _this.layout.layers) {
              if (layer.includes("wheel")) {
                let mesh = _this.layout.layers[layer];
                if (mesh.shader?.uniforms[key]) {
                  mesh.shader.uniforms[key].value = value;
                }
              }
            }
          }
        }
      };
      _this.startRender(_ => {
        PBRCarShader.TIME.value += (1 + ViewController.SPEED_MULTI.value * 2) * 0.015 * Render.HZ_MULTIPLIER;
      });
      await _this.layout.loadedAllLayers();
      ["tEnvDiffuse", "tEnvSpecular", "tLightmap", "uEnv", "uLight", "uWiggle", "uWheelSpeed", "uSaturation"].forEach(_config.onUpdate);
    })();
  });
  Class(function CarTransition(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      let inPlayground = Global.PLAYGROUND === "CarTransition";
      let name = `car_transition_${inPlayground && Utils.query("name") ? Utils.query("name") : _input?.get?.("wildcard")}`;
      _this.layout = _this.initClass(SceneLayout, name, {
        noGraph: !inPlayground
      });
      let layers = await _this.layout.getAllLayers();
      layers = Object.values(layers);
      _this.startRender(_ => {
        let progress = _this.shader.uniforms.uProgress.value;
        let speed = _this.shader.uniforms.uWheelSpeed.value;
        layers.map(layer => {
          if (!isNaN(layer.progress)) {
            layer.progress = progress;
          }
          if (!isNaN(layer.wheelSpeed)) {
            layer.wheelSpeed = speed;
          }
        });
      });
    })();
    this.shader = {
      uniforms: {
        uProgress: {
          value: 0
        },
        uWheelSpeed: {
          value: 1
        }
      }
    };
  });
  Class(function PBRCarShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uTime: PBRCarShader.TIME,
      uNoiseStrength: {
        value: 0
      },
      uWheelSpeed: {
        value: 0
      },
      uClearCoat: {
        value: new Vector3(0.6, 0.7, 0)
      },
      uWiggle: {
        value: new Vector4()
      },
      uSaturation: {
        value: 1
      }
    });
  }, _ => {
    PBRCarShader.TIME = {
      value: 1
    };
  });
  Class(function CarFlyAround(index, parentConfig) {
    Inherit(this, InteractiveSection, "carflyaround", index, parentConfig);
    const _this = this;
    function loop() {}
    (async function () {
      await _this.ready();
      (await _this.layout.getLayer("title")).setText(CMS.get("chapters.chapter-1.title"));
      _this.startRender(loop);
    })();
  });
  Class(function CloudCover(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: {
        value: new Color()
      },
      uAlpha: {
        value: 1
      }
    });
  });
  Class(function CarbonCaptureField() {
    Inherit(this, InteractiveSection, "ccfield");
    (async function () {})();
  });
  Class(function Ch1Intro(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch1intro", index, parentConfig);
    const _this = this;
    (async function () {
      await _this.ready();
      (await _this.layout.getLayer("text")).setText(CMS.get("chapters.chapter-1.title"));
    })();
  });
  Class(function Ch3Landing(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3newlanding", index, parentConfig, true);
    const _this = this;
    var _car;
    function loop() {
      _car.position.z = Math.range(_this.layout.timeline.elapsed, 0, 1, _car.start, _car.end);
    }
    (async function () {
      await _this.ready();
      (_car = await _this.layout.getLayer("cargroup")).start = _car.position.z;
      _car.end = _car.start + 19;
      console.log(_car);
      _this.startRender(loop);
    })();
  });
  Class(function Ch3OverFactory(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3landing", index, parentConfig, true);
  });
  Class(function Ch3InsideFactory(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3insidefactory", index, parentConfig);
  });
  Class(function Ch3LoadingDock(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3loadingdock", index, parentConfig);
  });
  Class(function Ch3Caravan(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3caravan", index, parentConfig);
  });
  Class(function Ch3Shipping(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3shipping", index, parentConfig);
  });
  Class(function Ch3Destination(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3destination", index, parentConfig);
  });
  Class(function Ch3Transition(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3ending", index, parentConfig);
  });
  Class(function Ch3Ending(index, parentConfig) {
    Inherit(this, InteractiveSection, "ch3endingsplit", index, parentConfig);
  });
  Class(function ForgeShadows(_mesh, _shader) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null
      },
      uColor: {
        value: new Color("#000000")
      },
      uFeather: {
        value: 0
      },
      uOpacity: {
        value: 1
      },
      uProgress1: {
        value: 1
      },
      uProgress2: {
        value: 1
      },
      uProgress3: {
        value: 1
      },
      uProgress4: {
        value: 1
      },
      transparent: true
    });
  });
  Class(function StylizedEndingRoad(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uStep: {
        value: 0.5
      },
      uTile: {
        value: new Vector2(1, 1)
      },
      uDirection: {
        value: new Vector2(0, 0)
      },
      uGrain: {
        value: 0.15
      },
      uGrainReduce: {
        value: 0
      },
      uHueAdjust: {
        value: 0
      },
      uColor1: {
        value: new Color("#FFFFFF")
      },
      uColor2: {
        value: new Color("#39404B")
      },
      uColor3: {
        value: new Color("#B34E3C")
      },
      uShadowColor: {
        value: new Color("#727C8B")
      },
      uPosterizeTime: {
        value: 12
      },
      uFogParams: {
        value: new Vector2(-10, -200)
      },
      uFogColor: {
        value: new Color("#FFFFFF")
      },
      uFogMix: {
        value: 0
      },
      uWiggle: {
        value: new Vector3()
      },
      uWiggleSpeed: {
        value: 0.1
      },
      uOrigin1: {
        value: new Vector2(0.5, 0.5)
      },
      uOrigin2: {
        value: new Vector2(0.5, 0.5)
      },
      uOrigin3: {
        value: new Vector2(0.5, 0.5)
      },
      uOrigin4: {
        value: new Vector2(0.5, 0.5)
      },
      uProgress1: {
        value: 0
      },
      uProgress2: {
        value: 0
      },
      uProgress3: {
        value: 0
      },
      uProgress4: {
        value: 0
      },
      uTransitionNoise: {
        value: new Vector4(1, 1, 1, 0)
      },
      uScaleAdjust: {
        value: new Vector2(1, 1)
      },
      tBrush: {
        value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
        ignoreUIL: true
      },
      uBrushBlend: {
        value: 0
      },
      uBrushScale: {
        value: new Vector2(1, 1)
      },
      uBrushRotate: {
        value: 0
      }
    });
  });
  Class(function StylizedForgeShader(_mesh, _shader) {
    Inherit(this, Component);
    (function () {
      let lookup = Utils3D.getLookupTexture("assets/images/pbr/lut.png");
      lookup.forcePersist = true;
      _shader.addUniforms({
        uTint: {
          value: new Color("#FFFFFF")
        },
        uTiling: {
          value: new Vector2(1, 1)
        },
        uOffset: {
          value: new Vector2(0, 0)
        },
        uMRON: {
          value: new Vector4(1, 1, 1, 1)
        },
        uEnv: {
          value: new Vector2(1, 0)
        },
        uUseLightmap: {
          value: 0
        },
        uHDR: {
          value: 0,
          ignoreUIL: true
        },
        uUseTonemapping: {
          value: 1,
          ignoreUIL: true
        },
        uUseLinearOutput: {
          value: 0
        },
        tLUT: {
          value: lookup,
          ignoreUIL: true
        },
        tBaseColor: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tMRO: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tNormal: {
          value: null,
          getTexture: Utils3D.getRepeatTexture
        },
        tEnvDiffuse: {
          value: null,
          premultiplyAlpha: false
        },
        tEnvSpecular: {
          value: null,
          premultiplyAlpha: false
        },
        tLightmap: {
          value: null,
          premultiplyAlpha: false
        },
        uClearCoat: {
          value: new Vector3(0.6, 0.7, 0)
        },
        uNoiseStrength: {
          value: 0
        },
        uSaturation: {
          value: 1
        },
        uStep: {
          value: 0.5
        },
        uTile: {
          value: new Vector2(1, 1)
        },
        uDirection: {
          value: new Vector2(0, 0)
        },
        uGrain: {
          value: -0.4
        },
        uGrainReduce: {
          value: 0.77
        },
        uHueAdjust: {
          value: 0
        },
        uColor1: {
          value: new Color("#232743")
        },
        uColor2: {
          value: new Color("#FFFFFF")
        },
        uColor3: {
          value: new Color("#000000")
        },
        uColor4: {
          value: new Color("#2e4e8e")
        },
        uColor5: {
          value: new Color("#724531")
        },
        uColor6: {
          value: new Color("#ac8062")
        },
        uColor7: {
          value: new Color("#423029")
        },
        uColor8: {
          value: new Color("#e1c2b7")
        },
        uApplyPBR: {
          value: 1
        },
        uShadowColor: {
          value: new Color("#454545")
        },
        uPosterizeTime: {
          value: 12
        },
        uFogParams: {
          value: new Vector2(-10, -200)
        },
        uFogColor: {
          value: new Color("#FFFFFF")
        },
        uFogMix: {
          value: 0
        },
        uWiggle: {
          value: new Vector3()
        },
        uWiggleSpeed: {
          value: 0.1
        },
        uOffsetHeight: {
          value: 10
        },
        uIndexRange1: {
          value: new Vector2(0, 0)
        },
        uIndexRange2: {
          value: new Vector2(1, 1)
        },
        uIndexRange3: {
          value: new Vector2(2, 2)
        },
        uIndexRange4: {
          value: new Vector2(3, 3)
        },
        uProgress1: {
          value: 0
        },
        uProgress2: {
          value: 0
        },
        uProgress3: {
          value: 0
        },
        uProgress4: {
          value: 0
        },
        tBrush: {
          value: Utils3D.getRepeatTexture("assets/images/noise/brushstroke.jpg"),
          ignoreUIL: true
        },
        uBrushBlend: {
          value: 0
        },
        uBrushScale: {
          value: new Vector2(1, 1)
        },
        uBrushRotate: {
          value: 0
        }
      });
    })();
  });
  Class(function Distill() {
    Inherit(this, InteractiveSection, "distill");
    (async function () {})();
  });
  Class(function Fan() {
    Inherit(this, InteractiveSection, "fanscene");
    (async function () {})();
  });
  Class(function Fan2() {
    Inherit(this, InteractiveSection, "fanscene2");
    (async function () {})();
  });
  Class(function ForgeField() {
    Inherit(this, InteractiveSection, "forgefield");
    (async function () {})();
  });
  Class(function ForgeField2() {
    Inherit(this, InteractiveSection, "forgefield2");
    (async function () {})();
  });
  Class(function GasStation() {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "gasstation");
      (await _this.layout.getLayer("camera")).lock();
    })();
  });
  Class(function GasStationGreybox() {
    Inherit(this, InteractiveSection, "gasstationgreybox");
    (async function () {})();
  });
  Class(function GasStation2(index, parentConfig, isFirst) {
    Inherit(this, InteractiveSection, "gasstation2", index, parentConfig, isFirst);
    const _this = this;
    (async function () {
      await _this.ready();
      (await _this.layout.getLayer("title")).setText(CMS.get("chapters.chapter-2.title"));
    })();
  });
  Class(function GasStation3() {
    Inherit(this, InteractiveSection, "gasstation3");
    (async function () {
      console.log("gas station 3");
    })();
  });
  Class(function OilFieldTransform() {
    Inherit(this, InteractiveSection, "oilfieldtransform");
    (async function () {})();
  });
  Class(function PlaneLayout() {
    Inherit(this, InteractiveSection, "planeLayout");
    (async function () {})();
  });
  Class(function Route66() {
    Inherit(this, InteractiveSection, "route66");
    (async function () {})();
  });
  Class(function SolarField() {
    Inherit(this, InteractiveSection, "solarfield");
    (async function () {})();
  });
  Class(function SolarField2() {
    Inherit(this, InteractiveSection, "solarfield2");
    (async function () {})();
  });
  Class(function ElectricityShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: {
        value: null,
        getTexture: Utils3D.getRepeatTexture
      },
      uPosterizeTime: {
        value: 12
      },
      uGrain: {
        value: 0.5
      },
      uStep: {
        value: 0.5
      },
      uColor0: {
        value: new Color("#FF6600")
      },
      uColor1: {
        value: new Color("#FFFFFF")
      },
      uScale: {
        value: 1
      },
      uNoise: {
        value: 0.1
      },
      uRange: {
        value: new Vector2()
      }
    });
  });
  Class(function MoleculeShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uKeyLightDir: {
        value: new Vector3(0, 4, 0)
      },
      uBounceLightDir: {
        value: new Vector3(-0.1, -1.5, 0)
      },
      uRimLightDir: {
        value: new Vector3(0, 1, -1)
      },
      uKeyLightStep: {
        value: 0.8
      },
      uBounceStep: {
        value: 1.1
      },
      uRimStep: {
        value: 0.8
      },
      uColor: {
        value: new Color("#C8CECF")
      },
      uBounceColor: {
        value: new Color("#ADB6BF")
      },
      uRimColor: {
        value: new Color("#ffffff")
      },
      uShadowColor: {
        value: new Color("#A6ADB5")
      },
      uGrain: {
        value: 0.9
      },
      uWobble: {
        value: new Vector2()
      },
      uWobbleSpeed: {
        value: 8
      },
      uRotationSpeed: {
        value: 0.1
      },
      uExplode: {
        value: 0
      },
      uBounds: {
        value: new Vector4()
      },
      uSign: {
        value: 1
      },
      uHover: {
        value: 1
      }
    });
  });
  Class(function Molecules(index, parentConfig) {
    Inherit(this, InteractiveSection, "molecules", index, parentConfig);
    const _this = this;
    var _layers;
    var _value = 0;
    var _target = -0.1;
    function loop() {
      _target = ViewController.SPEED_MULTI.value * 1.1 - 0.1;
      _target = Math.max(Math.range(_this.progress, 0.51, 0.57, 0, 1), _target);
      _value = Math.lerp(_target, _value, 0.1);
      _layers.glow.shader.uniforms.uScale.value = _value;
      _layers.hydrocarbon.shader.uniforms.uExplode.value = _value * -25;
      _layers.strike.shader.uniforms.uStep.value = 1 - _value;
    }
    (async function () {
      await _this.ready();
      _layers = await _this.layout.getAllLayers();
      _this.layout.timeline.add(_layers.h2o_and_co2.shader.uniforms.uExplode, {
        value: 20
      }, 30, "linear", 25);
      _this.layout.timeline.add(_layers.sky.shader.uniforms.uMix, {
        value: 0
      }, 9, "linear", 82);
      _this.startRender(loop);
    })();
  });
  Class(function StrikeShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tAnimation: {
        value: null
      },
      uPosterizeTime: {
        value: 12
      },
      uScale: {
        value: 1
      },
      uOffset: {
        value: new Vector3()
      },
      uColor: {
        value: new Color("ff6600")
      },
      uStep: {
        value: 0.5
      }
    });
  });
  Class(function TechScene() {
    Inherit(this, InteractiveSection, "techscenelayout");
    (async function () {})();
  });
  Class(function TestDrive() {
    Inherit(this, Object3D);
    const _this = this;
    (async function () {
      _this.layout = _this.initClass(SceneLayout, "testdrive");
      (await _this.layout.getLayer("camera")).lock();
    })();
  });
  Class(function TestPlane() {
    Inherit(this, InteractiveSection, "testplane");
    (async function () {})();
  });
  Class(function Trucks() {
    Inherit(this, InteractiveSection, "trucks");
    (async function () {})();
  });
  Class(function Main() {
    (function () {
      if (Utils.query("performance")) {
        return Performance.displayResults();
      }
      (function init() {
        GLUI.init();
        GlobalAudio3D.setup();
        if (!Device.mobile) {
          HydraCSS.style("body, html, #Stage", {
            overflowY: "scroll"
          });
        }
        if (window.location.search.includes("p=") && Config.ENV !== "production") {
          return AssetLoader.loadAssets(Assets.list().filter(["uil", "shaders"])).then(Playground.instance);
        }
        Container.instance();
      })();
      Mouse.resetOnRelease = true;
    })();
  });
  window._MINIFIED_ = true;
  window._BUILT_ = true;